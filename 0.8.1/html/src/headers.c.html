<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
    <HEAD>
        <TITLE>Header management functions</TITLE>
        <LINK REL="stylesheet" TYPE="text/css"
            HREF="../../resources/perl.css"
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY>
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Header management functions</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../html/index.html">Contents</a> | <a href="../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>src/headers.c &#45; Header management functions</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>Handles getting of various headers,
and pool creation.</p>

<h2><a name="Buffer_Header_Functions_for_small&#45;object_lookup_table"
>Buffer Header Functions for small&#45;object lookup table <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="static_void_*_get_free_buffer"
><b><code lang='und' xml:lang='und'>static void *get_free_buffer</b></code></a></dt><p class="pad"></p>

<dd>Gets a free object or buffer from the given <code lang='und' xml:lang='und'>pool</code> and returns it.
If the object is larger then a starndard <code lang='und' xml:lang='und'>PObj</code> structure,
all additional memory is cleared.</dd><p class="pad"></p>
</dl>

<h2><a name="Header_Pool_Creation_Functions"
>Header Pool Creation Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="Small_Object_Pool_*_new_pmc_pool"
><b><code lang='und' xml:lang='und'>Small_Object_Pool *new_pmc_pool</b></code></a></dt><p class="pad"></p>

<dd>Creates and initializes a new pool for PMCs and returns it.</dd><p class="pad"></p>

<dt><a name="Small_Object_Pool_*_new_bufferlike_pool"
><b><code lang='und' xml:lang='und'>Small_Object_Pool *new_bufferlike_pool</b></code></a></dt><p class="pad"></p>

<dd>Creates a new pool for buffer&#45;like structures.
This is called from <code lang='und' xml:lang='und'>make_bufferlike_pool()</code>,
and should probably not be called directly.</dd><p class="pad"></p>

<dt><a name="Small_Object_Pool_*_new_buffer_pool"
><b><code lang='und' xml:lang='und'>Small_Object_Pool *new_buffer_pool</b></code></a></dt><p class="pad"></p>

<dd>Creates a new <code lang='und' xml:lang='und'>Small_Object_Pool</code> structure for managing buffer objects.</dd><p class="pad"></p>

<dd>Non&#45;constant strings and plain Buffers are stored in the sized header pools.</dd><p class="pad"></p>

<dt><a name="Small_Object_Pool_*_new_string_pool"
><b><code lang='und' xml:lang='und'>Small_Object_Pool *new_string_pool</b></code></a></dt><p class="pad"></p>

<dd>Creates a new pool for <code lang='und' xml:lang='und'>STRINGS</code> and returns it.
This calls <code lang='und' xml:lang='und'>make_bufferlike_pool</code> internally,
which in turn calls <code lang='und' xml:lang='und'>new_bufferlike_pool</code>.</dd><p class="pad"></p>

<dt><a name="Small_Object_Pool_*_make_bufferlike_pool"
><b><code lang='und' xml:lang='und'>Small_Object_Pool *make_bufferlike_pool</b></code></a></dt><p class="pad"></p>

<dd>Make and return a bufferlike header pool for objects of a given size.
If a pool for objects of that size already exists no new pool will be created,
and the pointer to the existing pool is returned.</dd><p class="pad"></p>

<dt><a name="Small_Object_Pool_*_get_bufferlike_pool"
><b><code lang='und' xml:lang='und'>Small_Object_Pool *get_bufferlike_pool</b></code></a></dt><p class="pad"></p>

<dd>Returns a bufferlike header pool for objects of a given size.
Does not check to see if the pool already exists,
so if the pool is non&#45;existant,
this will return an invalid pointer.</dd><p class="pad"></p>

<dt><a name="PMC_*_new_pmc_header"
><b><code lang='und' xml:lang='und'>PMC *new_pmc_header</b></code></a></dt><p class="pad"></p>

<dd>Gets a new PMC header from the PMC pool&#39;s free list.
Guaranteed to return a valid PMC object or else Parrot will panic.
Set&#39;s the necessary flags for the objects and initializes the PMC data pointer to <code lang='und' xml:lang='und'>NULL</code>.</dd><p class="pad"></p>

<dt><a name="static_PMC_EXT_*_new_pmc_ext"
><b><code lang='und' xml:lang='und'>static PMC_EXT *new_pmc_ext</b></code></a></dt><p class="pad"></p>

<dd>Gets a new free <code lang='und' xml:lang='und'>PMC_EXT</code> structure from the PMC_EXT pool.
A pointer to the new PMC_EXT is returned.
Does not check to ensure the PMC_EXT is non&#45;null before it is returned (yet).</dd><p class="pad"></p>

<dt><a name="void_add_pmc_ext"
><b><code lang='und' xml:lang='und'>void add_pmc_ext</b></code></a></dt><p class="pad"></p>

<dd>Obtains a new <code lang='und' xml:lang='und'>PMC_EXT</code> structure,
and attaches it to the given <code lang='und' xml:lang='und'>PMC</code>.
Sets the necessary flags associated with the PMC_EXT structure.
Ensures that the PMC_EXT structure is marked as &#34;alive&#34; by the GC.</dd><p class="pad"></p>

<dt><a name="void_add_pmc_sync"
><b><code lang='und' xml:lang='und'>void add_pmc_sync</b></code></a></dt><p class="pad"></p>

<dd>Adds a <code lang='und' xml:lang='und'>Sync*</code> structure to the given <code lang='und' xml:lang='und'>PMC</code>.
Initializes the PMC&#39;s owner field and the synchronization mutext.
Does not check to ensure the <code lang='und' xml:lang='und'>Sync*</code> is non&#45;null.</dd><p class="pad"></p>

<dt><a name="STRING_*_new_string_header"
><b><code lang='und' xml:lang='und'>STRING *new_string_header</b></code></a></dt><p class="pad"></p>

<dd>Returns a new <code lang='und' xml:lang='und'>STRING</code> structure from the string pool or the constant string pool.
Sets default flags on the string object: <code lang='und' xml:lang='und'>PObj_is_string_FLAG</code>,
<code lang='und' xml:lang='und'>PObj_is_COWable_FLAG</code>,
and <code lang='und' xml:lang='und'>PObj_live_FLAG</code> (for GC).
Initializes the data field of the string buffer to <code lang='und' xml:lang='und'>NULL</code>.</dd><p class="pad"></p>

<dt><a name="Buffer_*_new_buffer_header"
><b><code lang='und' xml:lang='und'>Buffer *new_buffer_header</b></code></a></dt><p class="pad"></p>

<dd>Creates and returns a new <code lang='und' xml:lang='und'>Buffer</code> from the buffer header pool.
Does not check that the pointer is non&#45;null.
Calls <code lang='und' xml:lang='und'>get_free_buffer</code> to do all the work.</dd><p class="pad"></p>

<dt><a name="void_*_new_bufferlike_header"
><b><code lang='und' xml:lang='und'>void *new_bufferlike_header</b></code></a></dt><p class="pad"></p>

<dd>Returns a new buffer&#45;like header from the appropriate sized pool.
Does not check to ensure the header is non&#45;null.</dd><p class="pad"></p>

<dt><a name="size_t_get_max_buffer_address"
><b><code lang='und' xml:lang='und'>size_t get_max_buffer_address</b></code></a></dt><p class="pad"></p>

<dd>Calculates the maximum buffer address and returns it.
This is done by looping through all the sized pools,
and finding the pool whose <code lang='und' xml:lang='und'>end_arena_memory</code> field is the highest.
Notice that arenas in each pool are not necessarily located directly next to each other in memory,
and the last arena in the pool&#39;s list may not be located at the highest memory address.</dd><p class="pad"></p>

<dt><a name="size_t_get_min_buffer_address"
><b><code lang='und' xml:lang='und'>size_t get_min_buffer_address</b></code></a></dt><p class="pad"></p>

<dd>Calculates the minimum buffer address and returns it.
Loops through all sized pools,
and finds the one with the smallest <code lang='und' xml:lang='und'>start_arena_memory</code> field.
Notice that the memory region between <code lang='und' xml:lang='und'>get_min_buffer_address</code> and <code lang='und' xml:lang='und'>get_max_buffer_address</code> may be fragmented,
and parts of it may not be available for Parrot to use directly (such as bookkeeping data for the OS memory manager).</dd><p class="pad"></p>

<dt><a name="size_t_get_max_pmc_address"
><b><code lang='und' xml:lang='und'>size_t get_max_pmc_address</b></code></a></dt><p class="pad"></p>

<dd>Returns the maximum memory address used by the <code lang='und' xml:lang='und'>pmc_pool</code>.</dd><p class="pad"></p>

<dt><a name="size_t_get_min_pmc_address"
><b><code lang='und' xml:lang='und'>size_t get_min_pmc_address</b></code></a></dt><p class="pad"></p>

<dd>Returns the minimum memory address used by the <code lang='und' xml:lang='und'>pmc_pool</code>.
Notice that the memory region between <code lang='und' xml:lang='und'>get_min_pmc_address</code> and <code lang='und' xml:lang='und'>get_max_pmc_address</code> may be fragmented,
and not all of it may be used directly by Parrot for storing PMCs.</dd><p class="pad"></p>

<dt><a name="int_is_buffer_ptr"
><b><code lang='und' xml:lang='und'>int is_buffer_ptr</b></code></a></dt><p class="pad"></p>

<dd>Checks whether the given <code lang='und' xml:lang='und'>ptr</code> is located within one of the sized header pools.
Returns <code lang='und' xml:lang='und'>1</code> if it is,
and <code lang='und' xml:lang='und'>0</code> if not.</dd><p class="pad"></p>

<dt><a name="int_is_pmc_ptr"
><b><code lang='und' xml:lang='und'>int is_pmc_ptr</b></code></a></dt><p class="pad"></p>

<dd>Checks that <code lang='und' xml:lang='und'>ptr</code> is actually a PMC pointer.
Returns <code lang='und' xml:lang='und'>1</code> if it is,
returns <code lang='und' xml:lang='und'>0</code> otherwise.</dd><p class="pad"></p>

<dt><a name="void_Parrot_initialize_header_pools"
><b><code lang='und' xml:lang='und'>void Parrot_initialize_header_pools</b></code></a></dt><p class="pad"></p>

<dd>The initialization routine for the interpreter&#39;s header pools.
Initializes pools for string headers,
constant string headers,
buffers,
PMCs,
PMC_EXTs,
and constant PMCs.</dd><p class="pad"></p>

<dd>The <code lang='und' xml:lang='und'>string_header_pool</code> and <code lang='und' xml:lang='und'>buffer_header_pool</code> are actually both in the sized pools,
although no other sized pools are created here.</dd><p class="pad"></p>

<dt><a name="int_Parrot_forall_header_pools"
><b><code lang='und' xml:lang='und'>int Parrot_forall_header_pools</b></code></a></dt><p class="pad"></p>

<dd>Iterates through header pools,
invoking the given callback function on each pool in the list matching the given criteria.
Determines which pools to iterate over depending on flags passed to the function.
Returns the callback&#39;s return value,
if non&#45;zero.
A non&#45;zero return value from the callback function will terminate the iteration prematurely.</dd><p class="pad"></p>

<dl>
<dt><a name="flag_is_one_of"
>flag is one of</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  POOL_PMC
  POOL_BUFFER
  POOL_CONST
  POOL_ALL</pre>

<dd>Only matching pools will be used. Notice that it is not possible to iterate over certain sets of pools using the provided flags in the single pass. For instance, both the PMC pool and the constant PMC pool cannot be iterated over in a single pass.</dd><p class="pad"></p>

<dt><a name="arg"
>arg</a></dt><p class="pad"></p>

<dd>This argument is passed on to the iteration function.</dd><p class="pad"></p>

<dt><a name="pool_iter_fn"
>pool_iter_fn</a></dt><p class="pad"></p>

<dd>It is called with <code lang='und' xml:lang='und'>(Interp*, Small_Object_Pool *, int flag, void *arg)</code> If the function returns a non&#45;zero value iteration will stop.</dd><p class="pad"></p>
</dl>

<dt><a name="static_void_free_pool"
><b><code lang='und' xml:lang='und'>static void free_pool</b></code></a></dt><p class="pad"></p>

<dd>Frees a pool and all of it&#39;s arenas. Loops through the list of arenas backwards and returns each to the memory manager. Then, it frees the pool structure itself.</dd><p class="pad"></p>

<dt><a name="static_int_sweep_cb_buf"
><b><code lang='und' xml:lang='und'>static int sweep_cb_buf</b></code></a></dt><p class="pad"></p>

<dd>Performs a final garbage collection sweep, and then frees the pool. Calls <code lang='und' xml:lang='und'>Parrot_dod_sweep</code> to perform the sweep, and <code lang='und' xml:lang='und'>free_pool</code> to free the pool and all it&#39;s arenas.</dd><p class="pad"></p>

<dt><a name="static_int_sweep_cb_pmc"
><b><code lang='und' xml:lang='und'>static int sweep_cb_pmc</b></code></a></dt><p class="pad"></p>

<dd>Performs a garbage collection sweep of the given pmc pool, and then frees it. Calls <code lang='und' xml:lang='und'>Parrot_dod_sweep</code> to perform the sweep, and <code lang='und' xml:lang='und'>free_pool</code> to free the pool and all it&#39;s arenas. Always returns <code lang='und' xml:lang='und'>0</code>.</dd><p class="pad"></p>

<dt><a name="void_Parrot_destroy_header_pools"
><b><code lang='und' xml:lang='und'>void Parrot_destroy_header_pools</b></code></a></dt><p class="pad"></p>

<dd>Performs a garbage collection sweep on all pools, and then frees them. Calls <code lang='und' xml:lang='und'>Parrot_forall_header_pools</code> to loop over all the pools, passing <code lang='und' xml:lang='und'>sweep_cb_pmc</code> and <code lang='und' xml:lang='und'>sweep_cb_buf</code> callback routines. Frees the array of sized header pointers in the <code lang='und' xml:lang='und'>Arenas</code> structure too.</dd><p class="pad"></p>

<dt><a name="static_void_fix_pmc_syncs"
><b><code lang='und' xml:lang='und'>static void fix_pmc_syncs</b></code></a></dt><p class="pad"></p>

<dd>Walks through the given arena, looking for all live and shared PMCs, transferring their sync values to the destionation interpreter.</dd><p class="pad"></p>

<dt><a name="void_Parrot_merge_header_pools"
><b><code lang='und' xml:lang='und'>void Parrot_merge_header_pools</b></code></a></dt><p class="pad"></p>

<dd>Merge the header pools of <code lang='und' xml:lang='und'>source_interp</code> into those of <code lang='und' xml:lang='und'>dest_interp</code>. (Used to deal with shared objects left after interpreter destruction.)</dd><p class="pad"></p>

<dt><a name="void_Parrot_initialize_header_pool_names"
><b><code lang='und' xml:lang='und'>void Parrot_initialize_header_pool_names</b></code></a></dt><p class="pad"></p>

<dd>UNUSED. Sets the <code lang='und' xml:lang='und'>name</code> parameter of the various header pools to a Parrot string structure for the name of the pool.</dd><p class="pad"></p>
</dl>

<h1><a name="SEE_ALSO"
>SEE ALSO <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p><em lang='und' xml:lang='und'>include/parrot/headers.h</em>.</p>

<h1><a name="HISTORY"
>HISTORY <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>Initial version by Mike Lambert on 2002.05.27.</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../resources/parrot_small.png"
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
