<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
    <HEAD>
        <TITLE>Readme file for PIRC compiler.</TITLE>
        <LINK REL="stylesheet" TYPE="text/css"
            HREF="../../../resources/perl.css"
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY>
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Readme file for PIRC compiler.</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../html/index.html">Contents</a> | <a href="../../../html/compilers.html">Compilers</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>README.txt &#45; Readme file for PIRC compiler.</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>PIRC is a fresh implementation of the PIR language using Bison and Flex.
Its main features are:</p>

<ul>
<li>thread&#45;safety,
so it is reentrant.</li><p class="pad"></p>

<li>strength reduction,
implemented in the parser.</li><p class="pad"></p>

<li>constant folding,
implemented in the parser.</li><p class="pad"></p>

<li>checks for proper use of op arguments in PIR syntax (disallowing,
e.g.: $S0 = print)</li><p class="pad"></p>

<li>allow multiple heredocs in subroutine invocations (like: foo(&#60;&#60;&#39;A&#39;,
&#60;&#60;&#39;B&#39;,
&#60;&#60;&#39;C&#39;) )</li><p class="pad"></p>
</ul>

<h2><a name="Compiling_and_Running"
>Compiling and Running <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<h3><a name="Windows_using_Microsoft_Visual_Studio"
>Windows using Microsoft Visual Studio</a></h3>

<p>The Makefile doesn&#39;t work perfectly; compilation is fine,
but linking doesn&#39;t work,
so that needs to be done manually.</p>

<p>To compile:</p>

<pre lang='und' xml:lang='und'> cd compilers\pirc
 nmake pirc</pre>

<p>To link:</p>

<pre lang='und' xml:lang='und'> link /out:pirc.exe /nodefaultlib main.obj pircompunit.obj pirlexer.obj pirparser.obj \
   pirsymbol.obj pircompiler.obj pirmacro.obj hdocprep.obj \
   kernel32.lib msvcrt.lib ..\..\libparrot.lib</pre>

<p>When running PIRC, it needs the shared library <code lang='und' xml:lang='und'>libparrot</code>; an easy way to do this is copy <code lang='und' xml:lang='und'>libparrot.dll</code> in the Parrot root directory to <code lang='und' xml:lang='und'>compilers/pirc/new</code>.</p>

<p>Running PIRC is as easy as:</p>

<pre lang='und' xml:lang='und'> pirc test.pir</pre>

<p>See &#39;pirc &#45;h&#39; for help.</p>

<h3><a name="Linux_using_GCC"
>Linux using GCC</a></h3>

<p>The Makefile should work fine on Linux:</p>

<pre lang='und' xml:lang='und'> cd compilers/pirc &#38;&#38; make</pre>

<p>When running PIRC, it needs the shared library <code lang='und' xml:lang='und'>libparrot</code>; in order to let PIRC find it, set the path as follows:</p>

<pre lang='und' xml:lang='und'> export LD_LIBRARY_PATH=../../../blib/lib</pre>

<p>Running is as easy as:</p>

<pre lang='und' xml:lang='und'> ./pirc test.pir</pre>

<h2><a name="Overview"
>Overview <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>The new Bison/Flex based implementation of the PIR compiler is designed as a two&#45;stage compiler:</p>

<dl>
<dt><a name="1._Heredoc_preprocessor"
>1. Heredoc preprocessor</a></dt><p class="pad"></p>

<dt><a name="2._PIR_compiler"
>2. PIR compiler</a></dt><p class="pad"></p>
</dl>

<h2><a name="Heredoc_preprocessing"
>Heredoc preprocessing <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>The heredoc preprocessor takes the input as written by the PIR programmer, and flattens out all heredoc strings. An example is shown below to illustrate this concept:</p>

<p>The following input:</p>

<pre lang='und' xml:lang='und'> .sub main
   $S0 = &#60;&#60;&#39;EOS&#39;
 This is a heredoc string
   divided
     over
       five
         lines.
 EOS
 .end</pre>

<p>is transformed into:</p>

<pre lang='und' xml:lang='und'> .sub
   $S0 = &#34;This is a heredoc string\n  divided\n    over\n      five\n        lines.\n&#34;
 .end</pre>

<p>In order to allow <code lang='und' xml:lang='und'>.include</code>d file to have heredoc strings, the heredoc preprocessor also handles the <code lang='und' xml:lang='und'>.include</code> directive, even though logically this is a macro function. See the discussion below for how the <code lang='und' xml:lang='und'>.include</code> directive works.</p>

<h2><a name="PIR_compilers"
>PIR compilers <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>The PIR compiler parses the output of the heredoc preprocessor. PIRC&#39;s lexer also handles macros.</p>

<p>The macro layer basically implements text replacements. The following directives are handled:</p>

<dl>
<dt><a name=".macro"
><b><code lang='und' xml:lang='und'>.macro</b></code></a></dt><p class="pad"></p>

<dt><a name=".macro_const"
><b><code lang='und' xml:lang='und'>.macro_const</b></code></a></dt><p class="pad"></p>

<dt><a name=".macro_local"
><b><code lang='und' xml:lang='und'>.macro_local</b></code></a></dt><p class="pad"></p>

<dt><a name=".macro_label"
><b><code lang='und' xml:lang='und'>.macro_label</b></code></a></dt><p class="pad"></p>
</dl>

<h3><a name=".include"
><code lang='und' xml:lang='und'>.include</code></a></h3>

<p>The <code lang='und' xml:lang='und'>.include</code> directive takes a string argument, which is the name of a file. The contents of this file are inserted at the point where the <code lang='und' xml:lang='und'>.include</code> directive is written. To illustrate this, consider the following example:</p>

<pre lang='und' xml:lang='und'> main.pir:
 ========================
 .sub main
   print &#34;hi\n&#34;
   foo()
 .end

 .include &#34;lib.pir&#34;
 ========================

 lib.pir:
 ========================
 .sub foo
   print &#34;foo\n&#34;
 .end
 ========================</pre>

<p>This will result in the following output:</p>

<pre lang='und' xml:lang='und'> .sub main
   print &#34;hi\n&#34;
   foo()
 .end

 .sub foo
   print &#34;foo\n&#34;
 .end</pre>

<h3><a name=".macro"
><code lang='und' xml:lang='und'>.macro</code></a></h3>

<p>The macro directive starts a macro definition. The macro preprocessor implements the expansion of macros. For instance, given the following input:</p>

<pre lang='und' xml:lang='und'> .macro say(msg)
   print .msg
   print &#34;\n&#34;
 .endm

 .sub main
   .say(&#34;hi there!&#34;)
 .end</pre>

<p>will result in this output:</p>

<pre lang='und' xml:lang='und'> .sub main
   print &#34;hi there!&#34;
   print &#34;\n&#34;
 .end</pre>

<h3><a name=".macro_const"
><code lang='und' xml:lang='und'>.macro_const</code></a></h3>

<p>The <code lang='und' xml:lang='und'>.macro_const</code> directive is similar to the <code lang='und' xml:lang='und'>.macro</code> directive, except that a <code lang='und' xml:lang='und'>.macro_const</code> is just a simplified <code lang='und' xml:lang='und'>.macro</code>; it merely gives a name to some constant:</p>

<pre lang='und' xml:lang='und'> .macro_const PI 3.14

 .sub main
   print &#34;PI is approximately: &#34;
   print .PI
   print &#34;\n&#34;
 .end</pre>

<p>This will result in the output:</p>

<pre lang='und' xml:lang='und'> .sub main
   print &#34;PI is approximately: &#34;
   print 3.14
   print &#34;\n&#34;
 .end</pre>

<h3><a name="PIR_compiler"
>PIR compiler</a></h3>

<p>As Parrot instructions are polymorphic, the PIR compiler is responsible for selecting the right variant of the instruction. The selection is based on the types of the operands. For instance:</p>

<pre lang='und' xml:lang='und'> set $I0, 42</pre>

<p>will select the <code lang='und' xml:lang='und'>set_i_ic</code> instruction: this is the <code lang='und' xml:lang='und'>set</code> instruction, taking an integer (i) result operand and an integer constant (ic) operand. Other examples are:</p>

<pre lang='und' xml:lang='und'> $P0[1] = 42           &#45;&#45;&#62; set_p_kic_ic # kic = key integer constant
 $I0 = $P0[&#34;hi&#34;]       &#45;&#45;&#62; set_i_p_kc   # kc = key constant from constant table
 $P1 = new &#34;Hash&#34;      &#45;&#45;&#62; new_p_sc     # sc = string constant</pre>

<h3><a name="Constant_folding"
>Constant folding</a></h3>

<p>Expressions that can be evaluated at compile&#45;time are pre&#45;evaluated, saving calculations during runtime. Some constant&#45;folding is required, as Parrot depends on this. For instance:</p>

<pre lang='und' xml:lang='und'> add $I0, 1, 2</pre>

<p>is not a valid Parrot instruction; there is no <code lang='und' xml:lang='und'>add_i_ic_ic</code> instruction. Instead, this will be translated to:</p>

<pre lang='und' xml:lang='und'> set $I0, 3</pre>

<p>which, as was explained earlier, will select the <code lang='und' xml:lang='und'>set_i_ic</code> instruction.</p>

<p>The conditional branch instructions are also pre&#45;evaluated, if possible. For instance, consider the following statement:</p>

<pre lang='und' xml:lang='und'> if 1 &#60; 2 goto L1</pre>

<p>It is clear during compile time, that 1 is smaller than 2; so instead of evaluating this during runtime, we know for sure that the branch to label <code lang='und' xml:lang='und'>L1</code> will be made, effectively replacing the above statement by:</p>

<pre lang='und' xml:lang='und'> goto L1</pre>

<p>Likewise, if it&#39;s clear that certain instructions don&#39;t have any effect, they can be removed altogether:</p>

<pre lang='und' xml:lang='und'> if 1 &#62; 2 goto L1        &#45;&#45;&#62; nop  # nop is no opcode.
 $I0 = $I0 + 0           &#45;&#45;&#62; nop</pre>

<p>Another type of optimization is the selection of (slightly) more efficient variants of instructions. For instance, consider the following instruction:</p>

<pre lang='und' xml:lang='und'> $I0 = $I0 + $I1</pre>

<p>which is actually syntactic sugar for:</p>

<pre lang='und' xml:lang='und'> add $I0, $I0, $I1</pre>

<p>In C one would write (ignoring the fact that $I0 and $I0 are not a valid C identifiers):</p>

<pre lang='und' xml:lang='und'> $I0 += $I1</pre>

<p>which is in fact valid PIR as well. When the PIR parser sees an instruction of this form, it will automatically select the variant with 2 operands instead of the 3&#45;operand variant. So:</p>

<pre lang='und' xml:lang='und'> add $I0, $I0, $1    # $I0 is an out operand</pre>

<p>will be optimized, as if you had written:</p>

<pre lang='und' xml:lang='und'> add $I0, $I1        # $I0 is an in/out operand</pre>

<p>The PIR parser can do even more improvements, if it sees opportunity to do so. Consider the following statement:</p>

<pre lang='und' xml:lang='und'> $I0 = $I0 + 1</pre>

<p>or, in Parrot assembly syntax:</p>

<pre lang='und' xml:lang='und'> add $I0, $I0, 1</pre>

<p>Again, in C one would write (again ignoring the valid identifier issue): <code lang='und' xml:lang='und'>$I0++</code>, or in other words, <code lang='und' xml:lang='und'>incrementing</code> the given identifier. Parrot has <code lang='und' xml:lang='und'>inc</code> and <code lang='und' xml:lang='und'>dec</code> instructions built&#45;in as well, so that the above statement <code lang='und' xml:lang='und'>$I0 = $I0 + 1</code> can be optimized to:</p>

<pre lang='und' xml:lang='und'> inc $I0</pre>

<h3><a name="Vanilla_Register_Allocator"
>Vanilla Register Allocator</a></h3>

<p>The PIR compiler implements a vanilla register allocator. This means that each declared <code lang='und' xml:lang='und'>.local</code> or <code lang='und' xml:lang='und'>.param</code> symbol, and each PIR register ($Px, $Sx, $Ix, $Nx) is assigned a unique PASM register, that is associated with the original symbol or PIR register throughout the subroutine.</p>

<p>Any further optimizations on register usage can be implemented by writing a register allocator that takes this initial register allocation as input, and generating a more optimized register usage. Research and benchmarking is needed to decide whether this yields more efficient bytecode. In the end it is a choice between compile&#45;time overhead (register allocation) or runtime memory overhead (more register space needed per sub).</p>

<p>The implementation of the vanilla register allocator is done in the PIR symbol management module (<code lang='und' xml:lang='und'>pirsymbol.c</code>).</p>

<h2><a name="Status"
>Status <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>The PIR parser is complete, but should be tested intensively. The back&#45;end creates a data structure representing the input. Currently, only (almost working) PASM output is generated, but eventually a Parrot Byte Code (PBC) file should be generated. In order to do this, we need a proper API to generate the appropriate data structures (such as Parrot PackFile and friends).</p>

<h1><a name="IMPLEMENTATION"
>IMPLEMENTATION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>The directory compilers/pirc has a number of subdirectories:</p>

<dl>
<dt><a name="doc_&#45;_contains_documentation."
>doc &#45; contains documentation.</a></dt><p class="pad"></p>

<dt><a name="heredoc_&#45;_contains_the_implementation_of_the_heredoc_preprocessor"
>heredoc &#45; contains the implementation of the heredoc preprocessor</a></dt><p class="pad"></p>

<dt><a name="new_&#45;_contains_the_Bison/Flex_implementation_of_PIRC"
>new &#45; contains the Bison/Flex implementation of PIRC</a></dt><p class="pad"></p>

<dt><a
>src &#45; contains the hand&#45;written, recursive&#45;descent implementation of PIRC. Note that this is no longer maintained at the moment.</a></dt><p class="pad"></p>

<dt><a name="t_&#45;_for_tests._No_tests_yet_at_this_point."
>t &#45; for tests. No tests yet at this point.</a></dt><p class="pad"></p>

<dt><a
>macro &#45; contains the old implementation of the macro preprocessor. This is now integrated with pirc/new.</a></dt><p class="pad"></p>
</dl>

<h1><a name="NOTES"
>NOTES <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<h2><a name="Cygwin_processable_lexer_spec."
>Cygwin processable lexer spec. <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>The file <code lang='und' xml:lang='und'>pir.l</code> from which the lexer is generated is <i>not</i> processable by Cygwin&#39;s default version of Flex. In order to make a reentrant lexer, a newer version is needed, which can be downloaded from the link below.</p>

<p><a href='http://sourceforge.net/project/downloading.php?groupname=flex&#38;filename=flex&#45;2.5.33.tar.gz&#38;use_mirror=belnet'><a href="http://sourceforge.net/project/downloading.php?groupname=flex&#38;filename=flex&#45;2.5.33.tar.gz&#38;use_mirror=belnet">http://sourceforge.net/project/downloading.php?groupname=flex&#38;filename=flex&#45;2.5.33.tar.gz&#38;use_mirror=belnet</a></a></p>

<p>Just do:</p>

<pre lang='und' xml:lang='und'> $ ./configure
 $ make</pre>

<p>Then make sure to overwrite the supplied flex binary.</p>

<h1><a name="BUGS"
>BUGS <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Having a look at this implementation would be greatly appreciated, and any resulting feedback even more :&#45;)</p>

<ul>
<li>Memory management of the macro processor needs to be fixed. (heredoc and PIR parser are ok).</li><p class="pad"></p>

<li>Braced macro argument handling needs a lot of testing.</li><p class="pad"></p>
</ul>

<h1><a name="FUTURE_WORK:_HELP_WANTED"
>FUTURE WORK: HELP WANTED <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Eventually, either IMCC needs to be fixed rigorously, or, rewritten altogether. PIRC is an attempt to do the latter. The following things need to be considered when replacing IMCC with PIRC:</p>

<ul>
<li>PIR sub storage</li><p class="pad"></p>

<p>PIR subs are stored as PMC constants in the constant table, but it is not clear how exactly this is to be done.</p>

<li>bytecode generation</li><p class="pad"></p>

<p>There must be a proper bytecode API for PIRC to use.</p>

<li><code lang='und' xml:lang='und'>:immediate</code> and related flags</li><p class="pad"></p>

<p>Flags such as <code lang='und' xml:lang='und'>:immediate</code> must be implemented; a sub that is marked with the <code lang='und' xml:lang='und'>:immediate</code> flag must be run immediately after compilation.</p>
</ul>

<p>At this moment, the following things are unclear to me; if anybody can answer these, that&#39;d be helpful:</p>

<ul>
<li>how are named args/params handled/represented in bytecode?</li><p class="pad"></p>

<li>the Makefile (generated from config/gen/makefiles/pirc.in) must be fixed for Windows.</li><p class="pad"></p>
</ul>

<p>The following are some ideas for the near future:</p>

<ul>
<li>when parsing is done, we know the total number of instructions (or we can easily count this, by incrementing a counter in the instruction constructor). Then we can create an array, and convert the linked list of instructions into an array of instructions. This would allow to easily index this array and calculate offsets (labels etc.) and such.</li><p class="pad"></p>
</ul>

<h1><a name="SEE_ALSO"
>SEE ALSO <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>See also:</p>

<ul>
<li><code lang='und' xml:lang='und'>languages/PIR</code> for a PGE based implementation.</li><p class="pad"></p>

<li><code lang='und' xml:lang='und'>compilers/pirc/src</code>, a hand&#45;written, recursive&#45;descent PIR parser.</li><p class="pad"></p>

<li><code lang='und' xml:lang='und'>compilers/imcc</code>, the current <i>standard</i> PIR implementation.</li><p class="pad"></p>

<li><code lang='und' xml:lang='und'>docs/imcc/syntax.pod</code> for a description of PIR syntax.</li><p class="pad"></p>

<li><code lang='und' xml:lang='und'>docs/imcc/</code> for more documentation about the PIR language.</li><p class="pad"></p>

<li><code lang='und' xml:lang='und'>docs/pdds/pdd19_pir.pod</code> for the PIR design document.</li><p class="pad"></p>
</ul>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../resources/parrot_small.png"
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
