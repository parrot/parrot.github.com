<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Parrot Intermediate Representation</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Parrot Intermediate Representation</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../../html/index.html">Contents</a> | <a href="../../../../html/docs.html">Documentation</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>docs/pdds/pdd19_pir.pod &#45; Parrot Intermediate Representation</p>

<h1><a name="ABSTRACT"
>ABSTRACT <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>This document describes PIR,
a stable,
middle&#45;level language for both compiler and human to target on.</p>

<h1><a name="VERSION"
>VERSION <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>$Revision$</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<h1><a name="Comments_and_empty_lines"
>Comments and empty lines <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>Comments start with <b>#</b> and last until the following newline.
These and empty lines are ignored.</p>

<p>PIR allows POD blocks.</p>

<h1><a name="Statements"
>Statements <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>A valid PIR program consists of a sequence of <i>statements</i>.
A <i>statement</i> is terminated by a newline (&#60;NL&#62;).
So,
each statement has to be on its own line.</p>

<h2><a name="General_statement_format"
>General statement format <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Any statement can start with a optional label and is terminated by a newline:</p>

<pre lang='und' xml:lang='und'>  [label:] [instruction] &#60;NL&#62;</pre>

<h2><a name="Labels"
>Labels <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>PIR code has both local and global labels. Global labels start with an underscore, local labels shouldn&#39;t. Optional label for the given instruction, can stand on its own line. A label must conform to the syntax of <b>identifier</b> described below.</p>

<p>The name of a global label has to be unique, since it can be called at any point in the program. A local label is accessible only in the compilation unit where it&#39;s defined. A local label name must be unique within a compilation unit, but it can be reused in other compilation units.</p>

<p>Examples:</p>

<pre lang='und' xml:lang='und'>  branch L1   # local label
  bsr    _L2  # global label</pre>

<h1><a name="INSTRUCTIONS"
>INSTRUCTIONS <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<h2><a name="Terms_used_here"
>Terms used here <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="&#60;identifier&#62;"
>&#60;identifier&#62;</a></dt><p class="pad"></p>

<dd>Identifiers start with a letter or underscore, then may contain additionally letters, digits, underscores and <b>::</b>. Identifiers don&#39;t have any limit on length.</dd><p class="pad"></p>

<dd>{{ REVIEW: identifier length limit }}</dd><p class="pad"></p>

<dd>{{ REVIEW: can op&#45;names be used as identifiers? See #24251. }}</dd><p class="pad"></p>

<dd>Example:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    a
    _a
    A42
    a::b_c</pre>

<dt><a name="&#60;type&#62;"
>&#60;type&#62;</a></dt><p class="pad"></p>

<dd>Can be <b>int</b>, <b>float</b>, <b>string</b> or <b>pmc</b>.</dd><p class="pad"></p>

<dd>{{ REFERENCE: RT#42769 }}</dd><p class="pad"></p>

<dt><a name="&#60;reg&#62;"
>&#60;reg&#62;</a></dt><p class="pad"></p>

<dd>A PASM register In, Sn, Nn, Pn, or a PIR temporary register $In, $Sn, $Nn, $Pn, where <b>n</b> consists of digit(s) only. <b>n</b> must be between 1 and 99.</dd><p class="pad"></p>

<dd>{{ REVIEW: n limit }}</dd><p class="pad"></p>

<dt><a name="&#60;var&#62;"
>&#60;var&#62;</a></dt><p class="pad"></p>

<dd>A local <b>identifier</b>, a <b>reg</b> or a constant (when allowed). A constant is not allowed on the left side of an assignment.</dd><p class="pad"></p>

<dd>{{ REVIEW: any other places where constant is not allowed }}</dd><p class="pad"></p>
</dl>

<h2><a name="Constants"
>Constants <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="&#39;char_constant&#39;"
>&#39;char constant&#39;</a></dt><p class="pad"></p>

<dd>Are delimited by <b>&#39;</b>. They are taken to be <code lang='und' xml:lang='und'>ascii</code> encoded. No escape sequences are processed.</dd><p class="pad"></p>

<dt><a name="&#34;string_constants&#34;"
>&#34;string constants&#34;</a></dt><p class="pad"></p>

<dd>Are delimited by <b>&#34;</b>. A <b>&#34;</b> inside a string must be escaped by <b>\</b>. Only 7&#45;bit ASCII is accepted in string constants; to use characters outside thar range, specify an encoding in the way below.</dd><p class="pad"></p>

<dt><a name="&#60;&#60;&#34;heredoc&#34;,_&#60;&#60;&#39;heredoc&#39;"
>&#60;&#60;&#34;heredoc&#34;, &#60;&#60;&#39;heredoc&#39;</a></dt><p class="pad"></p>

<dd>Heredocs work like single or double quoted strings. All lines up to the terminating delimiter are slurped into the string. The delimiter has to be on its own line, at the beginning of the line and with no trailing whitespace.</dd><p class="pad"></p>

<dd>Assignment of a heredoc:</dd><p class="pad"></p>

<dd>A heredoc as an argument:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  function(&#60;&#60;&#34;END_OF_HERE&#34;, arg)
  ...
 END_OF_HERE

  .return(&#60;&#60;&#39;EOS&#39;)
  ...
 EOS

  .yield(&#60;&#60;&#39;EOS&#39;)
  ...
 EOS</pre>

<dd>Only one heredoc can be active per statement line.</dd><p class="pad"></p>

<dd>{{ REVIEW: it would be useful to have multiple heredocs per statement, which allows for writing:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>   function(&#60;&#60;&#39;INPUT&#39;, &#60;&#60;&#39;OUTPUT&#39;, &#39;some test&#39;)
   ...
 INPUT
   ...
 OUTPUT</pre>

<dd>}}</dd><p class="pad"></p>

<dt><a name="charset:&#34;string_constant&#34;"
>charset:&#34;string constant&#34;</a></dt><p class="pad"></p>

<dd>Like above with a character set attached to the string. Valid character sets are currently: <code lang='und' xml:lang='und'>ascii</code> (the default), <code lang='und' xml:lang='und'>binary</code>, <code lang='und' xml:lang='und'>unicode</code> (with UTF&#45;8 as the default encoding), and <code lang='und' xml:lang='und'>iso&#45;8859&#45;1</code>.</dd><p class="pad"></p>
</dl>

<h2><a name="String_escape_sequences"
>String escape sequences <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Inside double&#45;quoted strings the following escape sequences are processed.</p>

<pre lang='und' xml:lang='und'>  \xhh        1..2 hex digits
  \ooo        1..3 oct digits
  \cX         control char X
  \x{h..h}    1..8 hex digits
  \uhhhh      4 hex digits
  \Uhhhhhhhh  8 hex digits
  \a, \b, \t, \n, \v, \f, \r, \e, \\</pre>

<dl>
<dt><a name="encoding:charset:&#34;string_constant&#34;"
>encoding:charset:&#34;string constant&#34;</a></dt><p class="pad"></p>

<dd>Like above with an extra encoding attached to the string. For example:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  set S0, utf8:unicode:&#34;&#194;&#171;&#34;</pre>

<dd>The encoding and charset gets attached to the string, no further processing is done, specifically escape sequences are not honored.</dd><p class="pad"></p>

<dt><a name="numeric_constants"
>numeric constants</a></dt><p class="pad"></p>

<dd><b>0x</b> and <b>0b</b> denote hex and binary constants respectively.</dd><p class="pad"></p>
</dl>

<h2><a name="Directive_instructions"
>Directive instructions <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name=".pragma_n_operators"
>.pragma n_operators</a></dt><p class="pad"></p>

<dd>Convert arithmethic infix operators to n_infix operations. The unary opcodes <code lang='und' xml:lang='und'>abs</code>, <code lang='und' xml:lang='und'>not</code>, <code lang='und' xml:lang='und'>bnot</code>, <code lang='und' xml:lang='und'>bnots</code>, and <code lang='und' xml:lang='und'>neg</code> are also changed to use a <b>n_</b> prefix.</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'> .pragma n_operators 1
 .sub foo
   ...
   $P0 = $P1 + $P2           # n_add $P0, $P1, $P2
   $P2 = abs $P0             # n_abs $P2, $P0</pre>

<dt><a name=".loadlib_&#34;lib_name&#34;"
>.loadlib &#34;lib_name&#34;</a></dt><p class="pad"></p>

<dd>Load the given library at <b>compile time</b>, that is, as soon that line is parsed. See also the <code lang='und' xml:lang='und'>loadlib</code> opcode, which does the same at run time.</dd><p class="pad"></p>

<dd>A library loaded this way is also available at runtime, as if it has been loaded again in <code lang='und' xml:lang='und'>:load</code>, so there is no need to call <code lang='und' xml:lang='und'>loadlib</code> at runtime.</dd><p class="pad"></p>

<dt><a name=".HLL_&#34;hll_name&#34;,_&#34;hll_lib&#34;"
>.HLL &#34;hll_name&#34;, &#34;hll_lib&#34;</a></dt><p class="pad"></p>

<dd>Define the HLL for the current file. If the string <code lang='und' xml:lang='und'>hll_lib</code> isn&#39;t empty this <b>compile time pragma</b> also loads the shared lib for the HLL, so that integer type constants are working for creating new PMCs.</dd><p class="pad"></p>

<dt><a name=".HLL_map_&#39;CoreType&#39;,_&#39;UserType&#39;"
>.HLL_map &#39;CoreType&#39;, &#39;UserType&#39;</a></dt><p class="pad"></p>

<dd>Whenever Parrot has to create PMCs inside C code on behalf of the running user program it consults the current type mapping for the executing HLL and creates a PMC of type <i>&#39;UserType&#39;</i> instead of <i>&#39;CoreType&#39;</i>, if such a mapping is defined.</dd><p class="pad"></p>

<dd>E.g. with this code snippet ...</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  .loadlib &#39;dynlexpad&#39;

  .HLL &#34;Foo&#34;, &#34;&#34;
  .HLL_map &#39;LexPad&#39;, &#39;DynLexPad&#39;

  .sub main :main
    ...</pre>

<dd>... all subroutines for language <i>Foo</i> would use a dynamic lexpad pmc.</dd><p class="pad"></p>

<dd>{{ PROPOSAL: stop using integer constants for types RT#45453 }}</dd><p class="pad"></p>

<dt><a name=".sub_&#60;identifier&#62;_[:&#60;flag&#62;_...]"
>.sub &#60;identifier&#62; [:&#60;flag&#62; ...]</a></dt><p class="pad"></p>

<dd>Define a <i>compilation unit</i> with the label <b>identifier</b>. All code in a PIR source file must be defined in a compilation unit. See <a href='TODO#calling_conventions'>PIR Calling Conventions</a> for available flags. Optional flags are a list of <b>flag</b>, separated by empty spaces, and empty spaces only.</dd><p class="pad"></p>

<dd>{{ PROPOSAL: remove the optional comma in flag list RT#45697 }}</dd><p class="pad"></p>

<dd>Always paired with <code lang='und' xml:lang='und'>.end</code>.</dd><p class="pad"></p>

<dt><a name=".end"
>.end</a></dt><p class="pad"></p>

<dd>End a compilation unit. Always paired with <code lang='und' xml:lang='und'>.sub</code>.</dd><p class="pad"></p>

<dt><a name=".emit"
>.emit</a></dt><p class="pad"></p>

<dd>Define a <i>compilation unit</i> containing PASM code. Always paired with <code lang='und' xml:lang='und'>.eom</code>.</dd><p class="pad"></p>

<dt><a name=".eom"
>.eom</a></dt><p class="pad"></p>

<dd>End a <i>compilation unit</i> containing PASM code. Always paired with <code lang='und' xml:lang='und'>.emit</code>.</dd><p class="pad"></p>

<dt><a name=".local_&#60;type&#62;_&#60;identifier&#62;_[:unique_reg]"
>.local &#60;type&#62; &#60;identifier&#62; [:unique_reg]</a></dt><p class="pad"></p>

<dd>Define a local name <b>identifier</b> for this <i>compilation unit</i> and of the given <b>type</b>. You can define multiple identifiers of the same type by separating them with commas:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  .local int i, j</pre>

<dd>The optional <code lang='und' xml:lang='und'>:unique_reg</code> modifier will force the register allocator to associate the identifier with a unique register for the duration of the compilation unit.</dd><p class="pad"></p>

<dt><a name=".sym_&#60;type&#62;_&#60;identifier&#62;_[:unique_reg]"
>.sym &#60;type&#62; &#60;identifier&#62; [:unique_reg]</a></dt><p class="pad"></p>

<dd>Same as <code lang='und' xml:lang='und'>.local</code>.</dd><p class="pad"></p>

<dd>{{ PROPOSAL: remove .sym, see RT#45405 }}</dd><p class="pad"></p>

<dt><a name=".lex_&#60;identifier&#62;,_&#60;reg&#62;"
>.lex &#60;identifier&#62;, &#60;reg&#62;</a></dt><p class="pad"></p>

<dd>Declare a lexical variable that is an alias for a PMC register. The PIR compiler calls this method in response to a .lex STRING, PREG directive. For example, given this preamble:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    .lex &#34;$a&#34;, $P0
    $P1 = new &#39;Integer&#39;

    These two opcodes have an identical effect:

    $P0 = $P1
    store_lex &#34;$a&#34;, $P1

    And these two opcodes also have an identical effect:

    $P1 = $P0
    $P1 = find_lex &#34;$a&#34;</pre>

<dt><a name=".const_&#60;type&#62;_&#60;identifier&#62;_=_&#60;const&#62;"
>.const &#60;type&#62; &#60;identifier&#62; = &#60;const&#62;</a></dt><p class="pad"></p>

<dd>Define a constant named <b>identifier</b> of type <b>type</b> and assign value <b>const</b> to it.</dd><p class="pad"></p>

<dt><a name=".globalconst_&#60;type&#62;_&#60;identifier&#62;_=_&#60;const&#62;"
>.globalconst &#60;type&#62; &#60;identifier&#62; = &#60;const&#62;</a></dt><p class="pad"></p>

<dd>As <code lang='und' xml:lang='und'>.const</code> above, but the defined constant is globally accessible.</dd><p class="pad"></p>

<dt><a name=".namespace_&#60;identifier&#62;"
>.namespace &#60;identifier&#62;</a></dt><p class="pad"></p>

<dd>Open a new scope block. This &#34;namespace&#34; is not the same as the .namespace [ &#60;identifier&#62; ] syntax, which is used for storing subroutines in a particular namespace in the global symbol table. This directive is useful in cases such as (pseudocode):</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  local x = 1;
  print(x);       # prints 1
  do              # open a new namespace/scope block
    local x = 2;  # this x hides the previous x
    print(x);     # prints 2
  end             # close the current namespace
  print(x);       # prints 1 again</pre>

<dd>All types of common language constructs such as if, for, while, repeat and such that have nested scopes, can use this directive.</dd><p class="pad"></p>

<dt><a name=".endnamespace_&#60;identifier&#62;"
>.endnamespace &#60;identifier&#62;</a></dt><p class="pad"></p>

<dd>Closes the scope block that was opened with .namespace &#60;identifier&#62;.</dd><p class="pad"></p>

<dt><a name=".namespace_[_&#60;identifier&#62;_;_&#60;identifier&#62;_]"
>.namespace [ &#60;identifier&#62; ; &#60;identifier&#62; ]</a></dt><p class="pad"></p>

<dd>Defines the namespace from this point onwards. By default the program is not in any namespace. If you specify more than one, separated by semicolons, it creates nested namespaces, by storing the inner namespace object with a <code lang='und' xml:lang='und'>\0</code> prefix in the outer namespace&#39;s global pad.</dd><p class="pad"></p>

<dt><a name=".pcc_*"
>.pcc_*</a></dt><p class="pad"></p>

<dd>Directives used for Parrot Calling Conventions. These are:</dd><p class="pad"></p>

<dl>
<dt><a name=".pcc_begin_and_.pcc_end"
>.pcc_begin and .pcc_end</a></dt><p class="pad"></p>

<dt><a name=".pcc_begin_return_and_.pcc_end_return"
>.pcc_begin_return and .pcc_end_return</a></dt><p class="pad"></p>

<dt><a name=".pcc_begin_yield_and_.pcc_end_yield"
>.pcc_begin_yield and .pcc_end_yield</a></dt><p class="pad"></p>

<dt><a name=".pcc_call"
>.pcc_call</a></dt><p class="pad"></p>
</dl>

<dd>{{ REVIEW: Do we still want/need the &#34;pcc_&#34; prefix? See #45925. }}</dd><p class="pad"></p>
</dl>

<h2><a name="Directives_for_subroutine_parameters_and_return"
>Directives for subroutine parameters and return <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name=".param_&#60;type&#62;_&#60;identifier&#62;_[:&#60;flag&#62;]*"
>.param &#60;type&#62; &#60;identifier&#62; [:&#60;flag&#62;]*</a></dt><p class="pad"></p>

<dd>At the top of a subroutine, declare a local variable, in the mannter of <b>.local</b>, into which parameter(s) of the current subroutine should be stored. Available flags: <code lang='und' xml:lang='und'>:slurpy</code>, <code lang='und' xml:lang='und'>:optional</code>, <code lang='und' xml:lang='und'>:opt_flag</code> and <code lang='und' xml:lang='und'>:unique_reg</code>.</dd><p class="pad"></p>

<dt><a name=".param_&#60;type&#62;_&#34;&#60;identifier&#62;&#34;_=&#62;_&#60;identifier&#62;_[:&#60;flag&#62;]*"
>.param &#60;type&#62; &#34;&#60;identifier&#62;&#34; =&#62; &#60;identifier&#62; [:&#60;flag&#62;]*</a></dt><p class="pad"></p>

<dd>Define a named parameter. This is syntactic sugar for:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'> .param &#60;type&#62; &#60;identifier&#62; :named(&#34;&#60;identifier&#62;&#34;)</pre>

<dt><a name=".param_&#60;reg&#62;_[:&#60;flag&#62;]*"
>.param &#60;reg&#62; [:&#60;flag&#62;]*</a></dt><p class="pad"></p>

<dd>{{ Specifying a register for a parameter does not work. See. RT#46455. }}</dd><p class="pad"></p>

<dd>At the top of a subroutine, specify where parameter(s) of the current subroutine should be stored. Available flags: <code lang='und' xml:lang='und'>:slurpy</code>, <code lang='und' xml:lang='und'>:optional</code>, <code lang='und' xml:lang='und'>:opt_flag</code> and <code lang='und' xml:lang='und'>:unique_reg</code>.</dd><p class="pad"></p>

<dt><a name=".return_&#60;var&#62;_[:&#60;flag&#62;_...]"
>.return &#60;var&#62; [:&#60;flag&#62; ...]</a></dt><p class="pad"></p>

<dd>Between <b>.pcc_begin_return</b> and <b>.pcc_end_return</b>, specify one or more of the return value(s) of the current subroutine. Available flags: <code lang='und' xml:lang='und'>:flat</code>.</dd><p class="pad"></p>
</dl>

<h2><a name="Directives_for_making_a_PCC_call"
>Directives for making a PCC call <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name=".arg_&#60;var&#62;_[:&#60;flag&#62;_...]"
>.arg &#60;var&#62; [:&#60;flag&#62; ...]</a></dt><p class="pad"></p>

<dd>Between <b>.pcc_begin</b> and <b>.pcc_call</b>, specify an argument to be passed. Available flags: <code lang='und' xml:lang='und'>:flat</code>.</dd><p class="pad"></p>

<dt><a name=".result_&#60;var&#62;_[:&#60;flag&#62;_...]"
>.result &#60;var&#62; [:&#60;flag&#62; ...]</a></dt><p class="pad"></p>

<dd>Between <b>.pcc_call</b> and <b>.pcc_end</b>, specify where one or more return value(s) should be stored. Available flags: <code lang='und' xml:lang='und'>:slurpy</code>, <code lang='und' xml:lang='und'>:optional</code>, and <code lang='und' xml:lang='und'>:opt_flag</code>.</dd><p class="pad"></p>
</dl>

<h2><a name="Shorthand_directives_for_PCC_call_and_return"
>Shorthand directives for PCC call and return <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="([&#60;var1&#62;_[:&#60;flag1&#62;_...],_...])_=_&#60;var2&#62;([&#60;arg1&#62;_[:&#60;flag2&#62;_...],_...])"
>([&#60;var1&#62; [:&#60;flag1&#62; ...], ...]) = &#60;var2&#62;([&#60;arg1&#62; [:&#60;flag2&#62; ...], ...])</a></dt><p class="pad"></p>

<dd>This is short for:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  .pcc_begin
  .pcc_arg &#60;arg1&#62; &#60;flag2&#62;
  ...
  .pcc_call &#60;var2&#62;
  .result &#60;var1&#62; &#60;flag1&#62;
  ...
  .pcc_end</pre>

<dt><a name="&#60;var&#62;_=_&#60;var&#62;([arg_[:&#60;flag&#62;_...],_...])"
>&#60;var&#62; = &#60;var&#62;([arg [:&#60;flag&#62; ...], ...])</a></dt><p class="pad"></p>

<dt><a name="&#60;var&#62;([arg_[:&#60;flag&#62;_...],_...])"
>&#60;var&#62;([arg [:&#60;flag&#62; ...], ...])</a></dt><p class="pad"></p>

<dt><a name="&#60;var&#62;.&#34;_method&#34;([arg_[:&#60;flag&#62;_...],_...])"
>&#60;var&#62;.&#34;_method&#34;([arg [:&#60;flag&#62; ...], ...])</a></dt><p class="pad"></p>

<dt><a name="&#60;var&#62;._method([arg_[:&#60;flag&#62;_...],_...])"
>&#60;var&#62;._method([arg [:&#60;flag&#62; ...], ...])</a></dt><p class="pad"></p>

<dd>Function or method call. These notations are shorthand for a longer PCC function call with <b>.pcc_*</b> directives. <i>var</i> can denote a global subroutine, a local <b>identifier</b> or a <b>reg</b>.</dd><p class="pad"></p>

<dd>{{We should review the (currently inconsistent) specification of the method name. Currently it can be a bare word, a quoted string or a string register. See #45859.}}</dd><p class="pad"></p>

<dt><a name=".return_([&#60;var&#62;_[:&#60;flag&#62;_...],_...])"
>.return ([&#60;var&#62; [:&#60;flag&#62; ...], ...])</a></dt><p class="pad"></p>

<dd>Return from the current compilation unit with zero or more values.</dd><p class="pad"></p>

<dd>The surrounded parentheses are mandatory. Besides making sequence break more conspicuous, this is necessary to distinguish this syntax from other uses of the <b>.return</b> directive that will be probably deprecated.</dd><p class="pad"></p>

<dt><a name=".return_&#60;var&#62;(args)"
>.return &#60;var&#62;(args)</a></dt><p class="pad"></p>

<dt><a name=".return_&#60;var&#62;.&#34;somemethod&#34;(args)"
>.return &#60;var&#62;.&#34;somemethod&#34;(args)</a></dt><p class="pad"></p>

<dt><a name=".return_&#60;var&#62;.somemethod(args)"
>.return &#60;var&#62;.somemethod(args)</a></dt><p class="pad"></p>

<dd>Tail call: call a function or method and return from the sub with the function or method call return values.</dd><p class="pad"></p>

<dd>Internally, the call stack doesn&#39;t increase because of a tail call, so you can write recursive functions and not have stack overflows.</dd><p class="pad"></p>
</dl>

<h2><a name="Parameter_Passing_and_Getting_Flags"
>Parameter Passing and Getting Flags <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>See <a href='TODO#pdd03_calling_conventions.pod'>PDD03</a> for a description of the meaning of the flag bits <code lang='und' xml:lang='und'>SLURPY</code>, <code lang='und' xml:lang='und'>OPTIONAL</code>, <code lang='und' xml:lang='und'>OPT_FLAG</code>, and <code lang='und' xml:lang='und'>FLAT</code>, which correspond to the calling convention flags <code lang='und' xml:lang='und'>:slurpy</code>, <code lang='und' xml:lang='und'>:optional</code>, <code lang='und' xml:lang='und'>:opt_flag</code>, and <code lang='und' xml:lang='und'>:flat</code>.</p>

<p>{{ TODO: once these flag bits are solidified by long&#45;term use, then we may choose to copy appropriate bits of the documentation to here. }}</p>

<h2><a name="Instructions"
>Instructions <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Instructions may be a valid PASM instruction or anything listed here below:</p>

<dl>
<dt><a name="goto_&#60;identifier&#62;"
>goto &#60;identifier&#62;</a></dt><p class="pad"></p>

<dd><b>branch</b> to <b>identifier</b> (label or subroutine name).</dd><p class="pad"></p>

<dd>Examples:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  goto END</pre>

<dt><a name="if_&#60;var&#62;_goto_&#60;identifier&#62;"
>if &#60;var&#62; goto &#60;identifier&#62;</a></dt><p class="pad"></p>

<dd>If <b>var</b> evaluates as true, jump to the named <b>identifier</b>. Translate to <b>if var, identifier</b>.</dd><p class="pad"></p>

<dt><a name="unless_&#60;var&#62;_goto_&#60;identifier&#62;"
>unless &#60;var&#62; goto &#60;identifier&#62;</a></dt><p class="pad"></p>

<dd>Unless <b>var</b> evaluates as true, jump to the named <b>identifier</b>. Translate to <b>unless var, identifier</b>.</dd><p class="pad"></p>

<dt><a name="if_null_&#60;var&#62;_goto_&#60;identifier&#62;"
>if null &#60;var&#62; goto &#60;identifier&#62;</a></dt><p class="pad"></p>

<dd>If <b>var</b> evaluates as null, jump to the named <b>identifier</b>. Translate to <b>if_null var, identifier</b>.</dd><p class="pad"></p>

<dt><a name="unless_null_&#60;var&#62;_goto_&#60;identifier&#62;"
>unless null &#60;var&#62; goto &#60;identifier&#62;</a></dt><p class="pad"></p>

<dd>Unless <b>var</b> evaluates as null, jump to the named <b>identifier</b>. Translate to <b>unless_null var, identifier</b>.</dd><p class="pad"></p>

<dt><a name="if_&#60;var1&#62;_&#60;relop&#62;_&#60;var2&#62;_goto_&#60;identifier&#62;"
>if &#60;var1&#62; &#60;relop&#62; &#60;var2&#62; goto &#60;identifier&#62;</a></dt><p class="pad"></p>

<dd>The <b>relop</b> can be: <b>&#60;, &#60;=, ==, != &#62;= &#62;</b> which translate to the PASM opcodes <b>lt</b>, <b>le</b>, <b>eq</b>, <b>ne</b>, <b>ge</b> or <b>gt</b>. If <b>var1</b> <b>relop</b> <b>var2</b> evaluates as true, jump to the named <b>identifier</b>.</dd><p class="pad"></p>

<dt><a name="unless_&#60;var1&#62;_&#60;relop&#62;_&#60;var2&#62;_goto_&#60;identifier&#62;"
>unless &#60;var1&#62; &#60;relop&#62; &#60;var2&#62; goto &#60;identifier&#62;</a></dt><p class="pad"></p>

<dd>The <b>relop</b> can be: <b>&#60;, &#60;=, ==, != &#62;= &#62;</b> which translate to the PASM opcodes <b>lt</b>, <b>le</b>, <b>eq</b>, <b>ne</b>, <b>ge</b> or <b>gt</b>. Unless <b>var1</b> <b>relop</b> <b>var2</b> evaluates as true, jump to the named <b>identifier</b>.</dd><p class="pad"></p>

<dt><a name="&#60;var1&#62;_=_&#60;var2&#62;"
>&#60;var1&#62; = &#60;var2&#62;</a></dt><p class="pad"></p>

<dd>Assign a value. Translates to <b>set var1, var2</b>.</dd><p class="pad"></p>

<dt><a name="&#60;var1&#62;_=_&#60;unary&#62;_&#60;var2&#62;"
>&#60;var1&#62; = &#60;unary&#62; &#60;var2&#62;</a></dt><p class="pad"></p>

<dd>The <b>unary</b>s <b>!</b>, <b>&#45;</b> and <b>~</b> generate <b>not</b>, <b>neg</b> and <b>bnot</b> ops.</dd><p class="pad"></p>

<dt><a name="&#60;var1&#62;_=_&#60;var2&#62;_&#60;binary&#62;_&#60;var3&#62;"
>&#60;var1&#62; = &#60;var2&#62; &#60;binary&#62; &#60;var3&#62;</a></dt><p class="pad"></p>

<dd>The <b>binary</b>s <b>+</b>, <b>&#45;</b>, <b>*</b>, <b>/</b>, <b>%</b> and <b>**</b> generate <b>add</b>, <b>sub</b>, <b>mul</b>, <b>div</b>, <b>mod</b> and <b>pow</b> arithmetic ops. <b>binary</b> <b>.</b> is <b>concat</b> and only valid for string arguments.</dd><p class="pad"></p>

<dd><b>&#60;&#60;</b> and <b>&#62;&#62;</b> are arithmetic shifts <b>shl</b> and <b>shr</b>. <b>&#62;&#62;&#62;</b> is the logical shift <b>lsr</b>.</dd><p class="pad"></p>

<dd><b>&#38;&#38;</b>, <b>||</b> and <b>~~</b> are logic <b>and</b>, <b>or</b> and <b>xor</b>.</dd><p class="pad"></p>

<dd><b>&#38;</b>, <b>|</b> and <b>~</b> are binary <b>band</b>, <b>bor</b> and <b>bxor</b>.</dd><p class="pad"></p>

<dt><a name="&#60;var1&#62;_&#60;op&#62;=_&#60;var2&#62;"
>&#60;var1&#62; &#60;op&#62;= &#60;var2&#62;</a></dt><p class="pad"></p>

<dd>This is equivalent to <b>&#60;var1&#62; = &#60;var1&#62; &#60;op&#62; &#60;var2&#62;</b>. Where <b>op</b> is called an assignment operator and can be any of the following binary operators described earlier: <b>+</b>, <b>&#45;</b>, <b>*</b>, <b>/</b>, <b>%</b>, <b>.</b>, <b>&#38;</b>, <b>|</b>, <b>~</b>, <b>&#60;&#60;</b>, <b>&#62;&#62;</b> or <b>&#62;&#62;&#62;</b>.</dd><p class="pad"></p>

<dt><a name="&#60;var&#62;_=_&#60;var&#62;_[_&#60;var&#62;_]"
>&#60;var&#62; = &#60;var&#62; [ &#60;var&#62; ]</a></dt><p class="pad"></p>

<dd>This generates either a keyed <b>set</b> operation or <b>substr var, var, var, 1</b> for string arguments and an integer key.</dd><p class="pad"></p>

<dt><a name="&#60;var&#62;_=_&#60;var&#62;_[_&#60;key&#62;_]"
>&#60;var&#62; = &#60;var&#62; [ &#60;key&#62; ]</a></dt><p class="pad"></p>

<dd>where <code lang='und' xml:lang='und'>key</code> is:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'> &#60;var1&#62; .. &#60;var2&#62;</pre>

<dd>returns a slice defined starting at <code lang='und' xml:lang='und'>var1</code> and ending at <code lang='und' xml:lang='und'>var2</code>.</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'> .. &#60;var2&#62;</pre>

<dd>returns a slice starting at the first element, and ending at <code lang='und' xml:lang='und'>var2</code>.</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'> &#60;var1&#62; ..</pre>

<dd>returns a slice starting at <code lang='und' xml:lang='und'>var1</code> to the end of the array.</dd><p class="pad"></p>

<dd>see src/pmc/slice.pmc and t/pmc/slice.t.</dd><p class="pad"></p>

<dt><a name="&#60;var&#62;_[_&#60;var&#62;_]_=_&#60;var&#62;"
>&#60;var&#62; [ &#60;var&#62; ] = &#60;var&#62;</a></dt><p class="pad"></p>

<dd>A keyed <b>set</b> operation or the assign <b>substr</b> op with a length of 1.</dd><p class="pad"></p>

<dt><a name="&#60;var&#62;_=_new_&#39;&#60;type&#62;&#39;"
>&#60;var&#62; = new &#39;&#60;type&#62;&#39;</a></dt><p class="pad"></p>

<dd>Create a new PMC of type <b>type</b> stored in <b>var</b>. Translate to <b>new var, &#39;type&#39;</b>.</dd><p class="pad"></p>

<dt><a name="&#60;var1&#62;_=_new_&#39;&#60;type&#62;&#39;,_&#60;var2&#62;"
>&#60;var1&#62; = new &#39;&#60;type&#62;&#39;, &#60;var2&#62;</a></dt><p class="pad"></p>

<dd>Create a new PMC of type <b>type</b> stored in <b>var1</b> and using <b>var2</b> as PMC containing initialization data. Translate to <b>new var1, &#39;type&#39;, var2</b></dd><p class="pad"></p>

<dt><a name="&#60;var1&#62;_=_defined_&#60;var2&#62;"
>&#60;var1&#62; = defined &#60;var2&#62;</a></dt><p class="pad"></p>

<dd>Assign to <b>var1</b> the value for definedness of <b>var2</b>. Translate to <b>defined var1, var2</b>.</dd><p class="pad"></p>

<dt><a name="&#60;var1&#62;_=_defined_&#60;var2&#62;_[_&#60;var3&#62;_]"
>&#60;var1&#62; = defined &#60;var2&#62; [ &#60;var3&#62; ]</a></dt><p class="pad"></p>

<dd><b>defined var1, var2[var3]</b> the keyed op.</dd><p class="pad"></p>

<dt><a name="global_&#34;string&#34;_=_&#60;var&#62;"
>global &#34;string&#34; = &#60;var&#62;</a></dt><p class="pad"></p>

<dd>{{ DEPRECATED: op store_global was deprecated }}</dd><p class="pad"></p>

<dt><a name="&#60;var&#62;_=_global_&#34;string&#34;"
>&#60;var&#62; = global &#34;string&#34;</a></dt><p class="pad"></p>

<dd>{{ DEPRECATED: op find_global was deprecated }}</dd><p class="pad"></p>

<dt><a name="&#60;var1&#62;_=_clone_&#60;var2&#62;"
>&#60;var1&#62; = clone &#60;var2&#62;</a></dt><p class="pad"></p>

<dd>Assing to <b>var1</b> a clone of <b>var2</b>. Translate to <b>clone var1, var2</b>.</dd><p class="pad"></p>

<dt><a name="&#60;var&#62;_=_addr_&#60;identifier&#62;"
>&#60;var&#62; = addr &#60;identifier&#62;</a></dt><p class="pad"></p>

<dd>Assign to <b>var</b> the address of label identified by <b>identifier</b>. Translate to <b>set_addr var, var</b>.</dd><p class="pad"></p>

<dt><a name="&#60;var&#62;_=_null"
>&#60;var&#62; = null</a></dt><p class="pad"></p>

<dd>Set <b>var</b> to null. Translate to <b>null &#60;var</b>.</dd><p class="pad"></p>

<dt><a name="addr"
>addr</a></dt><p class="pad"></p>

<dd>Return the address of a label.</dd><p class="pad"></p>
</dl>

<h1><a name="QUESTIONS"
>QUESTIONS <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<ul>
<li>morph</li><p class="pad"></p>

<pre lang='und' xml:lang='und'>        &#60;pmichaud&#62;      I don&#39;t think that &#39;morph&#39; as a method call is a good idea
        &#60;pmichaud&#62;      we need something that says &#34;assign to value&#34; versus &#34;assign to container&#34;
        &#60;pmichaud&#62;      we can&#39;t eliminate the existing &#39;morph&#39; opcode until we have a replacement</pre>
</ul>

<h1><a name="ATTACHMENTS"
>ATTACHMENTS <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>N/A</p>

<h1><a name="FOOTNOTES"
>FOOTNOTES <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>N/A</p>

<h1><a name="REFERENCES"
>REFERENCES <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>N/A</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
