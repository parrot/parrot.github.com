<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Parrot Concurrency</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Parrot Concurrency</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../../html/index.html">Contents</a> | <a href="../../../../html/docs.html">Documentation</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>docs/pdds/draft/pdd25_concurrency.pod &#45; Parrot Concurrency</p>

<h1><a name="ABSTRACT"
>ABSTRACT <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>This document defines the requirements and implementation strategy for Parrot&#39;s concurrency models.</p>

<h1><a name="VERSION"
>VERSION <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>$Revision$</p>

<h1><a name="DEFINITIONS"
>DEFINITIONS <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p><i>Concurrency</i> is a parallel execution of units of code (on multiprocessor machines),
or a flexible ordering of units of code (on single processor machines).
For certain problem spaces,
concurrency offers significant speed gains by parceling out processor&#45;intensive activity or by ensuring that a wait for input or system resources doesn&#39;t hold up the entire application.</p>

<p>A <i>Task</i> is a unit of code that can be executed in parallel.</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<dl>
<dt><a
>&#45; Parrot supports multiple concurrency models,
including POSIX threads,
event&#45;based programming,
and asynchronous I/O.</a></dt><p class="pad"></p>

<dt><a
>&#45; To reduce conflicts between concurrency models,
Parrot provides a single central concurrency scheduler for each interpreter instance.
Each concurrency model defines a Task PMC that supports a standard minimal interface.
The scheduler can interact with tasks from various models without direct access to the details of each model.</a></dt><p class="pad"></p>

<dt><a
>&#45; On multiprocessor systems,
the scheduler is responsible for allocating tasks to processors,
or for delegating that allocation to the underlying OS.</a></dt><p class="pad"></p>
</dl>

<h1><a name="DEFINITIONS"
>DEFINITIONS <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>So we can all talk about things the same way,
the following definitons apply.
Some of these are drawn from the POSIX thread spec,
and as such we should have a translation section at the end.</p>

<dl>
<dt><a name="THREAD"
>THREAD</a></dt><p class="pad"></p>

<dd>An OS level thread.
If that makes no sense,
neither will any of the rest of this,
in which case I recommend picking up &#34;Programming with POSIX Threads&#34; by Dave Butenhof,
and coming back when you have.</dd><p class="pad"></p>

<dt><a name="MUTEX"
>MUTEX</a></dt><p class="pad"></p>

<dd>This is a low level,
under the hood,
not exposed to users,
thing that can be locked.
They&#39;re non&#45;recursive,
non&#45;read/write,
exclusive things.
When a thread gets a mutex,
any other attempt to get that mutex will block until the owning thread releases the mutex.
The platform&#45;native lock construct will be used for this.</dd><p class="pad"></p>

<dd>{{ &#45; Nigel Sandever: Will this be macroised to hide the platform native implementation from the main body of the code?
&#45; Dan: Yes.
}}</dd><p class="pad"></p>

<dt><a name="LOCK"
>LOCK</a></dt><p class="pad"></p>

<dd>This is an exposed&#45;to&#45;HLL&#45;code thing that can be locked.
Only PMCs can be locked,
and the lock may or may not be recursive or read/write.</dd><p class="pad"></p>

<dt><a name="CONDITION_VARIABLE"
>CONDITION VARIABLE</a></dt><p class="pad"></p>

<dd>The &#34;sleep until something pings me&#34; construct.
Useful for queue construction.
Not conceptually associated with a MUTEX.
(POSIX threads require this,
so we&#39;re going to hide it there behind macros and/or functions)</dd><p class="pad"></p>

<dd>{{ &#45; Nigel Sandever: Could you elaborate on the nature of what would constitute a &#34;ping&#34;?
&#45; Dan: POSIX has a function cond_signal (and cond_broadcast,
which is similar).
What happens is a thread grabs the condition variable and goes to sleep,
and sleeps until another thread does a cond_signal,
which then wakes it up.
If there are multiple threads sleeping on the condition variable,
only one is woken.
(cond_broadcast wakes them all up) }}</dd><p class="pad"></p>

<dt><a name="RENDEZVOUS_POINT"
>RENDEZVOUS POINT</a></dt><p class="pad"></p>

<dd>A HLL version of a condition variable.</dd><p class="pad"></p>

<dt><a name="INTERPRETER"
>INTERPRETER</a></dt><p class="pad"></p>

<dd>Those bits of the Parrot_Interp structure that are absolutely required to be thread&#45;specific.
This includes the current register sets and stack pointers,
as well as security context information.
Basically if a continuation captures it,
it&#39;s the interpreter.</dd><p class="pad"></p>

<dt><a name="INTERPRETER_ENVIRONMENT"
>INTERPRETER ENVIRONMENT</a></dt><p class="pad"></p>

<dd>Those bits of the Parrot_Interp structure that aren&#39;t required to be thread&#45;specific (though I&#39;m not sure there are any) <i>PLUS</i> anything pointed to that doesn&#39;t have to be thread&#45;specific.</dd><p class="pad"></p>

<dd>The environment includes the global namespaces,
pads,
stack chunks,
memory allocation regions,
arenas,
and whatnots.
Just because the pointer to the current pad is thread&#45;specific doesn&#39;t mean the pad <i>itself</i> has to be.
It can be shared.</dd><p class="pad"></p>

<dt><a name="INDEPENDENT_THREAD"
>INDEPENDENT THREAD</a></dt><p class="pad"></p>

<dd>A thread that has no contact <i>AT ALL</i> with the internal data of any other thread in the current process.
Independent threads need no synchronization for anything other than what few global things we have.
And the fewer the better,
though alas we can&#39;t have none at all.</dd><p class="pad"></p>

<dd>Note that independent threads may still communicate back and forth by passing either atomic things (ints,
floats,
and pointers) or static buffers that can become the property of the destination thread.</dd><p class="pad"></p>

<dt><a name="SHARED_THREAD"
>SHARED THREAD</a></dt><p class="pad"></p>

<dd>A thread that&#39;s part of a group of threads sharing a common interpreter environment.</dd><p class="pad"></p>

<dd>{{ &#45; Leo: I presume that this &#34;group of threads&#34; is one thread pool or interpreter pool.
Could you expand the definition to cover &#34;pool&#34;.
&#45; Dan: Ah,
damn,
I needed to fix that up before sending it out.
Should&#39;ve been &#34;SHARED INTERPRETER&#34;.
A shared interpreter is one that&#39;s in an interpreter pool.</dd><p class="pad"></p>

<dd>An interpreter pool is a set of interpreters that share common resources.
They&#39;re essentially threads in the OS sense,
and they have shared access to pretty much everything.
The memory pools,
arenas,
and global namespace are shared&#45;&#45;pretty much everything except what&#39;s in the interpreter structure itself.
}}</dd><p class="pad"></p>
</dl>

<h1><a name="REQUIREMENTS"
>REQUIREMENTS <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<h2><a name="Supported_Models"
>Supported Models <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="POSIX_threads"
>POSIX threads</a></dt><p class="pad"></p>

<dd>The threading scheme must be sufficient to support a POSIX share&#45;everything style of threading,
such as is used in perl 5&#39;s &#34;pthread&#34; model,
as well as the thread models for Ruby and Python.</dd><p class="pad"></p>

<dt><a name="&#34;Process&#45;type&#34;_threads"
>&#34;Process&#45;type&#34; threads</a></dt><p class="pad"></p>

<dd>The scheme must also support the perl 5 &#34;iThreads&#34; threading model.
In this model no data is shared implicitly,
and all sharing must be done on purpose and explicitly.
It very much resembles the Unix fork&#45;process&#45;with&#45;shared&#45;memory&#45;segment model,
not a surprise as it was originally developed with emulation of Unix&#39;s fork system in mind.</dd><p class="pad"></p>

<dd>{{ &#45; Nigel Sandever: Pseudo forks?
&#45; Dan: Yeah.
On Win32,
when Perl forks it starts a new thread and clones the interpreter and its contents.
If you later do an exec in that thread it starts a new process and grabs hold of it.
Definitely a clever trick.
}}</dd><p class="pad"></p>
</dl>

<h2><a name="Guarantees"
>Guarantees <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>{{ &#45;Dave Whipp: Maybe this isn&#39;t strictly a threading thing,
but are we going to make any guarantees about event orderings?
For example,
will we guarantee that a sequence of events send from one thread to another will always be received in the order they are sent?
(Obviously no guarantees about interleaving of events from other threads).
This is usually only important in distributed environments where multiple paths exists between a pair of endpoints,
but it would be nice for user&#45;code to be able to rely on it.
&#45; Dan: Hrm.
I suppose we really ought to,
so we will.
If we prioritize events (and I&#39;m still torn) then they&#39;ll be in priority then send order.
}}</p>

<dl>
<dt><a name="No_Crashes"
>No Crashes</a></dt><p class="pad"></p>

<dd>The interpreter guarantees that no user program errors of any sort will crash the interpreter.
This includes threading problems.
As such,
synchronization issues (where multiple interpreters are accessing the same shared data) must not crash the interpreter or corrupt its internal state.</dd><p class="pad"></p>
</dl>

<h2><a name="Assumptions"
>Assumptions <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="System_memory_allocation_routines_are_threadsafe"
>System memory allocation routines are threadsafe</a></dt><p class="pad"></p>

<dd>We are assuming that the memory allocation system of the base OS is threadsafe.
While some of the C runtime libraries are notoriously thread dangerous,
memory allocation code generally is threadsafe,
and we&#39;ll assume that on all platforms.
(Though we will,
in general,
manage our own memory)</dd><p class="pad"></p>

<dd>{{ &#45; Nigel Sandever: Is there any likelyhood that memory allocation will be hidden behind macros at two levels: &#45; ALLOCPOOL() for allocating large chunks of memory (ppols) that are later sub&#45;allocated (and managed) by: &#45; SUBALLOC() for sub allocating within a pool</dd><p class="pad"></p>

<dd>&#45; Dan: We&#39;ll generally hide behind the memory.c routines,
if for no other reason than to allow the embedder to override the memory functions.
We need to define that at some point...
&#45; Gordon Henriksen: Are you wanting something akin to Apache 2 pools,
which are hierarchical and designed to reduce path length when freeing blocks of objects?
For instance,
all objects and sub&#45;pools allocated during an HTTP request cycle can be deallocated just by free()&#39;ing the top&#45;level request pool.</dd><p class="pad"></p>

<dd>I don&#39;t think parrot could make use of that model,
since it can&#39;t very well guarantee that the user cannot retain references past the lifetime of the pool.
Apache trusts modules not to make such errors; parrot can&#39;t trust the byte&#45;code it&#39;s executing any further than it can throw it.
A generational collector is a more likely means by which parrot might reduce memory&#45;related overhead.
&#45; Nigel Sandever: Nothing to do with Apache memory pools.</dd><p class="pad"></p>

<dd>I believe that parrot already has the concept of memory pools in it&#39;s memory management.
The idea is that by allocating similarly sized objects from separate (large) allocations,
you can reduce the fragmentation of chunks and reduce the incidences where the memory need to be GC&#39;d and compacted.</dd><p class="pad"></p>

<dd>Allocating an 8 byte chunk from a common memory pool is quite likely to nip a little off from a previously freed large chunk.
When it comes time reallocate another chunk the same size as that large,
freed chunk,
although there is enough room in the over all freespace chain to accommodate it,
the largest available chunk is now 8 bytes or so too small for the requirement.</dd><p class="pad"></p>

<dd>That induces either a compaction cycle or the need to extend the memory pool by the size of the large request.</dd><p class="pad"></p>

<dd>Allocating all small requests from the same pool,
and large from another pool means that you are less likely to fragment the memory and more likely to be able to re&#45;use an existing slot in the free&#45;space chain for any given request.</dd><p class="pad"></p>

<dd>If the allocation of pools,
and the allocation of bit&#45;of&#45;a&#45;pool,
are macroised,
it makes it possible for OS&#39;s where there are multiple APIs for memory allocation to bypass the CRT memory allocation routines and use which ever native APis are best suited for the type of allocation.</dd><p class="pad"></p>

<dd>Personally,
I would like to see memory allocation for each class type be managed by the class constructor itself.
This would theoretically allow each class that has a fixed instance size to manage it&#39;s own pool on OS&#39;s where that makes sense.
The class would allocate a pool for itself when loaded and then allocate instances from that pool on new() and deallocate upon DESTROY.
If it&#39;s memory pool was exhausted when new was called,
it would invoke the GC on *it&#39;s pool only*.</dd><p class="pad"></p>

<dd>This separation would mean that each run of the GC would have a much smaller pool of memory to compact and garbage collect when it was invoked.
It would also be less likely to be called,
as each allocation from a pool of fixed sized sub allocations will only ever need to call the GC when it&#39;s pool is entirely exhausted.</dd><p class="pad"></p>

<dd>But that is a radical departure :),
so if would just like to see separate calls for pool allocation/reallocation and element allocation/reallocation,
rather than having calls to malloc() scattered through out the codebase.</dd><p class="pad"></p>

<dd>&#45; Gordon Henrikson: Don&#39;t presume that [allocating similarly sized objects reduces fragmentation and GC].
General purpose memory allocators tend to handle this scenario...
generically.
Use of custom allocators is usually a premature optimization; the best generic memory allocators are very,
very good.</dd><p class="pad"></p>

<dd>But the ultimate effect of the overuse of custom allocators or pools is to move memory fragmentation to a higher level,
preventing the generic allocator from addressing it even when the memory allocation patterns would otherwise allow it.</dd><p class="pad"></p>

<dd>Would much rather see [the allocation of pools] abstracted,
as they are now,
beneath an API.
This reduces the number of ways in which compiled parrot extensions can be incompatible with the parrot core.</dd><p class="pad"></p>

<dd>A PMC class is free to [manage the memory allocation for its own class constructor].
Only the PMC header cannot be thus managed,
and that&#39;s already pooled.</dd><p class="pad"></p>

<dd>Th[e idea that such a separation means a smaller pool to compact and garbage collect] is false.
The mark phase will still need to run over the entire process,
else it cannot detect all references into the pool.
(Unless you can provide a type&#45;safety guarantee that your type can only be referenced by other instances of itself.
In which case,
your type is necessarily &#34;garbage&#34; and the best optimization strategy would be dead&#45;code elimination.
:)</dd><p class="pad"></p>

<dd>&#45; Nigel Sandever: If by reference,
you mean address,
then that is true.</dd><p class="pad"></p>

<dd>If when a reference is taken,
the address of the referent is stored in arbitrary other data structures,
then all memory be scanned by the GC,</dd><p class="pad"></p>

<dd>However,
if references were not addresses,
but an index into a table of addresses,
then only the table need be scanned.</dd><p class="pad"></p>

<dd>When a reference,
or the thing holding it,
is deleted,
then the indexed slot in the address table is blanked and subsequent GC passes looking for references to a referent will no longer find the reference in the table.</dd><p class="pad"></p>

<dd>With the addition of a reference count to the table,
all references to a single entity can share the same index,
but now I&#39;m groping back in the direction of reference counting,
which is not flavour of the month:)</dd><p class="pad"></p>

<dd>&#45; Gordon Henrikson: I predict the best overall throughput would be with the sweep or copy phase run immediately after the mark phase,
across the entire process: It would be wasteful to do all that marking and yet leave known garbage uncollected.</dd><p class="pad"></p>

<dd>Statistically,
multiple pools will individually exhaust themselves *MORE* frequently than a global pool.
The ideal case for collection frequency is that there is only one pool,
or that all pools rise to capacity concurrently.
In these ideal cases,
the segregated pools will exhaust themselves precisely *AS* frequently as a global pool.
In any case,
there is no possibility for a decrease in collection events through the use of pooled memory.
As per above,
collection events will also not become less expensive.
Thus,
expect garbage collection to have a negative net impact on performance if pooled memory is used.</dd><p class="pad"></p>

<dd>&#45; Leo: The problem is not in the fixed sized header pools,
its with the *memory* pool used e.g for string memory.</dd><p class="pad"></p>

<dd>During GC we are walking the *header* pools,
and if we find its buffer memory being used,
we move that buffer memory to a new store,
thereby compacting it.
The old memory store(s) are freed then.</dd><p class="pad"></p>

<dd>So string memory can move around beyond your code.
}}</dd><p class="pad"></p>
</dl>

<h1><a name="Proposal"
>Proposal <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>The proposal is as follows:</p>

<dl>
<dt><a name="All_global_state_shall_be_protected_by_mutexes"
>All global state shall be protected by mutexes</a></dt><p class="pad"></p>

<dd>Straightforward enough.
This allows for independent threads to coexist without threatening the state of the proces.</dd><p class="pad"></p>

<dt><a name="Multiple_independent_interpreters_will_be_allowed"
>Multiple independent interpreters will be allowed</a></dt><p class="pad"></p>

<dd>Once again,
straightforward enough.
With threadsafe protected global state,
there&#39;s no issue here.</dd><p class="pad"></p>

<dt><a name="Only_one_OS_thread_in_an_interpreter_at_once"
>Only one OS thread in an interpreter at once</a></dt><p class="pad"></p>

<dd>While there is no requirement that any interpreter be tied to an underlying OS thread,
under no circumstances may multiple OS threads use a single interpreter simultaneously.</dd><p class="pad"></p>

<dt><a name="A_Stop&#45;and&#45;copy_communication_method_will_be_provided"
>A Stop&#45;and&#45;copy communication method will be provided</a></dt><p class="pad"></p>

<dd>Parrot will provide a function to make a call into another interpreter and wait for that call to complete.
This call may pass in data and have data returned to it.
The interpreter making the call will block until the call is complete.
The data passed in as parameters will be copied into the called interpreter,
and any return values will be copied back into the calling interpreter.
The called interpreter will block while the return data is copied back into the calling interpreter.</dd><p class="pad"></p>

<dt><a name="Inter&#45;interpreter_events_will_be_provided"
>Inter&#45;interpreter events will be provided</a></dt><p class="pad"></p>

<dd>Interpreters will be able to post events to other interpreters.</dd><p class="pad"></p>

<dt><a name="Each_interpreter_will_have_a_unique_id"
>Each interpreter will have a unique id</a></dt><p class="pad"></p>

<dd>This ID will be independent of the process or OS thread,
and will be constant across the lifetime of the interpreter.
Interpreter IDs <i>may</i> be reused as interpreters are destroyed and recreated,
and as such are only guaranteed valid while an interpreter is in use.</dd><p class="pad"></p>

<dd>(Note that we may decide to relax this requirement,
but doing so likely means moving to at least 64&#45;bit integers to mark interpreter IDs)</dd><p class="pad"></p>

<dd>{{ &#45; Nigel Sandever: The provision of method(s) to obtain the native TIDs/HANDLES would make life for those writing implementation specific extensions easier.
&#45; Dan: TIDs,
definitely.
It&#39;ll be a sysinfo or interpinfo function.
There&#39;s the issue of interpreters binding to different threads,
but we&#39;ll deal with that.
I&#39;m not sure what the HANDLE is,
but explain it and we can work something out.
:) }}</dd><p class="pad"></p>

<dt><a name="Each_interpreter_show_the_same_process_id"
>Each interpreter show the same process id</a></dt><p class="pad"></p>

<dd>All the interpreters within a process will share a process ID.
On those systems where each thread has its own unique ID (such as many versions of Linux) Parrot will still report a single process ID for all interpreters.</dd><p class="pad"></p>

<dd>This process ID will be the ID of the process that first instantiated Parrot.</dd><p class="pad"></p>

<dd>{{ &#45; Leo: The term &#34;process id&#34; is really misleading.
Again I presume that one pool is meant here.
I&#39;d vote for keeping a process ID what it is and use &#34;pool id&#34; or such here.
&#45; Dan: Nope.
It&#39;s the process ID.
Nothing misleading there,
unless you&#39;ve done threading work under linux,
since for a while it gave each thread a separate PID.
&#45; Leo: $ ps | grep [p]arrot 17472 pts/0 00:00:00 parrot 17473 pts/0 00:00:00 parrot 17474 pts/0 00:00:00 parrot</dd><p class="pad"></p>

<dd>So the unless applies ;) This is a single parrot interpreter,
with main,
thread&#45;manager,
and event&#45;handler thread.
3 PIDs.</dd><p class="pad"></p>

<dd>&#45; Liz Mattijsen: This _all_ depends on which version of Linux you&#39;re using.
Older versions don&#39;&#39;t do it that way,
and newer versions don&#39;t do it either (the specific versions escape me at the moment,
but I know RH9 does _not_ have pids for threads).</dd><p class="pad"></p>

<dd>I know,
because my Thread::Signal module depends on threads having pids.
But fewer and fewer Linux systems &#34;support&#34; it (and Linux was the only one who worked this way to begin with).</dd><p class="pad"></p>

<dd>&#45; Dan: Right.
Linux is,
as I said,
arguably broken here,
but I don&#39;t want to argue that point.
That&#39;s why I specified that the PID is the process id of whatever instantiated parrot &#45;&#45; in this case,
no matter which thread you&#39;re in,
when you ask for the pid from parrot you should get 17472.
(In this case,
at least)</dd><p class="pad"></p>

<dd>Parrot needs to grab the pid at global initialization time and store it away for later pid queries.
}}</dd><p class="pad"></p>

<dt><a name="Interpreter_pools_will_share_allocation_pools"
>Interpreter pools will share allocation pools</a></dt><p class="pad"></p>

<dd>All the interpreters in an interpreter pool will share header and memory allocation pools.
This means that when there is more than one interpreter in a pool the memory allocation and collection system needs to be swapped out,
as a copying collector is generally untenable in a threaded environment.</dd><p class="pad"></p>

<dd>{{ &#45; Dan: For a copying collector to work,
all the mutators must be blocked,
and arguably all readers should be blocked as well.
(I think they need to be,
otherwise you may be accessing reclaimed and reused memory) That means if we keep a copying collector we need to have everything that accesses strings or pmcs to get a lock on the GC before every access of every string or PMC.
A touch excessive,
I think.
&#45; Gordon Henriksen: True of non&#45;moving collectors,
too.
Or,
let me put it this way: non&#45; copying *GC* (the sweep or copy phase) can be threadsafe,
but the mark phase is never threadsafe.
The method in which marking is not threadsafe is a bit more pathological (i.e.,
it&#39;s not the common case as it is with the copying collector),
but a standard tracing DOD cannot be correct when competeting with mutators.
It WILL collect non&#45; garbage (those are MUTATORS,
remember),
and the result WILL be Heizenbugs and crashes.</dd><p class="pad"></p>

<dd>Some of what I&#39;ve written up [AR see next comment] addresses why.
It&#39;s pretty simple to demonstrate a single case to prove the point,
but I don&#39;t feel like re&#45;creating the ASCII art right now.
:) I&#39;ll send that section when I get out of the office.</dd><p class="pad"></p>

<dd>parrot will have to be able to suspend all threads in the environment.
Unfortunate,
but really quite unavoidable.</dd><p class="pad"></p>

<dd>&#45; Dan: I&#39;m not sure that&#39;s the case.
What we need to do is suspend metadata mutation&#45;&#45;that is,
buffers can&#39;t be resized while a gc run is in progress.
Other than that,
if we have guarantees of aligned atomic pointer writes (so we don&#39;t have word shearing to deal with) we don&#39;t have to stop the mutation of the contents of the buffers themselves.</dd><p class="pad"></p>

<dd>The only tricky bit comes in with the examination of the root set of other threads&#45;&#45;accessing the hardware register contents of another running thread may be...
interesting.
(Which,
I suppose,
argues for some sort of volatile marking of the temp variables)</dd><p class="pad"></p>

<dd>&#45; Leo: You&#39;ll provide the &#34;interesting&#34; part,
that is:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  use Psi::Estimate::CPU_Register_Changes_in_Future_till_mark_is_done; </pre>

<dd>&#45; Dan: Nah, no need for that one. I need to go back and recheck the stuff that Gordon posted in case I missed something, but if you put a lock on the arena allocator this isn&#39;t an issue.</dd><p class="pad"></p>

<dd>&#45; Gordon Henriksen: Consider this simple object graph:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>     Root set = { &#38;A, &#38;B }

     [ A=NULL]
     [ B=&#38;C  ] &#45;&#45;&#45;&#62; [ C=....]</pre>

<dd>Collection begins in thread 1 and marks A as reachable before being preempted by thread 2:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>     [xA=NULL]
     [ B=&#38;C  ] &#45;&#45;&#45;&#62; [ C=....]</pre>

<dd>Thread 2 sets A to &#38;C, and nullifies B before being preempted again by thread 1:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>     [xA=&#38;C  ] &#45;&#45;&#45;&#62; [ C=....]
     [ B=NULL]</pre>

<dd>Thread 1 marks B as reachable:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>     [xA=&#38;C  ] &#45;&#45;&#45;&#62; [ C=....]
     [xB=NULL]</pre>

<dd>The mark phase complete, thread 1 sweeps:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>     [ A=&#38;???] &#45;&#45;&#45;&#62; ???
     [ B=NULL]</pre>

<dd>C was not marked reachable (although it was) and was thus erroneously collected, leaving a dangling pointer. This problem applies equally to copying and mark&#45;sweep collectors.</dd><p class="pad"></p>

<dd>&#45; Dan: Ah, OK, I see. The problem comes in where we&#39;ve got an object in the transient root set (basically the processor stack and registers) that gets anchored into the base root set (stash, pads, or whatever) after the DOD has traced where it&#39;s going into and falls out of the transient root set before the DOD traces over to it.</dd><p class="pad"></p>

<dd>Race condition. Dammit.</dd><p class="pad"></p>

<dd>&#45; Gordon Henriksen: (Worse than that. It could come from any untraced location&#45;&#45;or possibly even be brand new, depending upon memory allocation details.)</dd><p class="pad"></p>

<dd>&#45; Dan: Okay, I&#39;d not wrapped my brain around that possibility, which will make for some interesting DOD tracing, especially on SMP systems. I was *really* hoping a single lock on the arena allocation system that the DOD held onto while tracing would be sufficient, but I see that it isn&#39;t.</dd><p class="pad"></p>

<dd>That means we&#39;re going to have to have either a really forgiving DOD system that takes multiple passes before it collects up a PMC or buffer (which still isn&#39;t safe) or have some way to force a low&#45;overhead rendezvous.</dd><p class="pad"></p>

<dd>The obvious rendezvous point is the arena lock, but that&#39;s going to see a lot of contention anyway, and we&#39;d as soon not have a single one for speed reasons. Feh.</dd><p class="pad"></p>

<dd>Okay, we&#39;re going to mandate that we have read/write locks, each interpreter pool has one, and mutating vtable entries must get a read lock on the pool read/write lock. Pricey (ick) but isolated to mutators. The DOD gets a write lock on it, which&#39;ll block all read/write access so no mutators can be in process while the pool DOD runs.</dd><p class="pad"></p>

<dd>I think that&#39;ll work. The .1j thread spec requires r/w locks, and we can fake them on platforms that don&#39;t implement them. Hopefully Nigel&#39;s got the Windows scoop so we can see if Win32 has anything like this (which I&#39;d expect it does)</dd><p class="pad"></p>

<dd>&#45; Leo: That is well knowm in the literature as &#34;Tri&#45;Color Invariant&#34;: Black are the already marked (live) PMCs, grey the PMCs on the next_for_GC list, white the not yet reached PMCs. The strong tri&#45;color invariants states that no black object may point to a white object, the weak invariant states, that at least one path from the black to a white object must contain a grey one.</dd><p class="pad"></p>

<dd>This can be handled by either stop the world GCs or by intercepting each read or write access that would change the color of an object and update the color accordingly. This is e.g. used for incremental GC. As soon as we have a thread in the background that runs GC, we have to cope with these issues. &#45; Dan: Yeah, point. And since we want to be able to have an incremental DOD at some point we need to get support for it in now.</dd><p class="pad"></p>

<dd>&#45; Leo: Stopping all interpreters seems to be cheaper. The rwlock will sooner or later stop all interpreters anyway (on first PMC access), so we can omit the price for the rwlock and just hold the world(s). &#45; Dan: The rwlock only stops all the interpreters when the DOD runs. Anything that mutates a PMC gets a *read* lock so that they don&#39;t interfere with each other, and only pause if the DOD is running. The DOD getting a *write* lock will block any read lock attempts, so when the DOD is running no mutation can take place. Since mutation doesn&#39;t require any global exclusion it doesn&#39;t need a write lock &#45;&#45; the read lock is sufficient. &#45; Leo: Sure. But that would still need to aquire a readers rwlock for each PMC access. This is more expensive then a mutex. During DOD any PMC access will halt the interpreter, so we can do that explicitely too and save the cost for the rwlock overhead. Albeit I can imagine, that aggregates will need a rwlock anyway. &#45; Dan: Well... only the mutating vtable entries need to get the lock, so that reduces the expense somewhat. Still, I agree, it may be untenably expensive.</dd><p class="pad"></p>

<dd>&#45; Leo: An alternative would be real background incremental GC, *when* running multiple threads. I estimate the overhead to be in regions of a rwlock (with no contention of course). &#45; Dan: If we have the facilities to do incremental DOD runs then this is definitely a possibility except for finalizers. Finalizers make things interesting, though if the background thread doing the DOD is a member of the interpreter pool then it&#39;d work out OK. &#45; Leo: Finalizers and incremental DOD don&#39;t play together. The DOD must run to end to be sure, that the objects isn&#39;t referenced any more. &#45; Dan: Finalizers and incremental DOD work just fine together. At some point the incremental DOD will figure out that something&#39;s dead, just as the stop&#45;the&#45;world DOD will. It just may take a bit longer. &#45; Leo: I wanted to say: &#34;Finalizers &#38; destructors of PMCs that need timely destruction ...&#34;. In the case of dead objects at scope exit.</dd><p class="pad"></p>

<dd>&#45; Leo: What about temporary PMCs (or strings)? Evaluating a non&#45;trivial expression can have lot of these. Each new temp would need a lock on the memory sub&#45;system. &#45; Dan: Those won&#39;t get marked as shared unless we&#39;re unconditionally marking things as shared. (Though we may just give &#39;em a mutex anyway) [New temps would need a lock] only on allocation. We could have a per&#45;thread freelist if we wanted. Wouldn&#39;t be unreasonable. &#45; Leo: This needs either one check per PMC, if its shared or not, or additional costs for locking temps. Both are rather expensive, compared to the raw working functionality of a vtable.</dd><p class="pad"></p>

<dd>That already smells like separate memory sub&#45;systems. The freelist has to be filled first. During DOD runs, it has to be refilled. To achieve some locality of the temp PMCs, you can&#39;t just give these to arbitrary intpreters. Separate free lists seem also to imply separate DOD runs to cleanup the temps.</dd><p class="pad"></p>

<dd>&#45; Leo: Combined with the cost of: &#34;All shared PMCs must have a threadsafe vtable &#45; The first thing that any vtable function of a shared PMC must do is to aquire the mutex of the PMCs in its parameter list &#34; i.e. typically 3 mutexes, it could be that the vtable of a shared PMC should just grab one interpreter lock (of the owner of that PMC) and that not all is shared (especially not the temps). &#45; Dan: Yeah, but since PMCs aren&#39;t owned by any one interpreter in the pool but are rather pool&#45;wide you run into either the global&#45;lock problem (which kills performance on SMP systems) or interpreters potentially deadlocking on unrelated data access. &#45; Leo: Could be. But the performance is the overall throughput. When a lot of fine grained locks (plus memory subsystem locks for temps) take much longer then one global lock, then that scheme can nethertheless be slower on SMP machines. It would scale better though for more CPUs.</dd><p class="pad"></p>

<dd>Deadlocks shouldn&#39;t be a problem, if exactly one vtable (like in SharedRef) just grabs one and only one lock.</dd><p class="pad"></p>

<dd>&#45; Leo: [The Guarantees section] doesn&#39;t have anything about user data integrity. So when 2 threads access a PerlNum, they could get a mixture of the typically 2 involved words. &#45; Dan: Potentially, yeah, though it&#39;s really unlikely. &#45; Leo: But: &#34;The first thing that any vtable function of a shared PMC must do is to aquire the mutex of the PMCs in its parameter list...&#34; ... seems to indicate that even whole ops like add P,P,P are atomic. &#45; Dan: Yep. They have to be, because they need to guarantee the integrity of the pmc structures and the data hanging off them (which includes buffer and string stuff) &#45; Leo: But isn&#39;t that a contradiction? Or better: When even an opcode like above is atomic, that an access to a shared PerlNum should be guaranteed being atomic too. &#45; Dan: Sure, but there&#39;s a *lot* more to user data integrity than atomic access to individual pieces. That&#39;s the least of the problem. The user data issue is one where you have multiple pieces being updated, or one piece being updated multiple times&#45;&#45;that&#39;s the stuff we&#39;re not guaranteeing.</dd><p class="pad"></p>

<dd>So, while we will make sure that storing a single value into a hash happens atomically, we won&#39;t guarantee that a series of stores into the hash, or a combination of loads and stores, or even a combination of reads and writes to a scalar, will happen atomically.</dd><p class="pad"></p>

<dd>&#45; Leo: And how does user level locking play together with that? &#45; Dan: I&#39;ve not decided &#45;&#45; That was something I thought we might hash out as we abused the first half of the design doc. Personally I&#39;m all for the user and low&#45;level lock being the same thing, but that doesn&#39;t have to be the case. There are advantages and disadvantages to either way of doing things.</dd><p class="pad"></p>

<dd>&#45; Damien Neil: Personally, I think it would be better to use corruption&#45;resistant buffer and string structures, and avoid locking during basic data access. While there are substantial differences in VM design&#45;&#45;PMCs are much more complicated than any JVM data type&#45;&#45;the JVM does provide a good example that this can be done, and done efficiently.</dd><p class="pad"></p>

<dd>Failing this, it would be worth investigating what the real&#45;world performance difference is between acquiring multiple locks per VM operation (current Parrot proposal) vs. having a single lock controlling all data access (Python) or jettisoning OS threads entirely in favor of VM&#45;level threading (Ruby). This forfeits the ability to take advantage of multiple CPUs&#45;&#45;but Leopold&#39;s initial timing tests of shared PMCs were showing a potential 3&#45;5x slowdown from excessive locking.</dd><p class="pad"></p>

<dd>I&#39;ve seen software before that was redesigned to take advantage of multiple CPUs&#45;&#45;and then required no less than four CPUs to match the performance of the older, single&#45;CPU version. The problem was largely attributed to excessive locking of mostly&#45;uncontested data structures. }}</dd><p class="pad"></p>

<dd>As the allocation and collection system is a black box to user programs and much of the interpreter internals, this isn&#39;t a big deal outside of needing swappable allocation systems, the potential issue of COW&#39;d shared memory leaking, and the need to switch allocation schemes mid&#45;execution.</dd><p class="pad"></p>

<dt><a name="Each_interpreter_has_a_separate_event_queue"
>Each interpreter has a separate event queue</a></dt><p class="pad"></p>

<dd>Some events, such as timers, may be interpreter&#45;specific and, as such, each interpreter has its own event queue.</dd><p class="pad"></p>

<dt><a name="Each_interpreter_pool_has_a_shared_event_queue"
>Each interpreter pool has a shared event queue</a></dt><p class="pad"></p>

<dd>Some events, such as IO callbacks, may not be interpreter&#45;specific, and can be serviced by any interpreter in the interpreter pool. For these events, there is a pool&#45;wide event queue.</dd><p class="pad"></p>

<dt><a name="PMCs_are_the_coordination_point_for_threads"
>PMCs are the coordination point for threads</a></dt><p class="pad"></p>

<dd>That is, only PMCs are shared as such between threads. Strings, specifically, are <i>not</i> shared between interpreters as such</dd><p class="pad"></p>

<dt><a name="All_PMCs_shared_amongst_interpreters_in_a_pool_must_be_marked_shared"
>All PMCs shared amongst interpreters in a pool must be marked shared</a></dt><p class="pad"></p>

<dd>A PMC which is not marked shared may not be handed to another interpreter. Parrot will prevent this from happening either by marking the PMC as shared, or throwing an exception when the PMC is placed in a spot where it may be shared but is not shareable.</dd><p class="pad"></p>

<dt><a name="All_shared_PMCs_must_have_a_threadsafe_vtable"
>All shared PMCs must have a threadsafe vtable</a></dt><p class="pad"></p>

<dd>The first thing that any vtable function of a shared PMC must do is to acquire the mutex of the PMCs in its parameter list, in ascending address order. When the mutexes are released they are not required to be released in any order.</dd><p class="pad"></p>

<dd>{{ &#45; Uri: why the ascending address order to grab mutexes? is this to help solve deadlocks? &#45; Dan: Yes. The recommendation I&#39;ve always seen for deadlock avoidance is to always have all your code grab its mutexes in some fixed order. With source, it&#39;s generally recommended that you grab mutex variables in lexical order. Since we&#39;re all binary we need a different order, and ascending addresses are reasonably simple to do. &#45; Gordon Henriksen: Note that this locking strategy cannot avoid deadlock if the user is allowed to acquire these locks&#45;&#45;HLL locks must be altogether different beasts from automatic PMC locks. That&#39;s okay. Just a design consequence worth noting for everyone. &#45; Dan: Oh, arguably it can&#39;t avoid deadlock at all, what with vtable methods having access to the full environment. I can live with deadlocks, only because there&#39;s no real alternative. &#45; Gordon Henriksen: But PMC implementations have to fall inside of the trusted environment, so that&#39;s not really a failure. Of course uncooperative code can break a cooperative algorithm.</dd><p class="pad"></p>

<dd>&#45; Sam Vilain: RE: &#34;have all your code grab its mutexes in some fixed order.&#34;</dd><p class="pad"></p>

<dd>Yes; otherwise, you need to back off and start again, if one lock acquisition fails.</dd><p class="pad"></p>

<dd>Consider these functions; for the purpose of this example, lexical lock ordering is implied;</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  func1($AAAA, $CCCC, $FFFF, $GGGG, $KKKK);
  func2($BBBB, $DDDD, $FFFF, $IIII, $KKKK);
  func3($FFFF, $KKKK);</pre>

<dd>So long as the locks are ramped up from the lowest to the highest, there is no chance of func1 acquiring a lock to be held by func2 (eg, $KKKK), if that other function already has one of the shared dependancies (eg, $FFFF).</dd><p class="pad"></p>

<dd>All well and good. But, what about recursive locks?</dd><p class="pad"></p>

<dd>ie</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'> sub func1($one is locked, $two is locked, $three is locked) {
     for my $x ($one, $two, $three) {
         func2($x.property) if $x.property;
     }
 }

 sub func2($eins is locked) {
     if ($eins.property) {
         func2($eins.property, { });
     }
 }

 $aaa.property = { };
 $bbb.property.property = $aaa;
 $ccc = { };

 if (thork()) {   # fork a thread
    # thread A
    func1($aaa, $bbb, $ccc);
 }
 else {
    # thread B
    func2($bbb.property);
 }</pre>

<dd>OK, the execution order that causes the deadlock is:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  1. Thread B &#45; func2() acquires a lock on the $bbb.property PMC.
  2. Thread A &#45; func() acquires a lock on $aaa, $bbb, $ccc.
  3. Thread A &#45; func2() acquires a lock on $aaa.property, which
     returns quickly
  4. Thread A &#45; func2() blocks waiting for a lock on $bbb.property,
     held by func2() in thread B
  5. Thread B &#45; func2() blocks waiting for a lock on
     $bbb.property.property, held by func() in thread A.</pre>

<dd>So, there are still possibilities for deadlocks, as the non&#45;linear nature of subroutine calls screws up your nice lock ramping.</dd><p class="pad"></p>

<dd>In summary, acquiring mutexes in a defined order as a means to avoid deadlocks only works when you are acquiring them all up front. If you are acquiring any later, and you detect a deadlock (ie, a loop of threads blocking on locks held by each other), you *must* be able to tell one of them to &#34;ramp off&#34; to holding no locks at all. ie, ROLLBACK :).</dd><p class="pad"></p>

<dd>The bugger is, winding back execution state automatically to when you last started acquiring locks is probably an intractable problem from an interpreter&#39;s perspective...</dd><p class="pad"></p>

<dd>Sounds like a job for an exception to me ;&#45;).</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  for (1..50) {
     eval {
        func_that_acquires_first_lock($args);
     };
     last unless $@ and $@ =~ m/mutex deadlock/i;
  } 
}}</pre>

<dt><a name="Automatic_PMC_sharing_will_be_provided"
>Automatic PMC sharing will be provided</a></dt><p class="pad"></p>

<dd>When a PMC is placed into a container which is shared (including lexical pads and global namespaces) then that PMC will automatically be marked as shared. It is acceptable for this to trigger an exception if for some reason a PMC should not be shared between interpreters.</dd><p class="pad"></p>

<dd>PMCs are, by default, not shared. This avoids sharing overhead for PMCs which are only used as temporaries and not shared. (Note that this is dangerous, and may end up not being done, due to the sharing of continuations)</dd><p class="pad"></p>

<dd>{{ &#45; Luke: I don&#39;t know why this is dangerous. A continuation is a data structure just like an array or a hash. When you share it, everything &#34;inside&#34; it gets shared, too. For a continuation, this could be an awful lot of stuff, but it&#39;s the safe way. &#45; Dan: True, but the danger part is if we don&#39;t mark everything grabbed by a continuation as shared by default. If we do, we might as well mark everything as shared, as there&#39;ll be less overhead. }}</dd><p class="pad"></p>

<dt><a name="All_interpreter_constructs_in_a_pool_are_shareable"
>All interpreter constructs in a pool are shareable</a></dt><p class="pad"></p>

<dd>This means that a PMC or string may be used by any interpreter in a pool. It additionally means that, if full sharing is enabled, that any interpreter in a pool may invoke a continuation, assuming the continuation is valid. (That is, a continuation taken at parrot&#39;s top level. Continuations taken within vtable functions, user&#45;defined ops, or extension code may not be shareable)</dd><p class="pad"></p>

<dt><a name="The_embedding_API_will_allow_posting_events_to_a_pool"
>The embedding API will allow posting events to a pool</a></dt><p class="pad"></p>

<dd>Many events are interpreter&#45;specific, often caused by one particular interpreter requesting an async event that later completes.</dd><p class="pad"></p>

<dt><a name="The_embedding_API_will_allow_posting_events_to_an_interpreter"
>The embedding API will allow posting events to an interpreter</a></dt><p class="pad"></p>

<dd>For events that don&#39;t have to go to any particular interpreter, they can go into the pool&#39;s event loop.</dd><p class="pad"></p>

<dt><a name="The_embedding_API_will_allow_calling_a_parrot_sub_with_a_pool"
>The embedding API will allow calling a parrot sub with a pool</a></dt><p class="pad"></p>

<dd>In those cases where there is an interpreter pool, embedders may call a parrot sub using the pool as a whole, rather than an individual interpreter, to run the sub. In that case Parrot may either choose a dormant interpreter (if there is one) or create a new interpreter in the pool to run the subroutine.</dd><p class="pad"></p>

<dd>When the sub is done, Parrot may either cache the created interpreter or destroy it as it needs to, though in no case will Parrot ever leave a pool with no interpreters at all.</dd><p class="pad"></p>
</dl>

<h1><a name="QUESTIONS"
>QUESTIONS <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<ul>
<li>Do we need a concurrent version of <code lang='und' xml:lang='und'>runinterp</code>? Needs to accept an interp and sub argument, as well as an event sub to throw on returning. Also returns a status object.</li><p class="pad"></p>
</ul>

<h1><a name="IMPLEMENTATION"
>IMPLEMENTATION <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>[Excerpt from Perl 6 and Parrot Essentials to seed discussion.]</p>

<p>Threads are a means of splitting a process into multiple pieces that execute simultaneously. It&#39;s a relatively easy way to get some parallelism without too much work. Threads don&#39;t solve all the parallelism problems your program may have. Sometimes multiple processes on a single system, multiple processes on a cluster, or processes on multiple separate systems are better. But threads do present a good solution for many common cases.</p>

<p>All the resources in a threaded process are shared between threads. This is simultaneously the great strength and great weakness of threads. Easy sharing is fast sharing, making it far faster to exchange data between threads or access shared global data than to share data between processes on a single system or on multiple systems. Easy sharing is dangerous, though, since without some sort of coordination between threads it&#39;s easy to corrupt that shared data. And, because all the threads are contained within a single process, if any one of them fails for some reason the entire process, with all its threads, dies.</p>

<p>With a low&#45;level language such as C, these issues are manageable. The core data types, integers, floats, and pointers are all small enough to be handled atomically. Composite data can be protected with mutexes, special structures that a thread can get exclusive access to. The composite data elements that need protecting can each have a mutex associated with them, and when a thread needs to touch the data it just acquires the mutex first. By default there&#39;s very little data that must be shared between threads, so it&#39;s relatively easy, barring program errors, to write thread&#45;safe code if a little thought is given to the program structure.</p>

<p>Things aren&#39;t this easy for Parrot, unfortunately. A PMC, Parrot&#39;s native data type, is a complex structure, so we can&#39;t count on the hardware to provide us atomic access. That means Parrot has to provide atomicity itself, which is expensive. Getting and releasing a mutex isn&#39;t really that expensive in itself. It has been heavily optimized by platform vendors because they want threaded code to run quickly. It&#39;s not free, though, and when you consider that running flat&#45;out Parrot does one PMC operation per 100 CPU cycles, even adding an additional 10 cycles per operation can slow Parrot down by 10%.</p>

<p>For any threading scheme, it&#39;s important that your program isn&#39;t hindered by the platform and libraries it uses. This is a common problem with writing threaded code in C, for example. Many libraries you might use aren&#39;t thread&#45;safe, and if you aren&#39;t careful with them your program will crash. While we can&#39;t make low&#45;level libraries any safer, we can make sure that Parrot itself won&#39;t be a danger. There is very little data shared between Parrot interpreters and threads, and access to all the shared data is done with coordinating mutexes. This is invisible to your program, and just makes sure that Parrot itself is thread&#45;safe.</p>

<p>When you think about it, there are really three different threading models. In the first one, multiple threads have no interaction among themselves. This essentially does with threads the same thing that&#39;s done with processes. This works very well in Parrot, with the isolation between interpreters helping to reduce the overhead of this scheme. There&#39;s no possibility of data sharing at the user level, so there&#39;s no need to lock anything.</p>

<p>In the second threading model, multiple threads run and pass messages back and forth between each other. Parrot supports this as well, via the event mechanism. The event queues are thread&#45;safe, so one thread can safely inject an event into another thread&#39;s event queue. This is similar to a multiple&#45;process model of programming, except that communication between threads is much faster, and it&#39;s easier to pass around structured data.</p>

<p>In the third threading model, multiple threads run and share data between themselves. While Parrot can&#39;t guarantee that data at the user level remains consistent, it can make sure that access to shared data is at least safe. We do this with two mechanisms.</p>

<p>First, Parrot presents an advisory lock system to user code. Any piece of user code running in a thread can lock a variable. Any attempt to lock a variable that another thread has locked will block until the lock is released. Locking a variable only blocks other lock attempts. It does <i>not</i> block plain access. This may seem odd, but it&#39;s the same scheme used by threading systems that obey the POSIX thread standard, and has been well tested in practice.</p>

<p>Secondly, Parrot forces all shared PMCs to be marked as such, and all access to shared PMCs must first acquire that PMC&#39;s private lock. This is done by installing an alternate vtable for shared PMCs, one that acquires locks on all its parameters. These locks are held only for the duration of the vtable function, but ensure that the PMCs affected by the operation aren&#39;t altered by another thread while the vtable function is in progress.</p>

<h1><a name="ATTACHMENTS"
>ATTACHMENTS <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>None.</p>

<h1><a name="FOOTNOTES"
>FOOTNOTES <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>None.</p>

<h1><a name="REFERENCES"
>REFERENCES <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>Dec 2003 &#45; (Dan ponders threads based on POSIX and Perl 5 experience) &#60;<a href="http://groups.google.com/group/perl.perl6.internals/browse_frm/thread/e64b22ab7de0a7a6/889b5d8c4cd267b7?lnk=gst&#38;q=threads&#38;rnum=3#889b5d8c4cd267b7">http://groups.google.com/group/perl.perl6.internals/browse_frm/thread/e64b22ab7de0a7a6/889b5d8c4cd267b7?lnk=gst&#38;q=threads&#38;rnum=3#889b5d8c4cd267b7</a>&#62;</p>

<p>Dec. 2003 &#45; &#34;threads and shared interpreter data structures&#34; &#60;<a href="http://groups.google.com/group/perl.perl6.internals/browse_frm/thread/e64ea4ff287e04fd/b71333e282d3d187?lnk=gst&#38;q=threads&#38;rnum=9#b71333e282d3d187">http://groups.google.com/group/perl.perl6.internals/browse_frm/thread/e64ea4ff287e04fd/b71333e282d3d187?lnk=gst&#38;q=threads&#38;rnum=9#b71333e282d3d187</a>&#62;</p>

<p>Jan. 2004 &#45; &#34;Threads Design. A Win32 perspective.&#34; &#60;<a href="http://groups.google.com/group/perl.perl6.internals/browse_frm/thread/3209629b23306029/52ba9d37425ba015?lnk=gst&#38;q=threads&#38;rnum=8#52ba9d37425ba015">http://groups.google.com/group/perl.perl6.internals/browse_frm/thread/3209629b23306029/52ba9d37425ba015?lnk=gst&#38;q=threads&#38;rnum=8#52ba9d37425ba015</a>&#62;</p>

<p>Jan. 2004 &#45; &#34;Start of threads proposal&#34; &#60;<a href="http://groups.google.com/group/perl.perl6.internals/browse_frm/thread/4c7de440da84d5c6/04cfb70b0d81dfba?tvc=1&#38;q=threads#04cfb70b0d81dfba">http://groups.google.com/group/perl.perl6.internals/browse_frm/thread/4c7de440da84d5c6/04cfb70b0d81dfba?tvc=1&#38;q=threads#04cfb70b0d81dfba</a>&#62;</p>

<p>Sept. 2005 &#45; &#34;consider using OS threads&#34; &#60;<a href="http://groups.google.com/group/perl.perl6.internals/browse_frm/thread/40b50e3aa9255f8e/036a87b5d2b5ed2c?lnk=gst&#38;q=threads&#38;rnum=2#036a87b5d2b5ed2c">http://groups.google.com/group/perl.perl6.internals/browse_frm/thread/40b50e3aa9255f8e/036a87b5d2b5ed2c?lnk=gst&#38;q=threads&#38;rnum=2#036a87b5d2b5ed2c</a>&#62;</p>

<p>Aug. 2007 &#45; &#34;multi&#45;threading a work in progress&#34; &#60;<a href="http://perlmonks.org/?node_id=636466">http://perlmonks.org/?node_id=636466</a>&#62;</p>

<p>Concurrency as Futures &#45; &#60;<a href="http://www.cincomsmalltalk.com/userblogs/mls/blogView?showComments=true&#38;entry=3336838959">http://www.cincomsmalltalk.com/userblogs/mls/blogView?showComments=true&#38;entry=3336838959</a>&#62;</p>

<p>Io language &#45; &#60;<a href="http://www.iolanguage.com/about/">http://www.iolanguage.com/about/</a>&#62;</p>

<p>Java memory and concurrency &#45; <a href="http://www.cs.umd.edu/~pugh/java/memoryModel/">http://www.cs.umd.edu/~pugh/java/memoryModel/</a></p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
