<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>lexical analysis for Parrot Intermediate Representation</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">lexical analysis for Parrot Intermediate Representation</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../../html/index.html">Contents</a> | <a href="../../../../html/compilers.html">Compilers</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>pirlexer.c &#45; lexical analysis for Parrot Intermediate Representation</p>

<h1><a name="THOUGHTS_FOR_LATER"
>THOUGHTS FOR LATER <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<ul>
<li>Implement dictionary as hashtable,
which will be MUCH faster</li><p class="pad"></p>

<li>Optimize small functions (using #define to inline) and optimize by &#39;smarter&#39; implementation (where appropiate).
I&#39;m doing a lot of stuff in read_char(),
which might slow down things.</li><p class="pad"></p>

<li>TODO: implement POD parsing</li><p class="pad"></p>

<li>TODO: read input files a few blocks a time,
instead of the whole file at once.
This is to prevent failure when compiling 100M files.</li><p class="pad"></p>

<li>Place and remove checks for EOF where appropiate,
they are scattered throughout the code.
Clean that up.</li><p class="pad"></p>

<li>Check for &#39;correct&#39; use of data types (unsigned etc.) (should characters be stored in <code lang='und' xml:lang='und'>char</code>s or <code lang='und' xml:lang='und'>int</code>s?</li><p class="pad"></p>
</ul>

<h1><a name="KEYWORDS"
>KEYWORDS <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>dictionary contains *all* keywords,
directives,
flags and other (descriptions of) tokens that are recognized by the lexer.</p>

<pre lang='und' xml:lang='und'>  global    goto
  if        n_operators
  int       null
  num       pmc
  string    unless</pre>

<h1><a name="DIRECTIVES"
>DIRECTIVES <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>The following are PIR directives.</p>

<pre lang='und' xml:lang='und'>  .arg               .const      .constant    .emit             .end
  .endnamespace      .endm       .eom         .get_results
  .globalconst       .HLL        .HLL_map     .include          .invocant
  .lex               .loadlib    .local       .macro            .meth_call
  .namespace         .nci_call   .param       .pcc_begin        .pcc_begin_return
  .pcc_begin_yield   .pcc_call   .pcc_end     .pcc_end_return   .pcc_end_yield
  .pragma     .result      .return           .sub
  .sym               .yield</pre>

<h1><a name="FLAGS"
>FLAGS <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>The following are flags for subroutines:</p>

<pre lang='und' xml:lang='und'>  :anon     :immediate   :init        :lex         :load        :main
  :method   :multi       :outer       :postcomp    :vtable      :named</pre>

<p>The following are flags for parameters/arguments.</p>

<pre lang='und' xml:lang='und'>  :opt_flag
  :optional
  :slurpy
  :flat
  :unique_reg</pre>

<h1><a name="STRING_ENCODINGS"
>STRING ENCODINGS <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>The following are string encoding specifiers:</p>

<pre lang='und' xml:lang='und'>  ascii:
  binary:
  iso&#45;8859&#45;1:
  unicode:</pre>

<h2><a name="file_buffer_structure"
>file_buffer structure <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Structure that represents a file. Its layout is shown below. First, it contains the filename of the file that is represented by this buffer. Then, the buffer is an array that holds the complete file contents. This is done for efficiency (instead of reading character by character from disk). The <code lang='und' xml:lang='und'>curchar</code> acts like a cursor, that points to the current character. The field <code lang='und' xml:lang='und'>filesize</code> contains the size of the file counted in bytes, <code lang='und' xml:lang='und'>line</code> keeps track of the current line number, and <code lang='und' xml:lang='und'>linepos</code> counts the number of characters since the last newline character. The field <code lang='und' xml:lang='und'>lastchar</code> stores the previous character (so the character <i>before</i> the character pointed to by <code lang='und' xml:lang='und'>curchar</code>. This field is used to decide whether the previous character was a newline. If so, then <code lang='und' xml:lang='und'>curchar</code> is at the start of a line (needed for Heredoc delimiters).</p>

<p>The field <code lang='und' xml:lang='und'>prevbuffer</code> points to another file_buffer; if the current file was <code lang='und' xml:lang='und'>.include</code>d, then <code lang='und' xml:lang='und'>prevbuffer</code> points to the file_buffer that represents the including file. An example:</p>

<pre lang='und' xml:lang='und'> $ cat main.pir

 .include &#34;util.pir&#34;

 .sub main
 # ...
 .end

 $ cat util.pir

 .sub foo
 # ...
 .end</pre>

<p>In this case, when parsing the file <code lang='und' xml:lang='und'>main.pir</code>, <code lang='und' xml:lang='und'>prevbuffer</code> is NULL, because this file was not included. Then, when the file <code lang='und' xml:lang='und'>util.pir</code> is included, a new file_buffer is created for that file, and <code lang='und' xml:lang='und'>prevbuffer</code> is set to the file_buffer representing <code lang='und' xml:lang='und'>main.pir</code>.</p>

<p>The file_buffer structure is shown below:</p>

<pre lang='und' xml:lang='und'> typedef struct file_buffer {
     char     *filename;              &#45;&#45; the name of this file
     char     *buffer;                &#45;&#45; buffer holding contents of this file
     char     *curchar;               &#45;&#45; pointer to the current char.
     unsigned  filesize;              &#45;&#45; size of this file in bytes
     unsigned  long line;             &#45;&#45; line number
     unsigned  short linepos;         &#45;&#45; position on the current line
     char      lastchar;              &#45;&#45; the previous character that was read.
     struct file_buffer *prevbuffer;  &#45;&#45; pointer to &#39;including&#39; file if any

 } file_buffer;</pre>

<h2><a name="lexer_state_structure"
>lexer_state structure <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Structure representing the lexer. It holds a pointer to the current file being read, a buffer holding the current token, and a pointer to add characters to the token buffer.</p>

<pre lang='und' xml:lang='und'> typedef struct lexer_state {
     struct file_buffer *curfile;    &#45;&#45; pointer to the current file
     char *token_chars;              &#45;&#45; characters of the current token
     char *charptr;                  &#45;&#45; used for adding/removing token chars

 } lexer_state;</pre>

<h1><a name="ACCESSOR_FUNCTIONS"
>ACCESSOR FUNCTIONS <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<dl>
<dt><a name="find_keyword()"
>find_keyword()</a></dt><p class="pad"></p>

<dd>Get the spelling of a keyword based on the specified token.</dd><p class="pad"></p>

<dt><a name="get_current_token()"
>get_current_token()</a></dt><p class="pad"></p>

<dd>return a constant pointer to the current token buffer</dd><p class="pad"></p>

<dt><a name="get_current_file()"
>get_current_file()</a></dt><p class="pad"></p>

<dd>return a constant pointer to the current file name</dd><p class="pad"></p>

<dt><a name="get_current_line()"
>get_current_line()</a></dt><p class="pad"></p>

<dd>return the current line number</dd><p class="pad"></p>

<dt><a name="get_current_linepos()"
>get_current_linepos()</a></dt><p class="pad"></p>

<dd>Returns the current line position (i.o.w., how many characters have been read on the current line?)</dd><p class="pad"></p>

<dt><a name="get_current_filepos()"
>get_current_filepos()</a></dt><p class="pad"></p>

<dd>Returns the number of charactars read in the current file so far.</dd><p class="pad"></p>

<dt><a name="print_error_context()"
>print_error_context()</a></dt><p class="pad"></p>

<dd>Print some surrounding text from the file to indicate where the error occurred. This may make finding the error easier.</dd><p class="pad"></p>
</dl>

<h1><a name="INTERNAL_FUNCTIONS"
>INTERNAL FUNCTIONS <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<dl>
<dt><a name="buffer_char()"
>buffer_char()</a></dt><p class="pad"></p>

<dd>Store a character in the lexer&#39;s buffer.</dd><p class="pad"></p>

<dt><a name="read_char()"
>read_char()</a></dt><p class="pad"></p>

<dd>Return the next character from the buffer. It&#39;s a good idea to check for &#34;c == EOF_MARKER&#34; after each call.</dd><p class="pad"></p>

<dt><a name="unread_char()"
>unread_char()</a></dt><p class="pad"></p>

<dd>Push back the last read character.</dd><p class="pad"></p>

<dt><a name="print_buffer()"
>print_buffer()</a></dt><p class="pad"></p>

<dd>Debug function to show the rest of the current buffer. (starting from current character)</dd><p class="pad"></p>

<dt><a name="clear_buffer()"
>clear_buffer()</a></dt><p class="pad"></p>

<dd>Clears the buffer in which the current token is stored.</dd><p class="pad"></p>

<dt><a name="read_file()"
>read_file()</a></dt><p class="pad"></p>

<dd>Allocate a new file_buffer structure, allocate memory for the file&#39;s contents and read all contents into this buffer. The file_buffer structure is returned.</dd><p class="pad"></p>

<dt><a name="destroy_buffer()"
>destroy_buffer()</a></dt><p class="pad"></p>

<dd>Destructor for file_buffer.</dd><p class="pad"></p>

<dt><a name="do_include_file()"
>do_include_file()</a></dt><p class="pad"></p>

<dd>Calls read_file() that returns a file_buffer structure. This file_buffer&#39;s previous buffer is set to the current file_buffer. The newfile buffer is assigned to the lexer&#39;s current file buffer.</dd><p class="pad"></p>

<dt><a name="is_start_of_line()"
>is_start_of_line()</a></dt><p class="pad"></p>

<dd>Checks whether the current pointer in the specified file buffer is at the beginning of a line.</dd><p class="pad"></p>

<dt><a name="check_dictionary()"
>check_dictionary()</a></dt><p class="pad"></p>

<dd>Checks whether the current token is a member of the specified dictionary. If it is, the index of the word in the dict. is returned. If not, T_NOT_FOUND is returned.</dd><p class="pad"></p>

<dt><a name="switch_buffer()"
>switch_buffer()</a></dt><p class="pad"></p>

<dd>set the current file_buffer to the previous one stored in the field prevbuffer. The .include&#39;ing file is now continued to be processed after this.</dd><p class="pad"></p>

<dt><a name="read_digits()"
>read_digits()</a></dt><p class="pad"></p>

<dd>Helper function to read as many digits into the current token&#39;s buffer. Returns the number of digits read.</dd><p class="pad"></p>

<dt><a name="update_line()"
>update_line()</a></dt><p class="pad"></p>

<dd>Updates the line number in the lexer, and resets the line position pointer.</dd><p class="pad"></p>

<dt><a name="read_string()"
>read_string()</a></dt><p class="pad"></p>

<dd>Read a quoted string.</dd><p class="pad"></p>
</dl>

<h1><a name="LEXER_API"
>LEXER API <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<dl>
<dt><a name="read_heredoc()"
>read_heredoc()</a></dt><p class="pad"></p>

<dd>Reads heredoc text up to the specified heredoc label. Returns either T_HEREDOC_STRING if successful, or T_EOF (if encountered). The heredoc string is stored in the token buffer.</dd><p class="pad"></p>

<dt><a name="read_macro()"
>read_macro()</a></dt><p class="pad"></p>

<dd>Just skip all tokens until we find &#34;.endm&#34; (or end of file) Later this can be improved.</dd><p class="pad"></p>

<dt><a name="new_lexer()"
>new_lexer()</a></dt><p class="pad"></p>

<dd>Constructor for the lexer.</dd><p class="pad"></p>

<dt><a name="destroy_lexer()"
>destroy_lexer()</a></dt><p class="pad"></p>

<dd>Destructor for lexer.</dd><p class="pad"></p>

<dt><a name="include_file()"
>include_file()</a></dt><p class="pad"></p>

<dd>This function takes a quoted string, to be found the current token, and removes the quotes. Then the file is included through do_include_file().</dd><p class="pad"></p>

<dt><a name="close_file()"
>close_file()</a></dt><p class="pad"></p>

<dd>Opposite of include_file(), it sets the current file in the lexer to the &#39;including&#39; file (found through the &#39;prevbuffer&#39; pointer).</dd><p class="pad"></p>

<dt><a name="next_token()"
>next_token()</a></dt><p class="pad"></p>

<dd>Reads a token from the current file buffer.</dd><p class="pad"></p>
</dl>

<h1><a name="LEXICAL_SPECIFICATION"
>LEXICAL SPECIFICATION <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<h2><a name="Comments"
>Comments <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Comments start with the pound sign (&#39;#&#39;) and continue up to the end of the line.</p>

<p>POD comments are not yet supported.</p>

<h2><a name="Tokens"
>Tokens <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Any whitespace in the specification is merely for readability. Significant whitespace is indicated explicitly.</p>

<pre lang='und' xml:lang='und'>  PASM&#45;REG        &#45;&#62; PASM&#45;PREG | PASM&#45;SREG | PASM&#45;NREG | PASM&#45;IREG

  PASM&#45;PREG       &#45;&#62; &#39;P&#39; DIGIT+

  PASM&#45;SREG       &#45;&#62; &#39;S&#39; DIGIT+

  PASM&#45;NREG       &#45;&#62; &#39;N&#39; DIGIT+

  PASM&#45;IREG       &#45;&#62; &#39;I&#39; DIGIT+

  IDENT           &#45;&#62; [a&#45;zA&#45;Z_][a&#45;zA&#45;Z_0&#45;9]*

  LABEL           &#45;&#62; IDENT &#39;:&#39;

  INVOCANT&#45;IDENT  &#45;&#62; IDENT &#39;.&#39;

  PARROT&#45;OP       &#45;&#62; IDENT

  MACRO&#45;IDENT     &#45;&#62; &#39;.&#39; IDENT

  MACRO&#45;LABEL     &#45;&#62; &#39;$&#39; IDENT &#39;:&#39;

  PIR&#45;REGISTER    &#45;&#62; &#39;$&#39; PASM&#45;REG

  HEREDOC&#45;IDENT   &#45;&#62; &#60;&#60; STRINGC

  STRING&#45;CONSTANT &#45;&#62; &#39; &#60;characters&#62; &#39; | &#34; &#60;characters&#62; &#34;

  INT&#45;CONSTANT    &#45;&#62; [&#45;] DIGIT+ | 0 [xX] DIGIT+ | 0 [bB] DIGIT+

  NUM&#45;CONSTANT    &#45;&#62; [&#45;] DIGIT+ &#39;.&#39; DIGIT*

  DIGIT           &#45;&#62; [0&#45;9]</pre>

<h2><a name="Special_tokens"
>Special tokens <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<pre lang='und' xml:lang='und'>  ( ) [ ] , ;</pre>

<h2><a name="Operators"
>Operators <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Due to PIR&#39;s simplicity, there are no different levels of precedence for operators.</p>

<h3><a name="Unary_operators"
>Unary operators</a></h3>

<pre lang='und' xml:lang='und'>    &#45;   !   ~</pre>

<h3><a name="Binary_operators"
>Binary operators</a></h3>

<pre lang='und' xml:lang='und'>    **  *  %  /  //  +  &#45;  &#62;&#62;  &#62;&#62;&#62;  &#60;&#60;  ~   ~~   &#38;  &#38;&#38;  |  ||  .</pre>

<h3><a name="Augmented_operators"
>Augmented operators</a></h3>

<pre lang='und' xml:lang='und'>    **=   *=    %=   /=   //=   +=   &#45;=  .=  &#62;&#62;=  &#62;&#62;&#62;=   &#60;&#60;=  &#38;=   |=   ~=</pre>

<h3><a name="Conditional_operators"
>Conditional operators</a></h3>

<pre lang='und' xml:lang='und'>    &#60;    &#62;   ==   &#60;=   &#62;=  !=</pre>

<h3><a name="Miscellaneous_operators"
>Miscellaneous operators</a></h3>

<pre lang='und' xml:lang='und'>    &#45;&#62;   =&#62;   ..</pre>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
