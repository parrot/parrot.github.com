<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Hash table</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Hash table</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../html/index.html">Contents</a> | <a href="../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>src/hash.c &#45; Hash table</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>A hashtable contains an array of bucket indexes.
Buckets are nodes in a linked list,
each containing a <code lang='und' xml:lang='und'>void *</code> key and value.
During hash creation,
the types of key and value as well as appropriate compare and hashing functions can be set.</p>

<p>This hash implementation uses just one piece of malloced memory.
The <code lang='und' xml:lang='und'>hash&#45;&#62;bs</code> bucket store points to this region.</p>

<p>This hash doesn&#39;t move during GC,
therefore a lot of the old caveats don&#39;t apply.</p>

<h2><a name="Functions"
>Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="key_hash_STRING"
><b><code lang='und' xml:lang='und'>key_hash_STRING</b></code></a></dt><p class="pad"></p>

<dd>Return the hashed value of the key <code lang='und' xml:lang='und'>value</code>.
See also string.c.</dd><p class="pad"></p>

<dt><a name="STRING_compare"
><b><code lang='und' xml:lang='und'>STRING_compare</b></code></a></dt><p class="pad"></p>

<dd>Compares the two strings,
returning 0 if they are identical.</dd><p class="pad"></p>

<dt><a name="pointer_compare"
><b><code lang='und' xml:lang='und'>pointer_compare</b></code></a></dt><p class="pad"></p>

<dd>Compares the two pointers,
returning 0 if they are identical</dd><p class="pad"></p>

<dt><a name="key_hash_pointer"
><b><code lang='und' xml:lang='und'>key_hash_pointer</b></code></a></dt><p class="pad"></p>

<dd>Returns a hashvalue for a pointer.</dd><p class="pad"></p>

<dt><a name="cstring_compare"
><b><code lang='und' xml:lang='und'>cstring_compare</b></code></a></dt><p class="pad"></p>

<dd>C string versions of the <code lang='und' xml:lang='und'>key_hash</code> and <code lang='und' xml:lang='und'>compare</code> functions.</dd><p class="pad"></p>

<dt><a name="key_hash_int"
><b><code lang='und' xml:lang='und'>key_hash_int</b></code></a></dt><p class="pad"></p>

<dd>Custom <code lang='und' xml:lang='und'>key_hash</code> function.</dd><p class="pad"></p>

<dt><a name="int_compare"
><b><code lang='und' xml:lang='und'>int_compare</b></code></a></dt><p class="pad"></p>

<dd>Custom <code lang='und' xml:lang='und'>compare</code> function.</dd><p class="pad"></p>

<dt><a name="parrot_dump_hash"
><b><code lang='und' xml:lang='und'>parrot_dump_hash</b></code></a></dt><p class="pad"></p>

<dd>Print out the hash in human&#45;readable form.
Except it&#39;s empty.</dd><p class="pad"></p>

<dt><a name="parrot_mark_hash"
><b><code lang='und' xml:lang='und'>parrot_mark_hash</b></code></a></dt><p class="pad"></p>

<dd>Marks the hash and its contents as live.</dd><p class="pad"></p>

<dt><a name="hash_thaw"
><b><code lang='und' xml:lang='und'>hash_thaw</b></code></a></dt><p class="pad"></p>

<dd>This is used by freeze/thaw to visit the contents of the hash.</dd><p class="pad"></p>

<dd><code lang='und' xml:lang='und'>pinfo</code> is the visit info,
(see include/parrot/pmc_freeze.h&#62;).</dd><p class="pad"></p>

<dt><a name="expand_hash"
><b><code lang='und' xml:lang='und'>expand_hash</b></code></a></dt><p class="pad"></p>

<dd>For a hashtable of size N,
we use <code lang='und' xml:lang='und'>MAXFULL_PERCENT</code> % of N as the number of buckets.
This way,
as soon as we run out of buckets on the free list,
we know that it&#39;s time to resize the hashtable.</dd><p class="pad"></p>

<dd>Algorithm for expansion: We exactly double the size of the hashtable.
Keys are assigned to buckets with the formula</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>        bucket_index = hash(key) % parrot_hash_size</pre>

<dd>so when doubling the size of the hashtable, we know that every key is either already in the correct bucket, or belongs in the current bucket plus <code lang='und' xml:lang='und'>parrot_hash_size</code> (the old <code lang='und' xml:lang='und'>parrot_hash_size</code>). In fact, because the hashtable is always a power of two in size, it depends only on the next bit in the hash value, after the ones previously used.</dd><p class="pad"></p>

<dd>So we scan through all the buckets in order, moving the buckets that need to be moved. No bucket will be scanned twice, and the cache should be reasonably happy because the hashtable accesses will be two parallel sequential scans. (Of course, this also mucks with the <code lang='und' xml:lang='und'>&#45;&#62;next</code> pointers, and they&#39;ll be all over memory.)</dd><p class="pad"></p>

<dt><a name="parrot_new_hash"
><b><code lang='und' xml:lang='und'>parrot_new_hash</b></code></a></dt><p class="pad"></p>

<dd>Returns a new Parrot STRING hash in <code lang='und' xml:lang='und'>hptr</code>.</dd><p class="pad"></p>

<dt><a name="parrot_new_pmc_hash"
><b><code lang='und' xml:lang='und'>parrot_new_pmc_hash</b></code></a></dt><p class="pad"></p>

<dd>Create a new Parrot STRING hash in PMC_struct_val(container)</dd><p class="pad"></p>

<dt><a name="parrot_new_cstring_hash"
><b><code lang='und' xml:lang='und'>parrot_new_cstring_hash</b></code></a></dt><p class="pad"></p>

<dd>Returns a new C string hash in <code lang='und' xml:lang='und'>hptr</code>.</dd><p class="pad"></p>

<dt><a name="parrot_new_hash_x"
><b><code lang='und' xml:lang='und'>parrot_new_hash_x</b></code></a></dt><p class="pad"></p>

<dd>Returns a new hash in <code lang='und' xml:lang='und'>hptr</code>.</dd><p class="pad"></p>

<dd>FIXME: This function can go back to just returning the hash struct pointer once Buffers can define their own custom mark routines.</dd><p class="pad"></p>

<dd>The problem is: During DODs stack walking the item on the stack must be a PMC. When an auto <code lang='und' xml:lang='und'>Hash*</code> is seen, it doesn&#39;t get properly marked (only the <code lang='und' xml:lang='und'>Hash*</code> buffer is marked, not its contents). By passing the <code lang='und' xml:lang='und'>**hptr</code> up to the Hash&#39;s init function, the newly constructed PMC is on the stack <i>including</i> this newly constructed Hash, so that it gets marked properly.</dd><p class="pad"></p>

<dt><a name="parrot_new_pmc_hash_x"
><b><code lang='und' xml:lang='und'>parrot_new_pmc_hash_x</b></code></a></dt><p class="pad"></p>

<dd>Like parrot_new_hash_x but w/o the described problems. The passed in <code lang='und' xml:lang='und'>container</code> PMC gets stored in the Hash end the newly created Hash is in PMC_struct_val(container).</dd><p class="pad"></p>

<dt><a name="parrot_new_pointer_hash"
><b><code lang='und' xml:lang='und'>parrot_new_pointer_hash</b></code></a></dt><p class="pad"></p>

<dd>Create a new HASH with void * keys and values.</dd><p class="pad"></p>

<dt><a name="parrot_new_INTVAL_hash"
><b><code lang='und' xml:lang='und'>parrot_new_INTVAL_hash</b></code></a></dt><p class="pad"></p>

<dd>Create a new Hash PMC with INTVAL keys and values. <code lang='und' xml:lang='und'>flags</code> can be <code lang='und' xml:lang='und'>PObj_constant_FLAG</code> or 0.</dd><p class="pad"></p>

<dt><a name="parrot_hash_size"
><b><code lang='und' xml:lang='und'>parrot_hash_size</b></code></a></dt><p class="pad"></p>

<dd>Return the number of used entries in the hash.</dd><p class="pad"></p>

<dt><a name="parrot_hash_get_idx"
><b><code lang='und' xml:lang='und'>parrot_hash_get_idx</b></code></a></dt><p class="pad"></p>

<dd>Called by iterator.</dd><p class="pad"></p>

<dt><a name="parrot_hash_get_bucket"
><b><code lang='und' xml:lang='und'>parrot_hash_get_bucket</b></code></a></dt><p class="pad"></p>

<dd>Returns the bucket for <code lang='und' xml:lang='und'>key</code>.</dd><p class="pad"></p>

<dt><a name="parrot_hash_get"
><b><code lang='und' xml:lang='und'>parrot_hash_get</b></code></a></dt><p class="pad"></p>

<dd>Returns the value keyed by <code lang='und' xml:lang='und'>key</code> or <code lang='und' xml:lang='und'>NULL</code> if no bucket is found.</dd><p class="pad"></p>

<dt><a name="parrot_hash_exists"
><b><code lang='und' xml:lang='und'>parrot_hash_exists</b></code></a></dt><p class="pad"></p>

<dd>Returns whether the key exists in the hash.</dd><p class="pad"></p>

<dt><a name="parrot_hash_put"
><b><code lang='und' xml:lang='und'>parrot_hash_put</b></code></a></dt><p class="pad"></p>

<dd>Puts the key and value into the hash. Note that <code lang='und' xml:lang='und'>key</code> is <b>not</b> copied.</dd><p class="pad"></p>

<dt><a name="parrot_hash_delete"
><b><code lang='und' xml:lang='und'>parrot_hash_delete</b></code></a></dt><p class="pad"></p>

<dd>Deletes the key from the hash.</dd><p class="pad"></p>

<dt><a name="parrot_hash_clone"
><b><code lang='und' xml:lang='und'>parrot_hash_clone</b></code></a></dt><p class="pad"></p>

<dd>Clones <code lang='und' xml:lang='und'>hash</code> to <code lang='und' xml:lang='und'>dest</code>.</dd><p class="pad"></p>
</dl>

<h1><a name="SEE_ALSO"
>SEE ALSO <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p><em lang='und' xml:lang='und'>docs/pdds/pdd08_keys.pod</em>.</p>

<h1><a name="TODO"
>TODO <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>Future optimizations:</p>

<ul>
<li>Stop reallocating the bucket pool, and instead add chunks on. (Saves pointer fixups and copying during <code lang='und' xml:lang='und'>realloc</code>.)</li><p class="pad"></p>

<li>Hash contraction (don&#39;t if it&#39;s worth it)</li><p class="pad"></p>
</ul>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
