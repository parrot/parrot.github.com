<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Parrot debugging</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Parrot debugging</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../html/index.html">Contents</a> | <a href="../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>src/debug.c &#45; Parrot debugging</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>This file implements Parrot debugging and is used by <code lang='und' xml:lang='und'>pdb</code>,
the Parrot debugger,
and the <code lang='und' xml:lang='und'>debug</code> ops.</p>

<h2><a name="Functions"
>Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="static_char*_nextarg(char*_command)"
><b><code lang='und' xml:lang='und'>static char *nextarg(char *command)</b></code></a></dt><p class="pad"></p>

<dd>Returns the position just past the current argument in a PASM instruction.
This is not the same as <code lang='und' xml:lang='und'>na()</code>,
above,
which is intended for debugger commands.
This function is used for <code lang='und' xml:lang='und'>eval</code>.</dd><p class="pad"></p>

<dt><a name="static_const_char*_skip_ws(const_char*_str)"
><b><code lang='und' xml:lang='und'>static const char *skip_ws(const char *str)</b></code></a></dt><p class="pad"></p>

<dd>Returns the pointer past any whitespace.</dd><p class="pad"></p>

<dt><a name="static_const_char*_skip_command(const_char*_str)"
><b><code lang='und' xml:lang='und'>static const char *skip_command(const char *str)</b></code></a></dt><p class="pad"></p>

<dd>Returns the pointer past the current debugger command.
(This is an alternative to the <code lang='und' xml:lang='und'>na()</code> macro above.)</dd><p class="pad"></p>

<dt><a name="static_const_char*_parse_int(const_char*_str,_int*_intP)"
><b><code lang='und' xml:lang='und'>static const char *parse_int(const char *str, int *intP)</b></code></a></dt><p class="pad"></p>

<dd>Parse an <code lang='und' xml:lang='und'>int</code> out of a string and return a pointer to just after the <code lang='und' xml:lang='und'>int</code>.</dd><p class="pad"></p>

<dt><a name="static_const_char*_parse_string(Interp_*interpreter,_const_char*_str,_STRING**_strP)"
><b><code lang='und' xml:lang='und'>static const char *parse_string(Interp *interpreter, const char *str, STRING** strP)</b></code></a></dt><p class="pad"></p>

<dd>Parse a double&#45;quoted string out of a C string and return a pointer to just after the string.
The parsed string is converted to a Parrot <code lang='und' xml:lang='und'>STRING</code>.</dd><p class="pad"></p>

<dt><a name="static_const_char*_parse_key(Interp_*interpreter,_const_char*_str,_PMC**_keyP)"
><b><code lang='und' xml:lang='und'>static const char *parse_key(Interp *interpreter, const char *str, PMC** keyP)</b></code></a></dt><p class="pad"></p>

<dd>Parse an aggregate key out of a string and return a pointer to just after the key.
Currently only string and integer keys are allowed.</dd><p class="pad"></p>

<dt><a name="static_const_char*_parse_command(const_char*_command,_unsigned_long*_cmdP)"
><b><code lang='und' xml:lang='und'>static const char *parse_command(const char *command, unsigned long *cmdP)</b></code></a></dt><p class="pad"></p>

<dd>Convert the command at the beginning of a string into a numeric value that can be used as a switch key for fast lookup.</dd><p class="pad"></p>

<dt><a name="void_PDB_get_command(Interp_*interpreter)"
><b><code lang='und' xml:lang='und'>void PDB_get_command(Interp *interpreter)</b></code></a></dt><p class="pad"></p>

<dd>Get a command from the user input to execute.</dd><p class="pad"></p>

<dd>It saves the last command executed (in <code lang='und' xml:lang='und'>pdb&#45;&#62;last_command</code>),
so it first frees the old one and updates it with the current one.</dd><p class="pad"></p>

<dd>Also prints the next line to run if the program is still active.</dd><p class="pad"></p>

<dd>The user input can&#39;t be longer than 255 characters.</dd><p class="pad"></p>

<dd>The input is saved in <code lang='und' xml:lang='und'>pdb&#45;&#62;cur_command</code>.</dd><p class="pad"></p>

<dt><a name="void_PDB_run_command(Interp_*interpreter,_const_char_*command)"
><b><code lang='und' xml:lang='und'>void PDB_run_command(Interp *interpreter, const char *command)</b></code></a></dt><p class="pad"></p>

<dd>Run a command.</dd><p class="pad"></p>

<dd>Hash the command to make a simple switch calling the correct handler.</dd><p class="pad"></p>

<dt><a name="void_PDB_next(Interp_*interpreter,_const_char_*command)"
><b><code lang='und' xml:lang='und'>void PDB_next(Interp *interpreter, const char *command)</b></code></a></dt><p class="pad"></p>

<dd>Execute the next N operation(s).</dd><p class="pad"></p>

<dd>Inits the program if needed,
runs the next N &#62;= 1 operations and stops.</dd><p class="pad"></p>

<dt><a name="void_PDB_trace(Interp_*interpreter,_const_char_*command)"
><b><code lang='und' xml:lang='und'>void PDB_trace(Interp *interpreter, const char *command)</b></code></a></dt><p class="pad"></p>

<dd>Execute the next N operations; if no number is specified,
it defaults to 1.</dd><p class="pad"></p>

<dt><a name="PDB_condition_t_*_PDB_cond(Interp_*interpreter,_const_char_*command)"
><b><code lang='und' xml:lang='und'>PDB_condition_t *PDB_cond(Interp *interpreter, const char *command)</b></code></a></dt><p class="pad"></p>

<dd>Analyzes a condition from the user input.</dd><p class="pad"></p>

<dt><a name="void_PDB_watchpoint(Interp_*interpreter,_const_char_*command)"
><b><code lang='und' xml:lang='und'>void PDB_watchpoint(Interp *interpreter, const char *command)</b></code></a></dt><p class="pad"></p>

<dd>Set a watchpoint.</dd><p class="pad"></p>

<dt><a name="void_PDB_set_break(Interp_*interpreter,_const_char_*command)"
><b><code lang='und' xml:lang='und'>void PDB_set_break(Interp *interpreter, const char *command)</b></code></a></dt><p class="pad"></p>

<dd>Set a break point,
the source code file must be loaded.</dd><p class="pad"></p>

<dt><a name="void_PDB_init(Interp_*interpreter,_const_char_*command)"
><b><code lang='und' xml:lang='und'>void PDB_init(Interp *interpreter, const char *command)</b></code></a></dt><p class="pad"></p>

<dd>Init the program.</dd><p class="pad"></p>

<dt><a name="void_PDB_continue(Interp_*interpreter,_const_char_*command)"
><b><code lang='und' xml:lang='und'>void PDB_continue(Interp *interpreter, const char *command)</b></code></a></dt><p class="pad"></p>

<dd>Continue running the program.
If a number is specified,
skip that many breakpoints.</dd><p class="pad"></p>

<dt><a name="PDB_breakpoint_t_*_PDB_find_breakpoint(Interp_*interpreter,_const_char_*command)"
><b><code lang='und' xml:lang='und'>PDB_breakpoint_t *PDB_find_breakpoint(Interp *interpreter, const char *command)</b></code></a></dt><p class="pad"></p>

<dd>Find breakpoint number N; returns <code lang='und' xml:lang='und'>NULL</code> if the breakpoint doesn&#39;t exist or if no breakpoint was specified.</dd><p class="pad"></p>

<dt><a name="void_PDB_disable_breakpoint(Interp_*interpreter,_const_char_*command)"
><b><code lang='und' xml:lang='und'>void PDB_disable_breakpoint(Interp *interpreter, const char *command)</b></code></a></dt><p class="pad"></p>

<dd>Disable a breakpoint; it can be reenabled with the enable command.</dd><p class="pad"></p>

<dt><a name="void_PDB_enable_breakpoint(Interp_*interpreter,_const_char_*command)"
><b><code lang='und' xml:lang='und'>void PDB_enable_breakpoint(Interp *interpreter, const char *command)</b></code></a></dt><p class="pad"></p>

<dd>Reenable a disabled breakpoint; if the breakpoint was not disabled,
has no effect.</dd><p class="pad"></p>

<dt><a name="void_PDB_delete_breakpoint(Interp_*interpreter,_const_char_*command)"
><b><code lang='und' xml:lang='und'>void PDB_delete_breakpoint(Interp *interpreter, const char *command)</b></code></a></dt><p class="pad"></p>

<dd>Delete a breakpoint.</dd><p class="pad"></p>

<dt><a name="void_PDB_delete_condition(Interp_*interpreter,_PDB_breakpoint_t_*breakpoint)"
><b><code lang='und' xml:lang='und'>void PDB_delete_condition(Interp *interpreter, PDB_breakpoint_t *breakpoint)</b></code></a></dt><p class="pad"></p>

<dd>Delete a condition associated with a breakpoint.</dd><p class="pad"></p>

<dt><a name="void_PDB_skip_breakpoint(Interp_*interpreter,_long_i)"
><b><code lang='und' xml:lang='und'>void PDB_skip_breakpoint(Interp *interpreter, long i)</b></code></a></dt><p class="pad"></p>

<dd>Skip <code lang='und' xml:lang='und'>i</code> times all breakpoints.</dd><p class="pad"></p>

<dt><a name="char_PDB_program_end(Interp_*interpreter)"
><b><code lang='und' xml:lang='und'>char PDB_program_end(Interp *interpreter)</b></code></a></dt><p class="pad"></p>

<dd>End the program.</dd><p class="pad"></p>

<dt><a name="char_PDB_check_condition(Interp_*interpreter,_PDB_condition_t_*condition)"
><b><code lang='und' xml:lang='und'>char PDB_check_condition(Interp *interpreter, PDB_condition_t *condition)</b></code></a></dt><p class="pad"></p>

<dd>Returns true if the condition was met.</dd><p class="pad"></p>

<dt><a name="char_PDB_break(Interp_*interpreter)"
><b><code lang='und' xml:lang='und'>char PDB_break(Interp *interpreter)</b></code></a></dt><p class="pad"></p>

<dd>Returns true if we have to stop running.</dd><p class="pad"></p>

<dt><a name="char_*_PDB_escape(const_char_*string,_INTVAL_length)"
><b><code lang='und' xml:lang='und'>char *PDB_escape(const char *string, INTVAL length)</b></code></a></dt><p class="pad"></p>

<dd>Escapes <code lang='und' xml:lang='und'>&#34;</code>,
<code lang='und' xml:lang='und'>\r</code>,
<code lang='und' xml:lang='und'>\n</code>,
<code lang='und' xml:lang='und'>\t</code>,
<code lang='und' xml:lang='und'>\a</code> and <code lang='und' xml:lang='und'>\\</code>.</dd><p class="pad"></p>

<dt><a name="int_PDB_unescape(char_*string)"
><b><code lang='und' xml:lang='und'>int PDB_unescape(char *string)</b></code></a></dt><p class="pad"></p>

<dd>Do inplace unescape of <code lang='und' xml:lang='und'>\r</code>,
<code lang='und' xml:lang='und'>\n</code>,
<code lang='und' xml:lang='und'>\t</code>,
<code lang='und' xml:lang='und'>\a</code> and <code lang='und' xml:lang='und'>\\</code>.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>size_t PDB_disassemble_op(Interp *interpreter, char *dest, int space, op_info_t *info, opcode_t *op, PDB_file_t *file, opcode_t *code_start, int full_name)</b></code></a></dt><p class="pad"></p>

<dd>Disassembles <code lang='und' xml:lang='und'>op</code>.</dd><p class="pad"></p>

<dt><a name="void_PDB_disassemble(Interp_*interpreter,_const_char_*command)"
><b><code lang='und' xml:lang='und'>void PDB_disassemble(Interp *interpreter, const char *command)</b></code></a></dt><p class="pad"></p>

<dd>Disassemble the bytecode.</dd><p class="pad"></p>

<dt><a name="long_PDB_add_label(PDB_file_t_*file,_opcode_t_*cur_opcode,_opcode_t_offset)"
><b><code lang='und' xml:lang='und'>long PDB_add_label(PDB_file_t *file, opcode_t *cur_opcode, opcode_t offset)</b></code></a></dt><p class="pad"></p>

<dd>Add a label to the label list.</dd><p class="pad"></p>

<dt><a name="void_PDB_free_file(Interp_*interpreter)"
><b><code lang='und' xml:lang='und'>void PDB_free_file(Interp *interpreter)</b></code></a></dt><p class="pad"></p>

<dd>Frees any allocated source files.</dd><p class="pad"></p>

<dt><a name="void_PDB_load_source(Interp_*interpreter,_const_char_*command)"
><b><code lang='und' xml:lang='und'>void PDB_load_source(Interp *interpreter, const char *command)</b></code></a></dt><p class="pad"></p>

<dd>Load a source code file.</dd><p class="pad"></p>

<dt><a name="char_PDB_hasinstruction(char_*c)"
><b><code lang='und' xml:lang='und'>char PDB_hasinstruction(char *c)</b></code></a></dt><p class="pad"></p>

<dd>Return true if the line has an instruction.</dd><p class="pad"></p>

<dd>XXX TODO:</dd><p class="pad"></p>

<ul>
<li>This should take the line,
get an instruction,
get the opcode for that instruction and check that is the correct one.</li><p class="pad"></p>

<li>Decide what to do with macros if anything.</li><p class="pad"></p>
</ul>

<dt><a name="void_PDB_list(Interp_*interpreter,_const_char_*command)"
><b><code lang='und' xml:lang='und'>void PDB_list(Interp *interpreter, const char *command)</b></code></a></dt><p class="pad"></p>

<dd>Show lines from the source code file.</dd><p class="pad"></p>

<dt><a name="void_PDB_eval(Interp_*interpreter,_const_char_*command)"
><b><code lang='und' xml:lang='und'>void PDB_eval(Interp *interpreter, const char *command)</b></code></a></dt><p class="pad"></p>

<dd><code lang='und' xml:lang='und'>eval</code>s an instruction.</dd><p class="pad"></p>

<dt><a name="struct_PackFile_*_PDB_compile(Interp_*interpreter,_const_char_*command)"
><b><code lang='und' xml:lang='und'>struct PackFile *PDB_compile(Interp *interpreter, const char *command)</b></code></a></dt><p class="pad"></p>

<dd>Compiles instructions with the PASM compiler.</dd><p class="pad"></p>

<dd>Appends an <code lang='und' xml:lang='und'>end</code> op.</dd><p class="pad"></p>

<dd>This may be called from <code lang='und' xml:lang='und'>PDB_eval</code> above or from the compile opcode which generates a malloced string.</dd><p class="pad"></p>

<dt><a name="int_PDB_extend_const_table(Interp_*interpreter)"
><b><code lang='und' xml:lang='und'>int PDB_extend_const_table(Interp *interpreter)</b></code></a></dt><p class="pad"></p>

<dd>Extend the constant table.</dd><p class="pad"></p>

<dt><a name="void_PDB_print_stack(Interp_*interpreter,_const_char_*command)"
><b><code lang='und' xml:lang='und'>void PDB_print_stack(Interp *interpreter, const char *command)</b></code></a></dt><p class="pad"></p>

<dd>Print entries in the stack.</dd><p class="pad"></p>

<dt><a name="void_PDB_print_stack_int(Interp_*interpreter,_const_char_*command)"
><b><code lang='und' xml:lang='und'>void PDB_print_stack_int(Interp *interpreter, const char *command)</b></code></a></dt><p class="pad"></p>

<dd>Print the integer register stack.</dd><p class="pad"></p>

<dt><a name="void_PDB_print_stack_num(Interp_*interpreter,_const_char_*command)"
><b><code lang='und' xml:lang='und'>void PDB_print_stack_num(Interp *interpreter, const char *command)</b></code></a></dt><p class="pad"></p>

<dd>Print the float register stack.</dd><p class="pad"></p>

<dt><a name="void_PDB_print_stack_string(Interp_*interpreter,_const_char_*command)"
><b><code lang='und' xml:lang='und'>void PDB_print_stack_string(Interp *interpreter, const char *command)</b></code></a></dt><p class="pad"></p>

<dd>Print the string register stack.</dd><p class="pad"></p>

<dt><a name="void_PDB_print_stack_pmc(Interp_*interpreter,_const_char_*command)"
><b><code lang='und' xml:lang='und'>void PDB_print_stack_pmc(Interp *interpreter, const char *command)</b></code></a></dt><p class="pad"></p>

<dd>Print the pmc register stack.</dd><p class="pad"></p>

<dt><a name="static_void_dump_string(Interp_*interpreter,_STRING*_s)"
><b><code lang='und' xml:lang='und'>static void dump_string(Interp *interpreter, STRING *s)</b></code></a></dt><p class="pad"></p>

<dd>Dumps the buflen,
flags,
bufused,
strlen,
offset associated with a string and the string itself.</dd><p class="pad"></p>

<dt><a name="void_PDB_print_user_stack(Interp_*interpreter,_const_char_*command)"
><b><code lang='und' xml:lang='und'>void PDB_print_user_stack(Interp *interpreter, const char *command)</b></code></a></dt><p class="pad"></p>

<dd>Print an entry from the user stack.</dd><p class="pad"></p>

<dt><a name="void_PDB_print(Interp_*interpreter,_const_char_*command)"
><b><code lang='und' xml:lang='und'>void PDB_print(Interp *interpreter, const char *command)</b></code></a></dt><p class="pad"></p>

<dd>Print interpreter registers.</dd><p class="pad"></p>

<dt><a name="void_PDB_print_int(Interp_*interpreter,_struct_IReg_*int_reg,_int_regnum)"
><b><code lang='und' xml:lang='und'>void PDB_print_int(Interp *interpreter, struct IReg *int_reg, int regnum)</b></code></a></dt><p class="pad"></p>

<dd>Print the whole or a specific value of a integer register structure.</dd><p class="pad"></p>

<dt><a name="void_PDB_print_int_frame(Interp_*interpreter,_struct_IRegFrame_*int_reg,_int_regnum)"
><b><code lang='und' xml:lang='und'>void PDB_print_int_frame(Interp *interpreter, struct IRegFrame *int_reg, int regnum)</b></code></a></dt><p class="pad"></p>

<dd>Print the whole or a specific value of a integer register frame structure.</dd><p class="pad"></p>

<dt><a name="void_PDB_print_num(Interp_*interpreter,_struct_NReg_*num_reg,_int_regnum)"
><b><code lang='und' xml:lang='und'>void PDB_print_num(Interp *interpreter, struct NReg *num_reg, int regnum)</b></code></a></dt><p class="pad"></p>

<dd>Print the whole or a specific value of a float register structure.</dd><p class="pad"></p>

<dt><a name="void_PDB_print_num_frame(Interp_*interpreter,_struct_NRegFrame_*num_reg,_int_regnum)"
><b><code lang='und' xml:lang='und'>void PDB_print_num_frame(Interp *interpreter, struct NRegFrame *num_reg, int regnum)</b></code></a></dt><p class="pad"></p>

<dd>Print the whole or a specific value of a float register frame structure.</dd><p class="pad"></p>

<dt><a name="void_PDB_print_string(Interp_*interpreter,_struct_SReg_*string_reg,_int_regnum)"
><b><code lang='und' xml:lang='und'>void PDB_print_string(Interp *interpreter, struct SReg *string_reg, int regnum)</b></code></a></dt><p class="pad"></p>

<dd>Print the whole or a specific value of a string register structure.</dd><p class="pad"></p>

<dt><a name="void_PDB_print_string_frame(Interp_*interpreter,_struct_SRegFrame_*string_reg,_int_regnum)"
><b><code lang='und' xml:lang='und'>void PDB_print_string_frame(Interp *interpreter, struct SRegFrame *string_reg, int regnum)</b></code></a></dt><p class="pad"></p>

<dd>Print the whole or a specific value of a string register frame structure.</dd><p class="pad"></p>

<dt><a name="static_void_print_pmc(Interp_*interpreter,_PMC*_pmc)"
><b><code lang='und' xml:lang='und'>static void print_pmc(Interp *interpreter, PMC *pmc)</b></code></a></dt><p class="pad"></p>

<dd>Prints out a human&#45;readable description of <code lang='und' xml:lang='und'>pmc</code>.</dd><p class="pad"></p>

<dt><a name="void_PDB_print_pmc(Interp_*interpreter,_struct_PReg_*pmc_reg,_int_regnum,_PMC*_key)"
><b><code lang='und' xml:lang='und'>void PDB_print_pmc(Interp *interpreter, struct PReg *pmc_reg, int regnum, PMC *key)</b></code></a></dt><p class="pad"></p>

<dd>Print the whole or a specific value of a PMC register structure.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>void PDB_print_pmc_frame(Interp *interpreter, struct PRegFrame *pmc_reg, int regnum, PMC *key)</b></code></a></dt><p class="pad"></p>

<dd>Print the whole or a specific value of a PMC register frame structure.</dd><p class="pad"></p>

<dt><a name="void_PDB_info(Interp_*interpreter)"
><b><code lang='und' xml:lang='und'>void PDB_info(Interp *interpreter)</b></code></a></dt><p class="pad"></p>

<dd>Print the interpreter info.</dd><p class="pad"></p>

<dt><a name="void_PDB_help(Interp_*interpreter,_const_char_*command)"
><b><code lang='und' xml:lang='und'>void PDB_help(Interp *interpreter, const char *command)</b></code></a></dt><p class="pad"></p>

<dd>Print the help text.
&#34;Help&#34; with no arguments prints a list of commands.
&#34;Help xxx&#34; prints information on command xxx.</dd><p class="pad"></p>

<dt><a name="void_PDB_backtrace(Interp_*interpreter)"
><b><code lang='und' xml:lang='und'>void PDB_backtrace(Interp *interpreter)</b></code></a></dt><p class="pad"></p>

<dd>Prints a backtrace of the interpreter&#39;s call chain.</dd><p class="pad"></p>
</dl>

<h1><a name="SEE_ALSO"
>SEE ALSO <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p><em lang='und' xml:lang='und'>include/parrot/debug.h</em>,
<em lang='und' xml:lang='und'><a href="pdb.c.html">src/pdb.c</a></em> and <em lang='und' xml:lang='und'><a href="../ops/debug.ops.html">ops/debug.ops</a></em>.</p>

<h1><a name="HISTORY"
>HISTORY <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>Initial version by Daniel Grunblatt on 2002.5.19.</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
