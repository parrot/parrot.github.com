<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>The Parrot Extension System</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">The Parrot Extension System</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../html/index.html">Contents</a> | <a href="../../../html/docs.html">Documentation</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>docs/pdds/pdd11_extending.pod &#45; The Parrot Extension System</p>

<h1><a name="ABSTRACT"
>ABSTRACT <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>The extension API for Parrot is a simple,
somewhat abstract,
interface to Parrot for code written in C or other compiled languages.
It provides about the same level of access to Parrot that bytecode programs have.</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>The API presents to C programs roughly the same interface presented to bytecode programs&#45;&#45;that is,
a C extension can see everything that a bytecode program can see,
including Parrot&#39;s base architecture,
registers,
stacks,
and whatnot.
This view isn&#39;t required,
however,
and often extension code won&#39;t need or want to know what Parrot&#39;s internal structures look like.
For this reason the functions in the extension API are divided into two broad groups,
one that has no particular knowledge of the internals and one that does.</p>

<p>The stability of the two API groups is guaranteed separately.
Group 1,
the internals unaware group,
should be good basically forever.
Group 2,
the internals aware group,
is only guaranteed for the lifetime of the current architecture.
(It&#39;s likely that both groups will last equally long; however,
the Group 1 interface could reasonably be emulated on a different engine,
while the Group 2 interface is more closely tied to Parrot).</p>

<p><b>Note:</b> The extension API has not yet been completely specified.
New functions may be added,
and those described below may change or be removed.
You have been warned...</p>

<h1><a name="API_&#45;_Group_1:_Internals&#45;unaware_functions"
>API &#45; Group 1: Internals&#45;unaware functions <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>These functions are the ones that are largely unaware of the structure and architecture of Parrot.
They deal mainly in data as abstract entities,
and Parrot itself as a black box that,
at best,
can make subroutine or method calls.
This is sufficient for many extensions which act as black box processing units and in turn treat Parrot itself as a black box.</p>

<h2><a name="PMC_access_functions"
>PMC access functions <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>The following functions are for storing and retrieving data inside PMCs.
Note that use of the _keyed functions with non&#45;aggregate PMCs will generally just result in Parrot throwing an exception.</p>

<dl>
<dt><a name="Parrot_PMC_get_string(interp,_pmc)"
><b><code lang='und' xml:lang='und'>Parrot_PMC_get_string(interp, pmc)</b></code></a></dt><p class="pad"></p>

<dd>Returns a Parrot_STRING that represents the string value of the PMC.</dd><p class="pad"></p>

<dt><a name="Parrot_PMC_get_string_intkey(interp,_pmc,_Parrot_Int_key)"
><b><code lang='und' xml:lang='und'>Parrot_PMC_get_string_intkey(interp, pmc, Parrot_Int key)</b></code></a></dt><p class="pad"></p>

<dd>Keyed version of <code lang='und' xml:lang='und'>Parrot_PMC_get_string</code>.
Returns a Parrot_STRING representing the string value of whatever is stored at the element of the PMC indexed by <code lang='und' xml:lang='und'>key</code>.</dd><p class="pad"></p>

<dt><a name="Parrot_PMC_get_pointer(interp,_pmc)"
><b><code lang='und' xml:lang='und'>Parrot_PMC_get_pointer(interp, pmc)</b></code></a></dt><p class="pad"></p>

<dd>Returns a pointer to some item of data.
The details of what the pointer points to depend on the particular PMC.
This function is useful for dealing with PMCs that hold pointers to arbitrary data.</dd><p class="pad"></p>

<dt><a name="Parrot_PMC_get_pointer_intkey(interp,_pmc,_Parrot_Int_key)"
><b><code lang='und' xml:lang='und'>Parrot_PMC_get_pointer_intkey(interp, pmc, Parrot_Int key)</b></code></a></dt><p class="pad"></p>

<dd>A keyed version of <code lang='und' xml:lang='und'>Parrot_PMC_get_pointer</code>.
Returns the pointer value of whatever is stored at the element of the PMC indexed by <code lang='und' xml:lang='und'>key</code>.</dd><p class="pad"></p>

<dt><a name="Parrot_PMC_get_intval(interp,_pmc)"
><b><code lang='und' xml:lang='und'>Parrot_PMC_get_intval(interp, pmc)</b></code></a></dt><p class="pad"></p>

<dd>Returns the integer value of the PMC.</dd><p class="pad"></p>

<dt><a name="Parrot_PMC_get_intval_intkey(interp,_pmc,_Parrot_Int_key)"
><b><code lang='und' xml:lang='und'>Parrot_PMC_get_intval_intkey(interp, pmc, Parrot_Int key)</b></code></a></dt><p class="pad"></p>

<dd>A keyed version of <code lang='und' xml:lang='und'>Parrot_PMC_get_intval</code>.
Returns the integer value of whatever is stored at the element of the PMC indexed by <code lang='und' xml:lang='und'>key</code>.</dd><p class="pad"></p>

<dt><a name="Parrot_PMC_get_numval(interp,_pmc)"
><b><code lang='und' xml:lang='und'>Parrot_PMC_get_numval(interp, pmc)</b></code></a></dt><p class="pad"></p>

<dd>Returns the numeric value of the PMC.</dd><p class="pad"></p>

<dt><a name="Parrot_PMC_get_numval_intkey(interp,_pmc,_Parrot_Int_key)"
><b><code lang='und' xml:lang='und'>Parrot_PMC_get_numval_intkey(interp, pmc, Parrot_Int key)</b></code></a></dt><p class="pad"></p>

<dd>A keyed version of <code lang='und' xml:lang='und'>Parrot_PMC_get_numval</code>.
Returns the numeric value of whatever is stored at the element of the PMC indexed by <code lang='und' xml:lang='und'>key</code>.</dd><p class="pad"></p>

<dt><a name="Parrot_PMC_get_cstring(interp,_pmc)"
><b><code lang='und' xml:lang='und'>Parrot_PMC_get_cstring(interp, pmc)</b></code></a></dt><p class="pad"></p>

<dd>Returns a C&#45;string (char *) that represents the string value of the PMC.
The memory the char * points to is a copy of the original value,
and changing it will not change the original in any way.</dd><p class="pad"></p>

<dd>This memory will <i>not</i> be reclaimed by garbage collection,
nor may it be returned to the system with <code lang='und' xml:lang='und'>free</code>.
It must be returned with <code lang='und' xml:lang='und'>Parrot_free_cstring</code>.</dd><p class="pad"></p>

<dt><a name="Parrot_PMC_get_cstring_intkey(interp,_pmc,_Parrot_Int_key)"
><b><code lang='und' xml:lang='und'>Parrot_PMC_get_cstring_intkey(interp, pmc, Parrot_Int key)</b></code></a></dt><p class="pad"></p>

<dd>A keyed version of <code lang='und' xml:lang='und'>Parrot_PMC_get_cstring</code>.
Returns a C&#45;string representing the string value of whatever is stored at the element of the PMC indexed by <code lang='und' xml:lang='und'>key</code>.</dd><p class="pad"></p>

<dt><a name="Parrot_PMC_get_cstringn(interp,_pmc,_&#38;len)"
><b><code lang='und' xml:lang='und'>Parrot_PMC_get_cstringn(interp, pmc, &#38;len)</b></code></a></dt><p class="pad"></p>

<dd>Returns a C&#45;string (char *) that represents the string value of the PMC.
The memory the char * points to is a copy of the original value,
and changing it will not change the original in any way.
The <code lang='und' xml:lang='und'>len</code> parameter is the address of an integer that will get the length of the string as Parrot knows it.</dd><p class="pad"></p>

<dd>This memory will <i>not</i> be reclaimed by garbage collection,
nor may it be returned to the system with <code lang='und' xml:lang='und'>free</code>.
It must be returned with <code lang='und' xml:lang='und'>Parrot_free_cstring</code>.</dd><p class="pad"></p>

<dt><a name="Parrot_PMC_get_cstringn_intkey(interp,_pmc,_&#38;len,_Parrot_Int_key)"
><b><code lang='und' xml:lang='und'>Parrot_PMC_get_cstringn_intkey(interp, pmc, &#38;len, Parrot_Int key)</b></code></a></dt><p class="pad"></p>

<dd>A keyed version of <code lang='und' xml:lang='und'>Parrot_PMC_get_cstringn</code>.
Returns a C&#45;string representing the string value of whatever is stored at the element of the PMC indexed by <code lang='und' xml:lang='und'>key</code>.
Stores the length of the string in <code lang='und' xml:lang='und'>len</code>.</dd><p class="pad"></p>

<dt><a name="Parrot_PMC_get_pmc_intkey(interp,_pmc,_Parrot_Int_key)"
><b><code lang='und' xml:lang='und'>Parrot_PMC_get_pmc_intkey(interp, pmc, Parrot_Int key)</b></code></a></dt><p class="pad"></p>

<dd>Returns the PMC stored at the element of the passed&#45;in PMC that is indexed by <code lang='und' xml:lang='und'>key</code>.</dd><p class="pad"></p>

<dt><a name="Parrot_PMC_set_string(interp,_pmc,_Parrot_STRING_value)"
><b><code lang='und' xml:lang='und'>Parrot_PMC_set_string(interp, pmc, Parrot_STRING value)</b></code></a></dt><p class="pad"></p>

<dd>Assign the passed&#45;in Parrot_STRING to the passed&#45;in PMC.</dd><p class="pad"></p>

<dt><a name="Parrot_PMC_set_string_intkey(interp,_pmc,_Parrot_STRING_value,_Parrot_Int_key)"
><b><code lang='und' xml:lang='und'>Parrot_PMC_set_string_intkey(interp, pmc, Parrot_STRING value, Parrot_Int key)</b></code></a></dt><p class="pad"></p>

<dd>Keyed version of <code lang='und' xml:lang='und'>Parrot_PMC_set_string</code>.
Assigns <code lang='und' xml:lang='und'>value</code> to the PMC stored at element &#60;key&#62; of the passed&#45;in PMC.</dd><p class="pad"></p>

<dt><a name="Parrot_PMC_set_pointer(interp,_pmc,_void_*value)"
><b><code lang='und' xml:lang='und'>Parrot_PMC_set_pointer(interp, pmc, void *value)</b></code></a></dt><p class="pad"></p>

<dd>Assign the passed&#45;in pointer to the passed&#45;in PMC.</dd><p class="pad"></p>

<dt><a name="Parrot_PMC_set_pointer_intkey(interp,_pmc,_void_*value,_Parrot_Int_key)"
><b><code lang='und' xml:lang='und'>Parrot_PMC_set_pointer_intkey(interp, pmc, void *value, Parrot_Int key)</b></code></a></dt><p class="pad"></p>

<dd>Keyed version of <code lang='und' xml:lang='und'>Parrot_PMC_set_pointer</code>.
Assigns <code lang='und' xml:lang='und'>value</code> to the PMC stored at element &#60;key&#62; of the passed&#45;in PMC.</dd><p class="pad"></p>

<dt><a name="Parrot_PMC_set_pmc_intkey(interp,_pmc,_Parrot_PMC_value,_Parrot_Int_key)"
><b><code lang='und' xml:lang='und'>Parrot_PMC_set_pmc_intkey(interp, pmc, Parrot_PMC value, Parrot_Int key)</b></code></a></dt><p class="pad"></p>

<dd>Assigns <code lang='und' xml:lang='und'>value</code> to the PMC stored at element &#60;key&#62; of the passed&#45;in PMC.</dd><p class="pad"></p>

<dt><a name="Parrot_PMC_set_intval(interp,_pmc,_Parrot_Int_value)"
><b><code lang='und' xml:lang='und'>Parrot_PMC_set_intval(interp, pmc, Parrot_Int value)</b></code></a></dt><p class="pad"></p>

<dd>Assign the passed&#45;in Parrot integer to the passed&#45;in PMC.</dd><p class="pad"></p>

<dt><a name="Parrot_PMC_set_intval_intkey(interp,_pmc,_Parrot_Int_value,_Parrot_Int_key)"
><b><code lang='und' xml:lang='und'>Parrot_PMC_set_intval_intkey(interp, pmc, Parrot_Int value, Parrot_Int key)</b></code></a></dt><p class="pad"></p>

<dd>Keyed version of <code lang='und' xml:lang='und'>Parrot_PMC_set_intval</code>.
Assigns <code lang='und' xml:lang='und'>value</code> to the PMC stored at element &#60;key&#62; of the passed&#45;in PMC.</dd><p class="pad"></p>

<dt><a name="Parrot_PMC_set_numval(interp,_pmc,_Parrot_Float_value)"
><b><code lang='und' xml:lang='und'>Parrot_PMC_set_numval(interp, pmc, Parrot_Float value)</b></code></a></dt><p class="pad"></p>

<dd>Assign the passed&#45;in Parrot number to the passed&#45;in PMC.</dd><p class="pad"></p>

<dt><a name="Parrot_PMC_set_numval_intkey(interp,_pmc,_Parrot_Float_value,_Parrot_Int_key)"
><b><code lang='und' xml:lang='und'>Parrot_PMC_set_numval_intkey(interp, pmc, Parrot_Float value, Parrot_Int key)</b></code></a></dt><p class="pad"></p>

<dd>Keyed version of <code lang='und' xml:lang='und'>Parrot_PMC_set_numval</code>.
Assigns <code lang='und' xml:lang='und'>value</code> to the PMC stored at element &#60;key&#62; of the passed&#45;in PMC.</dd><p class="pad"></p>

<dt><a name="Parrot_PMC_set_cstring(interp,_pmc,_const_char_*value)"
><b><code lang='und' xml:lang='und'>Parrot_PMC_set_cstring(interp, pmc, const char *value)</b></code></a></dt><p class="pad"></p>

<dd>Convert the passed&#45;in null&#45;terminated C string to a Parrot_STRING and assign it to the passed&#45;in PMC.</dd><p class="pad"></p>

<dt><a name="Parrot_PMC_set_cstring_intkey(interp,_pmc,_const_char_*value,_Parrot_Int_key)"
><b><code lang='und' xml:lang='und'>Parrot_PMC_set_cstring_intkey(interp, pmc, const char *value, Parrot_Int key)</b></code></a></dt><p class="pad"></p>

<dd>Keyed version of <code lang='und' xml:lang='und'>Parrot_PMC_set_cstring</code>.
Converts <code lang='und' xml:lang='und'>value</code> to a Parrot_STRING and assigns it to the PMC stored at element &#60;key&#62; of the passed&#45;in PMC.</dd><p class="pad"></p>

<dt><a name="Parrot_PMC_set_cstringn(interp,_pmc,_const_char_*value,_Parrot_Int_length)"
><b><code lang='und' xml:lang='und'>Parrot_PMC_set_cstringn(interp, pmc, const char *value, Parrot_Int length)</b></code></a></dt><p class="pad"></p>

<dd>Convert the passed&#45;in null&#45;terminated C string to a Parrot_STRING of length <code lang='und' xml:lang='und'>length</code> and assign it to the passed&#45;in PMC.
If <code lang='und' xml:lang='und'>value</code> is longer than <code lang='und' xml:lang='und'>length</code>,
then only the first <code lang='und' xml:lang='und'>length</code> characters will be converted.
If <code lang='und' xml:lang='und'>value</code> is shorter than <code lang='und' xml:lang='und'>length</code>,
then the extra characters in the Parrot_STRING should be assumed to contain garbage.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>Parrot_PMC_set_cstringn_intkey(interp, pmc, const char *value, Parrot_int length, Parrot_Int key)</b></code></a></dt><p class="pad"></p>

<dd>Keyed version of <code lang='und' xml:lang='und'>Parrot_PMC_set_cstringn</code>.
Converts the first <code lang='und' xml:lang='und'>length</code> characters of <code lang='und' xml:lang='und'>value</code> to a Parrot_STRING and assigns the resulting string to the PMC stored at element &#60;key&#62; of the passed&#45;in PMC.</dd><p class="pad"></p>
</dl>

<h2><a name="Creation_and_destruction"
>Creation and destruction <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Functions used to create and destroy PMCs,
Parrot_STRINGs,
etc.</p>

<dl>
<dt><a name="Parrot_PMC_new(interp,_Parrot_Int_typenum)"
><b><code lang='und' xml:lang='und'>Parrot_PMC_new(interp, Parrot_Int typenum)</b></code></a></dt><p class="pad"></p>

<dd>Creates and returns a new PMC.
<code lang='und' xml:lang='und'>typenum</code> is an integer identifier that specifies the type of PMC required.
The <code lang='und' xml:lang='und'>typenum</code> corresponding to a particular PMC class name can be found using <code lang='und' xml:lang='und'>Parrot_PMC_typenum</code>.</dd><p class="pad"></p>

<dt><a name="Parrot_PMC_typenum(interp,_const_char*_class)"
><b><code lang='und' xml:lang='und'>Parrot_PMC_typenum(interp, const char *class)</b></code></a></dt><p class="pad"></p>

<dd>Returns the internal integer identifier corresponding to a PMC with class name <code lang='und' xml:lang='und'>class</code>.</dd><p class="pad"></p>

<dt><a name="Parrot_PMC_null()"
><b><code lang='und' xml:lang='und'>Parrot_PMC_null()</b></code></a></dt><p class="pad"></p>

<dd>Returns the special <code lang='und' xml:lang='und'>NULL</code> PMC.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>Parrot_new_string(interp, char *buffer, int length, Parrot_Encoding encoding, Parrot_CharType charset, Parrot_Language language, Parrot_Int flags)</b></code></a></dt><p class="pad"></p>

<dd>Create a new Parrot string from a passed&#45;in buffer.
If the <code lang='und' xml:lang='und'>encoding</code>,
<code lang='und' xml:lang='und'>charset</code>,
or <code lang='und' xml:lang='und'>language</code> are unspecified (i.e.
if you pass in 0),
then the defaults are used.
Otherwise,
the functions <code lang='und' xml:lang='und'>Parrot_find_encoding</code>,
<code lang='und' xml:lang='und'> Parrot_find_chartype</code> and <code lang='und' xml:lang='und'>Parrot_find_language</code> (all described below) can be used to find the appropriate values for a particular choice of encoding,
chartype or language.</dd><p class="pad"></p>

<dd>Flag values are currently undocumented.</dd><p class="pad"></p>

<dd>Note that a copy of the buffer is made.</dd><p class="pad"></p>

<dt><a name="Parrot_find_encoding(interp,_char_*encoding_name)"
><b><code lang='und' xml:lang='und'>Parrot_find_encoding(interp, char *encoding_name)</b></code></a></dt><p class="pad"></p>

<dd>Find the magic token for an encoding,
by name.</dd><p class="pad"></p>

<dt><a name="Parrot_find_chartype(interp,_char_*chartype)"
><b><code lang='und' xml:lang='und'>Parrot_find_chartype(interp, char *chartype)</b></code></a></dt><p class="pad"></p>

<dd>Find the magic token for a chartype,
by name.</dd><p class="pad"></p>

<dt><a name="Parrot_find_language(interp,_char_*language)"
><b><code lang='und' xml:lang='und'>Parrot_find_language(interp, char *language)</b></code></a></dt><p class="pad"></p>

<dd>Find the magic token for a language,
by language name.</dd><p class="pad"></p>

<dt><a name="Parrot_free_cstring(char*_string)"
><b><code lang='und' xml:lang='und'>Parrot_free_cstring(char *string)</b></code></a></dt><p class="pad"></p>

<dd>Deallocates a C string that the interpreter has handed to you.
This function must be used to free strings produced by <code lang='und' xml:lang='und'>Parrot_PMC_get_cstring</code> and <code lang='und' xml:lang='und'>Parrot_PMC_get_cstringn</code>,
as these will not be reclaimed by the garbage collector.
It should not be used to deallocate strings that do not come from Parrot.</dd><p class="pad"></p>

<dt><a name="Parrot_register_pmc(interp,_pmc)"
><b><code lang='und' xml:lang='und'>Parrot_register_pmc(interp, pmc)</b></code></a></dt><p class="pad"></p>

<dd>Add a reference to the PMC to the interpreter&#39;s DOD registry.
This prevents PMCs known only to extensions from getting destroyed during DOD runs.</dd><p class="pad"></p>

<dt><a name="Parrot_unregister_pmc(interp,_pmc)"
><b><code lang='und' xml:lang='und'>Parrot_unregister_pmc(interp, pmc)</b></code></a></dt><p class="pad"></p>

<dd>Remove a reference to the PMC from the interpreter&#39;s DOD registry.
If the reference count reaches zero,
the PMC will be destroyed during the next DOD run.</dd><p class="pad"></p>
</dl>

<h2><a name="Subroutine_and_method_calls"
>Subroutine and method calls <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Functions to call Parrot subroutines and methods</p>

<dl>
<dt><a name="Parrot_call(interp,_Parrot_PMC_sub,_Parrot_Int_argcount,_...)"
><b><code lang='und' xml:lang='und'>Parrot_call(interp, Parrot_PMC sub, Parrot_Int argcount, ...)</b></code></a></dt><p class="pad"></p>

<dd>Calls a Parrot subroutine,
with <code lang='und' xml:lang='und'>argcount</code> PMC parameters.
This function sets up Parrot&#39;s registers in line with the Parrot calling conventions; see <a href='TODO'>pdd03_calling_conventions.pod</a> for more details.</dd><p class="pad"></p>

<dt><a name="Parrot_call_method(interp,_Parrot_PMC_sub,_Parrot_STRING_method,_Parrot_Int_argcount,_...)"
><b><code lang='und' xml:lang='und'>Parrot_call_method(interp, Parrot_PMC sub, Parrot_STRING method, Parrot_Int argcount, ...)</b></code></a></dt><p class="pad"></p>

<dd>Calls a Parrot method named <code lang='und' xml:lang='und'>method</code> with <code lang='und' xml:lang='und'>argcount</code> PMC parameters.
NB.
This is not yet implemented and may change.</dd><p class="pad"></p>
</dl>

<h1><a name="API_&#45;_Group_2:_Internals_aware"
>API &#45; Group 2: Internals aware <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>The internals&#45;aware functions are for those extensions that need to query or alter the state of Parrot&#39;s internals in some way.</p>

<p>Register access functions</p>

<p>The following functions allow the values stored in Parrot&#39;s registers to be accessed.
An attempt to access a non&#45;existent register (e.g.
string register &#45;123) will cause the function to throw an exception (well,
it will once we actually implement some bounds&#45;checking...).
The value stored in an uninitialized register is undefined; it may well be zero (or NULL),
but do not rely on this being the case.</p>

<dl>
<dt><a name="Parrot_get_intreg(interp,_Parrot_Int_regnum)"
><b><code lang='und' xml:lang='und'>Parrot_get_intreg(interp, Parrot_Int regnum)</b></code></a></dt><p class="pad"></p>

<dd>Return the value of an integer register.</dd><p class="pad"></p>

<dt><a name="Parrot_get_numreg(interp,_Parrot_Int_regnum)"
><b><code lang='und' xml:lang='und'>Parrot_get_numreg(interp, Parrot_Int regnum)</b></code></a></dt><p class="pad"></p>

<dd>Return the value of a numeric register.</dd><p class="pad"></p>

<dt><a name="Parrot_get_strreg(interp,_Parrot_Int_regnum)"
><b><code lang='und' xml:lang='und'>Parrot_get_strreg(interp, Parrot_Int regnum)</b></code></a></dt><p class="pad"></p>

<dd>Return the value of a string register.</dd><p class="pad"></p>

<dt><a name="Parrot_get_pmcreg(interp,_Parrot_Int_regnum)"
><b><code lang='und' xml:lang='und'>Parrot_get_pmcreg(interp, Parrot_Int regnum)</b></code></a></dt><p class="pad"></p>

<dd>Return the value of a PMC register.</dd><p class="pad"></p>
</dl>

<h1><a name="ATTACHMENTS"
>ATTACHMENTS <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>None.</p>

<h1><a name="FOOTNOTES"
>FOOTNOTES <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>None.</p>

<h1><a name="REFERENCES"
>REFERENCES <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p><em lang='und' xml:lang='und'><a href="../glossary.pod.html">docs/glossary.pod</a></em></p>

<h1><a name="VERSION"
>VERSION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<h2><a name="CURRENT"
>CURRENT <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<pre lang='und' xml:lang='und'>    Maintainer: 
    Class: Internals
    PDD Number: 11
    Version: 1.0
    Status: Developing
    Last Modified: February 20, 2004 
    PDD Format: 1
    Language: English</pre>

<h2><a name="HISTORY"
>HISTORY <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="Version_1"
>Version 1</a></dt><p class="pad"></p>

<dd>None. First version</dd><p class="pad"></p>
</dl>

<h1><a name="CHANGES"
>CHANGES <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<dl>
<dt><a name="Version_1.0"
>Version 1.0</a></dt><p class="pad"></p>

<dd>None. First version</dd><p class="pad"></p>
</dl>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
