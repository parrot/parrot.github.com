<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Common vtable format for all variables</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Common vtable format for all variables</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../html/index.html">Contents</a> | <a href="../../../html/docs.html">Documentation</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>docs/pdds/pdd02_vtables.pod &#45; Common vtable format for all variables</p>

<h1><a name="ABSTRACT"
>ABSTRACT <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>This PDD presents the vtable entries,
and their order,
that all variables MUST provide.</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>All parrot variables hide their guts behind a magic parrot structure generally referred to as a PMC,
or Parrot Magic Cookie.
Nothing outside the core of parrot (in fact,
nothing outside the data type&#39;s vtable routines) should infer anything about a PMC (hence the Magic part).</p>

<p>The first parameter to any vtable routine should be the current interpreter.
The second parameter should be the PMC itself.</p>

<p>vtables are neat because they decouple the interface and implementation of various object functions.
This does mean,
though,
that you need to either know what functions are available and what they do,
or have some method of finding out.
It&#39;s faster if you know which vtable entry does what,
so that&#39;s the method parrot&#39;s using.</p>

<p>The actual vtable structure contains pointers to functions that implement the methods for that particular vtable.
All pointers must point to valid functions with appropriate prototypes.</p>

<h1><a name="IMPLEMENTATION"
>IMPLEMENTATION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<h2><a name="vtable_functions"
>vtable functions <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>This is a list of each of the vtable methods,
their prototypes,
and a description of the method.</p>

<p>The following functions are singleton functions.
(There are no keyed versions of these)</p>

<dl>
<dt><a name="void_init(INTERP,_PMC*_self)"
>void init(INTERP,
PMC* self)</a></dt><p class="pad"></p>

<dd>The init vtable method takes an unused PMC as a parameter and turns it into a PMC appropriate for the class owning the vtable.
Called as a class method.
There is also a form that accepts a PMC initializer as a third argument.</dd><p class="pad"></p>

<dt><a name="void_init_pmc(INTERP,_PMC*_self,_PMC*_initializer)"
>void init_pmc(INTERP,
PMC* self,
PMC* initializer)</a></dt><p class="pad"></p>

<dd>This form of the init method takes a single initializer parameter.
The initializer is an array that contains keys and values.
The meaning of the keys and their corresponding values is left up to the PMC.</dd><p class="pad"></p>

<dd>Keys are either strings or integers.
If strings,
the PMC is responsible for figuring out what the string represents.
If integers,
it means the meaning has been pre&#45;figured based on meta&#45;information from the class.</dd><p class="pad"></p>

<dd>For example,
if a class has the known properties &#34;Size&#34;,
&#34;Dimension&#34; and &#34;Color&#34;,
they may be assigned the values 100,
101,
and 102.
If the creator of the PMC knows enough about the class to make the translation to numbers it may; otherwise,
the raw strings may be used.
So,
for the declaration:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>   my @foo Size(12), Dimension(3), Color(&#34;Green&#34;);</pre>

<dd>the init array may be [100, 12, 101, 3, 102, &#34;Green&#34;] or [&#34;Size&#34;, 12, &#34;Dimension&#34;, 3, &#34;Color&#34;, &#34;Green&#34;]. Note that, in all cases, the array is an array of PMCs. (So you get either an int PMC or a string PMC in the list of keys).</dd><p class="pad"></p>

<dt><a name="void_init_pmc_props(INTERP,_PMC*_self,_PMC*_initializer,_PMC*_properties)"
>void init_pmc_props(INTERP, PMC* self, PMC* initializer, PMC* properties)</a></dt><p class="pad"></p>

<dd>XXX: what does this do?</dd><p class="pad"></p>

<dt><a name="void_morph(INTERP,_PMC*_self,_INTVAL_type)"
>void morph(INTERP, PMC* self, INTVAL type)</a></dt><p class="pad"></p>

<dd>Turn the PMC into a PMC of type <code lang='und' xml:lang='und'>type</code>. If the morphing can&#39;t be done in any reasonable way &#45;&#45; for instance if an integer is asked to turn into an Array &#45;&#45; then the PMC is first destroyed, then recreated as an empty PMC of the new type.</dd><p class="pad"></p>

<dd>This method is primarily used when the interpreter has need of coercing a PMC to a particular type, and isn&#39;t meant as a general purpose casting tool. Compilers should only emit valid transformations.</dd><p class="pad"></p>

<dt><a name="void_mark(INTERP,_PMC*_self)"
>void mark(INTERP, PMC* self)</a></dt><p class="pad"></p>

<dd>Called by the DOD when it is sweeping through the PMCs and has detected that this PMC is both alive and has a custom mark routine (as indicated by the custom mark PMC flag).</dd><p class="pad"></p>

<dd>If a PMC has this flag set, then it is responsible for marking all buffers and PMCs under its control as alive. If it does not, those PMCs or buffers may be collected later. This method does <i>not</i> have to call the <code lang='und' xml:lang='und'>mark</code> method on any PMCs it marks&#45;&#45;the DOD system takes care of that. (So no need to recurse into aggregate PMCs or anything of the sort).</dd><p class="pad"></p>

<dd>This method may allocate no memory from Parrot, nor may it alter Parrot&#39;s internal structures. It should have no side&#45;effects from the C level either.</dd><p class="pad"></p>

<dd>This routine may <b>not</b> throw an exception.</dd><p class="pad"></p>

<dt><a name="void_destroy(INTERP,_PMC*_self)"
>void destroy(INTERP, PMC* self)</a></dt><p class="pad"></p>

<dd>This method is called by the DOD when it determines that a PMC is dead and that the PMC has marked itself as having a destroy method.</dd><p class="pad"></p>

<dd>When this method finishes, the PMC will be marked as dead. As such you should make sure that you do <i>not</i> leave any references to it in any parrot structure by the end of the method.</dd><p class="pad"></p>

<dd>This method may <i>not</i> throw an exception. It will be ignored if it does.</dd><p class="pad"></p>

<dt><a name="PMC*_getprop(INTERP,_PMC*_self,_STRING*_key)"
>PMC* getprop(INTERP, PMC* self, STRING* key)</a></dt><p class="pad"></p>

<dd>Return the value from the property hash of <b>self</b> keyed by <b>key</b>. The key should not be NULL.</dd><p class="pad"></p>

<dt><a name="void_setprop(INTERP,_PMC*_self,_STRING*_key,_PMC*_value)"
>void setprop(INTERP, PMC* self, STRING* key, PMC* value)</a></dt><p class="pad"></p>

<dd>Set the value in the property hash of <b>self</b> that is keyed by <b>key</b> to the value of <b>value</b>. The key should not be NULL.</dd><p class="pad"></p>

<dt><a name="void_delprop(INTERP,_PMC*_self,_STRING*_key)"
>void delprop(INTERP, PMC* self, STRING* key)</a></dt><p class="pad"></p>

<dd>Delete the value from the property hash of <b>self</b> keyed by <b>key</b>. The key should not be NULL.</dd><p class="pad"></p>

<dt><a name="PMC*_getprops(INTERP,_PMC*_self)"
>PMC* getprops(INTERP, PMC* self)</a></dt><p class="pad"></p>

<dd>Return the entire property hash for <b>self</b>.</dd><p class="pad"></p>
</dl>

<p>The following functions have a plain form, a _keyed form, and a _keyed_int form. The keyed forms take a PMC* or INTVAL for <i>each</i> PMC parameter. The PMC* parameter for each PMC is NULL if there is no key for that PMC; this means that that argument is unkeyed.</p>

<p>In some cases, the caller <i>must</i> provide a non&#45;NULL key. Those cases are explicitly stated below. In the other cases, you may have to implement the keyed vtable methods and check for a NULL <b>self</b> key even if you are implementing a non&#45;aggregate type. If the <b>self</b> key is non&#45;NULL and the PMC class is a non&#45;aggregate type, the _keyed_* methods should throw an exception.</p>

<p>If you do not implement the _keyed_int methods, the default will convert the INTVAL into a key PMC* and call the corresponding _keyed method.</p>

<p>The keyed methods should <i>NOT</i> assume that the key pointer will be valid after the method exits. The pointer may be to a stack variable in the calling function.</p>

<dl>
<dt><a name="INTVAL_type(INTERP,_PMC*_self)"
>INTVAL type(INTERP, PMC* self)</a></dt><p class="pad"></p>

<dd>Return the type of the PMC. Type is a unique tag associated with the PMC when the PMC&#39;s class is loaded. Negative numbers are considered interpreter&#45;specific, non&#45;public types.</dd><p class="pad"></p>

<dt><a name="INTVAL_type_keyed(INTERP,_PMC*_self,_PMC*_key)"
>INTVAL type_keyed(INTERP, PMC* self, PMC* key)</a></dt><p class="pad"></p>

<dt><a name="INTVAL_type_keyed_int(INTERP,_PMC*_self,_INTVAL_key)"
>INTVAL type_keyed_int(INTERP, PMC* self, INTVAL key)</a></dt><p class="pad"></p>

<dt><a name="INTVAL_type_keyed_str(INTERP,_PMC*_self,_STRING*_key)"
>INTVAL type_keyed_str(INTERP, PMC* self, STRING* key)</a></dt><p class="pad"></p>

<dd>Return the type of the PMC indexed by <b>key</b>. The <b>key</b> parameter is guaranteed not to be NULL for this method.</dd><p class="pad"></p>

<dt><a name="UINTVAL_subtype(INTERP,_PMC*_self,_INTVAL_type)"
>UINTVAL subtype(INTERP, PMC* self, INTVAL type)</a></dt><p class="pad"></p>

<dd>Return the subtype of a PMC. (Note that this may be unimplemented, and may go away). This is intended to return information about the PMC&#45;&#45;what type of number or string it is, whether it&#39;s a scalar, hash, array, or list, and suchlike things.</dd><p class="pad"></p>

<dt><a name="STRING*_name(INTERP,_PMC*_self)"
>STRING* name(INTERP, PMC* self)</a></dt><p class="pad"></p>

<dd>Return the name of the class for the PMC.</dd><p class="pad"></p>

<dt><a name="PMC*_clone(INTERP,_PMC*_self)"
>PMC* clone(INTERP, PMC* self)</a></dt><p class="pad"></p>

<dd>Return a clone of yourself.</dd><p class="pad"></p>

<dt><a name="PMC*_find_method(INTERP,_PMC*_self,_STRING*_method_name)"
>PMC* find_method(INTERP, PMC* self, STRING* method_name)</a></dt><p class="pad"></p>

<dd>Return a subroutine PMC for the passed method name. This subroutine PMC may be cached, so the method <i>must</i> return an equivalent sub PMC each time, or be capable of dealing with the returned sub PMCs being reused.</dd><p class="pad"></p>

<dt><a name="INTVAL_get_integer(INTERP,_PMC*_self)"
>INTVAL get_integer(INTERP, PMC* self)</a></dt><p class="pad"></p>

<dd>Return the native integer value of the PMC.</dd><p class="pad"></p>

<dt><a name="INTVAL_get_integer_keyed(INTERP,_PMC*_self,_PMC*_key)"
>INTVAL get_integer_keyed(INTERP, PMC* self, PMC* key)</a></dt><p class="pad"></p>

<dt><a name="INTVAL_get_integer_keyed_int(INTERP,_PMC*_self,_INTVAL_key)"
>INTVAL get_integer_keyed_int(INTERP, PMC* self, INTVAL key)</a></dt><p class="pad"></p>

<dt><a name="INTVAL_get_integer_keyed_str(INTERP,_PMC*_self,_STRING*_key)"
>INTVAL get_integer_keyed_str(INTERP, PMC* self, STRING* key)</a></dt><p class="pad"></p>

<dd>Return the native integer value of the PMC indexed by <b>key</b>. The <b>key</b> parameter is guaranteed not to be NULL for this method.</dd><p class="pad"></p>

<dt><a name="FLOATVAL_get_number(INTERP,_PMC*_self)"
>FLOATVAL get_number(INTERP, PMC* self)</a></dt><p class="pad"></p>

<dd>Return the native floating&#45;point value of the PMC.</dd><p class="pad"></p>

<dt><a name="FLOATVAL_get_number_keyed(INTERP,_PMC*_self,_PMC*_key)"
>FLOATVAL get_number_keyed(INTERP, PMC* self, PMC* key)</a></dt><p class="pad"></p>

<dt><a name="FLOATVAL_get_number_keyed_int(INTERP,_PMC*_self,_INTVAL_key)"
>FLOATVAL get_number_keyed_int(INTERP, PMC* self, INTVAL key)</a></dt><p class="pad"></p>

<dt><a name="FLOATVAL_get_number_keyed_str(INTERP,_PMC*_self,_STRING*_key)"
>FLOATVAL get_number_keyed_str(INTERP, PMC* self, STRING* key)</a></dt><p class="pad"></p>

<dd>Return the native floating&#45;point value of the PMC indexed by <b>key</b>. The <b>key</b> parameter is guaranteed not to be NULL for this method.</dd><p class="pad"></p>

<dt><a name="PMC*_get_bignum(INTERP,_PMC*_self)"
>PMC* get_bignum(INTERP, PMC* self)</a></dt><p class="pad"></p>

<dd>Return the value of the PMC as a new bignum PMC.</dd><p class="pad"></p>

<dt><a name="STRING*_get_string(INTERP,_PMC*_self)"
>STRING* get_string(INTERP, PMC* self)</a></dt><p class="pad"></p>

<dd>Return the native string value of the PMC. This may be in the encoding of the PMC&#39;s choice.</dd><p class="pad"></p>

<dt><a name="STRING*_get_string_keyed(INTERP,_PMC*_self,_PMC*_key)"
>STRING* get_string_keyed(INTERP, PMC* self, PMC* key)</a></dt><p class="pad"></p>

<dt><a name="STRING*_get_string_keyed_int(INTERP,_PMC*_self,_INTVAL_key)"
>STRING* get_string_keyed_int(INTERP, PMC* self, INTVAL key)</a></dt><p class="pad"></p>

<dt><a name="STRING*_get_string_keyed_str(INTERP,_PMC*_self,_STRING*_key)"
>STRING* get_string_keyed_str(INTERP, PMC* self, STRING* key)</a></dt><p class="pad"></p>

<dd>Return the string value of the PMC indexed by <b>key</b>. The <b>key</b> parameter is guaranteed not to be NULL for this method.</dd><p class="pad"></p>

<dt><a name="INTVAL_get_bool(INTERP,_PMC*_self)"
>INTVAL get_bool(INTERP, PMC* self)</a></dt><p class="pad"></p>

<dd>Return the constant TRUE if the PMC is true, or FALSE if the PMC is false. The definition of truth for a given PMC will depend on the type of the PMC: for a scalar, it may be as simple as 0 or &#34;&#34; being false, and any other value being true.</dd><p class="pad"></p>

<dt><a name="PMC*_get_pmc(INTERP,_PMC*_self)"
>PMC* get_pmc(INTERP, PMC* self)</a></dt><p class="pad"></p>

<dd>Return the PMC for this PMC. While this may seem nonsensical, it&#39;s useful in several circumstances. If the thing being accessed may return something odd, for example a reference, it may return a value different from the PMC that get_pmc is being called on.</dd><p class="pad"></p>

<dt><a name="PMC*_get_pmc_keyed(INTERP,_PMC*_self,_PMC*_key)"
>PMC* get_pmc_keyed(INTERP, PMC* self, PMC* key)</a></dt><p class="pad"></p>

<dt><a name="PMC*_get_pmc_keyed_int(INTERP,_PMC*_self,_INTVAL_key)"
>PMC* get_pmc_keyed_int(INTERP, PMC* self, INTVAL key)</a></dt><p class="pad"></p>

<dt><a name="PMC*_get_pmc_keyed_str(INTERP,_PMC*_self,_STRING*_key)"
>PMC* get_pmc_keyed_str(INTERP, PMC* self, STRING* key)</a></dt><p class="pad"></p>

<dd>Return the PMC indexed by <b>key</b>. The <b>key</b> parameter is guaranteed not to be NULL for this method.</dd><p class="pad"></p>

<dt><a name="void*_get_pointer(INTERP,_PMC*_self)"
>void* get_pointer(INTERP, PMC* self)</a></dt><p class="pad"></p>

<dt><a name="void*_get_pointer_keyed(INTERP,_PMC*_self,_PMC*_key)"
>void* get_pointer_keyed(INTERP, PMC* self, PMC* key)</a></dt><p class="pad"></p>

<dt><a name="void*_get_pointer_keyed_int(INTERP,_PMC*_self,_INTVAL_key)"
>void* get_pointer_keyed_int(INTERP, PMC* self, INTVAL key)</a></dt><p class="pad"></p>

<dt><a name="void*_get_pointer_keyed_str(INTERP,_PMC*_self,_STRING*_key)"
>void* get_pointer_keyed_str(INTERP, PMC* self, STRING* key)</a></dt><p class="pad"></p>

<dd>Return a pointer to some data. The details of the data (type, location etc.) depend on the PMC.</dd><p class="pad"></p>

<dt><a name="void_set_integer_native(INTERP,_PMC*_self,_INTVAL_value)"
>void set_integer_native(INTERP, PMC* self, INTVAL value)</a></dt><p class="pad"></p>

<dd>Sets the PMC to the integer value passed.</dd><p class="pad"></p>

<dt><a name="void_set_integer_same(INTERP,_PMC*_self,_PMC*_value)"
>void set_integer_same(INTERP, PMC* self, PMC* value)</a></dt><p class="pad"></p>

<dd>Sets the PMC to the integer value of the PMC in <b>value</b>. In this case, <b>value</b> is guaranteed to be of the same type as <b>self</b> so optimizations may be made.</dd><p class="pad"></p>

<dt><a name="void_set_integer_keyed(INTERP,_PMC*_self,_PMC*_key,_INTVAL_value)"
>void set_integer_keyed(INTERP, PMC* self, PMC* key, INTVAL value)</a></dt><p class="pad"></p>

<dt><a name="void_set_integer_keyed_int(INTERP,_PMC*_self,_INTVAL_key,_INTVAL_value)"
>void set_integer_keyed_int(INTERP, PMC* self, INTVAL key, INTVAL value)</a></dt><p class="pad"></p>

<dt><a name="void_set_integer_keyed_str(INTERP,_PMC*_self,_STRING*_key,_INTVAL_value)"
>void set_integer_keyed_str(INTERP, PMC* self, STRING* key, INTVAL value)</a></dt><p class="pad"></p>

<dd>Sets the PMC indexed by <b>key</b> to the integer value passed in <b>value</b>. The <b>key</b> parameter is guaranteed not to be NULL for this method.</dd><p class="pad"></p>

<dt><a name="void_set_number_native(INTERP,_PMC*_self,_FLOATVAL_value)"
>void set_number_native(INTERP, PMC* self, FLOATVAL value)</a></dt><p class="pad"></p>

<dd>Sets the PMC to the floating&#45;point value passed.</dd><p class="pad"></p>

<dt><a name="void_set_number_same(INTERP,_PMC*_self,_PMC*_value)"
>void set_number_same(INTERP, PMC* self, PMC* value)</a></dt><p class="pad"></p>

<dd>Sets the PMC to the floating&#45;point value of the PMC in <b>value</b>. In this case, <b>value</b> is guaranteed to be of the same type as <b>self</b> so optimizations may be made.</dd><p class="pad"></p>

<dt><a name="void_set_number_keyed(INTERP,_PMC*_self,_PMC*_key,_FLOATVAL_value)"
>void set_number_keyed(INTERP, PMC* self, PMC* key, FLOATVAL value)</a></dt><p class="pad"></p>

<dt><a name="void_set_number_keyed_int(INTERP,_PMC*_self,_INTVAL_key,_FLOATVAL_value)"
>void set_number_keyed_int(INTERP, PMC* self, INTVAL key, FLOATVAL value)</a></dt><p class="pad"></p>

<dt><a name="void_set_number_keyed_str(INTERP,_PMC*_self,_STRING*_key,_FLOATVAL_value)"
>void set_number_keyed_str(INTERP, PMC* self, STRING* key, FLOATVAL value)</a></dt><p class="pad"></p>

<dd>Sets the PMC indexed by <b>key</b> to the floating&#45;point value passed in <b>value</b>. The <b>key</b> parameter is guaranteed not to be NULL for this method.</dd><p class="pad"></p>

<dt><a name="void_set_bignum_int(INTERP,_PMC*_self,_INTVAL_value)"
>void set_bignum_int(INTERP, PMC* self, INTVAL value)</a></dt><p class="pad"></p>

<dd>Morph the PMC to a BIGNUM PMC with value being the passed in value.</dd><p class="pad"></p>

<dt><a name="void_set_string_native(INTERP,_PMC*_self,_STRING*_value)"
>void set_string_native(INTERP, PMC* self, STRING* value)</a></dt><p class="pad"></p>

<dd>Sets the PMC to the passed in string value.</dd><p class="pad"></p>

<dt><a name="void_assign_string_native(INTERP,_PMC*_self,_STRING*_value)"
>void assign_string_native(INTERP, PMC* self, STRING* value)</a></dt><p class="pad"></p>

<dd>Sets the PMC to the copied string value.</dd><p class="pad"></p>

<dt><a name="void_set_string_same(INTERP,_PMC*_self,_PMC*_value)"
>void set_string_same(INTERP, PMC* self, PMC* value)</a></dt><p class="pad"></p>

<dd>Sets the PMC to the string value of <b>value</b>. In this case, <b>value</b> is guaranteed to be of the same type as <b>self</b> so optimizations may be made.</dd><p class="pad"></p>

<dt><a name="void_set_string_keyed(INTERP,_PMC*_self,_PMC*_key,_STRING*_value)"
>void set_string_keyed(INTERP, PMC* self, PMC* key, STRING* value)</a></dt><p class="pad"></p>

<dt><a name="void_set_string_keyed_int(INTERP,_PMC*_self,_INTVAL_key,_STRING*_value)"
>void set_string_keyed_int(INTERP, PMC* self, INTVAL key, STRING* value)</a></dt><p class="pad"></p>

<dt><a name="void_set_string_keyed_str(INTERP,_PMC*_self,_STRING*_key,_STRING*_value)"
>void set_string_keyed_str(INTERP, PMC* self, STRING* key, STRING* value)</a></dt><p class="pad"></p>

<dd>Sets the PMC indexed by <b>key</b> to the string value passed in <b>value</b>. The <b>key</b> parameter is guaranteed not to be NULL for this method.</dd><p class="pad"></p>

<dt><a name="void_set_bool(INTERP,_PMC*_self,_INTVAL_value)"
>void set_bool(INTERP, PMC* self, INTVAL value)</a></dt><p class="pad"></p>

<dd>Sets the boolean state of the PMC to TRUE if <b>value</b> is TRUE, or FALSE if <b>value</b> is FALSE.</dd><p class="pad"></p>

<dt><a name="void_set_pmc(INTERP,_PMC*_self,_PMC*_value)"
>void set_pmc(INTERP, PMC* self, PMC* value)</a></dt><p class="pad"></p>

<dd>Make the PMC <b>self</b> refer to the PMC <b>value</b>.</dd><p class="pad"></p>

<dt><a name="void_assign_pmc(INTERP,_PMC*_self,_PMC*_value)"
>void assign_pmc(INTERP, PMC* self, PMC* value)</a></dt><p class="pad"></p>

<dd>Sets the value of the PMC in <b>self</b> to the value of the PMC in <b>value</b> by copying the value.</dd><p class="pad"></p>

<dt><a name="void_set_pmc_keyed(INTERP,_PMC*_self,_PMC*_key,_PMC*_value)"
>void set_pmc_keyed(INTERP, PMC* self, PMC* key, PMC* value)</a></dt><p class="pad"></p>

<dt><a name="void_set_pmc_keyed_int(INTERP,_PMC*_self,_INTVAL_key,_PMC*_value)"
>void set_pmc_keyed_int(INTERP, PMC* self, INTVAL key, PMC* value)</a></dt><p class="pad"></p>

<dt><a name="void_set_pmc_keyed_str(INTERP,_PMC*_self,_STRING*_key,_PMC*_value)"
>void set_pmc_keyed_str(INTERP, PMC* self, STRING* key, PMC* value)</a></dt><p class="pad"></p>

<dd>Sets the value of the PMC keyed by <b>key</b> to the value of the PMC in <b>value</b>.</dd><p class="pad"></p>

<dt><a name="void_set_pointer(INTERP,_PMC*_self,_void*_value)"
>void set_pointer(INTERP, PMC* self, void* value)</a></dt><p class="pad"></p>

<dt><a name="void_set_pointer_keyed(INTERP,_PMC*_self,_PMC*_key,_void*_value)"
>void set_pointer_keyed(INTERP, PMC* self, PMC* key, void* value)</a></dt><p class="pad"></p>

<dt><a name="void_set_pointer_keyed_int(INTERP,_PMC*_self,_INTVAL_key,_void*_value)"
>void set_pointer_keyed_int(INTERP, PMC* self, INTVAL key, void* value)</a></dt><p class="pad"></p>

<dt><a name="void_set_pointer_keyed_str(INTERP,_PMC*_self,_STRING*_key,_void*_value)"
>void set_pointer_keyed_str(INTERP, PMC* self, STRING* key, void* value)</a></dt><p class="pad"></p>

<dd>Sets a pointer inside the PMC. The details depend on the PMC.</dd><p class="pad"></p>

<dt><a name="INTVAL_elements(INTERP,_PMC*_self)"
>INTVAL elements(INTERP, PMC* self)</a></dt><p class="pad"></p>

<dd>Return the number of elements in the PMC.</dd><p class="pad"></p>

<dt><a name="INTVAL_pop_integer(INTERP,_PMC*_self)"
>INTVAL pop_integer(INTERP, PMC* self)</a></dt><p class="pad"></p>

<dd>Return the integer value of the last item on the list, removing that item.</dd><p class="pad"></p>

<dt><a name="FLOATVAL_pop_float(INTERP,_PMC*_self)"
>FLOATVAL pop_float(INTERP, PMC* self)</a></dt><p class="pad"></p>

<dd>Return the floating&#45;point value of the last item on the list, removing that item.</dd><p class="pad"></p>

<dt><a name="STRING*_pop_string(INTERP,_PMC*_self)"
>STRING* pop_string(INTERP, PMC* self)</a></dt><p class="pad"></p>

<dd>Return the string value of the last item on the list, removing that item.</dd><p class="pad"></p>

<dt><a name="PMC*_pop_pmc(INTERP,_PMC*_self)"
>PMC* pop_pmc(INTERP, PMC* self)</a></dt><p class="pad"></p>

<dd>Return the PMC value of the last item on the list, removing that item.</dd><p class="pad"></p>

<dt><a name="void_push_integer(INTERP,_PMC*_self,_INTVAL_value)"
>void push_integer(INTERP, PMC* self, INTVAL value)</a></dt><p class="pad"></p>

<dd>Add the passed in integer value to the end of the list.</dd><p class="pad"></p>

<dt><a name="void_push_float(INTERP,_PMC*_self,_FLOATVAL_value)"
>void push_float(INTERP, PMC* self, FLOATVAL value)</a></dt><p class="pad"></p>

<dd>Add the passed in floating&#45;point number to the end of the list.</dd><p class="pad"></p>

<dt><a name="void_push_string(INTERP,_PMC*_self,_STRING*_value)"
>void push_string(INTERP, PMC* self, STRING* value)</a></dt><p class="pad"></p>

<dd>Add the passed in string to the end of the list.</dd><p class="pad"></p>

<dt><a name="void_push_pmc(INTERP,_PMC*_self,_PMC*_value)"
>void push_pmc(INTERP, PMC* self, PMC* value)</a></dt><p class="pad"></p>

<dd>Add the passed in PMC to the end of the list.</dd><p class="pad"></p>

<dt><a name="INTVAL_shift_integer(INTERP,_PMC*_self)"
>INTVAL shift_integer(INTERP, PMC* self)</a></dt><p class="pad"></p>

<dd>Return the integer value of the first item on the list, removing that item.</dd><p class="pad"></p>

<dt><a name="FLOATVAL_shift_float(INTERP,_PMC*_self)"
>FLOATVAL shift_float(INTERP, PMC* self)</a></dt><p class="pad"></p>

<dd>Return the floating&#45;point value of the first item on the list, removing that item.</dd><p class="pad"></p>

<dt><a name="STRING*_shift_string(INTERP,_PMC*_self)"
>STRING* shift_string(INTERP, PMC* self)</a></dt><p class="pad"></p>

<dd>Return the string value of the first item on the list, removing that item.</dd><p class="pad"></p>

<dt><a name="PMC*_shift_pmc(INTERP,_PMC*_self)"
>PMC* shift_pmc(INTERP, PMC* self)</a></dt><p class="pad"></p>

<dd>Return the PMC value of the first item on the list, removing that item.</dd><p class="pad"></p>

<dt><a name="void_unshift_integer(INTERP,_PMC*_self,_INTVAL_value)"
>void unshift_integer(INTERP, PMC* self, INTVAL value)</a></dt><p class="pad"></p>

<dd>Add the passed in integer value to the beginning of the list.</dd><p class="pad"></p>

<dt><a name="void_unshift_float(INTERP,_PMC*_self,_FLOATVAL_value)"
>void unshift_float(INTERP, PMC* self, FLOATVAL value)</a></dt><p class="pad"></p>

<dd>Add the passed in floating&#45;point number to the beginning of the list.</dd><p class="pad"></p>

<dt><a name="void_unshift_string(INTERP,_PMC*_self,_STRING*_value)"
>void unshift_string(INTERP, PMC* self, STRING* value)</a></dt><p class="pad"></p>

<dd>Add the passed in string to the beginning of the list.</dd><p class="pad"></p>

<dt><a name="void_splice(INTERP,_PMC*_self,_PMC*_value,_INTVAL_offset,_INTVAL_count)"
>void splice(INTERP, PMC* self, PMC* value, INTVAL offset, INTVAL count)</a></dt><p class="pad"></p>

<dd>Replace the <b>count</b> PMCs at offset <b>offset</b> from the beginning of <b>self</b> with the PMCs in the aggregate <b>value</b>.</dd><p class="pad"></p>

<dt><a name="void_add(INTERP,_PMC*_self,_PMC*_value,_PMC*_dest)"
>void add(INTERP, PMC* self, PMC* value, PMC* dest)</a></dt><p class="pad"></p>

<dt><a name="void_add_int(INTERP,_PMC*_self,_INTVAL_value,_PMC*_dest)"
>void add_int(INTERP, PMC* self, INTVAL value, PMC* dest)</a></dt><p class="pad"></p>

<dt><a name="void_add_float(INTERP,_PMC*_self,_FLOATVAL_value,_PMC*_dest)"
>void add_float(INTERP, PMC* self, FLOATVAL value, PMC* dest)</a></dt><p class="pad"></p>

<dd>Add <b>self</b> to <b>value</b> and store the result in <b>dest</b>. Note that <b>dest</b> may be equal to <b>self</b>; in that case optimizations <i>may</i> be made.</dd><p class="pad"></p>

<dt><a name="PMC*_subtract(INTERP,_PMC*_self,_PMC*_value,_PMC*_dest)"
>PMC* subtract(INTERP, PMC* self, PMC* value, PMC* dest)</a></dt><p class="pad"></p>

<dt><a name="PMC*_subtract_int(INTERP,_PMC*_self,_INTVAL_value,_PMC*_dest)"
>PMC* subtract_int(INTERP, PMC* self, INTVAL value, PMC* dest)</a></dt><p class="pad"></p>

<dt><a name="PMC*_subtract_float(INTERP,_PMC*_self,_FLOATVAL_value,_PMC*_dest)"
>PMC* subtract_float(INTERP, PMC* self, FLOATVAL value, PMC* dest)</a></dt><p class="pad"></p>

<dd>If <b>dest</b> is NULL create a result PMC of an appropriate type. Subtract <b>value</b> from <b>self</b> and store the result in <b>dest</b>. Note that <b>dest</b> may be equal to <b>self</b>; in that case optimizations <i>may</i> be made.</dd><p class="pad"></p>

<dt><a name="void_i_subtract(INTERP,_PMC*_self,_PMC*_value)"
>void i_subtract(INTERP, PMC* self, PMC* value)</a></dt><p class="pad"></p>

<dt><a name="void_i_subtract_int(INTERP,_PMC*_self,_INTVAL_value)"
>void i_subtract_int(INTERP, PMC* self, INTVAL value)</a></dt><p class="pad"></p>

<dt><a name="void_i_subtract_float(INTERP,_PMC*_self,_FLOATVAL_value)"
>void i_subtract_float(INTERP, PMC* self, FLOATVAL value)</a></dt><p class="pad"></p>

<dd>Inplace operation <b>self &#45;= value</b>.</dd><p class="pad"></p>

<dt><a name="void_multiply(INTERP,_PMC*_self,_PMC*_value,_PMC*_dest)"
>void multiply(INTERP, PMC* self, PMC* value, PMC* dest)</a></dt><p class="pad"></p>

<dt><a name="void_multiply_int(INTERP,_PMC*_self,_INTVAL_value,_PMC*_dest)"
>void multiply_int(INTERP, PMC* self, INTVAL value, PMC* dest)</a></dt><p class="pad"></p>

<dt><a name="void_multiply_float(INTERP,_PMC*_self,_FLOATVAL_value,_PMC*_dest)"
>void multiply_float(INTERP, PMC* self, FLOATVAL value, PMC* dest)</a></dt><p class="pad"></p>

<dd>Multiply <b>value</b> by <b>self</b> and store the result in <b>dest</b>. Note that <b>dest</b> may be equal to <b>self</b>; in that case optimizations <i>may</i> be made.</dd><p class="pad"></p>

<dt><a name="void_divide(INTERP,_PMC*_self,_PMC*_value,_PMC*_dest)"
>void divide(INTERP, PMC* self, PMC* value, PMC* dest)</a></dt><p class="pad"></p>

<dt><a name="void_divide_int(INTERP,_PMC*_self,_INTVAL_value,_PMC*_dest)"
>void divide_int(INTERP, PMC* self, INTVAL value, PMC* dest)</a></dt><p class="pad"></p>

<dt><a name="void_divide_float(INTERP,_PMC*_self,_FLOATVAL_value,_PMC*_dest)"
>void divide_float(INTERP, PMC* self, FLOATVAL value, PMC* dest)</a></dt><p class="pad"></p>

<dd>Divide <b>self</b> by <b>value</b> and store the result in <b>dest</b>. Note that <b>dest</b> may be equal to <b>self</b>; in that case optimizations <i>may</i> be made.</dd><p class="pad"></p>

<dt><a name="void_modulus(INTERP,_PMC*_self,_PMC*_value,_PMC*_dest)"
>void modulus(INTERP, PMC* self, PMC* value, PMC* dest)</a></dt><p class="pad"></p>

<dt><a name="void_modulus_int(INTERP,_PMC*_self,_INTVAL_value,_PMC*_dest)"
>void modulus_int(INTERP, PMC* self, INTVAL value, PMC* dest)</a></dt><p class="pad"></p>

<dt><a name="void_modulus_float(INTERP,_PMC*_self,_FLOATVAL_value,_PMC*_dest)"
>void modulus_float(INTERP, PMC* self, FLOATVAL value, PMC* dest)</a></dt><p class="pad"></p>

<dd>Divide <b>self</b> by <b>value</b> and store the remainder in <b>dest</b>. Note that <b>dest</b> may be equal to <b>self</b>; in that case optimizations <i>may</i> be made.</dd><p class="pad"></p>

<dt><a name="void_cmodulus(INTERP,_PMC*_self,_PMC*_value,_PMC*_dest)"
>void cmodulus(INTERP, PMC* self, PMC* value, PMC* dest)</a></dt><p class="pad"></p>

<dt><a name="void_cmodulus_int(INTERP,_PMC*_self,_INTVAL_value,_PMC*_dest)"
>void cmodulus_int(INTERP, PMC* self, INTVAL value, PMC* dest)</a></dt><p class="pad"></p>

<dt><a name="void_cmodulus_float(INTERP,_PMC*_self,_FLOATVAL_value,_PMC*_dest)"
>void cmodulus_float(INTERP, PMC* self, FLOATVAL value, PMC* dest)</a></dt><p class="pad"></p>

<dd>Divide <b>self</b> by <b>value</b> and store the remainder in <b>dest</b>. Note that <b>dest</b> may be equal to <b>self</b>; in that case optimizations <i>may</i> be made.</dd><p class="pad"></p>

<dd><b>Note</b>: <code lang='und' xml:lang='und'>modulus</code> uses the Knuth&#39;s &#34;corrected mod&#34; algorithm, as implemented in <em lang='und' xml:lang='und'><a href="../../src/utils.c.html">src/utils.c</a></em>, while <code lang='und' xml:lang='und'>cmodulus</code> uses the C&#45;style fmod function.</dd><p class="pad"></p>

<dt><a name="void_neg(INTERP,_PMC*_self,_PMC*_dest)"
>void neg(INTERP, PMC* self, PMC* dest)</a></dt><p class="pad"></p>

<dd>Negate the sign of <b>self</b> and store the result in <b>dest</b>. Note that <b>self</b> and <b>dest</b> may refer to the same PMC, in which case optimizations <i>may</i> be made.</dd><p class="pad"></p>

<dt><a name="void_bitwise_or(INTERP,_PMC*_self,_PMC*_value,_PMC*_dest)"
>void bitwise_or(INTERP, PMC* self, PMC* value, PMC* dest)</a></dt><p class="pad"></p>

<dt><a name="void_bitwise_or_int(INTERP,_PMC*_self,_INTVAL_value,_PMC*_dest)"
>void bitwise_or_int(INTERP, PMC* self, INTVAL value, PMC* dest)</a></dt><p class="pad"></p>

<dd>Calculate the bitwise&#45;OR of <b>self</b> and <b>value</b> and store the result in <b>dest</b>. Note that <b>dest</b> may be equal to <b>self</b>; in that case optimizations <i>may</i> be made.</dd><p class="pad"></p>

<dt><a name="void_bitwise_and(INTERP,_PMC*_self,_PMC*_value,_PMC*_dest)"
>void bitwise_and(INTERP, PMC* self, PMC* value, PMC* dest)</a></dt><p class="pad"></p>

<dt><a name="void_bitwise_and_int(INTERP,_PMC*_self,_INTVAL_value,_PMC*_dest)"
>void bitwise_and_int(INTERP, PMC* self, INTVAL value, PMC* dest)</a></dt><p class="pad"></p>

<dd>Calculate the bitwise&#45;AND of <b>self</b> and <b>value</b> and store the result in <b>dest</b>. Note that <b>dest</b> may be equal to <b>self</b>; in that case optimizations <i>may</i> be made.</dd><p class="pad"></p>

<dt><a name="void_bitwise_xor(INTERP,_PMC*_self,_PMC*_value,_PMC*_dest)"
>void bitwise_xor(INTERP, PMC* self, PMC* value, PMC* dest)</a></dt><p class="pad"></p>

<dt><a name="void_bitwise_xor_int(INTERP,_PMC*_self,_INTVAL_value,_PMC*_dest)"
>void bitwise_xor_int(INTERP, PMC* self, INTVAL value, PMC* dest)</a></dt><p class="pad"></p>

<dd>Calculate the bitwise&#45;XOR of <b>self</b> and <b>value</b> and store the result in <b>dest</b>. Note that <b>dest</b> may be equal to <b>self</b>; in that case optimizations <i>may</i> be made.</dd><p class="pad"></p>

<dt><a name="void_bitwise_ors(INTERP,_PMC*_self,_PMC*_value,_PMC*_dest)"
>void bitwise_ors(INTERP, PMC* self, PMC* value, PMC* dest)</a></dt><p class="pad"></p>

<dt><a name="void_bitwise_ors_str(INTERP,_PMC*_self,_STRING*_value,_PMC*_dest)"
>void bitwise_ors_str(INTERP, PMC* self, STRING* value, PMC* dest)</a></dt><p class="pad"></p>

<dd>Calculate the bitwise&#45;OR of the strings in <b>self</b> and <b>value</b> and store the result in <b>dest</b>. Note that <b>dest</b> may be equal to <b>self</b>; in that case optimizations <i>may</i> be made.</dd><p class="pad"></p>

<dt><a name="void_bitwise_ands(INTERP,_PMC*_self,_PMC*_value,_PMC*_dest)"
>void bitwise_ands(INTERP, PMC* self, PMC* value, PMC* dest)</a></dt><p class="pad"></p>

<dt><a name="void_bitwise_ands_str(INTERP,_PMC*_self,_STRING*_value,_PMC*_dest)"
>void bitwise_ands_str(INTERP, PMC* self, STRING* value, PMC* dest)</a></dt><p class="pad"></p>

<dd>Calculate the bitwise&#45;AND of the strings in <b>self</b> and <b>value</b> and store the result in <b>dest</b>. Note that <b>dest</b> may be equal to <b>self</b>; in that case optimizations <i>may</i> be made.</dd><p class="pad"></p>

<dt><a name="void_bitwise_xors(INTERP,_PMC*_self,_PMC*_value,_PMC*_dest)"
>void bitwise_xors(INTERP, PMC* self, PMC* value, PMC* dest)</a></dt><p class="pad"></p>

<dt><a name="void_bitwise_xors_str(INTERP,_PMC*_self,_STRING*_value,_PMC*_dest)"
>void bitwise_xors_str(INTERP, PMC* self, STRING* value, PMC* dest)</a></dt><p class="pad"></p>

<dd>Calculate the bitwise&#45;XOR of the strings in <b>self</b> and <b>value</b> and store the result in <b>dest</b>. Note that <b>dest</b> may be equal to <b>self</b>; in that case optimizations <i>may</i> be made.</dd><p class="pad"></p>

<dt><a name="void_bitwise_not(INTERP,_PMC*_self,_PMC*_dest)"
>void bitwise_not(INTERP, PMC* self, PMC* dest)</a></dt><p class="pad"></p>

<dd>Apply a bitwise negation to <b>self</b> and store the result in <b>dest</b>. Note that <b>self</b> and <b>dest</b> may refer to the same PMC; in that case optimizations <i>may</i> be made.</dd><p class="pad"></p>

<dt><a name="void_bitwise_shl(INTERP,_PMC*_self,_PMC*_value,_PMC*_dest)"
>void bitwise_shl(INTERP, PMC* self, PMC* value, PMC* dest)</a></dt><p class="pad"></p>

<dt><a name="void_bitwise_shl_int(INTERP,_PMC*_self,_INTVAL_value,_PMC*_dest)"
>void bitwise_shl_int(INTERP, PMC* self, INTVAL value, PMC* dest)</a></dt><p class="pad"></p>

<dd>Apply a leftward shift of <b>value</b> bits to the number stored in <b>self</b>, and place the resulting value in <b>dest</b>. Note that <b>self</b> and <b>dest</b> may refer to the same PMC; in that case optimizations <i>may</i> be made.</dd><p class="pad"></p>

<dt><a name="void_bitwise_shr(INTERP,_PMC*_self,_PMC*_value,_PMC*_dest)"
>void bitwise_shr(INTERP, PMC* self, PMC* value, PMC* dest)</a></dt><p class="pad"></p>

<dt><a name="void_bitwise_shr_int(INTERP,_PMC*_self,_INTVAL_value,_PMC*_dest)"
>void bitwise_shr_int(INTERP, PMC* self, INTVAL value, PMC* dest)</a></dt><p class="pad"></p>

<dd>Applies a rightward shift of <b>value</b> bits to the number stored in <b>self</b>, and places the resulting value in <b>dest</b>. Note that <b>self</b> and <b>dest</b> may refer to the same PMC; in that case optimizations <i>may</i> be made.</dd><p class="pad"></p>

<dt><a name="void_concatenate(INTERP,_PMC*_self,_PMC*_value,_PMC*_dest)"
>void concatenate(INTERP, PMC* self, PMC* value, PMC* dest)</a></dt><p class="pad"></p>

<dt><a name="void_concatenate_str(INTERP,_PMC*_self,_STRING*_value,_PMC*_dest)"
>void concatenate_str(INTERP, PMC* self, STRING* value, PMC* dest)</a></dt><p class="pad"></p>

<dd>Concatenate the strings in <b>self</b> and <b>value</b> and store the result in <b>dest</b>. Note that <b>self</b> and <b>dest</b> may refer to the same PMC; in that case optimizations <i>may</i> be made.</dd><p class="pad"></p>

<dt><a name="INTVAL_is_equal(INTERP,_PMC*_self,_PMC*_value)"
>INTVAL is_equal(INTERP, PMC* self, PMC* value)</a></dt><p class="pad"></p>

<dd>Return TRUE if the two PMCs are generically equivalent, or FALSE if they aren&#39;t.</dd><p class="pad"></p>

<dt><a name="INTVAL_is_same(INTERP,_PMC*_self,_PMC*_value)"
>INTVAL is_same(INTERP, PMC* self, PMC* value)</a></dt><p class="pad"></p>

<dd>Return TRUE if the PMCs are the same, and FALSE if they&#39;re not. In this case, &#34;the same&#34; means identical at a low level. For plain equality, use the is_equal method.</dd><p class="pad"></p>

<dt><a name="INTVAL_cmp(INTERP,_PMC*_self,_PMC*_value)"
>INTVAL cmp(INTERP, PMC* self, PMC* value)</a></dt><p class="pad"></p>

<dd>Compare the two PMCs as PMCs (whatever that means for the class). Return &#45;1 if <b>self</b> is smaller, 0 if the two are equal, and 1 if <b>value</b> is smaller.</dd><p class="pad"></p>

<dt><a name="INTVAL_cmp_num(INTERP,_PMC*_self,_PMC*_value)"
>INTVAL cmp_num(INTERP, PMC* self, PMC* value)</a></dt><p class="pad"></p>

<dd>Compare the two PMCs numerically. Return &#45;1 if <b>self</b> is smaller, 0 if the two are equal, and 1 if <b>value</b> is smaller.</dd><p class="pad"></p>

<dt><a name="INTVAL_cmp_string(INTERP,_PMC*_self,_PMC*_value)"
>INTVAL cmp_string(INTERP, PMC* self, PMC* value)</a></dt><p class="pad"></p>

<dd>Compare the two PMCs as strings. Return &#45;1 if <b>self</b> is smaller, 0 if the two are equal, and 1 if <b>value</b> is smaller.</dd><p class="pad"></p>

<dt><a name="void_logical_or(INTERP,_PMC*_self,_PMC*_value,_PMC*_dest)"
>void logical_or(INTERP, PMC* self, PMC* value, PMC* dest)</a></dt><p class="pad"></p>

<dd>Do a short&#45;circuiting logical&#45;OR of <b>self</b> and <b>value</b>, storing the winner in <b>dest</b>.</dd><p class="pad"></p>

<dt><a name="void_logical_and(INTERP,_PMC*_self,_PMC*_value,_PMC*_dest)"
>void logical_and(INTERP, PMC* self, PMC* value, PMC* dest)</a></dt><p class="pad"></p>

<dd>Do a short&#45;circuiting logical&#45;AND of <b>self</b> and <b>value</b>, storing the winner in dest.</dd><p class="pad"></p>

<dt><a name="void_logical_xor(INTERP,_PMC*_self,_PMC*_value,_PMC*_dest)"
>void logical_xor(INTERP, PMC* self, PMC* value, PMC* dest)</a></dt><p class="pad"></p>

<dd>If exactly one of <b>self</b> or <b>value</b> is true, store it in <b>dest</b>. Else set <b>dest</b> to be false.</dd><p class="pad"></p>

<dt><a name="void_logical_not(INTERP,_PMC*_self,_PMC*_dest)"
>void logical_not(INTERP, PMC* self, PMC* dest)</a></dt><p class="pad"></p>

<dd>Do a logical&#45;NOT on <b>self</b> and stores the result in <b>dest</b>.</dd><p class="pad"></p>

<dt><a name="void_repeat(INTERP,_PMC*_self,_PMC*_value,_PMC*_dest)"
>void repeat(INTERP, PMC* self, PMC* value, PMC* dest)</a></dt><p class="pad"></p>

<dt><a name="void_repeat_int(INTERP,_PMC*_self,_INTVAL_value,_PMC*_dest)"
>void repeat_int(INTERP, PMC* self, INTVAL value, PMC* dest)</a></dt><p class="pad"></p>

<dd>Repeat the string value of <b>self</b> <b>value</b> times and store the resultant string in <b>dest</b>.</dd><p class="pad"></p>

<dt><a name="void_increment(INTERP,_PMC*_self)"
>void increment(INTERP, PMC* self)</a></dt><p class="pad"></p>

<dd>Auto&#45;increment the PMC.</dd><p class="pad"></p>

<dt><a name="void_decrement(INTERP,_PMC*_self)"
>void decrement(INTERP, PMC* self)</a></dt><p class="pad"></p>

<dd>Auto&#45;decrement the PMC.</dd><p class="pad"></p>

<dt><a name="void_abs(INTERP,_PMC*_self,_PMC*_dest)"
>void abs(INTERP, PMC* self, PMC* dest)</a></dt><p class="pad"></p>

<dd>Set <code lang='und' xml:lang='und'>dest</code> to the absolute value of <code lang='und' xml:lang='und'>SELF</code>. Note: <code lang='und' xml:lang='und'>dest</code> may be <code lang='und' xml:lang='und'>SELF</code>.</dd><p class="pad"></p>

<dt><a name="INTVAL_exists_keyed(INTERP,_PMC*_self,_PMC*_key)"
>INTVAL exists_keyed(INTERP, PMC* self, PMC* key)</a></dt><p class="pad"></p>

<dt><a name="INTVAL_exists_keyed_int(INTERP,_PMC*_self,_INTVAL_key)"
>INTVAL exists_keyed_int(INTERP, PMC* self, INTVAL key)</a></dt><p class="pad"></p>

<dt><a name="INTVAL_exists_keyed_str(INTERP,_PMC*_self,_STRING*_key)"
>INTVAL exists_keyed_str(INTERP, PMC* self, STRING* key)</a></dt><p class="pad"></p>

<dd>Only valid for keyed access.</dd><p class="pad"></p>

<dd>Returns TRUE if the key exists in the aggregate being queried; otherwise, return FALSE.</dd><p class="pad"></p>

<dd>The key is guaranteed to be non&#45;NULL.</dd><p class="pad"></p>

<dt><a name="INTVAL_defined(INTERP,_PMC*_self)"
>INTVAL defined(INTERP, PMC* self)</a></dt><p class="pad"></p>

<dd>Check to see if the PMC is defined. Return TRUE if it is; otherwise, return FALSE.</dd><p class="pad"></p>

<dt><a name="INTVAL_defined_keyed(INTERP,_PMC*_self,_PMC*_key)"
>INTVAL defined_keyed(INTERP, PMC* self, PMC* key)</a></dt><p class="pad"></p>

<dt><a name="INTVAL_defined_keyed_int(INTERP,_PMC*_self,_INTVAL_key)"
>INTVAL defined_keyed_int(INTERP, PMC* self, INTVAL key)</a></dt><p class="pad"></p>

<dt><a name="INTVAL_defined_keyed_str(INTERP,_PMC*_self,_STRING*_key)"
>INTVAL defined_keyed_str(INTERP, PMC* self, STRING* key)</a></dt><p class="pad"></p>

<dd>Return TRUE if the value of <b>self</b> keyed by <b>key</b> is defined; otherwise, return FALSE.</dd><p class="pad"></p>

<dd>The key is guaranteed to be non&#45;NULL.</dd><p class="pad"></p>

<dt><a name="void_delete_keyed(INTERP,_PMC*_self,_PMC*_key)"
>void delete_keyed(INTERP, PMC* self, PMC* key)</a></dt><p class="pad"></p>

<dt><a name="void_delete_keyed_int(INTERP,_PMC*_self,_INTVAL_key)"
>void delete_keyed_int(INTERP, PMC* self, INTVAL key)</a></dt><p class="pad"></p>

<dt><a name="void_delete_keyed_str(INTERP,_PMC*_self,_STRING*_key)"
>void delete_keyed_str(INTERP, PMC* self, STRING* key)</a></dt><p class="pad"></p>

<dd>Delete the specified entry from the aggregate.</dd><p class="pad"></p>

<dd>The key is guaranteed to be non&#45;NULL.</dd><p class="pad"></p>

<dt><a name="PMC*_nextkey_keyed(INTERP,_PMC*_self,_PMC*_key)"
>PMC* nextkey_keyed(INTERP, PMC* self, PMC* key)</a></dt><p class="pad"></p>

<dt><a name="PMC*_nextkey_keyed_int(INTERP,_PMC*_self,_INTVAL_key)"
>PMC* nextkey_keyed_int(INTERP, PMC* self, INTVAL key)</a></dt><p class="pad"></p>

<dt><a name="PMC*_nextkey_keyed_str(INTERP,_PMC*_self,_STRING*_key,_INTVAL_what)"
>PMC* nextkey_keyed_str(INTERP, PMC* self, STRING* key, INTVAL what)</a></dt><p class="pad"></p>

<dd>Given the passed in key for the PMC, return the next key.</dd><p class="pad"></p>

<dd>The key is guaranteed to be non&#45;NULL.</dd><p class="pad"></p>

<dt><a name="PMC*_get_iter(INTERP,_PMC*_self)"
>PMC* get_iter(INTERP, PMC* self)</a></dt><p class="pad"></p>

<dd>Return a new iterator for this aggregate. The iterator should be initialized so that iterations starts at the first element of the aggregate. If the aggregate is empty, set PMC_int_val() of the iterator key to &#45;1.</dd><p class="pad"></p>

<dt><a name="PMC*_slice(INTERP,_PMC*_self,_PMC*_key)"
>PMC* slice(INTERP, PMC* self, PMC* key)</a></dt><p class="pad"></p>

<dd>Return a new iterator for this aggregate and the given Slice key.</dd><p class="pad"></p>

<dt><a name="void_substr(INTERP,_PMC*_self,_INTVAL_offset,_INTVAL_length,_PMC*_dest)"
>void substr(INTERP, PMC* self, INTVAL offset, INTVAL length, PMC* dest)</a></dt><p class="pad"></p>

<dd>Place the value of the substring of <b>self</b> at offset <b>offset</b> and with length <b>length</b> into <b>dest</b>.</dd><p class="pad"></p>

<dt><a name="STRING*_substr_str(INTERP,_PMC*_self,_INTVAL_offset,_INTVAL_length)"
>STRING* substr_str(INTERP, PMC* self, INTVAL offset, INTVAL length)</a></dt><p class="pad"></p>

<dd>Return the substring of <b>self</b> at offset <b>offset</b> and with length <b>length</b>.</dd><p class="pad"></p>

<dt><a name="void*_invoke(INTERP,_PMC*_self,_void*_next)"
>void* invoke(INTERP, PMC* self, void* next)</a></dt><p class="pad"></p>

<dd>Invoke the subroutine/method in the given PMC.</dd><p class="pad"></p>

<dd>It should set up the environment for the sub, and should return the location at which operation flow should continue after the subroutine returns. (Note that this will generally be the address of the next instruction).</dd><p class="pad"></p>

<dd>It is <b>NOT</b> responsible for preserving any of the current context; the caller should have preserved anything that they want preserved before calling this method.</dd><p class="pad"></p>

<dd>See <em lang='und' xml:lang='und'>pdd03_calling_conventions.pod</em> for more details.</dd><p class="pad"></p>

<dd><b>next*</b> is passed in from the run loop and is the program counter of the next instruction.</dd><p class="pad"></p>

<dt><a name="INTVAL_can(INTERP,_PMC*_self,_STRING*_method)"
>INTVAL can(INTERP, PMC* self, STRING* method)</a></dt><p class="pad"></p>

<dd>Determine whether the PMC can perform the method specified by name in <b>method</b>. Returns TRUE if it can; otherwise, returns FALSE.</dd><p class="pad"></p>

<dt><a name="INTVAL_does(INTERP,_PMC*_self,_STRING*_method)"
>INTVAL does(INTERP, PMC* self, STRING* method)</a></dt><p class="pad"></p>

<dd>Determine whether the PMC implements the interface specified by name in <b>method</b>. Returns TRUE if it can; otherwise, returns FALSE.</dd><p class="pad"></p>

<dt><a name="INTVAL_isa(INTERP,_PMC*_self,_STRING*__class)"
>INTVAL isa(INTERP, PMC* self, STRING* _class)</a></dt><p class="pad"></p>

<dd>Is the PMC a member of <b>_class</b> or one of its subclasses.</dd><p class="pad"></p>

<dd>See also <em lang='und' xml:lang='und'>pdd15_objects.pod</em>.</dd><p class="pad"></p>

<dt><a name="PMC*_subclass(STRING*_name)"
>PMC* subclass(STRING* name)</a></dt><p class="pad"></p>

<dd>Creates a subclass, optionally with a given <b>name</b>.</dd><p class="pad"></p>

<dt><a name="void_freeze(INTERP,_PMC*_self,_visit_info*_info)"
>void freeze(INTERP, PMC* self, visit_info* info)</a></dt><p class="pad"></p>

<dt><a name="void_thaw(INTERP,_PMC*_self,_visit_info*_info)"
>void thaw(INTERP, PMC* self, visit_info* info)</a></dt><p class="pad"></p>

<dt><a name="void_thawfinish(INTERP,_PMC*_self,_visit_info*_info)"
>void thawfinish(INTERP, PMC* self, visit_info* info)</a></dt><p class="pad"></p>

<dt><a name="void_visit(INTERP,_PMC*_self,_visit_info*_info)"
>void visit(INTERP, PMC* self, visit_info* info)</a></dt><p class="pad"></p>

<dd>Serialization functions.</dd><p class="pad"></p>

<dd>XXX: these need documenting by somebody who understands them.</dd><p class="pad"></p>

<dt><a name="void_share(INTERP,_PMC*_self)"
>void share(INTERP, PMC* self)</a></dt><p class="pad"></p>

<dd>XXX: needs documenting</dd><p class="pad"></p>
</dl>

<h1><a name="VERSION"
>VERSION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<h2><a name="CURRENT"
>CURRENT <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<pre lang='und' xml:lang='und'>   Maintainer: Dan Sugalski &#60;dan@sidhe.org&#62;
   Class: Internals
   PDD Number: 2
   Version: 1.5
   Status: Developing
   Last Modified: 27 July 2003
   PDD Format: 1
   Language: English</pre>

<h2><a name="HISTORY"
>HISTORY <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="1.5"
>1.5</a></dt><p class="pad"></p>

<dd>18 May 2004</dd><p class="pad"></p>

<dt><a name="1.4"
>1.4</a></dt><p class="pad"></p>

<dd>1 Nov 2003</dd><p class="pad"></p>

<dt><a name="1.3"
>1.3</a></dt><p class="pad"></p>

<dd>27 July 2003</dd><p class="pad"></p>

<dt><a name="1.2"
>1.2</a></dt><p class="pad"></p>

<dd>22 June 2002</dd><p class="pad"></p>

<dt><a name="1.1"
>1.1</a></dt><p class="pad"></p>

<dd>13 May 2002</dd><p class="pad"></p>

<dt><a name="1.0"
>1.0</a></dt><p class="pad"></p>

<dd>None. First version</dd><p class="pad"></p>
</dl>

<h1><a name="CHANGES"
>CHANGES <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<dl>
<dt><a name="1.5"
>1.5</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'> * Remove obsolete _keyed vtables.
 * s/concat_native/concat_str/</pre>

<dt><a name="1.4"
>1.4</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'> * Add set/get_pointer vtables.
 * Change s/KEY/PMC/ and s/INTVAL* key/INTVAL key/</pre>

<dt><a name="1.3"
>1.3</a></dt><p class="pad"></p>

<dd>Added a number of missing method definitions. Many other minor cleanups.</dd><p class="pad"></p>

<dt><a name="1.2"
>1.2</a></dt><p class="pad"></p>

<dd>Many cleanups and clarifications. Much detail added. Many missing methods added.</dd><p class="pad"></p>

<dt><a name="1.1"
>1.1</a></dt><p class="pad"></p>

<dd>Cleaned up the definition. It was a mess.</dd><p class="pad"></p>

<dt><a name="1.0"
>1.0</a></dt><p class="pad"></p>

<dd>None. First version</dd><p class="pad"></p>
</dl>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
