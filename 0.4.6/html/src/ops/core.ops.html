<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Parrot Core Ops</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Parrot Core Ops</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../html/index.html">Contents</a> | <a href="../../../html/ops.html">Ops</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>core.ops &#45; Parrot Core Ops</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Parrot&#39;s core library of ops.</p>

<p>Core operations are primarily flow control and interpreter introspection.</p>

<h2><a name="Basic_ops"
>Basic ops <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>These are the fundamental operations.
Please note: These opcodes must not be moved; they must have exactly these opcode numbers.
Opcodes ending with underscores are for internal use only; don&#39;t emit these opcodes.</p>

<dl>
<dt><a name="end()"
><b>end</b>()</a></dt><p class="pad"></p>

<dd>Halts the interpreter.
(Must be op #0,
CORE_OPS_end).
See also <b>exit</b>.</dd><p class="pad"></p>

<dt><a name="noop()"
><b>noop</b>()</a></dt><p class="pad"></p>

<dd>Does nothing other than waste an iota of time and 32 bits of bytecode space.
(Must be op #1,
CORE_OPS_noop)</dd><p class="pad"></p>

<dt><a name="cpu_ret()"
><b>cpu_ret</b>()</a></dt><p class="pad"></p>

<dd>Emit a cpu return instruction.
This is used to return from CGP core to JIT code.
Note: Do <b>not</b> use this opcode.
It is for internal use only.
(Must be op #2,
CORE_OPS_cpu_ret)</dd><p class="pad"></p>

<dt><a name="check_events()"
><b>check_events</b>()</a></dt><p class="pad"></p>

<dd>Check the event queue and run event handlers if there are unhandled events.
Note: This opcode is mainly for testing.
It should not be necessary to ever use it explicitly.
(Must be op #3,
CORE_OPS_check_events).</dd><p class="pad"></p>

<dt><a name="check_events__()"
><b>check_events__</b>()</a></dt><p class="pad"></p>

<dd>Check the event queue and run event handlers if there are unhandled events.
Note: Do <b>not</b> use this opcode.
It is for internal use only.
(Must be op #4,
CORE_OPS_check_events__).</dd><p class="pad"></p>

<dt><a name="wrapper__()"
><b>wrapper__</b>()</a></dt><p class="pad"></p>

<dd>Internal opcode to wrap unknown ops from loaded opcode libs.
Don&#39;t use.
(Must be op #5,
CORE_OPS_wrapper__).</dd><p class="pad"></p>

<dt><a name="prederef__()"
><b>prederef__</b>()</a></dt><p class="pad"></p>

<dd>Internal opcode to prederef opcodes on the fly.
Don&#39;t use.
(Must be op #6,
CORE_OPS_prederef__ ).</dd><p class="pad"></p>

<dt><a name="reserved(inconst_INT)"
><b>reserved</b>(inconst INT)</a></dt><p class="pad"></p>

<dd>Reserve 1 more fix entry.</dd><p class="pad"></p>

<dt><a name="load_bytecode(in_STR)"
><b>load_bytecode</b>(in STR)</a></dt><p class="pad"></p>

<dd>Load Parrot bytecode from file $1,
and (TODO) search the library path,
to locate the file.</dd><p class="pad"></p>
</dl>

<h2><a name="Control_flow"
>Control flow <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>The control flow opcodes check conditions and manage program flow.</p>

<dl>
<dt><a name="branch(label_INT)"
><b>branch</b>(label INT)</a></dt><p class="pad"></p>

<dd>Branch forward or backward by the amount in $1.</dd><p class="pad"></p>

<dt><a name="branch_cs(in_STR)"
><b>branch_cs</b>(in STR)</a></dt><p class="pad"></p>

<dd>Intersegment branch to location in fixup table named $1.</dd><p class="pad"></p>

<dt><a name="bsr(label_INT)"
><b>bsr</b>(label INT)</a></dt><p class="pad"></p>

<dd>Branch to the location specified by $1.
Push the current location onto the call stack for later returning.</dd><p class="pad"></p>

<dt><a name="ret()"
><b>ret</b>()</a></dt><p class="pad"></p>

<dd>Pop the location off the top of the call stack and go there.</dd><p class="pad"></p>

<dt><a name="jsr(label_INT)"
><b>jsr</b>(label INT)</a></dt><p class="pad"></p>

<dd>Jump to the location specified by register $1.
Push the current location onto the call stack for later returning.</dd><p class="pad"></p>

<dt><a name="jump(label_INT)"
><b>jump</b>(label INT)</a></dt><p class="pad"></p>

<dd>Jump to the address held in register $1.</dd><p class="pad"></p>

<dt><a name="enternative()"
><b>enternative</b>()</a></dt><p class="pad"></p>

<dd>Internal opcode used to jump from normal bytecode into a JITted version.</dd><p class="pad"></p>
</dl>

<h2><a name="Conditional_branch_operations"
>Conditional branch operations <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>These operations perform a conditional relative branch.
If the condition is met,
the branch happens.
Otherwise control falls to the next operation.</p>

<dl>
<dt><a name="if(invar_INT,_labelconst_INT)"
><b>if</b>(invar INT,
labelconst INT)</a></dt><p class="pad"></p>

<dt><a name="if(invar_NUM,_labelconst_INT)"
><b>if</b>(invar NUM,
labelconst INT)</a></dt><p class="pad"></p>

<dt><a name="if(invar_PMC,_labelconst_INT)"
><b>if</b>(invar PMC,
labelconst INT)</a></dt><p class="pad"></p>

<dt><a name="if(invar_STR,_labelconst_INT)"
><b>if</b>(invar STR,
labelconst INT)</a></dt><p class="pad"></p>

<dd>Check register $1.
If true,
branch by $2.</dd><p class="pad"></p>

<dt><a name="unless(invar_INT,_labelconst_INT)"
><b>unless</b>(invar INT,
labelconst INT)</a></dt><p class="pad"></p>

<dt><a name="unless(invar_NUM,_labelconst_INT)"
><b>unless</b>(invar NUM,
labelconst INT)</a></dt><p class="pad"></p>

<dt><a name="unless(invar_PMC,_labelconst_INT)"
><b>unless</b>(invar PMC,
labelconst INT)</a></dt><p class="pad"></p>

<dt><a name="unless(invar_STR,_labelconst_INT)"
><b>unless</b>(invar STR,
labelconst INT)</a></dt><p class="pad"></p>

<dd>Check register $1.
If false,
branch by $2.</dd><p class="pad"></p>
</dl>

<h2><a name="Subroutine_operations"
>Subroutine operations <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>These operations are used to generate and call subroutines and continuations.</p>

<dl>
<dt><a name="invokecc(invar_PMC)"
><b>invokecc</b>(invar PMC)</a></dt><p class="pad"></p>

<dd>Call the subroutine in $1 and generate a new return continuation,
if needed.
For example,
a NCI subroutine which executes code in some C library will not create a continuation,
nor will anything but the first call to a coroutine.</dd><p class="pad"></p>

<dt><a name="invoke(invar_PMC,_invar_PMC)"
><b>invoke</b>(invar PMC,
invar PMC)</a></dt><p class="pad"></p>

<dd>Call the subroutine in $1 and use continuation $2.</dd><p class="pad"></p>

<dt><a name="yield()"
><b>yield</b>()</a></dt><p class="pad"></p>

<dd>Yield results from a coroutine.</dd><p class="pad"></p>

<dt><a name="tailcall(invar_PMC)"
><b>tailcall</b>(invar PMC)</a></dt><p class="pad"></p>

<dd>Call the subroutine in $1 and use the current continuation as the subs continuation.</dd><p class="pad"></p>

<dt><a name="returncc()"
><b>returncc</b>()</a></dt><p class="pad"></p>

<dd>Return from the sub or method via the current continuation.</dd><p class="pad"></p>

<dt><a name="newclosure(out_PMC,_invar_PMC)"
><b>newclosure</b>(out PMC,
invar PMC)</a></dt><p class="pad"></p>

<dd>Create a closure of the given subroutine PMC by cloning the sub&#39;s state.</dd><p class="pad"></p>
</dl>

<h2><a name="Function_argument_opcode"
>Function argument opcode <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Implementations of function argument and params handling</p>

<dl>
<dt><a name="set_args(inconst_PMC_/*_,_..._*/)"
><b>set_args</b>(inconst PMC /* ,
...
*/)</a></dt><p class="pad"></p>

<dd>Define arguments for the next function call.</dd><p class="pad"></p>

<dt><a name="get_results(inconst_PMC_/*_,_..._*/)"
><b>get_results</b>(inconst PMC /* ,
...
*/)</a></dt><p class="pad"></p>

<dd>Define return values for the next function call.</dd><p class="pad"></p>

<dt><a name="get_params(inconst_PMC_/*_,_..._*/)"
><b>get_params</b>(inconst PMC /* ,
...
*/)</a></dt><p class="pad"></p>

<dd>Define function parameters for this subroutine.</dd><p class="pad"></p>

<dt><a name="set_returns(inconst_PMC_/*_,_..._*/)"
><b>set_returns</b>(inconst PMC /* ,
...
*/)</a></dt><p class="pad"></p>

<dd>Define return results for the subroutine return statement.</dd><p class="pad"></p>

<dd>For all of these opcodes the passed invar PMC constant is the string representation of a FixedIntegerArray with one flag word per argument.
The flags are documented currently in <em lang='und' xml:lang='und'>include/parrot/enum.h</em> only.</dd><p class="pad"></p>

<dd>After this argument a variable amount of arguments must follow according to the elements of the signature array.</dd><p class="pad"></p>

<dt><a name="result_info(out_PMC)"
><b>result_info</b>(out PMC)</a></dt><p class="pad"></p>

<dd>Returns the get_results signature PMC of the caller.
This PMC is a FixedIntegerPMCArray.
The number of elements of this PMC is equal to the number of return values that are expected.
The individual bits per entry are specified in <em lang='und' xml:lang='und'><a href="../../docs/pdds/pdd03_calling_conventions.pod.html">docs/pdds/pdd03_calling_conventions.pod</a></em>.</dd><p class="pad"></p>
</dl>

<h2><a name="Address_manipulation"
>Address manipulation <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>########################################</p>

<dl>
<dt><a name="set_addr(out_INT,_labelconst_INT)"
><b>set_addr</b>(out INT,
labelconst INT)</a></dt><p class="pad"></p>

<dd>Sets register $1 to the current address plus the offset $2.</dd><p class="pad"></p>

<dt><a name="set_addr(invar_PMC,_labelconst_INT)"
><b>set_addr</b>(invar PMC,
labelconst INT)</a></dt><p class="pad"></p>

<dd>Sets PMC in register $1 to the current address plus the offset $2.</dd><p class="pad"></p>

<dt><a name="set_addr(invar_PMC,_labelvar_INT)"
><b>set_addr</b>(invar PMC,
labelvar INT)</a></dt><p class="pad"></p>

<dd>Sets PMC in register $1 to the absolute address $2 obtained from <b>get_addr</b>.</dd><p class="pad"></p>

<dt><a name="get_addr(out_INT,_invar_PMC)"
><b>get_addr</b>(out INT,
invar PMC)</a></dt><p class="pad"></p>

<dd>Sets $1 to the absolute address of the Sub PMC $2.</dd><p class="pad"></p>
</dl>

<h2><a name="Exception_handling"
>Exception handling <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="push_eh(labelconst_INT)"
><b>push_eh</b>(labelconst INT)</a></dt><p class="pad"></p>

<dd>Create an exception handler for the given catch label and push it onto the control stack.</dd><p class="pad"></p>

<dt><a name="clear_eh()"
><b>clear_eh</b>()</a></dt><p class="pad"></p>

<dd>Clear out the most recently placed exception.</dd><p class="pad"></p>

<dt><a name="throw(invar_PMC)"
><b>throw</b>(invar PMC)</a></dt><p class="pad"></p>

<dd>Throw the exception in $1.</dd><p class="pad"></p>

<dt><a name="rethrow(invar_PMC)"
><b>rethrow</b>(invar PMC)</a></dt><p class="pad"></p>

<dd>Only valid inside an exception handler.
Rethrow the exception $1.</dd><p class="pad"></p>

<dt><a name="die(in_INT,_in_INT)"
><b>die</b>(in INT,
in INT)</a></dt><p class="pad"></p>

<dd>Die with severity $1 and error $2.
If severity is .EXCEPT_DOOMED,
call _exit($2).
The latter isn&#39;t catchable.</dd><p class="pad"></p>

<dt><a name="exit(in_INT)"
><b>exit</b>(in INT)</a></dt><p class="pad"></p>

<dd>Exit the interpreter with exit_status $1.
If you want to communicate an extended exit status,
create an exception with severity <b>EXCEPT_exit</b> and throw it.</dd><p class="pad"></p>

<dt><a name="pushmark(in_INT)"
><b>pushmark</b>(in INT)</a></dt><p class="pad"></p>

<dd>Push a mark labeled $1 onto the control stack.</dd><p class="pad"></p>

<dt><a name="popmark(in_INT)"
><b>popmark</b>(in INT)</a></dt><p class="pad"></p>

<dd>Pop all items off the control stack to the given mark.</dd><p class="pad"></p>

<dt><a name="pushaction(invar_PMC)"
><b>pushaction</b>(invar PMC)</a></dt><p class="pad"></p>

<dd>Push the given Sub PMC $1 onto the control stack.
If the control stack is unwound due to a <code lang='und' xml:lang='und'>popmark</code>,
subroutine return,
or an exception,
the subroutine will be invoked with an integer argument: <code lang='und' xml:lang='und'>0</code> means a normal return; <code lang='und' xml:lang='und'>1</code> means an exception has been raised.</dd><p class="pad"></p>
</dl>

<h2><a name="Interpreter_operations"
>Interpreter operations <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>These operations inspect or modify the interpreter itself,
possibly affecting its subsequent operation.</p>

<dl>
<dt><a name="debug(in_INT)"
><b>debug</b>(in INT)</a></dt><p class="pad"></p>

<dd>If $1 is zero,
turn off debugging.
Otherwise turn debug flag $1 on.</dd><p class="pad"></p>

<dt><a name="bounds(in_INT)"
><b>bounds</b>(in INT)</a></dt><p class="pad"></p>

<dd>If $1 is zero,
turn off byte code bounds checking.
Otherwise turn it on.</dd><p class="pad"></p>

<dt><a name="profile(in_INT)"
><b>profile</b>(in INT)</a></dt><p class="pad"></p>

<dd>If $1 is zero,
turn off profiling.
Otherwise turn it on.</dd><p class="pad"></p>

<dt><a name="trace(in_INT)"
><b>trace</b>(in INT)</a></dt><p class="pad"></p>

<dd>If $1 is zero,
turn off tracing.
Otherwise turn trace flag $1 on.</dd><p class="pad"></p>

<dt><a name="gc_debug(in_INT)"
><b>gc_debug</b>(in INT)</a></dt><p class="pad"></p>

<dd>If $1 is zero,
turn off GC_DEBUG.
Otherwise turn it on.</dd><p class="pad"></p>

<dt><a name="interpinfo"
><b>interpinfo</b></a></dt><p class="pad"></p>

<dd>Fetch some piece of information about the interpreter and put it in $1.
Possible values for $2 are defined in <em lang='und' xml:lang='und'>runtime/parrot/include/interpinfo.pasm</em>.
The valid constants for each return value are:</dd><p class="pad"></p>

<dl>
<dt><a name="interpinfo(out_INT,_in_INT)"
><b>interpinfo</b>(out INT,
in INT)</a></dt><p class="pad"></p>

<dd>.TOTAL_MEM_ALLOC,
.DOD_RUNS,
.COLLECT_RUNS,
.ACTIVE_PMCS,
.ACTIVE_BUFFERS,
.TOTAL_PMCS,
.TOTAL_BUFFERS,
.HEADER_ALLOCS_SINCE_COLLECT,
.MEM_ALLOCS_SINCE_COLLECT,
.TOTAL_COPIED,
.IMPATIENT_PMCS,
.LAZY_DOD_RUNS,
.EXTENDED_PMCS</dd><p class="pad"></p>

<dt><a name="interpinfo(out_PMC,_in_INT)"
><b>interpinfo</b>(out PMC,
in INT)</a></dt><p class="pad"></p>

<dd>.CURRENT_SUB,
.CURRENT_CONT,
.CURRENT_OBJECT,
.NAMESPACE_ROOT,
.CURRENT_LEXPAD</dd><p class="pad"></p>

<dt><a name="interpinfo(out_STR,_in_INT)"
><b>interpinfo</b>(out STR,
in INT)</a></dt><p class="pad"></p>

<dd>.CURRENT_METHOD</dd><p class="pad"></p>
</dl>

<dt><a name="warningson(in_INT)"
><b>warningson</b>(in INT)</a></dt><p class="pad"></p>

<dd>Turns on warnings categories.
Categories already turned on will stay on.
Initial setting is currently all warnings off.
Include <em lang='und' xml:lang='und'>warnings.pasm</em> to access the categories.
They are:</dd><p class="pad"></p>

<dl>
<dt><a name=".PARROT_WARNINGS_UNDEF_FLAG"
>.PARROT_WARNINGS_UNDEF_FLAG</a></dt><p class="pad"></p>

<dt><a name=".PARROT_WARNINGS_IO_FLAG"
>.PARROT_WARNINGS_IO_FLAG</a></dt><p class="pad"></p>

<dt><a name=".PARROT_WARNINGS_PLATFORM_FLAG"
>.PARROT_WARNINGS_PLATFORM_FLAG</a></dt><p class="pad"></p>

<dt><a name=".PARROT_WARNINGS_ALL_FLAG"
>.PARROT_WARNINGS_ALL_FLAG</a></dt><p class="pad"></p>
</dl>

<dd>To turn on multiple categories,
OR the category numbers together.</dd><p class="pad"></p>

<dt><a name="warningsoff(in_INT)"
><b>warningsoff</b>(in INT)</a></dt><p class="pad"></p>

<dd>Turns off warnings categories.
Categories already turned off will stay off.
See the documentation for <b>warningson</b> for category numbers.</dd><p class="pad"></p>

<dt><a name="errorson(in_INT)"
><b>errorson</b>(in INT)</a></dt><p class="pad"></p>

<dd>Turns on error categories.
Categories already turned on will stay on.
To access these from PASM,
include <em lang='und' xml:lang='und'>errors.pasm</em>.
The current categories are:</dd><p class="pad"></p>

<dl>
<dt><a name=".PARROT_ERRORS_GLOBALS_FLAG"
>.PARROT_ERRORS_GLOBALS_FLAG</a></dt><p class="pad"></p>

<dd>Throw an exception if global doesn&#39;t exist.
Default: on.</dd><p class="pad"></p>

<dt><a name=".PARROT_ERRORS_OVERFLOW_FLAG"
>.PARROT_ERRORS_OVERFLOW_FLAG</a></dt><p class="pad"></p>

<dd>Throw math overflow instead of promoting to BigInt.
Default: off.</dd><p class="pad"></p>

<dt><a name=".PARROT_ERRORS_PARAM_COUNT_FLAG"
>.PARROT_ERRORS_PARAM_COUNT_FLAG</a></dt><p class="pad"></p>

<dd>Throw exception on argument &#60;&#45;&#62; param count mismatch.
Default: off.</dd><p class="pad"></p>

<dt><a name=".PARROT_ERRORS_RESULT_COUNT_FLAG"
>.PARROT_ERRORS_RESULT_COUNT_FLAG</a></dt><p class="pad"></p>

<dd>Throw exception on return &#60;&#45;&#62; result count mismatch.
Default: off.</dd><p class="pad"></p>

<dt><a name=".PARROT_ERRORS_ALL_FLAG"
>.PARROT_ERRORS_ALL_FLAG</a></dt><p class="pad"></p>
</dl>

<dd>To turn on multiple categories,
OR the category numbers together.</dd><p class="pad"></p>

<dt><a name="errorsoff(in_INT)"
><b>errorsoff</b>(in INT)</a></dt><p class="pad"></p>

<dd>Turns off errors categories.
Categories already turned off will stay off.
See the documentation for <b>errorson</b> for category numbers.</dd><p class="pad"></p>

<dt><a name="runinterp(invar_PMC,_label_INT)"
><b>runinterp</b>(invar PMC,
label INT)</a></dt><p class="pad"></p>

<dd>Run the code starting at offset $2 within interpreter $1.</dd><p class="pad"></p>

<dt><a name="getinterp(out_PMC)"
><b>getinterp</b>(out PMC)</a></dt><p class="pad"></p>

<dd>Get the current ParrotInterpreter.</dd><p class="pad"></p>
</dl>

<h2><a name="Dead_Object_Detection/Garbage_Collection"
>Dead Object Detection/Garbage Collection <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Opcodes that interact with the DOD and GC subsystems.</p>

<dl>
<dt><a name="sweep(inconst_INT)"
><b>sweep</b>(inconst INT)</a></dt><p class="pad"></p>

<dd>Triggers a DOD run,
based on the value of $1,
where:</dd><p class="pad"></p>

<ul>
<li>0</li><p class="pad"></p>

<p>Trigger a DOD run only if there are things that have flagged themselves as really needing to be collected.</p>

<li>1</li><p class="pad"></p>

<p>Trigger a dead object detection (DOD) sweep unconditionally.</p>
</ul>

<dt><a name="collect()"
><b>collect</b>()</a></dt><p class="pad"></p>

<dd>Trigger a garbage collection.</dd><p class="pad"></p>

<dt><a name="sweepoff()"
><b>sweepoff</b>()</a></dt><p class="pad"></p>

<dd>Disable DOD sweeps.
(Nestable)</dd><p class="pad"></p>

<dt><a name="sweepon()"
><b>sweepon</b>()</a></dt><p class="pad"></p>

<dd>Re&#45;enable DOD sweeps.</dd><p class="pad"></p>

<dt><a name="collectoff()"
><b>collectoff</b>()</a></dt><p class="pad"></p>

<dd>Disable GC runs (nestable).</dd><p class="pad"></p>

<dt><a name="collecton()"
><b>collecton</b>()</a></dt><p class="pad"></p>

<dd>Re&#45;enable GC.</dd><p class="pad"></p>

<dt><a name="needs_destroy(invar_PMC)"
><b>needs_destroy</b>(invar PMC)</a></dt><p class="pad"></p>

<dd>Mark the PMC wanting destruction as soon as possible,
for example when unused during the lazy sweep,
triggered by <code lang='und' xml:lang='und'>sweep 0</code>.</dd><p class="pad"></p>
</dl>

<p>###############################################################################</p>

<h2><a name="Native_Call_Interface"
>Native Call Interface <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Opcodes for interfacing with C functions in shared libraries.</p>

<dl>
<dt><a name="loadlib(out_PMC,_in_STR)"
><b>loadlib</b>(out PMC,
in STR)</a></dt><p class="pad"></p>

<dd>Load a dynamic link library named $2 and store it in $1.</dd><p class="pad"></p>

<dt><a name="dlfunc(out_PMC,_invar_PMC,_in_STR,_in_STR)"
><b>dlfunc</b>(out PMC,
invar PMC,
in STR,
in STR)</a></dt><p class="pad"></p>

<dd>Look up symbol $3 in library $2 with signature $4,
and put the corresponding sub object in $1.
Note that you need the signature so we can build or find an appropriate thunking function.</dd><p class="pad"></p>

<dt><a name="dlvar(out_PMC,_invar_PMC,_in_STR)"
><b>dlvar</b>(out PMC,
invar PMC,
in STR)</a></dt><p class="pad"></p>

<dd>Look up symbol $3 in library $2.
We assume that this is actually a variable address rather than a function address,
and build an UnManagedStruct PMC and stick the address into its data pointer.</dd><p class="pad"></p>

<dt><a name="compile(out_PMC,_invar_PMC,_in_STR)"
><b>compile</b>(out PMC,
invar PMC,
in STR)</a></dt><p class="pad"></p>

<dd>Don&#39;t use compile &#45;&#45; just invoke the compiler.</dd><p class="pad"></p>

<dt><a name="compreg(out_PMC,_in_STR)"
><b>compreg</b>(out PMC,
in STR)</a></dt><p class="pad"></p>

<dd>Get a compiler for source type $2.</dd><p class="pad"></p>

<dt><a name="compreg(in_STR,_invar_PMC)"
><b>compreg</b>(in STR,
invar PMC)</a></dt><p class="pad"></p>

<dd>Register the sub $2 as a compiler for source type $1.
$2 is either a NCI PMC with signature <code lang='und' xml:lang='und'>pIt</code> or a PASM Sub.</dd><p class="pad"></p>

<dt><a name="new_callback(out_PMC,_invar_PMC,_invar_PMC,_in_STR)"
><b>new_callback</b>(out PMC,
invar PMC,
invar PMC,
in STR)</a></dt><p class="pad"></p>

<dd>Create a callback stub $1 for PASM subroutine $2 with userdata $3 and function signature $4.</dd><p class="pad"></p>
</dl>

<h1><a name="COPYRIGHT"
>COPYRIGHT <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Copyright (C) 2001&#45;2006,
The Perl Foundation.</p>

<h1><a name="LICENSE"
>LICENSE <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>This program is free software.
It is subject to the same license as the Parrot interpreter itself.</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
