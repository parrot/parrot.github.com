<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Hash table</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Hash table</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../html/index.html">Contents</a> | <a href="../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>src/hash.c &#45; Hash table</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>A hashtable contains an array of bucket indexes.
Buckets are nodes in a linked list,
each containing a <code lang='und' xml:lang='und'>void *</code> key and value.
During hash creation the types of key and value as well as appropriate compare and hashing functions can be set.</p>

<p>This hash implementation uses just one piece of malloced memory.
The <code lang='und' xml:lang='und'>hash&#45;&#62;bs</code> bucket store points this regions.</p>

<p>This hash doesn&#39;t move during GC,
therefore a lot of the old caveats don&#39;t apply.</p>

<h2><a name="Functions"
>Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="static_size_t_key_hash_STRING(Interp_*interpreter,_void_*value,_size_t_seed)"
><b><code lang='und' xml:lang='und'>static size_t key_hash_STRING(Interp *interpreter, void *value, size_t seed)</b></code></a></dt><p class="pad"></p>

<dd>Return the hashed value of the key <code lang='und' xml:lang='und'>value</code>.</dd><p class="pad"></p>

<dt><a name="static_int_STRING_compare(Parrot_Interp_interp,_void_*a,_void_*b)"
><b><code lang='und' xml:lang='und'>static int STRING_compare(Parrot_Interp interp, void *a, void *b)</b></code></a></dt><p class="pad"></p>

<dd>Compares the two strings,
return 0 if they are identical.</dd><p class="pad"></p>

<dd><code lang='und' xml:lang='und'>a</code> is the search key,
<code lang='und' xml:lang='und'>b</code> is the bucket key.</dd><p class="pad"></p>

<dt><a name="static_size_t_key_hash_cstring(Interp_*interpreter,_void_*value,_size_t_seed)"
><b><code lang='und' xml:lang='und'>static size_t key_hash_cstring(Interp *interpreter, void *value, size_t seed)</b></code></a></dt><p class="pad"></p>

<dt><a name="static_int_cstring_compare(Parrot_Interp_interp,_void_*a,_void_*b)"
><b><code lang='und' xml:lang='und'>static int cstring_compare(Parrot_Interp interp, void *a, void *b)</b></code></a></dt><p class="pad"></p>

<dd>C string versions of the <code lang='und' xml:lang='und'>key_hash</code> and <code lang='und' xml:lang='und'>compare</code> functions.</dd><p class="pad"></p>

<dt><a name="static_size_t_key_hash_int(Interp_*interp,_void_*value,_size_t_seed)"
><b><code lang='und' xml:lang='und'>static size_t key_hash_int(Interp *interp, void *value, size_t seed)</b></code></a></dt><p class="pad"></p>

<dt><a name="static_int_int_compare(Parrot_Interp_interp,_void_*a,_void_*b)"
><b><code lang='und' xml:lang='und'>static int int_compare(Parrot_Interp interp, void *a, void *b)</b></code></a></dt><p class="pad"></p>

<dd>Custom <code lang='und' xml:lang='und'>key_hash</code> and <code lang='und' xml:lang='und'>compare</code> functions.</dd><p class="pad"></p>

<dt><a name="void_parrot_dump_hash(Interp_*interpreter,_Hash_*hash)"
><b><code lang='und' xml:lang='und'>void parrot_dump_hash(Interp *interpreter, Hash *hash)</b></code></a></dt><p class="pad"></p>

<dd>Print out the hash in human&#45;readable form.</dd><p class="pad"></p>

<dt><a name="void_parrot_mark_hash(Interp_*interpreter,_Hash_*hash)"
><b><code lang='und' xml:lang='und'>void parrot_mark_hash(Interp *interpreter, Hash *hash)</b></code></a></dt><p class="pad"></p>

<dd>Marks the hash and its contents as live.</dd><p class="pad"></p>

<dt><a name="void_parrot_hash_visit(Interp_*interpreter,_Hash_*hash,_void*_pinfo)"
><b><code lang='und' xml:lang='und'>void parrot_hash_visit(Interp *interpreter, Hash *hash, void *pinfo)</b></code></a></dt><p class="pad"></p>

<dd>This is used by freeze/thaw to visit the contents of the hash.</dd><p class="pad"></p>

<dd><code lang='und' xml:lang='und'>pinfo</code> is the visit info,
(see include/parrot/pmc_freeze.h&#62;).</dd><p class="pad"></p>

<dt><a name="static_void_expand_hash(Interp_*interpreter,_Hash_*hash)"
><b><code lang='und' xml:lang='und'>static void expand_hash(Interp *interpreter, Hash *hash)</b></code></a></dt><p class="pad"></p>

<dd>For a hashtable of size N,
we use <code lang='und' xml:lang='und'>MAXFULL_PERCENT</code> % of N as the number of buckets.
This way,
as soon as we run out of buckets on the free list,
we know that it&#39;s time to resize the hashtable.</dd><p class="pad"></p>

<dd>Algorithm for expansion: We exactly double the size of the hashtable.
Keys are assigned to buckets with the formula</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>        bucket_index = hash(key) % parrot_hash_size</pre>

<dd>so when doubling the size of the hashtable, we know that every key is either already in the correct bucket, or belongs in the current bucket plus <code lang='und' xml:lang='und'>parrot_hash_size</code> (the old <code lang='und' xml:lang='und'>parrot_hash_size</code>). In fact, because the hashtable is always a power of two in size, it depends only on the next bit in the hash value, after the ones previously used.</dd><p class="pad"></p>

<dd>So we scan through all the buckets in order, moving the buckets that need to be moved. No bucket will be scanned twice, and the cache should be reasonably happy because the hashtable accesses will be two parallel sequential scans. (Of course, this also mucks with the <code lang='und' xml:lang='und'>&#45;&#62;next</code> pointers, and they&#39;ll be all over memory.)</dd><p class="pad"></p>

<dt><a name="void_parrot_new_hash(Interp_*interpreter,_Hash_**hptr)"
><b><code lang='und' xml:lang='und'>void parrot_new_hash(Interp *interpreter, Hash **hptr)</b></code></a></dt><p class="pad"></p>

<dd>Returns a new Parrot STRING hash in <code lang='und' xml:lang='und'>hptr</code>.</dd><p class="pad"></p>

<dd>parrot_new_pmc_hash(Interp *interpreter, PMC *container)&#62;</dd><p class="pad"></p>

<dd>Create a new Parrot STRING hash in PMC_struct_val(container)</dd><p class="pad"></p>

<dt><a name="void_parrot_new_cstring_hash(Interp_*interpreter,_Hash_**hptr)"
><b><code lang='und' xml:lang='und'>void parrot_new_cstring_hash(Interp *interpreter, Hash **hptr)</b></code></a></dt><p class="pad"></p>

<dd>Returns a new C string hash in <code lang='und' xml:lang='und'>hptr</code>.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>void parrot_new_hash_x(Interp *interpreter, Hash **hptr, PARROT_DATA_TYPES val_type, Hash_key_type hkey_type, hash_comp_fn compare, hash_hash_key_fn keyhash)</b></code></a></dt><p class="pad"></p>

<dd>Returns a new hash in <code lang='und' xml:lang='und'>hptr</code>.</dd><p class="pad"></p>

<dd>FIXME: This function can go back to just returning the hash struct pointer once Buffers can define their own custom mark routines.</dd><p class="pad"></p>

<dd>The problem is: During DODs stack walking the item on the stack must be a PMC. When an auto <code lang='und' xml:lang='und'>Hash*</code> is seen, it doesn&#39;t get properly marked (only the <code lang='und' xml:lang='und'>Hash*</code> buffer is marked, not its contents). By passing the <code lang='und' xml:lang='und'>**hptr</code> up to the Hash&#39;s init function, the newly constructed PMC is on the stack <i>including</i> this newly constructed Hash, so that it gets marked properly.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>void parrot_new_pmc_hash_x(Interp *interpreter, PMC *container, PARROT_DATA_TYPES val_type, Hash_key_type hkey_type, hash_comp_fn compare, hash_hash_key_fn keyhash)</b></code></a></dt><p class="pad"></p>

<dd>Like above but w/o the described problems. The passed in <code lang='und' xml:lang='und'>container</code> PMC gets stored in the Hash end the newly created Hash is in PMC_struct_val(container).</dd><p class="pad"></p>

<dt><a name="PMC*_Parrot_new_INTVAL_hash(Interp_*interpreter,_UINTVAL_flags)"
><b><code lang='und' xml:lang='und'>PMC *Parrot_new_INTVAL_hash(Interp *interpreter, UINTVAL flags)</b></code></a></dt><p class="pad"></p>

<dd>Create a new Hash PMC with INTVAL keys and values. <code lang='und' xml:lang='und'>flags</code> can be <code lang='und' xml:lang='und'>PObj_constant_FLAG</code> or 0.</dd><p class="pad"></p>

<dt><a name="INTVAL_parrot_hash_size(Interp_*interpreter,_Hash_*hash)"
><b><code lang='und' xml:lang='und'>INTVAL parrot_hash_size(Interp *interpreter, Hash *hash)</b></code></a></dt><p class="pad"></p>

<dd>Return the number of used entries in the hash.</dd><p class="pad"></p>

<dt><a name="void_*_parrot_hash_get_idx(Interp_*interpreter,_Hash_*hash,_PMC_*_key)"
><b><code lang='und' xml:lang='und'>void *parrot_hash_get_idx(Interp *interpreter, Hash *hash, PMC *key)</b></code></a></dt><p class="pad"></p>

<dd>Called by iterator.</dd><p class="pad"></p>

<dt><a name="HashBucket_*_parrot_hash_get_bucket(Interp_*interpreter,_Hash_*hash,_void_*key)"
><b><code lang='und' xml:lang='und'>HashBucket *parrot_hash_get_bucket(Interp *interpreter, Hash *hash, void *key)</b></code></a></dt><p class="pad"></p>

<dd>Returns the bucket for <code lang='und' xml:lang='und'>key</code>.</dd><p class="pad"></p>

<dt><a name="void_*_parrot_hash_get(Interp_*interpreter,_Hash_*hash,_void_*key)"
><b><code lang='und' xml:lang='und'>void *parrot_hash_get(Interp *interpreter, Hash *hash, void *key)</b></code></a></dt><p class="pad"></p>

<dd>Returns the bucket for <code lang='und' xml:lang='und'>key</code> or <code lang='und' xml:lang='und'>NULL</code> if no bucket is found.</dd><p class="pad"></p>

<dt><a name="INTVAL_parrot_hash_exists(Interp_*interpreter,_Hash_*hash,_void_*key)"
><b><code lang='und' xml:lang='und'>INTVAL parrot_hash_exists(Interp *interpreter, Hash *hash, void *key)</b></code></a></dt><p class="pad"></p>

<dd>Returns whether the key exists in the hash.</dd><p class="pad"></p>

<dt><a name="HashBucket*_parrot_hash_put(Interp_*interpreter,_Hash_*hash,_void_*key,_void_*value)"
><b><code lang='und' xml:lang='und'>HashBucket *parrot_hash_put(Interp *interpreter, Hash *hash, void *key, void *value)</b></code></a></dt><p class="pad"></p>

<dd>Puts the key and value into the hash. Note that <code lang='und' xml:lang='und'>key</code> is <b>not</b> copied.</dd><p class="pad"></p>

<dt><a name="void_parrot_hash_delete(Interp_*interpreter,_Hash_*hash,_void_*key)"
><b><code lang='und' xml:lang='und'>void parrot_hash_delete(Interp *interpreter, Hash *hash, void *key)</b></code></a></dt><p class="pad"></p>

<dd>Deletes the key from the hash.</dd><p class="pad"></p>

<dt><a name="void_parrot_hash_clone(Interp_*interp,_Hash_*hash,_Hash_**dest)"
><b><code lang='und' xml:lang='und'>void parrot_hash_clone(Interp *interp, Hash *hash, Hash **dest)</b></code></a></dt><p class="pad"></p>

<dd>Clones <code lang='und' xml:lang='und'>hash</code> to <code lang='und' xml:lang='und'>dest</code>.</dd><p class="pad"></p>
</dl>

<h1><a name="SEE_ALSO"
>SEE ALSO <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p><em lang='und' xml:lang='und'>docs/pdds/pdd08_keys.pod</em>.</p>

<h1><a name="HISTORY"
>HISTORY <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<ul>
<li>Initial version by Jeff G. on 2001.12.05</li><p class="pad"></p>

<li>Substantially rewritten by Steve F.</li><p class="pad"></p>

<li>2003.10.25</li><p class="pad"></p>

<p>leo add function pointer for compare, hash, mark</p>

<p>hash keys are now <code lang='und' xml:lang='und'>(void *)</code></p>

<p>add <code lang='und' xml:lang='und'>parrot_new_cstring_hash()</code> function</p>

<li>2003.11.04</li><p class="pad"></p>

<p><code lang='und' xml:lang='und'>bucket&#45;&#62;value</code> is now a plain pointer, no more an <code lang='und' xml:lang='und'>HASH_ENTRY</code></p>

<p>With little changes, we can again store arbitrary items if needed, see TODO in code.</p>

<li>2003.11.06</li><p class="pad"></p>

<p>boemmels renamed <code lang='und' xml:lang='und'>HASH</code> and <code lang='und' xml:lang='und'>HASHBUCKET</code> to <code lang='und' xml:lang='und'>Hash</code> and <code lang='und' xml:lang='und'>HashBucket</code></p>

<li>2003.11.11</li><p class="pad"></p>

<p>leo randomize <code lang='und' xml:lang='und'>key_hash</code> seed</p>

<p>extend <code lang='und' xml:lang='und'>parrot_new_hash_x()</code> init call by <code lang='und' xml:lang='und'>value_type</code> and <code lang='und' xml:lang='und'>_size</code>.</p>

<li>2003.11.14</li><p class="pad"></p>

<p>leo <code lang='und' xml:lang='und'>USE_STRING_EQUAL</code> define, see comment above</p>

<li>2005.05.23</li><p class="pad"></p>

<p>leo heavy rewrite: use just one piece of malloced memory</p>
</ul>

<h1><a name="TODO"
>TODO <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>Future optimizations:</p>

<ul>
<li>Stop reallocating the bucket pool, and instead add chunks on. (Saves pointer fixups and copying during <code lang='und' xml:lang='und'>realloc</code>.)</li><p class="pad"></p>

<li>Hash contraction (don&#39;t if it&#39;s worth it)</li><p class="pad"></p>
</ul>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
