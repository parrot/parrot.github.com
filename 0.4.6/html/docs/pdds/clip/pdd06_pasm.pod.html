<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Parrot Assembly Language</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Parrot Assembly Language</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../../html/index.html">Contents</a> | <a href="../../../../html/docs.html">Documentation</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>docs/pdds/pdd06_pasm.pod &#45; Parrot Assembly Language</p>

<h1><a name="ABSTRACT"
>ABSTRACT <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>This PDD describes the format of Parrot&#39;s bytecode assembly language.</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>Parrot&#39;s bytecode can be thought of as a form of machine language for a virtual super CISC machine.
It makes sense,
then,
to define an assembly language for it for those people who may need to generate bytecode directly,
rather than indirectly via the perl (or any other) language.</p>

<p>{{ NOTE: out&#45;of&#45;date and incomplete.
It seems that it would be more useful as a specification of the format of PASM than as a comprehensive listing of all opcodes.
}}</p>

<h1><a name="IMPLEMENTATION"
>IMPLEMENTATION <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>Parrot opcodes take the format of:</p>

<pre lang='und' xml:lang='und'>  code destination[dest_key], source1[source1_key], source2[source2_key]</pre>

<p>The brackets do not denote optional arguments as such&#45;&#45;they are real brackets. They may be left out entirely, however. If any argument has a key the assembler will substitute the null key for arguments missing keys.</p>

<p>Conditional branches take the format:</p>

<pre lang='und' xml:lang='und'>  code boolean[bool_key], true_dest</pre>

<p>The key parameters are optional, and may be either an integer or a string. If either is passed they are associated with the parameter to their left, and are assumed to be either an array/list entry number, or a hash key. Any time a source or destination can be a PMC register, there may be a key.</p>

<p>Destinations for conditional branches are an integer offset from the current PC.</p>

<p>All registers have a type prefix of P, S, I, or N, for PMC, string, integer, and number respectively.</p>

<h1><a name="Assembly_Syntax"
>Assembly Syntax <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>All assembly opcodes contain only ASCII lowercase letters, digits, and the underscore.</p>

<p>Upper case names are reserved for assembler directives. {{ NOTE: no longer true. }}</p>

<p>Labels all end with a colon. They may have ASCII letters, numbers, and underscores in them. Labels that begin with a dollar sign (the only valid spot in a label a dollar sign can appear) are private to the subroutine they appear in.</p>

<p>Namespaces are noted with the <code lang='und' xml:lang='und'>.namespace</code> directive. It takes a single parameter, the name of the namespace, in the form of a multi&#45;dimensional key.</p>

<p>Subroutine names are noted with the <code lang='und' xml:lang='und'>.sub</code> directive. It takes a single parameter, the name of the subroutine, which is added to the namespace&#39;s symbol table. Sub names may be any valid Unicode alphanumeric character and the underscore.</p>

<p>Constants don&#39;t need to be named and put in a separate section of the assembly source. The assembler will take care of putting them in the appropriate part of the generated bytecode.</p>

<h1><a name="OPCODE_LIST"
>OPCODE LIST <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>In the following list, there may be multiple (but unlisted) versions of an opcode. If an opcode takes a register that might be keyed, the keyed version of the opcode has a _k suffix. If an opcode might take multiple types of registers for a single parameter, the opcode function really has a _x suffix, where x is either P, S, I, or N, depending on whether a PMC, string, integer, or numeric register is involved. The suffix isn&#39;t necessary (though not an error) as the assembler can intuit the information from the code.</p>

<p>In those cases where an opcode can take several types of registers, and more than one of the sources or destinations are of variable type, then the register is passed in extended format. An extended format register number is of the form:</p>

<pre lang='und' xml:lang='und'>     register_number | register_type</pre>

<p>where register_type is 0x100, 0x200, 0x400, or 0x800 for PMC, string, integer, or number respectively. So N19 would be 0x413.</p>

<p><b>Note</b>: Instructions tagged with a * will call a vtable method to handle the instruction if used on PMC registers.</p>

<p>In all cases, the letters x, y, and z refer to register numbers. The letter t refers to a generic register (P, S, I, or N). A lowercase p, s, i, or n means either a register or constant of the appropriate type (PMC, string, integer, or number)</p>

<h2><a name="Control_flow"
>Control flow <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>The control flow opcodes check conditions and manage program flow.</p>

<dl>
<dt><a name="if_tx,_ix"
>if tx, ix</a></dt><p class="pad"></p>

<dd>Check register tx. If true, branch by X.</dd><p class="pad"></p>

<dt><a name="unless_tx,_ix"
>unless tx, ix</a></dt><p class="pad"></p>

<dd>Check register tx. If false, branch by X.</dd><p class="pad"></p>

<dt><a name="jump_tx"
>jump tx</a></dt><p class="pad"></p>

<dd>Jump to the address held in register x (Px, Sx, or Ix).</dd><p class="pad"></p>

<dt><a name="branch_tx"
>branch tx</a></dt><p class="pad"></p>

<dd>Branch forward or backward by the amount in register x. (X may be either Ix, Nx, or Px) Branch offset may also be an integer constant.</dd><p class="pad"></p>

<dt><a name="jsr_tx"
>jsr tx</a></dt><p class="pad"></p>

<dd>Jump to the location specified by register X. Push the current location onto the call stack for later returning.</dd><p class="pad"></p>

<dt><a name="bsr_ix"
>bsr ix</a></dt><p class="pad"></p>

<dd>Branch to the location specified by X (either register or label). Push the current location onto the call stack for later returning.</dd><p class="pad"></p>

<dt><a name="ret"
>ret</a></dt><p class="pad"></p>

<dd>Pop the location off the top of the stack and go there.</dd><p class="pad"></p>
</dl>

<h2><a name="Data_manipulation"
>Data manipulation <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>These ops handle manipulating the data in registers</p>

<dl>
<dt><a name="new_Px,_iy"
>new Px, iy</a></dt><p class="pad"></p>

<dd>Create a new PMC of class y stored in PMC register x.</dd><p class="pad"></p>

<dt><a name="destroy_Px"
>destroy Px</a></dt><p class="pad"></p>

<dd>Destroy the PMC in register X, leaving it undef</dd><p class="pad"></p>

<dt><a name="set_tx,_ty"
>set tx, ty</a></dt><p class="pad"></p>

<dd>Copies y into x. Note that strings and PMCs are referred to by pointer, so if you do something like:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>   set S0, S1</pre>

<dd>this will copy the pointer in S1 into S0, leaving <b>both</b> registers pointing at the same string.</dd><p class="pad"></p>

<dt><a name="exchange_tx,_ty"
>exchange tx, ty</a></dt><p class="pad"></p>

<dd>Exchange the contents of registers X and Y, which must be of the same type. (Generally cheaper than using the stack as an intermediary when setting up registers for function calls)</dd><p class="pad"></p>

<dt><a name="assign_Px,_ty"
>assign Px, ty</a></dt><p class="pad"></p>

<dd>Takes the contents of Y and assigns them into the existing PMC in X.</dd><p class="pad"></p>

<dd>While set just copies pointers from one register to another, assign actually does a value assignment, as:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    $foo = $bar;</pre>

<dd>X&#39;s assign vtable method is invoked and it does whatever is appropriate.</dd><p class="pad"></p>

<dt><a name="clone_Px,_Py"
>clone Px, Py</a></dt><p class="pad"></p>

<dt><a name="clone_Sx,_xy"
>clone Sx, xy</a></dt><p class="pad"></p>

<dd>Performs a &#34;deeper&#34; copy of y into x, using the vtable appropriate to the class of Py if cloning a PMC.</dd><p class="pad"></p>

<dt><a name="tostring_Sx,_ty,_Iz"
>tostring Sx, ty, Iz</a></dt><p class="pad"></p>

<dd>Take the value in register y and convert it to a string of type z, storing the result in string register x.</dd><p class="pad"></p>

<dt><a name="add_tx,_ty,_tz_*"
>add tx, ty, tz *</a></dt><p class="pad"></p>

<dd>Add registers y and z and store the result in register x. (x = y + z) The registers must all be the same type, PMC, integer, or number.</dd><p class="pad"></p>

<dt><a name="sub_tx,_ty,_tz_*"
>sub tx, ty, tz *</a></dt><p class="pad"></p>

<dd>Subtract register z from register y and store the result in register x. (x = y &#45; z) The registers must all be the same type, PMC, integer, or number.</dd><p class="pad"></p>

<dt><a name="mul_tx,_ty,_tz_*"
>mul tx, ty, tz *</a></dt><p class="pad"></p>

<dd>Multiply register y by register z and store the results in register x. The registers must be the same type.</dd><p class="pad"></p>

<dt><a name="div_tx,_ty,_tz_*"
>div tx, ty, tz *</a></dt><p class="pad"></p>

<dd>Divide register y by register z, and store the result in register x.</dd><p class="pad"></p>

<dt><a name="inc_tx,_nn_*"
>inc tx, nn *</a></dt><p class="pad"></p>

<dd>Increment register x by nn. nn is an integer constant. If nn is omitted, increment is 1.</dd><p class="pad"></p>

<dt><a name="dec_tx,_nn_*"
>dec tx, nn *</a></dt><p class="pad"></p>

<dd>Decrement register x by nn. nn is an integer constant. If nn is omitted, decrement by 1.</dd><p class="pad"></p>

<dt><a name="length_Ix,_Sy"
>length Ix, Sy</a></dt><p class="pad"></p>

<dd>Put the length of string y into integer register x.</dd><p class="pad"></p>

<dt><a name="concat_Sx,_Sy"
>concat Sx, Sy</a></dt><p class="pad"></p>

<dd>Add string y to the end of string x.</dd><p class="pad"></p>

<dt><a name="repeat_Sx,_Sy,_iz"
>repeat Sx, Sy, iz</a></dt><p class="pad"></p>

<dd>Copies string y z times into string x.</dd><p class="pad"></p>
</dl>

<h2><a name="Transcendental_operations"
>Transcendental operations <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>These opcodes handle the transcendental math functions. The destination register here must always be either a numeric or a PMC register.</p>

<dl>
<dt><a name="sin_nx,_ty"
>sin nx, ty</a></dt><p class="pad"></p>

<dd>Return the sine of the number in Y</dd><p class="pad"></p>

<dt><a name="cos_nx,_ty"
>cos nx, ty</a></dt><p class="pad"></p>

<dd>Return the cosine of the number in Y</dd><p class="pad"></p>

<dt><a name="tan_nx,_ty"
>tan nx, ty</a></dt><p class="pad"></p>

<dd>Return the tangent of the number in Y</dd><p class="pad"></p>

<dt><a name="sec_nx,_ty"
>sec nx, ty</a></dt><p class="pad"></p>

<dd>Return the secant of the number in Y</dd><p class="pad"></p>

<dt><a name="atan_nx,_ty"
>atan nx, ty</a></dt><p class="pad"></p>

<dd>Return the arctangent of Y</dd><p class="pad"></p>

<dt><a name="atan2_nx,_ty"
>atan2 nx, ty</a></dt><p class="pad"></p>

<dd>Return the result of atan2 of Y</dd><p class="pad"></p>

<dt><a name="asin_nx,_ty"
>asin nx, ty</a></dt><p class="pad"></p>

<dd>Return the arcsine of y</dd><p class="pad"></p>

<dt><a name="acos_nx,_ty"
>acos nx, ty</a></dt><p class="pad"></p>

<dd>Return the arccosine of y</dd><p class="pad"></p>

<dt><a name="asec_nx,_ty"
>asec nx, ty</a></dt><p class="pad"></p>

<dd>Return the arcsecant of y</dd><p class="pad"></p>

<dt><a name="cosh_nx,_ty"
>cosh nx, ty</a></dt><p class="pad"></p>

<dd>Return the hyperbolic cosine of y</dd><p class="pad"></p>

<dt><a name="sinh_nx,_ty"
>sinh nx, ty</a></dt><p class="pad"></p>

<dd>Return the hyperbolic sine of y</dd><p class="pad"></p>

<dt><a name="tanh_nx,_ty"
>tanh nx, ty</a></dt><p class="pad"></p>

<dd>Return the hyperbolic tangent of y</dd><p class="pad"></p>

<dt><a name="sech_nx,_ty"
>sech nx, ty</a></dt><p class="pad"></p>

<dd>Return the hyperbolic secant of y</dd><p class="pad"></p>

<dt><a name="log2_nx,_ty"
>log2 nx, ty</a></dt><p class="pad"></p>

<dd>Return the base 2 log of y</dd><p class="pad"></p>

<dt><a name="log10_nx,_ty"
>log10 nx, ty</a></dt><p class="pad"></p>

<dd>Return the base 10 log of y</dd><p class="pad"></p>

<dt><a name="ln_Nx,_ty"
>ln Nx, ty</a></dt><p class="pad"></p>

<dd>Return the base e log of y</dd><p class="pad"></p>

<dt><a name="log_nx,_ty,_tz"
>log nx, ty, tz</a></dt><p class="pad"></p>

<dd>Return the base Z log of Y</dd><p class="pad"></p>

<dt><a name="pow_nx,_ty,_tz"
>pow nx, ty, tz</a></dt><p class="pad"></p>

<dd>Return Y to the Z power</dd><p class="pad"></p>

<dt><a name="exp_nx,_ty"
>exp nx, ty</a></dt><p class="pad"></p>

<dd>Return e to the Y power</dd><p class="pad"></p>
</dl>

<h2><a name="Register_and_stack_ops"
>Register and stack ops <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>These opcodes deal with registers and stacks</p>

<dl>
<dt><a name="pushp"
>pushp</a></dt><p class="pad"></p>

<dd>Push the current set of PMC registers onto the register frame stack, and start a new set (which will all initially be NULL). Register frames hold only 16 registers, so we need to push two frames onto the stack. The first frame holds the contents of registers 0&#45;15; the second holds the contents of registers 16&#45;31.</dd><p class="pad"></p>

<dt><a name="popp"
>popp</a></dt><p class="pad"></p>

<dd>Restore all of the PMC registers from the most recently <code lang='und' xml:lang='und'>push</code>ed PMC register frames. Since the register frames hold only 16 registers, we pop two frames. We use the first frame to restore registers 16&#45;31, and the second frame to restore registers 0&#45;15. Hence, <code lang='und' xml:lang='und'>pushp</code> followed by <code lang='und' xml:lang='und'>popp</code> restores all of the PMC registers to their original state.</dd><p class="pad"></p>

<dt><a name="poptopp"
>poptopp</a></dt><p class="pad"></p>

<dd>Pop a single PMC register frame off the PMC register frame stack and use it to restore the values of registers 16&#45;31. Registers 0&#45;15 retain their old values.</dd><p class="pad"></p>

<dt><a name="popbottomp"
>popbottomp</a></dt><p class="pad"></p>

<dd>Pop a single PMC register frame off the PMC register frame stack and use it to restore the values of registers 0&#45;15. Registers 16&#45;31 retain their old values.</dd><p class="pad"></p>

<dt><a name="pushi"
>pushi</a></dt><p class="pad"></p>

<dd>The same as <a href='TODO'>pushp</a>, for the integer register set.</dd><p class="pad"></p>

<dt><a name="popi"
>popi</a></dt><p class="pad"></p>

<dd>The same as <a href='TODO'>popp</a>, for the integer register set.</dd><p class="pad"></p>

<dt><a name="poptopi"
>poptopi</a></dt><p class="pad"></p>

<dd>The same as <a href='TODO'>poptopp</a>, for the integer register set.</dd><p class="pad"></p>

<dt><a name="popbottomi"
>popbottomi</a></dt><p class="pad"></p>

<dd>The same as <a href='TODO'>popbottomp</a>, for the integer register set.</dd><p class="pad"></p>

<dt><a name="pushs"
>pushs</a></dt><p class="pad"></p>

<dd>The same as <a href='TODO'>pushp</a>, for the string register set.</dd><p class="pad"></p>

<dt><a name="pops"
>pops</a></dt><p class="pad"></p>

<dd>The same as <a href='TODO'>popp</a>, for the string register set.</dd><p class="pad"></p>

<dt><a name="poptops"
>poptops</a></dt><p class="pad"></p>

<dd>The same as <a href='TODO'>poptopp</a>, for the string register set.</dd><p class="pad"></p>

<dt><a name="popbottoms"
>popbottoms</a></dt><p class="pad"></p>

<dd>The same as <a href='TODO'>popbottomp</a>, for the string register set.</dd><p class="pad"></p>

<dt><a name="pushn"
>pushn</a></dt><p class="pad"></p>

<dd>The same as <a href='TODO'>pushp</a>, for the floating&#45;point register set.</dd><p class="pad"></p>

<dt><a name="popn"
>popn</a></dt><p class="pad"></p>

<dd>The same as <a href='TODO'>popp</a>, for the floating&#45;point register set.</dd><p class="pad"></p>

<dt><a name="poptopn"
>poptopn</a></dt><p class="pad"></p>

<dd>The same as <a href='TODO'>poptopp</a>, for the floating&#45;point register set.</dd><p class="pad"></p>

<dt><a name="popbottomn"
>popbottomn</a></dt><p class="pad"></p>

<dd>The same as <a href='TODO'>popbottomp</a>, for the floating&#45;point register set.</dd><p class="pad"></p>

<dt><a name="clearp"
>clearp</a></dt><p class="pad"></p>

<dd>Clean out the current set of PMC registers, setting them to NULL</dd><p class="pad"></p>

<dt><a name="cleari"
>cleari</a></dt><p class="pad"></p>

<dd>Clean out the current set of I registers, setting them to 0</dd><p class="pad"></p>

<dt><a name="clears"
>clears</a></dt><p class="pad"></p>

<dd>Clean out the current set of S registers, setting them to NULL</dd><p class="pad"></p>

<dt><a name="clearn"
>clearn</a></dt><p class="pad"></p>

<dd>Clean out the current set of N registers, setting them to 0</dd><p class="pad"></p>

<dt><a name="null_tx"
>null tx</a></dt><p class="pad"></p>

<dd>Set register X to a null value; for S and P registers, this will be NULL, while for I and N registers it is 0</dd><p class="pad"></p>

<dt><a name="save_tx"
>save tx</a></dt><p class="pad"></p>

<dd>Push register or constant X onto the generic stack</dd><p class="pad"></p>

<dt><a name="restore_tx"
>restore tx</a></dt><p class="pad"></p>

<dd>Restore register X from the generic stack by popping off the topmost entry. The type of this entry must match the register type.</dd><p class="pad"></p>

<dt><a name="saveall"
>saveall</a></dt><p class="pad"></p>

<dd>Save all of the current set of registers onto the appropriate frame stacks. Equivalent to performing a separate push for each register type.</dd><p class="pad"></p>

<dt><a name="restoreall"
>restoreall</a></dt><p class="pad"></p>

<dd>Restore all of the registers from the appropriate frame stacks. Equivalent to performing a separate pop for each register type.</dd><p class="pad"></p>

<dt><a name="savetop"
>savetop</a></dt><p class="pad"></p>

<dd>As <a href='TODO'>saveall</a> but only acts on registers 16&#45;31.</dd><p class="pad"></p>

<dt><a name="restoretop"
>restoretop</a></dt><p class="pad"></p>

<dd>As <a href='TODO'>restoreall</a> but only affects registers 16&#45;31.</dd><p class="pad"></p>

<dt><a name="set_warp_string"
>set_warp string</a></dt><p class="pad"></p>

<dd>Sets a named marker for the stacks for later use.</dd><p class="pad"></p>

<dt><a name="entrytype_Ix,_iy"
>entrytype Ix, iy</a></dt><p class="pad"></p>

<dd>Put the type of generic stack entry Y into integer register X</dd><p class="pad"></p>

<dt><a name="depth_Ix"
>depth Ix</a></dt><p class="pad"></p>

<dd>Get the current depth of the generic stack</dd><p class="pad"></p>

<dt><a name="lookback_tx,_iy"
>lookback tx, iy</a></dt><p class="pad"></p>

<dd>Fetch the entry that&#39;s at position Y from the top of the generic stack. This does not remove an entry from the stack, merely fetches the entry off it.</dd><p class="pad"></p>

<dd>0 is the entry at the top of the stack, 1 is the entry immediately previous to that, and so on. Entry &#45;1 is the very bottom&#45;most entry in the stack. (While the stack may be a tree when looked at from the bottom up, you don&#39;t have access to any other branches when looking this way).</dd><p class="pad"></p>

<dt><a name="warp_[string]"
>warp [string]</a></dt><p class="pad"></p>

<dd>Reset the current register stacks to the state they were in when the warp was set. Resets only the frame pointers, doesn&#39;t guarantee the contents of the registers. Be <i>very</i> careful modifying the frame pointers by, for example, pushing register frames.</dd><p class="pad"></p>

<dd>If a name is passed, warp back to the named point.</dd><p class="pad"></p>

<dt><a name="unwarp"
>unwarp</a></dt><p class="pad"></p>

<dd>Reset the current register stacks to the state they were in before the last warp.</dd><p class="pad"></p>
</dl>

<h2><a name="Names,_pads,_and_globals"
>Names, pads, and globals <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>These operations are responsible for finding names in lexical or global scopes, as well as storing data into those slots. A static scope is captured by a scratchpad. The current dynamic scope is represented by the state of the lexical stack (which contains scratchpads). For more detail on these ops see the inline POD documentation in <em lang='und' xml:lang='und'>ops/var.ops</em>.</p>

<dl>
<dt><a name="new_pad_ix"
>new_pad ix</a></dt><p class="pad"></p>

<dt><a name="new_pad_Px,_iy"
>new_pad Px, iy</a></dt><p class="pad"></p>

<dt><a name="push_pad_Px"
>push_pad Px</a></dt><p class="pad"></p>

<dt><a name="pop_pad"
>pop_pad</a></dt><p class="pad"></p>

<dt><a name="pop_pad_Px"
>pop_pad Px</a></dt><p class="pad"></p>

<dt><a name="peek_pad_Px"
>peek_pad Px</a></dt><p class="pad"></p>

<dd>Instructions for creating scratchpads and manipulating the lexical stack.</dd><p class="pad"></p>

<dt><a name="store_lex_sx,_Py"
>store_lex sx, Py</a></dt><p class="pad"></p>

<dt><a name="store_lex_ix,_sy,_Pz"
>store_lex ix, sy, Pz</a></dt><p class="pad"></p>

<dt><a name="store_lex_ix,_iy,_Pz"
>store_lex ix, iy, Pz</a></dt><p class="pad"></p>

<dt><a name="find_lex_Px,_sy"
>find_lex Px, sy</a></dt><p class="pad"></p>

<dt><a name="find_lex_Px,_iy,_sz"
>find_lex Px, iy, sz</a></dt><p class="pad"></p>

<dt><a name="find_lex_Px,_iy,_iz"
>find_lex Px, iy, iz</a></dt><p class="pad"></p>

<dd>Instructions for storing in, and retrieving from the scratchpad currently at the top of the lexical stack. For each of these operations there is an equivalent form that uses keyed versions of the set instruction. The keyed variants require that a scratchpad be specified rather than implicitly operating on the scratchpad on the top of the stack.</dd><p class="pad"></p>

<dt><a name="find_global_Px,_sy,_sz"
>find_global Px, sy, sz</a></dt><p class="pad"></p>

<dd>Find the PMC for the global variable sy from the table sz and store it in register X</dd><p class="pad"></p>

<dt><a name="find_global_Px,_sy"
>find_global Px, sy</a></dt><p class="pad"></p>

<dd>Find the PMC for the global in the default table and put it in X.</dd><p class="pad"></p>

<dt><a name="find_global_table_Px,_sy"
>find_global_table Px, sy</a></dt><p class="pad"></p>

<dd>Find the global symbol table Y and store its PMC in X</dd><p class="pad"></p>

<dt><a name="find_global_slot_ix,_Py,_sz"
>find_global_slot ix, Py, sz</a></dt><p class="pad"></p>

<dd>Find the slot in the global table Y for the global named Z, and store its slot in register X.</dd><p class="pad"></p>

<dt><a name="fetch_global_Px,_Py,_iz"
>fetch_global Px, Py, iz</a></dt><p class="pad"></p>

<dd>Fetch the global in slot Z of the symbol table pointed to by Y</dd><p class="pad"></p>

<dt><a name="store_global_Px,_sy"
>store_global Px, sy</a></dt><p class="pad"></p>

<dd>Store X in the default global symbol table with a name of Y.</dd><p class="pad"></p>
</dl>

<h2><a name="Exceptions"
>Exceptions <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>These opcodes deal with exception handling at the lowest level. Exception handlers are dynamically scoped, and any exception handler set in a scope will be removed when that scope is exited.</p>

<dl>
<dt><a name="set_eh_Px"
>set_eh Px</a></dt><p class="pad"></p>

<dd>Sets an exception handler in place. The code referred to by register Px will get called if an exception is thrown while the exception handler is in scope.</dd><p class="pad"></p>

<dt><a name="clear_eh"
>clear_eh</a></dt><p class="pad"></p>

<dd>Clear out the most recently placed exception</dd><p class="pad"></p>

<dt><a name="throw_Px"
>throw Px</a></dt><p class="pad"></p>

<dd>Throw an exception represented by the object in PMC register x.</dd><p class="pad"></p>

<dt><a name="rethrow_Px"
>rethrow Px</a></dt><p class="pad"></p>

<dd>Only valid inside an exception handler. Rethrow the exception represented by the object in PMC register x. This object may have been altered by the exception handler.</dd><p class="pad"></p>
</dl>

<h2><a name="Object_things"
>Object things <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>These opcodes deal with PMCs as objects, rather than as opaque data items.</p>

<dl>
<dt><a name="make_object_Px,_ty"
>make_object Px, ty</a></dt><p class="pad"></p>

<dd>Make the variable in PMC x an object of type ty. The type can be a string, in which case we treat it as a package name.</dd><p class="pad"></p>

<dt><a name="find_method_Px,_Py,_tz"
>find_method Px, Py, tz</a></dt><p class="pad"></p>

<dd>Find the method Z for object Y, and return a PMC for it in X.</dd><p class="pad"></p>

<dt><a name="call_method_Px,_ty"
>call_method Px, ty</a></dt><p class="pad"></p>

<dt><a name="find_attribute_Px,_sy"
>find_attribute Px, sy</a></dt><p class="pad"></p>

<dt><a name="set_attribute_Px,_ty,_tz"
>set_attribute Px, ty, tz</a></dt><p class="pad"></p>

<dt><a name="can_Ix,_Py,_sz"
>can Ix, Py, sz</a></dt><p class="pad"></p>

<dd>Sets X to TRUE if object Y can perform method Z; otherwise, X is set to FALSE.</dd><p class="pad"></p>

<dt><a name="does_Ix,_Py,_sz"
>does Ix, Py, sz</a></dt><p class="pad"></p>

<dd>Sets X to TRUE if object Y can implements interface Z; otherwise, X is set to FALSE.</dd><p class="pad"></p>

<dt><a name="isa_Px,_ty"
>isa Px, ty</a></dt><p class="pad"></p>
</dl>

<h2><a name="Module_handling"
>Module handling <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>These opcodes deal with loading in bytecode or executable code libraries, and fetching info about those libraries. This is all dealing with precompiled bytecode or shared libraries.</p>

<dl>
<dt><a name="load_bytecode_sx"
>load_bytecode sx</a></dt><p class="pad"></p>

<dd>Load in the bytecode in file X. Search the library path if need be.</dd><p class="pad"></p>

<dt><a name="load_opcode_lib_sx,_iy"
>load_opcode_lib sx, iy</a></dt><p class="pad"></p>

<dd>Load in the opcode library X, starting at opcode number Y. Search the path if needed.</dd><p class="pad"></p>

<dt><a name="load_string_lib_sx"
>load_string_lib sx</a></dt><p class="pad"></p>

<dd>Load in the string handling library named X</dd><p class="pad"></p>

<dt><a name="get_op_count_sx"
>get_op_count sx</a></dt><p class="pad"></p>

<dd>Return the number of opcodes in opcode library X</dd><p class="pad"></p>

<dt><a name="get_string_name_sx"
>get_string_name sx</a></dt><p class="pad"></p>

<dd>Get the name of the string encoding that the library X handles</dd><p class="pad"></p>

<dt><a name="find_string_lib_sx,_sy"
>find_string_lib sx, sy</a></dt><p class="pad"></p>

<dd>Find the string library that handles strings of type Y. Return its name in X.</dd><p class="pad"></p>
</dl>

<h2><a name="I/O_operations"
>I/O operations <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Reads and writes read and write records, for some value of record.</p>

<dl>
<dt><a name="new_fh_px"
>new_fh px</a></dt><p class="pad"></p>

<dd>Create a new filehandle px</dd><p class="pad"></p>

<dt><a name="open_px,_sy"
>open px, sy</a></dt><p class="pad"></p>

<dd>Open the file Y on filehandle X</dd><p class="pad"></p>

<dt><a name="read_px,_py,_pz"
>read px, py, pz</a></dt><p class="pad"></p>

<dd>Issue a read on the filehandle in y, and put the result in PMC X. PMC Z is the sync object.</dd><p class="pad"></p>

<dt><a name="write_px,_sy,_pz"
>write px, sy, pz</a></dt><p class="pad"></p>

<dd>Write the string Y to filehandle X. PMC Z is the sync object.</dd><p class="pad"></p>

<dt><a name="wait_px"
>wait px</a></dt><p class="pad"></p>

<dd>Wait for the I/O operation represented by sync object X to finish</dd><p class="pad"></p>

<dt><a name="readw_px,_py"
>readw px, py</a></dt><p class="pad"></p>

<dd>Read from filehandle Y and put the results in PMC X. Blocks until the read completes.</dd><p class="pad"></p>

<dt><a name="writew_px,_sy"
>writew px, sy</a></dt><p class="pad"></p>

<dd>Write string Y to filehandle X, waiting for the write to complete.</dd><p class="pad"></p>

<dt><a name="seek_px,_ty"
>seek px, ty</a></dt><p class="pad"></p>

<dd>Seek filehandle X to position Y.</dd><p class="pad"></p>

<dt><a name="tell_tx,_py"
>tell tx, py</a></dt><p class="pad"></p>

<dd>Return the current position of filehandle Y and put it in X. Returns &#45;1 for filehandles where this can&#39;t be determined. (Such as stream connections)</dd><p class="pad"></p>

<dt><a name="status_px,_py,_tz"
>status px, py, tz</a></dt><p class="pad"></p>

<dd>Get informational item Z for filehandle Y and put the result in X. This fetches things like the number of entries in the IO pipe, number of outstanding I/O ops, number of ops on the filehandle, and so forth.</dd><p class="pad"></p>
</dl>

<h2><a name="Threading_ops"
>Threading ops <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="lock_Px"
>lock Px</a></dt><p class="pad"></p>

<dd>Take out a high&#45;level lock on the PMC in register X</dd><p class="pad"></p>

<dt><a name="unlock_Px"
>unlock Px</a></dt><p class="pad"></p>

<dd>Unlock the PMC in register X</dd><p class="pad"></p>

<dt><a name="pushunlock_Px"
>pushunlock Px</a></dt><p class="pad"></p>

<dd>Push an unlock request on the stack</dd><p class="pad"></p>
</dl>

<h2><a name="Interpreter_ops"
>Interpreter ops <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="newinterp_Px,_flags"
>newinterp Px, flags</a></dt><p class="pad"></p>

<dd>Create a new interpreter in X, using the passed flags.</dd><p class="pad"></p>

<dt><a name="runinterp_Px,_iy"
>runinterp Px, iy</a></dt><p class="pad"></p>

<dd>Jump into interpreter X and run the code starting at offset Y from the current location. (This is temporary until we get something better)</dd><p class="pad"></p>

<dt><a name="callout_Pw,_Px,_sy,_pz"
>callout Pw, Px, sy, pz</a></dt><p class="pad"></p>

<dd>Call routine Y in interpreter x, passing it the list of parameters Z. W is a synchronization object returned. It can be waited on like the sync objects returned from async I/O routines.</dd><p class="pad"></p>

<dt><a name="interpinfo_Ix,_iy"
>interpinfo Ix, iy</a></dt><p class="pad"></p>

<dd>Get information item Y and put it in register X. Currently defined are:</dd><p class="pad"></p>

<dl>
<dt><a name="1_TOTAL_MEM_ALLOC"
>1 TOTAL_MEM_ALLOC</a></dt><p class="pad"></p>

<dd>The total amount of system memory allocated for later parceling out to Buffers. Doesn&#39;t include any housekeeping memory, memory for Buffer or PMC structs, or things of that nature.</dd><p class="pad"></p>

<dt><a name="2_DOD_RUNS"
>2 DOD_RUNS</a></dt><p class="pad"></p>

<dd>The total number of dead object detection runs that have been made.</dd><p class="pad"></p>

<dt><a name="3_COLLECT_RUNS"
>3 COLLECT_RUNS</a></dt><p class="pad"></p>

<dd>The total number of memory collection runs that have been made.</dd><p class="pad"></p>

<dt><a name="4_ACTIVE_PMCS"
>4 ACTIVE_PMCS</a></dt><p class="pad"></p>

<dd>The number of PMCs considered active. This means the DOD scan hasn&#39;t noted them as dead.</dd><p class="pad"></p>

<dt><a name="5_ACTIVE_BUFFERS"
>5 ACTIVE_BUFFERS</a></dt><p class="pad"></p>

<dd>The number of Buffers (usually STRINGs but could be other things) considered active.</dd><p class="pad"></p>

<dt><a name="6_TOTAL_PMCS"
>6 TOTAL_PMCS</a></dt><p class="pad"></p>

<dd>The total number of PMCs the interpreter has available. Includes both active and free PMCs</dd><p class="pad"></p>

<dt><a name="7_TOTAL_BUFFERS"
>7 TOTAL_BUFFERS</a></dt><p class="pad"></p>

<dd>The total number of Buffer structs the interpreter has available.</dd><p class="pad"></p>

<dt><a name="8_HEADERS_ALLOC_SINCE_COLLECT"
>8 HEADERS_ALLOC_SINCE_COLLECT</a></dt><p class="pad"></p>

<dd>The number of new Buffer header block allocations that have been made since the last DOD run. (Buffers, when allocated, are allocated in chunks)</dd><p class="pad"></p>

<dt><a name="9_MEM_ALLOCS_SINCE_COLLECT"
>9 MEM_ALLOCS_SINCE_COLLECT</a></dt><p class="pad"></p>

<dd>The number of times we&#39;ve requested a block of memory from the system for allocation to Buffers since the last time we compacted the memory heap.</dd><p class="pad"></p>
</dl>
</dl>

<h2><a name="Garbage_collection"
>Garbage collection <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="sweep"
>sweep</a></dt><p class="pad"></p>

<dd>Fire off a dead object sweep</dd><p class="pad"></p>

<dt><a name="collect"
>collect</a></dt><p class="pad"></p>

<dd>Fire off a garbage collection sweep</dd><p class="pad"></p>

<dt><a name="pausecollect"
>pausecollect</a></dt><p class="pad"></p>

<dd>Pause the garbage collector. No collections will be done for this interpreter until the collector is unpaused.</dd><p class="pad"></p>

<dt><a name="resumecollect"
>resumecollect</a></dt><p class="pad"></p>

<dd>Unpause the collector. This doesn&#39;t necessarily do a GC run, merely allows the interpreter to fire one off when it deems it necessary.</dd><p class="pad"></p>
</dl>

<h2><a name="Key_operations"
>Key operations <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Keys are used to get access to individual elements of an aggregate variable. This is done to allow for opaque, packed, and multidimensional aggregate types.</p>

<p>A key entry may be an integer, string, or PMC. Integers are used for array lookups, strings for hash lookups, and PMCs for either.</p>

<dl>
<dt><a name="new_key_Sx"
>new_key Sx</a></dt><p class="pad"></p>

<dd>Create a new key structure and put a pointer to it in register X.</dd><p class="pad"></p>

<dt><a name="clone_key_Sx,_ky"
>clone_key Sx, ky</a></dt><p class="pad"></p>

<dd>Make a copy of the key Y and put a pointer to it in register X. Y may be either an S register or a constant.</dd><p class="pad"></p>

<dt><a name="size_key_Sx,_iy"
>size_key Sx, iy</a></dt><p class="pad"></p>

<dd>Make the key structure X large enough to hold Y key entries</dd><p class="pad"></p>

<dt><a name="key_size_Ix,_ky"
>key_size Ix, ky</a></dt><p class="pad"></p>

<dd>Put the number of elements in key Y into integer register X.</dd><p class="pad"></p>

<dt><a name="toss_key_Sx"
>toss_key Sx</a></dt><p class="pad"></p>

<dd>Nuke key X. Throws the structure away and invalidates the register.</dd><p class="pad"></p>

<dt><a name="ke_type_Ix,_ky,_iz"
>ke_type Ix, ky, iz</a></dt><p class="pad"></p>

<dd>Put the type of key Y&#39;s entry Z in register X. Current values are 0, 1, and 2 for Integer, String, and PMC, respectively.</dd><p class="pad"></p>

<dt><a name="ke_value_tx,_ky,_iz"
>ke_value tx, ky, iz</a></dt><p class="pad"></p>

<dd>Put the value from key Y, entry Z into register X.</dd><p class="pad"></p>

<dt><a name="chop_key_Sx"
>chop_key Sx</a></dt><p class="pad"></p>

<dd>Toss the topmost entry from key X.</dd><p class="pad"></p>

<dt><a name="inc_key_Sx,_iy"
>inc_key Sx, iy</a></dt><p class="pad"></p>

<dd>Increment entry Y of key X by one.</dd><p class="pad"></p>

<dt><a name="set_key_Sw,_[isp]x,_iy[,_iz]"
>set_key Sw, [isp]x, iy[, iz]</a></dt><p class="pad"></p>

<dd>Set key W, offset Y, to value X. If X is a PMC, then the fourth operand must be specified. It can have a value of 0, 1, or 2, corresponding to integer, string, or object. Aggregates use this to figure out how to treat the key entry.</dd><p class="pad"></p>
</dl>

<h2><a name="Properties"
>Properties <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Properties are a sort of runtime note attached to a PMC. Any PMC can have properties on it. Properties live in a flat namespace, and they are not in any way associated with the class of the PMC that they are attached to.</p>

<p>Properties may be used for runtime notes on variables, or other metadata that may change. They are not for object attributes.</p>

<dl>
<dt><a name="setprop_Px,_sy,_Pz"
>setprop Px, sy, Pz</a></dt><p class="pad"></p>

<dd>Set the property named Y of PMC X to the PMC in Z</dd><p class="pad"></p>

<dt><a name="getprop_Px,_sy,_Pz"
>getprop Px, sy, Pz</a></dt><p class="pad"></p>

<dd>Get the property named Y from PMC Z and put the result in register X. Returns a NULL if the property doesn&#39;t exist.</dd><p class="pad"></p>

<dt><a name="delprop_Px,_sy"
>delprop Px, sy</a></dt><p class="pad"></p>

<dd>Delete the property Y from PMC X</dd><p class="pad"></p>

<dt><a name="prophash_Px,_Py"
>prophash Px, Py</a></dt><p class="pad"></p>

<dd>Fetch the properties from Y, put them in a Hash, and put the Hash in X.</dd><p class="pad"></p>
</dl>

<h2><a name="Symbolic_support_for_HLLs"
>Symbolic support for HLLs <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="setline_ix"
>setline ix</a></dt><p class="pad"></p>

<dd>Sets the &#39;current line&#39; marker.</dd><p class="pad"></p>

<dt><a name="setfile_sx"
>setfile sx</a></dt><p class="pad"></p>

<dd>Sets the &#39;current file&#39; marker.</dd><p class="pad"></p>

<dt><a name="setpackage_sx"
>setpackage sx</a></dt><p class="pad"></p>

<dd>Sets the &#39;current package&#39; marker.</dd><p class="pad"></p>

<dt><a name="getline_ix"
>getline ix</a></dt><p class="pad"></p>

<dd>Fetches the &#39;current line&#39; marker.</dd><p class="pad"></p>

<dt><a name="getfile_sx"
>getfile sx</a></dt><p class="pad"></p>

<dd>Fetches the &#39;current file&#39; marker.</dd><p class="pad"></p>

<dt><a name="getpackage_sx"
>getpackage sx</a></dt><p class="pad"></p>

<dd>Fetches the &#39;current package&#39; marker.</dd><p class="pad"></p>
</dl>

<h2><a name="Foreign_library_access"
>Foreign library access <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>These are the ops we use to load in and interface to non&#45;parrot libraries.</p>

<dl>
<dt><a name="loadlib_Px,_Sy"
>loadlib Px, Sy</a></dt><p class="pad"></p>

<dd>Load in the library whose name is specified by y, and put a handle to it into P register x.</dd><p class="pad"></p>

<dt><a name="dlfunc_Pw,_Px,_Sy,_Sz"
>dlfunc Pw, Px, Sy, Sz</a></dt><p class="pad"></p>

<dd>Find a routine named Y, in library X (which you did, of course, open with loadlib), and put a sub PMC onto W for it. You can call this sub as if it were any other parrot subroutine.</dd><p class="pad"></p>

<dd>Z has the function signature, which tells Parrot how to build the interface from parrot (and parrot&#39;s calling conventions) to the calling conventions of the library routine. Yes, this does mean that you must know the function signature, but if you don&#39;t know that why the heck would you be invoking the function, right?</dd><p class="pad"></p>

<dd>The signature is a series of 1 or more characters, representing the types for the call. The first character is the return type, while the rest are the parameters. The types are:</dd><p class="pad"></p>

<dl>
<dt><a name="v"
>v</a></dt><p class="pad"></p>

<dd>Void. As a return type indicates that there <i>is</i> no return type. As a parameter indicates that there are no parameters. Can&#39;t be mixed with other parameter types.</dd><p class="pad"></p>

<dt><a name="c"
>c</a></dt><p class="pad"></p>

<dd>Char. This is an integer type, taken from (or put into) an I register.</dd><p class="pad"></p>

<dt><a name="s"
>s</a></dt><p class="pad"></p>

<dd>short. An integer type, taken from 0 or put into an I register</dd><p class="pad"></p>

<dt><a name="i"
>i</a></dt><p class="pad"></p>

<dd>int. An integer type.</dd><p class="pad"></p>

<dt><a name="l"
>l</a></dt><p class="pad"></p>

<dd>long. An integer type. You know the drill.</dd><p class="pad"></p>

<dt><a name="f"
>f</a></dt><p class="pad"></p>

<dd>float. F register denizen.</dd><p class="pad"></p>

<dt><a name="d"
>d</a></dt><p class="pad"></p>

<dd>double. F register, double&#45;precision floating point type</dd><p class="pad"></p>

<dt><a name="p"
>p</a></dt><p class="pad"></p>

<dd>PMC thingie. A generic pointer, taken from or stuck into a PMC&#39;s data pointer. If this is a return type, parrot will create a new UnManagedStruct PMC type, which is just a generic &#34;pointer so some damn thing or other&#34; PMC type which Parrot does <i>no</i> management of.</dd><p class="pad"></p>

<dt><a name="t"
>t</a></dt><p class="pad"></p>

<dd>string pointer. Taken from, or stuck into, a string register. (Converted to a null&#45;terminated C string before passing in)</dd><p class="pad"></p>
</dl>

<dd>So the signature for, for example, this SDL routine:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>   int SDL_BlitSurface(SDL_Surface *src, SDL_Rect *srcrect, SDL_Surface *dst, SDL_Rect *dstrect);</pre>

<dd>would be <code lang='und' xml:lang='und'>ipppp</code>, since it returns an integer and takes four pointers. Presumably previous calls would have set those pointers up properly.</dd><p class="pad"></p>

<dd>Do note that parrot makes no guarantees as to the behaviour of the libraries, and currently does no type checking on the input parameters. We will fix that later.</dd><p class="pad"></p>

<dd>The generated routine follows the calling conventions in PDD03. Note that int, string, pmc, and float parameters are counted separately. So if you have a signature of <code lang='und' xml:lang='und'>ippiidd</code> the return goes into I5, and the parameters come from P5, P6, I5, I6, N5, and N6, respectively. A signature of <code lang='und' xml:lang='und'>ipdiidp</code> has the identical same set of registers used (and in the same order).</dd><p class="pad"></p>

<dt><a name="invoke"
>invoke</a></dt><p class="pad"></p>

<dd>Invoke a subroutine in P0. Presumes that all the registers are set up right for the call. The invoked subroutine <i>must</i> preserve any registers that are not explicitly return parameters or calling convention metadata parameters. (Such as the number of I reg parameters, for example)</dd><p class="pad"></p>
</dl>

<h2><a name="Runtime_compilation"
>Runtime compilation <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>These opcodes deal with runtime creation of bytecode and compilation of source code.</p>

<dl>
<dt><a name="compile_Px,_Py,_Sz"
>compile Px, Py, Sz</a></dt><p class="pad"></p>

<dd>Compile source string Z, with compiler unit Y, and stick a handle to a subroutine for the resulting bytecode segment (already loaded into the current interpreter) into X.</dd><p class="pad"></p>

<dd>Y is a assembler/compiler object of some sort, as registered with the <b>compreg</b> opcode or the Parrot_compreg function. This will be something like &#34;Perl5&#34;, &#34;Perl6&#34;, &#34;Perl5RE&#34;, &#34;Perl6RE&#34;, &#34;Python&#34;, &#34;Ruby&#34;... you get the picture.</dd><p class="pad"></p>

<dd>Parrot knows of a &#34;PASM1&#34; compiler, i.e. a one statement PASM compiler implemented as PDB_eval. Imcc registers &#34;PASM&#34; and &#34;PIR&#34; compilers.</dd><p class="pad"></p>

<dd>This is a high&#45;level op, with the assumption that the resulting sub will be called. It&#39;s the equivalent of perl 5&#39;s string eval, except for the actual execution of the resulting code.</dd><p class="pad"></p>

<dt><a name="compreg_Px,_Sy"
>compreg Px, Sy</a></dt><p class="pad"></p>

<dd>Get a compiler for source type Y.</dd><p class="pad"></p>

<dt><a name="compreg_Sx,_Py"
>compreg Sx, Py</a></dt><p class="pad"></p>

<dd>Register the sub Y as a parser/compiler function named X. It will be called whenever anyone invokes the compile op with the name X.</dd><p class="pad"></p>
</dl>

<h1><a name="ATTACHMENTS"
>ATTACHMENTS <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>None.</p>

<h1><a name="REFERENCES"
>REFERENCES <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>None.</p>

<h1><a name="VERSION"
>VERSION <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>None.</p>

<h2><a name="CURRENT"
>CURRENT <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<pre lang='und' xml:lang='und'>    Maintainer: Dan Sugalski
    Class: Internals
    PDD Number: 6
    Version: 1.8
    Status: Developing
    Last Modified: 02 December 2002
    PDD Format: 1
    Language: English</pre>

<h2><a name="HISTORY"
>HISTORY <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="Version_1.8"
>Version 1.8</a></dt><p class="pad"></p>

<dd>December 11, 2002</dd><p class="pad"></p>

<dt><a name="Version_1.7"
>Version 1.7</a></dt><p class="pad"></p>

<dd>December 02, 2002</dd><p class="pad"></p>

<dt><a name="Version_1.6"
>Version 1.6</a></dt><p class="pad"></p>

<dd>November 05, 2001</dd><p class="pad"></p>

<dt><a name="Version_1.5"
>Version 1.5</a></dt><p class="pad"></p>

<dd>October 12, 2001</dd><p class="pad"></p>

<dt><a name="Version_1.4"
>Version 1.4</a></dt><p class="pad"></p>

<dd>September 24, 2001</dd><p class="pad"></p>

<dt><a name="Version_1.3"
>Version 1.3</a></dt><p class="pad"></p>

<dd>September 12, 2001</dd><p class="pad"></p>

<dt><a name="Version_1.2"
>Version 1.2</a></dt><p class="pad"></p>

<dd>August 25, 2001</dd><p class="pad"></p>

<dt><a name="Version_1.1"
>Version 1.1</a></dt><p class="pad"></p>

<dd>August 8, 2001</dd><p class="pad"></p>

<dt><a name="version_1"
>version 1</a></dt><p class="pad"></p>

<dd>None. First version</dd><p class="pad"></p>
</dl>

<h1><a name="CHANGES"
>CHANGES <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<dl>
<dt><a name="Version_1.8"
>Version 1.8</a></dt><p class="pad"></p>

<ul>
<li>Added property ops</li><p class="pad"></p>

<li>Fixed some bad register designations</li><p class="pad"></p>

<li>Opened up opcode name character list to include numbers</li><p class="pad"></p>
</ul>

<dt><a name="Version_1.7"
>Version 1.7</a></dt><p class="pad"></p>

<ul>
<li>Fixed stack ops</li><p class="pad"></p>

<p>push, pop, and clear properly documented according to the engine&#39;s behaviour now.</p>
</ul>

<dt><a name="Version_1.6"
>Version 1.6</a></dt><p class="pad"></p>

<ul>
<li>Added GC opcodes</li><p class="pad"></p>
</ul>

<dt><a name="Version_1.5"
>Version 1.5</a></dt><p class="pad"></p>

<ul>
<li>Now have a bsr in addition to a jsr</li><p class="pad"></p>

<li>return is now ret</li><p class="pad"></p>

<li>Added save and restore ops for saving and restoring individual registers</li><p class="pad"></p>
</ul>

<dt><a name="Version_1.4"
>Version 1.4</a></dt><p class="pad"></p>

<ul>
<li>Conditional branches have just a true destination now</li><p class="pad"></p>

<li>Added the I/O ops</li><p class="pad"></p>

<li>Added in the threading ops</li><p class="pad"></p>

<li>Added in the interpreter ops</li><p class="pad"></p>
</ul>

<dt><a name="Version_1.3"
>Version 1.3</a></dt><p class="pad"></p>

<ul>
<li>Added in the low&#45;level module loading ops</li><p class="pad"></p>

<li>Added in transcendental functions and modulo</li><p class="pad"></p>

<li>Finished the pad/global variable fetching bits</li><p class="pad"></p>
</ul>

<dt><a name="Version_1.2"
>Version 1.2</a></dt><p class="pad"></p>

<dd>We have an interpreter now! Yay! (Okay, a simple one, but still...) Changes made to reflect that.</dd><p class="pad"></p>

<dt><a name="Version_1.1"
>Version 1.1</a></dt><p class="pad"></p>

<ul>
<li>Added in object</li><p class="pad"></p>

<li>Changed remnants of &#34;perl&#34; to &#34;Parrot&#34;</li><p class="pad"></p>

<li>Branch destination may be integer constant</li><p class="pad"></p>

<li>Added <a href='#Assembly_Syntax'>&#34;Assembly Syntax&#34;</a> section</li><p class="pad"></p>
</ul>

<dt><a name="Version_1.0"
>Version 1.0</a></dt><p class="pad"></p>

<dd>None. First version</dd><p class="pad"></p>
</dl>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
