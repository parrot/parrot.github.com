<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
    <HEAD>
        <TITLE>Readme file for PIRC compiler, a fresh implementation of</TITLE>
        <LINK REL="stylesheet" TYPE="text/css"
            HREF="../../../resources/perl.css"
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY>
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Readme file for PIRC compiler, a fresh implementation of</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../html/index.html">Contents</a> | <a href="../../../html/compilers.html">Compilers</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>README.txt &#45; Readme file for PIRC compiler,
a fresh implementation of the PIR language using Bison and Flex.</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>PIRC is a fresh implementation of the PIR language.
Maintaining the current default implementation (IMCC) is a bit of a pain,
and it contains a lot of &#34;XXX&#34; and &#34;TODO&#34; and other kludge alerts.
Furthermore,
IMCC is not re&#45;entrant,
as it has a number of global variables.</p>

<h2><a name="Overview"
>Overview <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>The new Bison/Flex based implementation of the PIR compiler is designed as a three&#45;stage compiler:</p>

<dl>
<dt><a name="1._Heredoc_preprocessor"
>1.
Heredoc preprocessor</a></dt><p class="pad"></p>

<dt><a name="2._Macro_preprocessor"
>2.
Macro preprocessor</a></dt><p class="pad"></p>

<dt><a name="3._PIR_compiler"
>3.
PIR compiler</a></dt><p class="pad"></p>
</dl>

<h2><a name="Heredoc_preprocessing"
>Heredoc preprocessing <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>The heredoc preprocessor takes the input as written by the PIR programmer,
and flattens out all heredoc strings.
An example is shown below to illustrate this concept:</p>

<p>The following input:</p>

<pre lang='und' xml:lang='und'> .sub main
   $S0 = &#60;&#60;&#39;EOS&#39;
 This is a heredoc string
   divided
     over
       five
         lines.
 EOS
 .end</pre>

<p>is transformed into:</p>

<pre lang='und' xml:lang='und'> .sub
   $S0 = &#34;This is a heredoc string\n  divided\n    over\n      five\n        lines.\n&#34;
 .end</pre>

<h2><a name="Macro_preprocessing"
>Macro preprocessing <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>The macro layer basically implements text replacements. The following directives are handled:</p>

<dl>
<dt><a name=".include"
><b><code lang='und' xml:lang='und'>.include</b></code></a></dt><p class="pad"></p>

<dt><a name=".macro"
><b><code lang='und' xml:lang='und'>.macro</b></code></a></dt><p class="pad"></p>

<dt><a name=".macro_const"
><b><code lang='und' xml:lang='und'>.macro_const</b></code></a></dt><p class="pad"></p>
</dl>

<h3><a name=".include"
><code lang='und' xml:lang='und'>.include</code></a></h3>

<p>The <code lang='und' xml:lang='und'>.include</code> directive takes a string argument, which is the name of a file. The contents of this file are inserted at the point where the <code lang='und' xml:lang='und'>.include</code> directive is written. To illustrate this, consider the following example:</p>

<pre lang='und' xml:lang='und'> main.pir:
 ========================
 .sub main
   print &#34;hi\n&#34;
   foo()
 .end

 .include &#34;lib.pir&#34;
 ========================

 lib.pir:
 ========================
 .sub foo
   print &#34;foo\n&#34;
 .end
 ========================</pre>

<p>This will result in the following output:</p>

<pre lang='und' xml:lang='und'> .sub main
   print &#34;hi\n&#34;
   foo()
 .end

 .sub foo
   print &#34;foo\n&#34;
 .end</pre>

<h3><a name=".macro"
><code lang='und' xml:lang='und'>.macro</code></a></h3>

<p>The macro directive starts a macro definition. The macro preprocessor implements the expansion of macros. For instance, given the following input:</p>

<pre lang='und' xml:lang='und'> .macro say(msg)
   print .msg
   print &#34;\n&#34;
 .endm

 .sub main
   .say(&#34;hi there!&#34;)
 .end</pre>

<p>will result in this output:</p>

<pre lang='und' xml:lang='und'> .sub main
   print &#34;hi there!&#34;
   print &#34;\n&#34;
 .end</pre>

<h3><a name=".macro_const"
><code lang='und' xml:lang='und'>.macro_const</code></a></h3>

<p>The <code lang='und' xml:lang='und'>.macro_const</code> directive is similar to the <code lang='und' xml:lang='und'>.macro</code> directive, except that a <code lang='und' xml:lang='und'>.macro_const</code> is just a simplified <code lang='und' xml:lang='und'>.macro</code>; it merely gives a name to some constant:</p>

<pre lang='und' xml:lang='und'> .macro_const PI 3.14

 .sub main
   print &#34;PI is approximately: &#34;
   print .PI
   print &#34;\n&#34;
 .end</pre>

<p>This will result in the output:</p>

<pre lang='und' xml:lang='und'> .sub main
   print &#34;PI is approximately: &#34;
   print 3.14
   print &#34;\n&#34;
 .end</pre>

<h2><a name="PIR_Compiler"
>PIR Compiler <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>The output of the macro preprocessor is fed to the actual PIR compiler. The PIR compiler builds a data structure during the parsing phase (often referred to as an Abstract Syntax Tree &#45; AST). The rest of this section describes the features of the PIR compiler.</p>

<h3><a name="Instruction_selection"
>Instruction selection</a></h3>

<p>As Parrot instructions are polymorphic, the PIR compiler is responsible for selecting the right variant of the instruction. The selection is based on the types of the operands. For instance:</p>

<pre lang='und' xml:lang='und'> set $I0, 42</pre>

<p>will select the <code lang='und' xml:lang='und'>set_i_ic</code> instruction: this is the <code lang='und' xml:lang='und'>set</code> instruction, taking an integer (i) result operand and an integer constant (ic) operand. Other examples are:</p>

<pre lang='und' xml:lang='und'> $P0[1] = 42           &#45;&#45;&#62; set_p_kic_ic # kic = key integer constant
 $I0 = $P0[&#34;hi&#34;]       &#45;&#45;&#62; set_i_p_kc   # kc = key constant from constant table
 $P1 = new &#34;Hash&#34;      &#45;&#45;&#62; set_p_sc     # sc = string constant</pre>

<h3><a name="Constant_folding"
>Constant folding</a></h3>

<p>Expressions that can be evaluated at compile&#45;time are pre&#45;evaluated, saving calculations during runtime. Some constant&#45;folding is required, as Parrot depends on this. For instance:</p>

<pre lang='und' xml:lang='und'> add $I0, 1, 2</pre>

<p>is not a valid Parrot instruction; there is no <code lang='und' xml:lang='und'>add_i_ic_ic</code> instruction. Instead, this will be translated to:</p>

<pre lang='und' xml:lang='und'> set $I0, 3</pre>

<p>which, as was explained earlier, will select the <code lang='und' xml:lang='und'>set_i_ic</code> instruction.</p>

<p>The conditional branch instructions are also pre&#45;evaluated, if possible. For instance, consider the following statement:</p>

<pre lang='und' xml:lang='und'> if 1 &#60; 2 goto L1</pre>

<p>It is clear during compile time, that 1 is smaller than 2; so instead of evaluating this during runtime, we know for sure that the branch to label <code lang='und' xml:lang='und'>L1</code> will be made, effectively replacing the above statement by:</p>

<pre lang='und' xml:lang='und'> goto L1</pre>

<p>Likewise, if it&#39;s clear that certain instructions don&#39;t have any effect, they can be removed altogether:</p>

<pre lang='und' xml:lang='und'> if 1 &#62; 2 goto L1        &#45;&#45;&#62; nop  # nop is no opcode.
 $I0 = $I0 + 0           &#45;&#45;&#62; nop</pre>

<p>Another type of optimization is the selection of (slightly) more efficient variants of instructions. For instance, consider the following instruction:</p>

<pre lang='und' xml:lang='und'> $I0 = $I0 + $I1</pre>

<p>which is actually syntactic sugar for:</p>

<pre lang='und' xml:lang='und'> add $I0, $I0, $I1</pre>

<p>In C one would write (ignoring the fact that $I0 and $I0 are not a valid C identifiers):</p>

<pre lang='und' xml:lang='und'> $I0 += $I1</pre>

<p>which is in fact valid PIR as well. When the PIR parser sees an instruction of this form, it will automatically select the variant with 2 operands instead of the 3&#45;operand variant. So:</p>

<pre lang='und' xml:lang='und'> add $I0, $I0, $1    # $I0 is an out operand</pre>

<p>will be optimized, as if you had written:</p>

<pre lang='und' xml:lang='und'> add $I0, $I1        # $I0 is an in/out operand</pre>

<p>The PIR parser can do even more improvements, if it sees opportunity to do so. Consider the following statement:</p>

<pre lang='und' xml:lang='und'> $I0 = $I0 + 1</pre>

<p>or, in Parrot assembly syntax:</p>

<pre lang='und' xml:lang='und'> add $I0, $I0, 1</pre>

<p>Again, in C one would write (again ignoring the valid identifier issue): <code lang='und' xml:lang='und'>$I0++</code>, or in other words, <code lang='und' xml:lang='und'>incrementing</code> the given identifier. Parrot has <code lang='und' xml:lang='und'>inc</code> and <code lang='und' xml:lang='und'>dec</code> instructions built&#45;in as well, so that the above statement <code lang='und' xml:lang='und'>$I0 = $I0 + 1</code> can be optimized to:</p>

<pre lang='und' xml:lang='und'> inc $I0</pre>

<h3><a name="Vanilla_Register_Allocator"
>Vanilla Register Allocator</a></h3>

<p>The PIR compiler implements a vanilla register allocator. This means that each declared <code lang='und' xml:lang='und'>.local</code> or <code lang='und' xml:lang='und'>.param</code> symbol, and each PIR register ($Px, $Sx, $Ix, $Nx) is assigned a unique PASM register, that is associated with the original symbol or PIR register throughout the subroutine.</p>

<p>Any further optimizations on register usage can be implemented by writing a register allocator that takes this initial register allocation as input, and generating a more optimized register usage. Research and benchmarking is needed to decide whether this yields more efficient bytecode. In the end it is a choice between compile&#45;time overhead (register allocation) or runtime memory overhead (more register space needed per sub).</p>

<p>The implementation of the vanilla register allocator is done in the PIR symbol management module (<code lang='und' xml:lang='und'>pirsymbol.c</code>).</p>

<h2><a name="Status"
>Status <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>The PIR parser is complete, but should be tested intensively. The back&#45;end creates a data structure representing the input. Currently, only (almost working) PASM output is generated, but eventually a Parrot Byte Code (PBC) file should be generated. In order to do this, we need a proper API to generate the appropriate data structures (such as Parrot PackFile and friends).</p>

<h1><a name="IMPLEMENTATION"
>IMPLEMENTATION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>The directory compilers/pirc has a number of subdirectories:</p>

<dl>
<dt><a name="doc_&#45;_contains_documentation."
>doc &#45; contains documentation.</a></dt><p class="pad"></p>

<dt><a name="heredoc_&#45;_contains_the_implementation_of_the_heredoc_preprocessor"
>heredoc &#45; contains the implementation of the heredoc preprocessor</a></dt><p class="pad"></p>

<dt><a name="macro_&#45;_contains_the_implementation_of_the_macro_layer"
>macro &#45; contains the implementation of the macro layer</a></dt><p class="pad"></p>

<dt><a name="new_&#45;_contains_the_Bison/Flex_implementation_of_PIRC"
>new &#45; contains the Bison/Flex implementation of PIRC</a></dt><p class="pad"></p>

<dt><a
>src &#45; contains the hand&#45;written, recursive&#45;descent implementation of PIRC. Note that this is no longer maintained at the moment.</a></dt><p class="pad"></p>

<dt><a name="t_&#45;_for_tests."
>t &#45; for tests.</a></dt><p class="pad"></p>
</dl>

<h1><a name="NOTES"
>NOTES <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<h2><a name="Usage"
>Usage <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Currently the different compilers/pre&#45;processors are located in different directories. The different pre&#45;processors are invoked from the main driver in pirc.c. The latter assumes all three processors are compiled, as the following executables:</p>

<pre lang='und' xml:lang='und'> heredoc pre&#45;processor: hdocprep
 macro pre&#45;processor:   macroparser</pre>

<p>Running a file through the whole PIR compiler is then done as follows:</p>

<pre lang='und' xml:lang='und'> $ ./pirc test.pir</pre>

<p>When you want to run the heredoc pre&#45;processor only, do this:</p>

<pre lang='und' xml:lang='und'> $ ./pirc &#45;H test.pir</pre>

<p>When you want to pre&#45;process the file only (heredoc + macro parsing), do this:</p>

<pre lang='und' xml:lang='und'> $ ./pirc &#45;E test.pir</pre>

<h2><a name="Cygwin_processable_lexer_spec."
>Cygwin processable lexer spec. <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>The file <code lang='und' xml:lang='und'>pir.l</code> from which the lexer is generated is <i>not</i> processable by Cygwin&#39;s default version of Flex. In order to make a reentrant lexer, a newer version is needed, which can be downloaded from the link below.</p>

<p><a href='http://sourceforge.net/project/downloading.php?groupname=flex&#38;filename=flex&#45;2.5.33.tar.gz&#38;use_mirror=belnet'><a href="http://sourceforge.net/project/downloading.php?groupname=flex&#38;filename=flex&#45;2.5.33.tar.gz&#38;use_mirror=belnet">http://sourceforge.net/project/downloading.php?groupname=flex&#38;filename=flex&#45;2.5.33.tar.gz&#38;use_mirror=belnet</a></a></p>

<p>Just do:</p>

<pre lang='und' xml:lang='und'> $ ./configure
 $ make</pre>

<p>Then make sure to overwrite the supplied flex binary.</p>

<h1><a name="BUGS"
>BUGS <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Having a look at this implementation would be greatly appreciated, and any resulting feedback even more :&#45;)</p>

<ul>
<li>All, except the first heredoc argument, contains 1 newline character too many. Heredoc parsing is a bit complex, and there might be many other issues.</li><p class="pad"></p>

<li>Memory management needs to be improved.</li><p class="pad"></p>

<li>Braced macro argument handling needs a lot of testing.</li><p class="pad"></p>

<li>The current design does not allow any heredocs in <code lang='und' xml:lang='und'>.include</code>d files, because the <code lang='und' xml:lang='und'>.include</code> directive is implemented in the second phase. This issue should be solved at some point. A possible solution is to combine the heredoc and macro preprocessors, however this might result in unmaintainable code. Another solution would be to implement the heredoc preprocessor in plain C, as opposed to the Flex implementation.</li><p class="pad"></p>
</ul>

<h1><a name="FUTURE_WORK:_HELP_WANTED"
>FUTURE WORK: HELP WANTED <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Eventually, either IMCC needs to be fixed rigorously, or, rewritten altogether. PIRC is an attempt to do the latter. The following things need to be considered when replacing IMCC with PIRC:</p>

<ul>
<li>is_op</li><p class="pad"></p>

<p>PIRC needs a function to decide whether an identifier is an instruction. IMCC uses a function is_op that does this. For this to work, libparrot must be linked in, and I&#39;m having trouble doing this.</p>

<li>instruction code</li><p class="pad"></p>

<p>The PIR compiler can already decide what variant of an instruction must be used; for instance, for <code lang='und' xml:lang='und'>set $I0, 42</code> the <code lang='und' xml:lang='und'>set_i_ic</code> variant must be selected. However, the actual opcode for an instruction must be retrieved, because these must be written to a PBC file.</p>

<li>PIR sub storage</li><p class="pad"></p>

<p>PIR subs are stored as PMC constants in the constant table, but it is not clear how exactly this is to be done.</p>

<li>bytecode generation</li><p class="pad"></p>

<p>There must be a proper bytecode API for PIRC to use.</p>

<li><code lang='und' xml:lang='und'>:immediate</code> and related flags</li><p class="pad"></p>

<p>Flags such as <code lang='und' xml:lang='und'>:immediate</code> must be implemented; a sub that is marked with the <code lang='und' xml:lang='und'>:immediate</code> flag must be run immediately after compilation.</p>
</ul>

<h1><a name="SEE_ALSO"
>SEE ALSO <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>See also:</p>

<ul>
<li><code lang='und' xml:lang='und'>languages/PIR</code> for a PGE based implementation.</li><p class="pad"></p>

<li><code lang='und' xml:lang='und'>compilers/pirc</code>, a hand&#45;written, recursive&#45;descent PIR parser.</li><p class="pad"></p>

<li><code lang='und' xml:lang='und'>compilers/imcc</code>, the current <i>standard</i> PIR implementation.</li><p class="pad"></p>

<li><code lang='und' xml:lang='und'>docs/imcc/syntax.pod</code> for a description of PIR syntax.</li><p class="pad"></p>

<li><code lang='und' xml:lang='und'>docs/imcc/</code> for more documentation about the PIR language.</li><p class="pad"></p>

<li><code lang='und' xml:lang='und'>docs/pdds/pdd19_pir.pod</code> for the PIR design document.</li><p class="pad"></p>
</ul>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../resources/parrot_small.png"
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
