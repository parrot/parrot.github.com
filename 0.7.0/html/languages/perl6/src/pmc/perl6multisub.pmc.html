<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
    <HEAD>
        <TITLE>Perl 6 MultiSub PMC</TITLE>
        <LINK REL="stylesheet" TYPE="text/css"
            HREF="../../../../../resources/perl.css"
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY>
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Perl 6 MultiSub PMC</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../../../html/index.html">Contents</a> | <a href="../../../../../html/languages.html">Language Implementations</a> | <a href="../../../../../html/perl6.html">Perl6</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../../../resources/up.gif'></a></a></h1>

<p>src/pmc/perl6multiub.pmc &#45; Perl 6 MultiSub PMC</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../../../resources/up.gif'></a></a></h1>

<p>Subclass of MultiSub that overrides invoke to implement the Perl 6 multiple dispatch algorithm,
along with providing various other pieces.</p>

<p>Since we need to store some extra information,
we cannot just actually be a ResizablePMCArray,
but rather we need to have one.</p>

<h1><a name="TODO"
>TODO <a href='#_top'><img alt='^' border=0 src='../../../../../resources/up.gif'></a></a></h1>

<p>This is a list of things that I need to deal with/come back and worry about later (it&#39;s not a complete todo list for finishing up the PMC itself,
just of fixup tasks in what is already done).</p>

<dl>
<dt><a name="Use_Perl_6_types_when_boxing_native_arguments_in_the_arg_list"
>Use Perl 6 types when boxing native arguments in the arg list</a></dt><p class="pad"></p>

<dt><a
>Fix pmc2c so we can have ATTR candidate_info **candidates_sorted.
We will have to move them to their own .h file,
but in pmc2c we need to be able to include that *before* this PMC&#39;s generated .h file (I couldn&#39;t work out how to do that) and also make it parse double indirections.
Then we can toss any (candidate_info**) casts.</a></dt><p class="pad"></p>

<dt><a
>Make sure we override everything that ResizablePMCArray and its parents would provide us with.
Otherwise,
we&#39;ll just get segfaults &#39;cus we don&#39;t store stuff the way it does.</a></dt><p class="pad"></p>
</dl>

<h1><a name="INTERNAL_STRUCTURES"
>INTERNAL STRUCTURES <a href='#_top'><img alt='^' border=0 src='../../../../../resources/up.gif'></a></a></h1>

<p>We have some structures that we use to keep data around internally.</p>

<dl>
<dt><a name="candidate_info"
>candidate_info</a></dt><p class="pad"></p>

<dd>Represents a candidate.
We extract various bits of information about it when we are building the sorted candidate list and store them in here for fast access during a dispatch.</dd><p class="pad"></p>

<dd>*/</dd><p class="pad"></p>

<dd>#include &#34;parrot/oplib/ops.h&#34;</dd><p class="pad"></p>

<dd>typedef struct candidate_info { PMC *sub; /* The sub that is the candidate.
*/ INTVAL min_arity; /* The number of required positonal arguments.
*/ INTVAL max_arity; /* The number of required and optional positional arguments.
*/ PMC **types; /* Class or role type constraints for each parameter.
*/ PMC **constraints; /* Refinement type constraints for each parameter (if there * are many,
this will be a junction).
*/ INTVAL num_types; /* Number of entries in the above two arrays.
*/ } candidate_info;</dd><p class="pad"></p>

<dd>/*</dd><p class="pad"></p>

<dt><a name="candidate_graph_node"
>candidate_graph_node</a></dt><p class="pad"></p>

<dd>Represents the produced information about a candidate as well as the graph edges originating from it.
The edges array contains pointers to the edges in the graph that we have arrows to.</dd><p class="pad"></p>

<dd>*/ typedef struct candidate_graph_node { candidate_info *info; struct candidate_graph_node **edges; INTVAL edges_in; INTVAL edges_out; } candidate_graph_node;</dd><p class="pad"></p>

<dd>/*</dd><p class="pad"></p>
</dl>

<h1><a name="FUNCTIONS"
>FUNCTIONS <a href='#_top'><img alt='^' border=0 src='../../../../../resources/up.gif'></a></a></h1>

<p>These are worker functions used by the methods of the PMC,
and not visible from the outside.</p>

<dl>
<dt><a name="static_PMC*_get_args()"
><b><code lang='und' xml:lang='und'>static PMC *get_args()</b></code></a></dt><p class="pad"></p>

<dd>Gets a list of the arguments that are being passed,
taking them from the registers and the constants table and flattening any :flat arguments as required.
Returns a ResizablePMCArray of them.</dd><p class="pad"></p>

<dt><a name="static_INTVAL_is_narrower(PARROT_INTERP,_candidate_info_*a,_candidate_info_*b)"
><b><code lang='und' xml:lang='und'>static INTVAL is_narrower(PARROT_INTERP, candidate_info *a, candidate_info *b)</b></code></a></dt><p class="pad"></p>

<dd>Takes two candidates and determines if the first one is narrower than the second.
Returns a true value if they are.</dd><p class="pad"></p>

<dd>*/ static INTVAL is_narrower(PARROT_INTERP,
candidate_info *a,
candidate_info *b) { STRING *ACCEPTS = CONST_STRING(interp,
&#34;ACCEPTS&#34;); INTVAL narrower = 0; INTVAL tied = 0; INTVAL i;</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    /* Check if they have the same number of effective parameters &#45; if
     * not, incomparable. */
    if (a&#45;&#62;num_types != b&#45;&#62;num_types)
        return 0;

    /* Analyse each parameter in the two candidates. */
    for (i = 0; i &#60; a&#45;&#62;num_types; i++) {
        PMC *type_obj_a = a&#45;&#62;types[i];
        PMC *type_obj_b = b&#45;&#62;types[i];
        if (type_obj_a == type_obj_b) {
            /* Same type, so tied. */
            tied++;
        }
        else {
            PMC *accepts_meth_a = VTABLE_find_method(interp, type_obj_b, ACCEPTS);
            PMC *result_n = (PMC *) Parrot_run_meth_fromc_args(interp, accepts_meth_a, type_obj_b,
                    ACCEPTS, &#34;PP&#34;, type_obj_a);
            if (VTABLE_get_integer(interp, result_n)) {
                /* Narrower &#45; note it and we&#39;re done. */
                narrower++;
            }
            else {
                /* Make sure it&#39;s tied, rather than the other way around. */
                PMC *accepts_meth_b = VTABLE_find_method(interp, type_obj_a, ACCEPTS);
                PMC *result_w = (PMC *) Parrot_run_meth_fromc_args(interp,
                        accepts_meth_b, type_obj_a,
                        ACCEPTS, &#34;PP&#34;, type_obj_b);
                if (!VTABLE_get_integer(interp, result_w)) {
                    tied++;
                }
            }
        }
    }

    return narrower &#62; 1 &#38;&#38; narrower + tied == a&#45;&#62;num_types;
}</pre>

<dd>/*</dd><p class="pad"></p>

<dt><a name="static_candidate_info**_sort_candidiates(PMC_*candidates)"
><b><code lang='und' xml:lang='und'>static candidate_info** sort_candidiates(PMC *candidates)</b></code></a></dt><p class="pad"></p>

<dd>Takes a ResizablePMCArray of the candidates, collects information about them and then does a topological sort of them.</dd><p class="pad"></p>

<dd>*/ static candidate_info** sort_candidiates(PARROT_INTERP, PMC *candidates) { INTVAL i, j, sig_elems, candidates_to_sort, result_pos; PMC *signature, *params, *meth;</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    /* Allocate results array (just allocate it for worst case, which
     * is no ties ever, so a null between all of them, and then space
     * for the terminating null. */
    INTVAL num_candidates = VTABLE_elements(interp, candidates);
    candidate_info** result = mem_allocate_n_zeroed_typed(
            2 * num_candidates + 1, candidate_info*);

    /* Create a node for each candidate in the graph. */
    candidate_graph_node** graph = mem_allocate_n_zeroed_typed(
            num_candidates, candidate_graph_node*);
    for (i = 0; i &#60; num_candidates; i++) {
        /* Get information about this candidate. */
        candidate_info *info = mem_allocate_zeroed_typed(candidate_info);
        PMC *candidate = VTABLE_get_pmc_keyed_int(interp, candidates, i);
        info&#45;&#62;sub = candidate;

        /* Arity. */
        info&#45;&#62;min_arity = VTABLE_get_integer(interp,
                VTABLE_inspect_str(interp, candidate, CONST_STRING(interp, &#34;pos_required&#34;)));
        if (VTABLE_get_integer(interp, VTABLE_inspect_str(interp, candidate,
               CONST_STRING(interp, &#34;pos_slurpy&#34;))))
            info&#45;&#62;max_arity = 1 &#60;&#60; 30;
        else
            info&#45;&#62;max_arity = info&#45;&#62;min_arity + VTABLE_get_integer(interp,
                    VTABLE_inspect_str(interp, candidate, CONST_STRING(interp, &#34;pos_optional&#34;)));

        /* Type information. */
        meth = VTABLE_find_method(interp, candidate,
                CONST_STRING(interp, &#34;signature&#34;));
        signature = (PMC*)Parrot_run_meth_fromc_args(interp, meth, candidate,
                CONST_STRING(interp, &#34;signature&#34;), &#34;P&#34;);
        meth = VTABLE_find_method(interp, signature,
                CONST_STRING(interp, &#34;params&#34;));
        params = (PMC*)Parrot_run_meth_fromc_args(interp, meth, signature,
                CONST_STRING(interp, &#34;params&#34;), &#34;P&#34;);
        sig_elems = VTABLE_elements(interp, params);
        info&#45;&#62;types = mem_allocate_n_zeroed_typed(sig_elems + 1, PMC*);
        info&#45;&#62;constraints = mem_allocate_n_zeroed_typed(sig_elems + 1, PMC*);
        for (j = 0; j &#60; sig_elems; j++) {
            PMC *param = VTABLE_get_pmc_keyed_int(interp, params, j);
            PMC *type = VTABLE_get_pmc_keyed_str(interp, param,
                    CONST_STRING(interp, &#34;type&#34;));
            PMC *constraints = VTABLE_get_pmc_keyed_str(interp, param,
                    CONST_STRING(interp, &#34;constraints&#34;));
            info&#45;&#62;types[j] = type;
            info&#45;&#62;constraints[j] = constraints;
        }
        info&#45;&#62;num_types = sig_elems;

        /* Add it to graph node, and initialize list of edges. */
        graph[i] = mem_allocate_zeroed_typed(candidate_graph_node);
        graph[i]&#45;&#62;info = info;
        graph[i]&#45;&#62;edges = mem_allocate_n_zeroed_typed(num_candidates, candidate_graph_node*);
    }

    /* Now analyze type narrowness of the candidates relative to each other
     * and create the edges. */
    for (i = 0; i &#60; num_candidates; i++) {
        for (j = 0; j &#60; num_candidates; j++) {
            if (i == j)
                continue;
            if (is_narrower(interp, graph[i]&#45;&#62;info, graph[j]&#45;&#62;info)) {
                graph[i]&#45;&#62;edges[graph[i]&#45;&#62;edges_out] = graph[j];
                graph[i]&#45;&#62;edges_out++;
                graph[j]&#45;&#62;edges_in++;
            }
        }
    }

    /* Perform the topological sort. */
    candidates_to_sort = num_candidates;
    result_pos = 0;
    while (candidates_to_sort &#62; 0) {
        INTVAL rem_start_point = result_pos;

        /* Find any nodes that have no incoming edges and add them to results. */
        for (i = 0; i &#60; num_candidates; i++) {
            if (graph[i]&#45;&#62;edges_in == 0) {
                /* Add to results. */
                result[result_pos] = graph[i]&#45;&#62;info;
                result_pos++;
                candidates_to_sort&#45;&#45;;
                graph[i]&#45;&#62;edges_in = &#45;1;

                /* Now we have added this node, remove its outgoing edges. */
                for (j = 0; j &#60; graph[i]&#45;&#62;edges_out; j++)
                    graph[i]&#45;&#62;edges[j]&#45;&#62;edges_in&#45;&#45;;
            }
        }
        if (rem_start_point == result_pos)
            Parrot_ex_throw_from_c_args(interp, 0, 1,
                    &#34;Circularity detected in multi sub types.&#34;);

        /* This is end of a tied group, so leave a gap. */
        result_pos++;
    }

    return result;
}</pre>

<dd>/*</dd><p class="pad"></p>

<dt><a name="static_PMC*_do_dispatch(candidate_info**_candidates,_int_many)"
><b><code lang='und' xml:lang='und'>static PMC *do_dispatch(candidate_info** candidates, int many)</b></code></a></dt><p class="pad"></p>

<dd>Runs the Perl 6 MMD algorithm. If many is set to a true value, returns a ResizablePMCArray of all possible candidates, which may be empty. If many is false, then returns either the one winning unambiguous candidate or throws an error saying that the dispatch failed if there were no candidates or that it was ambiguous if there were tied candidates.</dd><p class="pad"></p>

<dd>*/</dd><p class="pad"></p>

<dd>static PMC* do_dispatch(PARROT_INTERP, candidate_info** candidates, PMC *args, int many, int num_candidates, opcode_t *next) { INTVAL i, j, type_check_count; INTVAL num_args = VTABLE_elements(interp, args); candidate_info **cur_candidate = candidates; candidate_info **possibles = mem_allocate_n_typed(num_candidates, candidate_info*); INTVAL possibles_count = 0; INTVAL type_mismatch; STRING *ACCEPTS = CONST_STRING(interp, &#34;ACCEPTS&#34;);</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    /* Iterate over the candidates and collect best ones; terminate
     * when we see two nulls (may break out earlier). */
    while (cur_candidate[0] != NULL || cur_candidate[1] != NULL) {
        if (*cur_candidate == NULL) {
            /* If we&#39;re after just one candidate and we have found some, then
             * we&#39;ve hit the end of a tied group now, so stop looking if we are
             * only after one. */
            if (!many &#38;&#38; possibles_count)
                break;
            cur_candidate++;
            continue;
        }

        /* Check if it&#39;s admissable by arity. */
        if (num_args &#60; (*cur_candidate)&#45;&#62;min_arity || num_args &#62; (*cur_candidate)&#45;&#62;max_arity) {
            cur_candidate++;
            continue;
        }

        /* Check if it&#39;s admissable by type. */
        type_check_count = (*cur_candidate)&#45;&#62;num_types &#62; num_args ?
                num_args : (*cur_candidate)&#45;&#62;num_types;
        type_mismatch = 0;
        for (i = 0; i &#60; type_check_count; i++) {
            PMC *param = VTABLE_get_pmc_keyed_int(interp, args, i);
            PMC *type_obj = (*cur_candidate)&#45;&#62;types[i];
            PMC *accepts_meth = VTABLE_find_method(interp, type_obj, ACCEPTS);
            PMC *result = (PMC*)Parrot_run_meth_fromc_args(interp, accepts_meth, type_obj,
                    ACCEPTS, &#34;PP&#34;, param);
            if (!VTABLE_get_integer(interp, result)) {
                type_mismatch = 1;
                break;
            }
        }
        if (type_mismatch) {
            cur_candidate++;
            continue;
        }

        /* If we get here, it&#39;s an admissable candidate; add to list. */
        possibles[possibles_count] = *cur_candidate;
        possibles_count++;
        cur_candidate++;
    }

    /* If we have multiple candidates left, tie&#45;break on any constraints. */
    if (possibles_count &#62; 1) {
        candidate_info **matching = mem_allocate_n_typed(possibles_count, candidate_info*);
        candidate_info **constraint_free = mem_allocate_n_typed(possibles_count, candidate_info*);
        INTVAL matching_count = 0;
        INTVAL constraint_free_count = 0;
        for (i = 0; i &#60; possibles_count; i++) {
            /* Check if we match any constraints. */
            INTVAL constraint_checked = 0;
            INTVAL constraint_failed = 0;
            for (j = 0; j &#60; possibles[i]&#45;&#62;num_types; j++) {
                PMC *type_obj = possibles[i]&#45;&#62;constraints[j];
                if (!PMC_IS_NULL(type_obj)) {
                    PMC *param = VTABLE_get_pmc_keyed_int(interp, args, j);
                    PMC *result = Parrot_runops_fromc_args(interp, type_obj,
                            &#34;PP&#34;, param);
                    constraint_checked = 1;
                    if (!VTABLE_get_integer(interp, result)) {
                        constraint_failed = 1;
                        break;
                    }
                }
            }
            if (!constraint_failed) {
                if (constraint_checked) {
                    matching[matching_count] = possibles[i];
                    matching_count++;
                }
                else {
                    constraint_free[constraint_free_count] = possibles[i];
                    constraint_free_count++;
                }
            }
        }

        /* If we did find constraints to check, choose the matching over the
         * ones without any constraints. */
        if (matching_count) {
            mem_sys_free(possibles);
            mem_sys_free(constraint_free);
            possibles = matching;
            possibles_count = matching_count;
        }
        else if (constraint_free_count) {
            mem_sys_free(possibles);
            mem_sys_free(matching);
            possibles = constraint_free;
            possibles_count = constraint_free_count;
        }
    }

    /* XXX Check is default trait */

    /* XXX If still none/ambiguous, try and find a proto to call. */

    if (!many) {
        /* Need a unique candidate. */
        if (possibles_count == 1) {
            return possibles[0]&#45;&#62;sub;
        }
        else if (possibles_count == 0) {
            Parrot_ex_throw_from_c_args(interp, next, 1,
                    &#34;No applicable candidates found to dispatch to.&#34;);
        }
        else {
            Parrot_ex_throw_from_c_args(interp, next, 1,
                    &#34;Ambiguous dispatch.&#34;);
        }
    }
}</pre>

<dd>/*</dd><p class="pad"></p>

<dt><a name="static_int_assert_invokable(PARROT_INTERP,_PMC_*value)"
><b><code lang='und' xml:lang='und'>static int assert_invokable(PARROT_INTERP, PMC *value)</b></code></a></dt><p class="pad"></p>

<dd>Checks if a PMC is invokable; returns a true value if so and a false value if not.</dd><p class="pad"></p>

<dd>*/ static int check_invokable(PARROT_INTERP, PMC *value) { STRING * const _sub = CONST_STRING(interp, &#34;Sub&#34;); STRING * const _nci = CONST_STRING(interp, &#34;NCI&#34;); return VTABLE_isa(interp, value, _sub) || VTABLE_isa(interp, value, _nci); }</dd><p class="pad"></p>

<dd>/*</dd><p class="pad"></p>
</dl>

<h1><a name="ATTRIBUTES"
>ATTRIBUTES <a href='#_top'><img alt='^' border=0 src='../../../../../resources/up.gif'></a></a></h1>

<dl>
<dt><a name="candidates"
>candidates</a></dt><p class="pad"></p>

<dd>Unsorted list of all candidates.</dd><p class="pad"></p>

<dt><a name="candidates_sorted"
>candidates_sorted</a></dt><p class="pad"></p>

<dd>C array of canididate_info structures. It stores a sequence of candidates length one or greater that are tied, followed by a NULL, followed by the next bunch that are less narrow but tied and so forth. It is terminated by a double NULL.</dd><p class="pad"></p>
</dl>

<h1><a name="METHODS"
>METHODS <a href='#_top'><img alt='^' border=0 src='../../../../../resources/up.gif'></a></a></h1>

<dl>
<dt><a name="VTABLE_void_init()"
>VTABLE void init()</a></dt><p class="pad"></p>

<dd>Allocates the PMC&#39;s underlying storage.</dd><p class="pad"></p>

<dt><a name="VTABLE_void_destroy()"
>VTABLE void destroy()</a></dt><p class="pad"></p>

<dd>Frees the memory associated with this PMC&#39;s underlying storage.</dd><p class="pad"></p>

<dt><a name="VTABLE_opcode_t_invoke()"
>VTABLE opcode_t invoke()</a></dt><p class="pad"></p>

<dd>Does a dispatch to the best candidate with the current arguments, according to the Perl 6 MMD algorithm.</dd><p class="pad"></p>

<dt><a name="VTABLE_void_mark()"
><b><code lang='und' xml:lang='und'>VTABLE void mark()</b></code></a></dt><p class="pad"></p>

<dd>Marks the candidate list.</dd><p class="pad"></p>

<dd>*/ VTABLE void mark() { PMC *candidates; GETATTR_Perl6MultiSub_candidates(interp, SELF, candidates); if (!PMC_IS_NULL(candidates)) pobject_lives(interp, (PObj*)candidates); }</dd><p class="pad"></p>

<dd>/*</dd><p class="pad"></p>

<dt><a name="VTABLE_void_push_pmc(PMC_*sub)"
>VTABLE void push_pmc(PMC *sub)</a></dt><p class="pad"></p>

<dd>Adds a new candidate to the candidate list.</dd><p class="pad"></p>

<dt><a name="VTABLE_INTVAL_elements()"
>VTABLE INTVAL elements()</a></dt><p class="pad"></p>

<dd>Gets the number of candidate on the candidate list.</dd><p class="pad"></p>
</dl>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../../../resources/parrot_small.png"
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
