<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
    <HEAD>
        <TITLE>Untitled</TITLE>
        <LINK REL="stylesheet" TYPE="text/css"
            HREF="../../../../resources/perl.css"
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY>
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Untitled</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../../html/index.html">Contents</a> | <a href="../../../../html/languages.html">Language Implementations</a> | <a href="../../../../html/perl6.html">Perl6</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="Overview_of_the_Rakudo_Perl_6_compiler"
>Overview of the Rakudo Perl 6 compiler <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>This document describes the architecture and layout of the Rakudo Perl 6 (a.k.a.
Rakudo) compiler.
See the <em lang='und' xml:lang='und'>README</em> or <em lang='und' xml:lang='und'>docs/STATUS</em> files for information about how to use the compiler or what features have been implemented.</p>

<p>The Rakudo compiler is constructed from four major components:</p>

<ol>
<li>the parse grammar (src/parser/grammar.pg,
src/parser/*.pir)</li><p class="pad"></p>

<li>a set of action methods to transform the parse tree into an abstract syntax tree (src/parser/actions.pm)</li><p class="pad"></p>

<li>the main compiler object (perl6.pir)</li><p class="pad"></p>

<li>builtin functions and runtime support (src/builtins/,
src/classes/,
src/pmc/)</li><p class="pad"></p>
</ol>

<p>The <em lang='und' xml:lang='und'>Makefile</em> takes care of compiling all of the individual components into compiled form and linking them together to form the <em lang='und' xml:lang='und'>perl6.pbc</em> executable.</p>

<h2><a name="Parse_grammar"
>Parse grammar <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>The parse grammar is written using a mix of Perl 6 regular expressions,
operator tokens,
and special&#45;purpose PIR subroutines.
The primary purpose of the parse grammar is to parse Perl 6 source code into a parse tree.</p>

<p>Currently the parse grammar is spread across three files:</p>

<pre lang='und' xml:lang='und'>    src/parser/grammar.pg           &#45; the top&#45;level grammar
    src/parser/grammer&#45;oper.pg      &#45; operator tokens
    src/parser/quote_expression.pir &#45; quote rule</pre>

<p>The top&#45;level portion of the grammar is written using Perl 6 rules (Synopsis 5) and is based on the STD.pm grammar in the Pugs repository (<a href='http://svn.pugscode.org/pugs/src/perl6/STD.pm'><a href="http://svn.pugscode.org/pugs/src/perl6/STD.pm">http://svn.pugscode.org/pugs/src/perl6/STD.pm</a></a>). There are a few places where this grammar deviates from STD.pm, but the ultimate goal is for the two to converge. The grammar inherits from <code lang='und' xml:lang='und'>PCT::Grammar</code>, which provides the <code lang='und' xml:lang='und'>&#60;.panic&#62;</code> rule to throw exceptions for syntax errors.</p>

<p>The parse grammar is compiled into PIR (<em lang='und' xml:lang='und'>src/gen_grammar.pir</em>) using the Perl6Grammar compiler that is part of PGE and the Parrot Compiler Toolkit. Because PGE doesn&#39;t yet implement the proto&#45;regex or longest token matching semantics of S05, we make use of PGE&#39;s built&#45;in operator precedence parser and define operator tokens in grammar&#45;oper.pg .</p>

<p>Lastly, the <em lang='und' xml:lang='und'>src/parser/quote_expression.pir</em> file implements code to parse the various forms of Perl 6 quoting rules. It&#39;s far easier to write this component using PIR instead of a regular expression, but otherwise it acts just like any other rule in the grammar.</p>

<h2><a name="Action_methods"
>Action methods <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>The action methods (in <em lang='und' xml:lang='und'>src/parser/actions.pm</em>) are used to convert the nodes of the parse tree (produced by the parse grammar) into an equivalent abstract syntax tree (PAST) representation. The action methods are where the Rakudo compiler does the bulk of the work of creating an executable program. Action methods are written in Perl 6, but we use NQP to compile them into PIR as <em lang='und' xml:lang='und'>src/gen_actions.pir</em>.</p>

<p>When Rakudo is compiling a Perl 6 program, action methods are invoked by the <code lang='und' xml:lang='und'> {*} </code> symbols in the parse grammar. Each <code lang='und' xml:lang='und'> {*} </code> in a rule causes the action method corresponding to the rule&#39;s name to be invoked, passing the current match object as an argument. If the rule source line containing <code lang='und' xml:lang='und'> {*} </code> also contains a comment starting with <code lang='und' xml:lang='und'> #= </code>, any text after the comment is passed as a separate key argument to the action method. (This is similar to the approach that STD.pm uses to mark and distinguish actions.)</p>

<p>For example, here&#39;s the parse rule for Rakudo&#39;s <code lang='und' xml:lang='und'>unless</code> statement (in src/parser/grammar.pg):</p>

<pre lang='und' xml:lang='und'>    rule unless_statement {
        $&#60;sym&#62;=[unless] &#60;EXPR&#62; &#60;block&#62;
        {*}
    }</pre>

<p>This rule says that an unless statement consists of the word &#34;unless&#34; (captured into <code lang='und' xml:lang='und'>$&#60;sym&#62;</code>), followed by an expression and then a block. If all of those match successfully, then the <code lang='und' xml:lang='und'> {*} </code> invokes the corresponding action method for unless_statement. Here&#39;s the action method for the unless statement (from src/parser/actions.pm):</p>

<pre lang='und' xml:lang='und'>    method unless_statement($/) {
        my $then := $( $&#60;block&#62; );
        $then.blocktype(&#39;immediate&#39;);
        my $past := PAST::Op.new( $( $&#60;EXPR&#62; ), $then,
                                  :pasttype(&#39;unless&#39;),
                                  :node( $/ )
                                );
        make $past;
    }</pre>

<p>When this action method is invoked from the unless_statement rule, the current match object containing the parsed statement is passed into the method as <code lang='und' xml:lang='und'> $/ </code>. In Perl 6, this means that the expressions <code lang='und' xml:lang='und'>$&#60;EXPR&#62;</code> and <code lang='und' xml:lang='und'>$&#60;block&#62;</code> will refer to whatever was matched by the <code lang='und' xml:lang='und'>&#60;EXPR&#62;</code> and <code lang='und' xml:lang='und'>&#60;block&#62;</code> subrules of the <code lang='und' xml:lang='und'>unless_statement</code> rule. ( <code lang='und' xml:lang='und'>$&#60;block&#62;</code> is Perl 6 syntactic sugar for <code lang='und' xml:lang='und'> $/{&#39;block&#39;} </code>.)</p>

<p>Now then, the purpose of the action methods in our compiler is to convert the parsed elements of the source program into their abstract syntax tree (PAST) equivalents. The magic for this occurs in the <code lang='und' xml:lang='und'> $(...) </code> and <code lang='und' xml:lang='und'>make</code> expressions in the method body. The <code lang='und' xml:lang='und'> $(...) </code> operator is used to retrieve the PAST representation of a parsed subtree. Thus, the first two statements of <code lang='und' xml:lang='und'>unless_statement</code> retrieve the PAST representation of the <code lang='und' xml:lang='und'>&#60;block&#62;</code> subtree into <code lang='und' xml:lang='und'>$then</code>, and set that block to be an immediately executed block.</p>

<p>The third statement creates a new <code lang='und' xml:lang='und'>PAST::Op</code> node for the unless statement, using the PAST representation of <code lang='und' xml:lang='und'>&#60;EXPR&#62;</code> as the condition to be tested, the <code lang='und' xml:lang='und'>$then</code> block as the body, and <code lang='und' xml:lang='und'>:pasttype(&#39;unless&#39;)</code> as the type of operation to be performed. The <code lang='und' xml:lang='und'>:node($/)</code> argument is used to link this PAST node back to the source code that generated it (e.g., for error reporting).</p>

<p>Finally, the <code lang='und' xml:lang='und'>make</code> statement at the end of the method sets the newly created PAST::Op node as the PAST representation of the unless statement that was just parsed.</p>

<p>The Parrot Compiler Toolkit provides a wide variety of PAST node types for representing the various components of a HLL program &#45;&#45; for more details about the available node types, see PDD 26 (<a href='http://svn.perl.org/parrot/trunk/docs/pdds/pdd26_ast.pod'><a href="http://svn.perl.org/parrot/trunk/docs/pdds/pdd26_ast.pod">http://svn.perl.org/parrot/trunk/docs/pdds/pdd26_ast.pod</a></a>).</p>

<p>One important observation to make here is that NQP is used only for <i>building</i> the Rakudo compiler, and then only to convert the action methods in <em lang='und' xml:lang='und'>src/parser/actions.pm</em> into equivalent PIR (<em lang='und' xml:lang='und'>src/gen_actions.pir</em>). The <em lang='und' xml:lang='und'>src/gen_actions.pir</em> file is then used to build <em lang='und' xml:lang='und'>perl6.pbc</em>. In particular, NQP is <i>not</i> part of the Rakudo runtime &#45;&#45; i.e., when Rakudo is running, NQP is not loaded or used. Yes, this does mean that we can conceivably use the Rakudo compiler to compile <em lang='und' xml:lang='und'>actions.pm</em> to PIR and eliminate the need for NQP entirely. At some point as Rakudo matures we will probably do this. However, for the time being it&#39;s slightly easier to manage the process if we keep a distinction between the two tools, and using NQP for this stage also helps us to limit ourselves to using a regular, well&#45;defined, and relatively easy&#45;to&#45;implement subset of Perl 6 for the core compiler. So, while it&#39;s possible for us to eliminate NQP from the process, there are some good reasons not to do so just yet. (If at some point we discover that we need something for the compiler that NQP can&#39;t or won&#39;t support, then that will probably be a good point to switch.)</p>

<h2><a name="Main_compiler"
>Main compiler <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Driving the parser and action methods is the Perl 6 compiler object itself, in <em lang='und' xml:lang='und'>perl6.pir</em>. The compiler is an instance of <code lang='und' xml:lang='und'>PCT::HLLCompiler</code>, which provides a standard framework for parsing, optimization, and command line argument handling for Parrot compilers. The <code lang='und' xml:lang='und'>onload</code> subroutine in <em lang='und' xml:lang='und'>perl6.pir</em> simply creates a new <code lang='und' xml:lang='und'>PCT::HLLCompiler</code> object, registers it as the <code lang='und' xml:lang='und'>Perl6</code> compiler, and sets it to use the <code lang='und' xml:lang='und'>Perl6::Grammar</code> and <code lang='und' xml:lang='und'>Perl6::Grammar::Actions</code> classes defined above.</p>

<p>The <code lang='und' xml:lang='und'>main</code> subroutine in perl6.pir is used when Rakudo is invoked from the command line &#45;&#45; it simply passes control to the <code lang='und' xml:lang='und'>Perl6</code> compiler object registered by the <code lang='und' xml:lang='und'>onload</code> subroutine.</p>

<p>Lastly, the <code lang='und' xml:lang='und'>perl6.pir</code> source uses PIR <code lang='und' xml:lang='und'>.include</code> directives to pull in the PIR sources for the parse grammar, action methods, and runtime builtin functions.</p>

<h2><a name="Builtin_functions_and_runtime_support"
>Builtin functions and runtime support <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>The last component of the compiler are the various builtin functions and libraries that a Perl 6 program expects to have available when it is running. These include functions for the basic operations (<code lang='und' xml:lang='und'>infix:&#60;+&#62;</code>, <code lang='und' xml:lang='und'>prefix:&#60;abs&#62;</code>) as well as common global functions such as <code lang='und' xml:lang='und'>say</code> and <code lang='und' xml:lang='und'>print</code>.</p>

<p>Currently, most of the builtins are written in PIR, either because it&#39;s simpler to write them that way or because they represent very primitive operations (e.g., math primitives) or they&#39;re easier to write in PIR than in Perl 6 or some other language.</p>

<p>In the very near future we expect to be writing much of the additional runtime as Perl 6 code instead of PIR. In other words, we&#39;ll build just enough runtime to get a basic Rakudo compiler running, and then use that to compile the remainder of the runtime libraries (written in Perl 6) that a standard Perl 6 program would expect to have available when it is run.</p>

<h2><a name="Still_to_be_documented"
>Still to be documented <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>* Rakudo PMCs * The relationship between Parrot classes and Rakudo classes * Protoobject implementation and basic class hierarchy</p>

<h1><a name="AUTHORS"
>AUTHORS <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>Patrick Michaud &#60;pmichaud@pobox.com&#62; is the primary author and maintainer.</p>

<h1><a name="COPYRIGHT"
>COPYRIGHT <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>Copyright (C) 2007&#45;2008, The Perl Foundation.</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../../resources/parrot_small.png"
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
