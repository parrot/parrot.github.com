<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
    <HEAD>
        <TITLE>Stack handling routines for Parrot</TITLE>
        <LINK REL="stylesheet" TYPE="text/css"
            HREF="../../resources/perl.css"
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY>
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Stack handling routines for Parrot</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../html/index.html">Contents</a> | <a href="../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>src/stacks.c &#45; Stack handling routines for Parrot</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>The stack is stored as a linked list of chunks (<code lang='und' xml:lang='und'>Stack_Chunk</code>),
where each chunk has room for one entry.</p>

<h2><a name="Functions"
>Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="void_stack_system_init"
><b><code lang='und' xml:lang='und'>void stack_system_init</b></code></a></dt><p class="pad"></p>

<dd>Called from <code lang='und' xml:lang='und'>make_interpreter()</code> to initialize the interpreter&#39;s register stacks.</dd><p class="pad"></p>

<dt><a name="Stack_Chunk_t_*_cst_new_stack_chunk"
><b><code lang='und' xml:lang='und'>Stack_Chunk_t *cst_new_stack_chunk</b></code></a></dt><p class="pad"></p>

<dd>Get a new chunk either from the freelist or allocate one.</dd><p class="pad"></p>

<dt><a name="Stack_Chunk_t_*_new_stack"
><b><code lang='und' xml:lang='und'>Stack_Chunk_t *new_stack</b></code></a></dt><p class="pad"></p>

<dd>Create a new stack and name it.
<code lang='und' xml:lang='und'>stack&#45;&#62;name</code> is used for debugging/error reporting.</dd><p class="pad"></p>

<dt><a name="void_mark_stack"
><b><code lang='und' xml:lang='und'>void mark_stack</b></code></a></dt><p class="pad"></p>

<dd>Mark entries in a stack structure during DOD.</dd><p class="pad"></p>

<dt><a name="void_stack_destroy"
><b><code lang='und' xml:lang='und'>void stack_destroy</b></code></a></dt><p class="pad"></p>

<dd>stack_destroy() doesn&#39;t need to do anything,
since GC does it all.</dd><p class="pad"></p>

<dt><a name="size_t_stack_height"
><b><code lang='und' xml:lang='und'>size_t stack_height</b></code></a></dt><p class="pad"></p>

<dd>Returns the height of the stack.
The maximum &#34;depth&#34; is height &#45; 1.</dd><p class="pad"></p>

<dt><a name="Stack_Entry_t_*_stack_entry"
><b><code lang='und' xml:lang='und'>Stack_Entry_t *stack_entry</b></code></a></dt><p class="pad"></p>

<dd>If <code lang='und' xml:lang='und'>depth &#62;= 0</code>,
return the entry at that depth from the top of the stack,
with 0 being the top entry.
If <code lang='und' xml:lang='und'>depth &#60; 0</code>,
then return the entry <code lang='und' xml:lang='und'>|depth|</code> entries from the bottom of the stack.
Returns <code lang='und' xml:lang='und'>NULL</code> if <code lang='und' xml:lang='und'>|depth| </code> number&#62; of entries in stack.</dd><p class="pad"></p>

<dt><a name="void_rotate_entries"
><b><code lang='und' xml:lang='und'>void rotate_entries</b></code></a></dt><p class="pad"></p>

<dd>Rotate the top N entries by one.
If <code lang='und' xml:lang='und'>N &#62; 0</code>,
the rotation is bubble up,
so the top most element becomes the Nth element.
If <code lang='und' xml:lang='und'>N &#60; 0</code>,
the rotation is bubble down,
so that the Nth element becomes the top most element.</dd><p class="pad"></p>

<dd>*/</dd><p class="pad"></p>

<dd>PARROT_API void rotate_entries(PARROT_INTERP,
ARGMOD(Stack_Chunk_t **stack_p),
INTVAL num_entries) { Stack_Chunk_t * const stack = *stack_p;</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    if (num_entries &#62;= &#45;1 &#38;&#38; num_entries &#60;= 1) {
        return;
    }

    if (num_entries &#60; 0) {
        INTVAL i;
        Stack_Entry_t temp;
        INTVAL depth;

        num_entries = &#45;num_entries;
        depth = num_entries &#45; 1;

        if (stack_height(interp, stack) &#60; (size_t)num_entries)
            Parrot_ex_throw_from_c_args(interp, NULL, ERROR_STACK_SHALLOW,
                &#34;Stack too shallow!&#34;);

        /* XXX Dereferencing stack_entry here is a cavalcade of danger */
        temp = *stack_entry(interp, stack, depth);
        for (i = depth; i &#62; 0; i&#45;&#45;) {
            *stack_entry(interp, stack, i) =
                *stack_entry(interp, stack, i &#45; 1);
        }

        *stack_entry(interp, stack, 0) = temp;
    }
    else {
        INTVAL i;
        Stack_Entry_t temp;
        INTVAL depth = num_entries &#45; 1;

        if (stack_height(interp, stack) &#60; (size_t)num_entries)
            Parrot_ex_throw_from_c_args(interp, NULL, ERROR_STACK_SHALLOW,
                &#34;Stack too shallow!&#34;);

        /* XXX Dereferencing stack_entry here is a cavalcade of danger */
        temp = *stack_entry(interp, stack, 0);

        for (i = 0; i &#60; depth; i++) {
            *stack_entry(interp, stack, i) =
                *stack_entry(interp, stack, i + 1);
        }

        *stack_entry(interp, stack, depth) = temp;
    }
}</pre>

<dd>/*</dd><p class="pad"></p>

<dt><a name="Stack_Entry_t*_stack_prepare_push"
><b><code lang='und' xml:lang='und'>Stack_Entry_t *stack_prepare_push</b></code></a></dt><p class="pad"></p>

<dd>Return a pointer, where new entries go for push.</dd><p class="pad"></p>

<dt><a name="void_stack_push"
><b><code lang='und' xml:lang='und'>void stack_push</b></code></a></dt><p class="pad"></p>

<dd>Push something on the generic stack.</dd><p class="pad"></p>

<dd>Note that the cleanup pointer, if non&#45;<code lang='und' xml:lang='und'>NULL</code>, points to a routine that&#39;ll be called when the entry is removed from the stack. This is handy for those cases where you need some sort of activity to take place when an entry is removed, such as when you push a lexical lock onto the call stack, or localize (or tempify, or whatever we&#39;re calling it) variable or something.</dd><p class="pad"></p>

<dd>*/</dd><p class="pad"></p>

<dd>PARROT_API void stack_push(PARROT_INTERP, ARGMOD(Stack_Chunk_t **stack_p), ARGIN(void *thing), Stack_entry_type type, NULLOK(Stack_cleanup_method cleanup)) { Stack_Entry_t * const entry = (Stack_Entry_t *)stack_prepare_push(interp, stack_p);</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    /* Remember the type */
    entry&#45;&#62;entry_type = type;

    /* Remember the cleanup function */
    entry&#45;&#62;cleanup = cleanup;

    /* Store our thing */
    switch (type) {
        case STACK_ENTRY_MARK:
            UVal_int(entry&#45;&#62;entry) = *(INTVAL *)thing;
            break;
        case STACK_ENTRY_DESTINATION:
            UVal_ptr(entry&#45;&#62;entry) = thing;
            break;
        case STACK_ENTRY_ACTION:
        case STACK_ENTRY_PMC:
            UVal_pmc(entry&#45;&#62;entry) = (PMC *)thing;
            break;
        default:
            Parrot_ex_throw_from_c_args(interp, NULL, ERROR_BAD_STACK_TYPE,
                &#34;Invalid Stack_Entry_type!&#34;);
    }
}</pre>

<dd>/*</dd><p class="pad"></p>

<dt><a name="Stack_Entry_t*_stack_prepare_pop"
><b><code lang='und' xml:lang='und'>Stack_Entry_t *stack_prepare_pop</b></code></a></dt><p class="pad"></p>

<dd>Return a pointer, where new entries are popped off.</dd><p class="pad"></p>

<dt><a name="void_*_stack_pop"
><b><code lang='und' xml:lang='und'>void *stack_pop</b></code></a></dt><p class="pad"></p>

<dd>Pop off an entry and return a pointer to the contents.</dd><p class="pad"></p>

<dd>*/</dd><p class="pad"></p>

<dd>PARROT_API PARROT_CAN_RETURN_NULL void * stack_pop(PARROT_INTERP, ARGMOD(Stack_Chunk_t **stack_p), ARGOUT_NULLOK(void *where), Stack_entry_type type) { Stack_Chunk_t *cur_chunk = *stack_p; Stack_Entry_t * const entry = (Stack_Entry_t *)stack_prepare_pop(interp, stack_p);</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    /* Types of 0 mean we don&#39;t care */
    if (type &#38;&#38; entry&#45;&#62;entry_type != type)
        Parrot_ex_throw_from_c_args(interp, NULL, ERROR_BAD_STACK_TYPE,
            &#34;Wrong type on top of stack!\n&#34;);

    /* Cleanup routine? */
    if (entry&#45;&#62;cleanup != STACK_CLEANUP_NULL)
        (*entry&#45;&#62;cleanup) (interp, entry);

    /* Sometimes the caller cares what the value was */
    if (where) {
        /* Snag the value */
        switch (type) {
        case STACK_ENTRY_MARK:
            *(INTVAL *)where   = UVal_int(entry&#45;&#62;entry);
            break;
        case STACK_ENTRY_DESTINATION:
            *(void **)where    = UVal_ptr(entry&#45;&#62;entry);
            break;
        case STACK_ENTRY_ACTION:
        case STACK_ENTRY_PMC:
            *(PMC **)where     = UVal_pmc(entry&#45;&#62;entry);
            break;
        default:
            Parrot_ex_throw_from_c_args(interp, NULL, ERROR_BAD_STACK_TYPE,
                &#34;Wrong type on top of stack!\n&#34;);
        }
    }

    /* recycle this chunk to the free list if it&#39;s otherwise unreferenced */
    if (cur_chunk&#45;&#62;refcount &#60;= 0) {
        Small_Object_Pool * const pool = cur_chunk&#45;&#62;pool;

        pool&#45;&#62;dod_object(interp, pool, (PObj *)cur_chunk);
        pool&#45;&#62;add_free_object(interp, pool, (PObj *)cur_chunk);
    }

    return where;
}</pre>

<dd>/*</dd><p class="pad"></p>

<dt><a name="void_*_pop_dest"
><b><code lang='und' xml:lang='und'>void *pop_dest</b></code></a></dt><p class="pad"></p>

<dd>Pop off a destination entry and return a pointer to the contents.</dd><p class="pad"></p>

<dt><a name="void_*_stack_peek"
><b><code lang='und' xml:lang='und'>void *stack_peek</b></code></a></dt><p class="pad"></p>

<dd>Peek at stack and return pointer to entry and the type of the entry.</dd><p class="pad"></p>

<dt><a name="Stack_entry_type_get_entry_type"
><b><code lang='und' xml:lang='und'>Stack_entry_type get_entry_type</b></code></a></dt><p class="pad"></p>

<dd>Returns the stack entry type of <code lang='und' xml:lang='und'>entry</code>.</dd><p class="pad"></p>

<dt><a name="void_Parrot_dump_dynamic_environment"
><b><code lang='und' xml:lang='und'>void Parrot_dump_dynamic_environment</b></code></a></dt><p class="pad"></p>

<dd>Print a representation of the dynamic stack to the standard error (using <code lang='und' xml:lang='und'>PIO_eprintf</code>). This is used only temporarily for debugging.</dd><p class="pad"></p>

<dt><a name="static_void_run_cleanup_action"
><b><code lang='und' xml:lang='und'>static void run_cleanup_action</b></code></a></dt><p class="pad"></p>

<dd>Runs the sub PMC from the Stack_Entry_t pointer with an INTVAL arg of 0. Used in <code lang='und' xml:lang='und'>Parrot_push_action</code>.</dd><p class="pad"></p>

<dt><a name="void_Parrot_push_action"
><b><code lang='und' xml:lang='und'>void Parrot_push_action</b></code></a></dt><p class="pad"></p>

<dd>Pushes an action handler onto the dynamic environment.</dd><p class="pad"></p>

<dt><a name="void_Parrot_push_mark"
><b><code lang='und' xml:lang='und'>void Parrot_push_mark</b></code></a></dt><p class="pad"></p>

<dd>Push a cleanup mark onto the dynamic environment.</dd><p class="pad"></p>

<dt><a name="void_Parrot_pop_mark"
><b><code lang='und' xml:lang='und'>void Parrot_pop_mark</b></code></a></dt><p class="pad"></p>

<dd>Pop items off the dynamic environment up to the mark.</dd><p class="pad"></p>
</dl>

<h1><a name="SEE_ALSO"
>SEE ALSO <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p><em lang='und' xml:lang='und'>include/parrot/stacks.h</em> and <em lang='und' xml:lang='und'>include/parrot/enums.h</em>.</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../resources/parrot_small.png"
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
