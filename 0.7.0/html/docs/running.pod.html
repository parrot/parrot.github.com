<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
    <HEAD>
        <TITLE>running</TITLE>
        <LINK REL="stylesheet" TYPE="text/css"
            HREF="../../resources/perl.css"
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY>
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">running</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../html/index.html">Contents</a> | <a href="../../html/docs.html">Documentation</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>Parrot &#45; running</p>

<h1><a name="VERSION"
>VERSION <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>$Revision$</p>

<h1><a name="OVERVIEW"
>OVERVIEW <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>This document describes Parrot&#39;s command line options.</p>

<h1><a name="SYNOPSIS"
>SYNOPSIS <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<pre lang='und' xml:lang='und'> parrot [&#45;options] &#60;file&#62; [arguments ...]</pre>

<h1><a name="ENVIRONMENT"
>ENVIRONMENT <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<dl>
<dt><a name="PARROT_RUNTIME"
>PARROT_RUNTIME</a></dt><p class="pad"></p>

<dd>If this environment variable is set, parrot will use this path as its runtime prefix instead of the compiled in path.</dd><p class="pad"></p>

<dt><a name="PARROT_GC_DEBUG"
>PARROT_GC_DEBUG</a></dt><p class="pad"></p>

<dd>Turn on the <i>&#45;&#45;gc&#45;debug</i> flag.</dd><p class="pad"></p>
</dl>

<h1><a name="OPTIONS"
>OPTIONS <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<h2><a name="Assembler_options"
>Assembler options <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="&#45;a,_&#45;&#45;pasm"
>&#45;a, &#45;&#45;pasm</a></dt><p class="pad"></p>

<dd>Assume PASM input on stdin.</dd><p class="pad"></p>

<dt><a name="&#45;c,_&#45;&#45;pbc"
>&#45;c, &#45;&#45;pbc</a></dt><p class="pad"></p>

<dd>Assume PBC file on stdin, run it.</dd><p class="pad"></p>

<dt><a name="&#45;d,_&#45;&#45;imcc&#45;debug_[hexbits]"
>&#45;d, &#45;&#45;imcc&#45;debug [hexbits]</a></dt><p class="pad"></p>

<dd>The <b>&#45;d</b> switch takes an optional argument which is considered to hold a hex value of debug bits. Without a value, debug is set to 1.</dd><p class="pad"></p>

<dd>The individual bits can be listed on the command line by use of the <b>&#45;&#45;help&#45;debug</b> switch.</dd><p class="pad"></p>

<dd>To produce really huge output on <em lang='und' xml:lang='und'>stderr</em> run <code lang='und' xml:lang='und'>&#34;parrot <b>&#45;d 0ffff</b> ...&#34;</code>. Note: If the argument is separated by whitespace from the <b>&#45;d</b> switch, it has to start with a number.</dd><p class="pad"></p>

<dt><a name="&#45;h,_&#45;&#45;help"
>&#45;h, &#45;&#45;help</a></dt><p class="pad"></p>

<dd>Print command line option summary.</dd><p class="pad"></p>

<dt><a name="&#45;&#45;help&#45;debug"
>&#45;&#45;help&#45;debug</a></dt><p class="pad"></p>

<dd>Print debugging and tracing flag bits summary.</dd><p class="pad"></p>

<dt><a name="&#45;o_outputfile,_&#45;&#45;output=outputfile"
>&#45;o outputfile, &#45;&#45;output=outputfile</a></dt><p class="pad"></p>

<dd>Act like an assembler. Don&#39;t run code, unless <b>&#45;r</b> is given too. If the outputfile ends with <em lang='und' xml:lang='und'>.pbc</em>, a PBC file is written. If it ends with <em lang='und' xml:lang='und'>.pasm</em>, a PASM output is generated, even from PASM input. This can be handy to check various optimizations, including <code lang='und' xml:lang='und'>&#45;Op</code>.</dd><p class="pad"></p>

<dt><a name="&#45;&#45;output&#45;pbc"
>&#45;&#45;output&#45;pbc</a></dt><p class="pad"></p>

<dd>Act like an assembler, but always output bytecode, even if the output file does not end in <em lang='und' xml:lang='und'>.pbc</em></dd><p class="pad"></p>

<dt><a name="&#45;r,_&#45;&#45;run&#45;pbc"
>&#45;r, &#45;&#45;run&#45;pbc</a></dt><p class="pad"></p>

<dd>Only useful after <code lang='und' xml:lang='und'>&#45;o</code> or <code lang='und' xml:lang='und'>&#45;&#45;output&#45;pbc</code>. Run the program from the compiled in&#45;memory image. If two <code lang='und' xml:lang='und'>&#45;r</code> options are given, the <em lang='und' xml:lang='und'>.pbc</em> file is read from disc and run. This is mainly needed for tests.</dd><p class="pad"></p>

<dt><a name="&#45;v,_&#45;&#45;verbose"
>&#45;v, &#45;&#45;verbose</a></dt><p class="pad"></p>

<dd>One <code lang='und' xml:lang='und'>&#45;v</code> shows which files are worked on and prints a summary over register usage and optimization stats per <i>compilation unit</i>. With two <code lang='und' xml:lang='und'>&#45;v</code> switches, <code lang='und' xml:lang='und'>parrot</code> prints a line per individual processing step too.</dd><p class="pad"></p>

<dt><a name="&#45;y,_&#45;&#45;yydebug"
>&#45;y, &#45;&#45;yydebug</a></dt><p class="pad"></p>

<dd>Turn on yydebug in <em lang='und' xml:lang='und'>yacc</em>/<em lang='und' xml:lang='und'>bison</em>.</dd><p class="pad"></p>

<dt><a name="&#45;V,_&#45;&#45;version"
>&#45;V, &#45;&#45;version</a></dt><p class="pad"></p>

<dd>Print version information and exit.</dd><p class="pad"></p>

<dt><a name="&#45;Ox"
>&#45;Ox</a></dt><p class="pad"></p>

<dd>Optimize</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'> &#45;O0 no optimization (default)
 &#45;O1 optimizations without life info (e.g. branches)
 &#45;O  same
 &#45;O2 optimizations with life info
 &#45;Op rewrite I and N PASM registers most used first
 &#45;Ot select fastest runcore (default with &#45;O1 and &#45;O2)
 &#45;Oc turns on the optional/experimental tail call optimizations</pre>

<dd>See <em lang='und' xml:lang='und'><a href="dev/optimizer.pod.html">docs/dev/optimizer.pod</a></em> for more information on the optimizer. Note that optimization is currently experimental and these options are likely to change.</dd><p class="pad"></p>

<dt><a name="&#45;E,_&#45;&#45;pre&#45;process&#45;only"
>&#45;E, &#45;&#45;pre&#45;process&#45;only</a></dt><p class="pad"></p>

<dd>Preprocess source file (expand macros) and print result to stdout:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  $ parrot &#45;E t/op/macro_10.pasm
  $ parrot &#45;E t/op/macro_10.pasm | parrot &#45;&#45; &#45;</pre>
</dl>

<h2><a name="Runcore_Options"
>Runcore Options <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>These options select the runcore, which is useful for performance tuning and debugging. See <a href='#About_runcores'>&#34;About runcores&#34;</a> for details.</p>

<dl>
<dt><a name="&#45;R,_&#45;&#45;runcore_CORE"
>&#45;R, &#45;&#45;runcore CORE</a></dt><p class="pad"></p>

<dd>Select the runcore. The following cores are available:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  slow, bounds  bounds checking core (default)
  fast          fast core (no bounds checking, profiling, or tracing)
  switch        switch core
  cgp           computed goto&#45;predereferenced core
  cgoto         computed goto core
  jit           JIT core
  cgp&#45;jit       computed goto&#45;predereferenced core with JIT
  switch&#45;jit    switch core with JIT
  exec          exec core (uses JIT at compile time to generate native code)
  trace         bounds checking core w/ trace info (see &#39;parrot &#45;&#45;help&#45;debug&#39;)
  gcdebug       performs a full GC run before every op dispatch (good for
                debugging GC problems)</pre>

<dt><a name="&#45;b,_&#45;&#45;bounds&#45;checks,_&#45;&#45;slow&#45;core"
>&#45;b, &#45;&#45;bounds&#45;checks, &#45;&#45;slow&#45;core</a></dt><p class="pad"></p>

<dd>Select the bounds&#45;checking slow core (default).</dd><p class="pad"></p>

<dt><a name="&#45;C,_&#45;&#45;CGP&#45;core"
>&#45;C, &#45;&#45;CGP&#45;core</a></dt><p class="pad"></p>

<dd>Select the CGP (CGoto Predereferenced) core (if available).</dd><p class="pad"></p>

<dt><a name="&#45;f,_&#45;&#45;fast&#45;core"
>&#45;f, &#45;&#45;fast&#45;core</a></dt><p class="pad"></p>

<dd>Select the fast (or function) core.</dd><p class="pad"></p>

<dt><a name="&#45;g,_&#45;&#45;computed&#45;goto&#45;core"
>&#45;g, &#45;&#45;computed&#45;goto&#45;core</a></dt><p class="pad"></p>

<dd>Select the CGoto core (if available).</dd><p class="pad"></p>

<dt><a name="&#45;j,_&#45;&#45;jit&#45;core"
>&#45;j, &#45;&#45;jit&#45;core</a></dt><p class="pad"></p>

<dd>Run with the JIT subsystem (if available).</dd><p class="pad"></p>

<dt><a name="&#45;p,_&#45;&#45;profile"
>&#45;p, &#45;&#45;profile</a></dt><p class="pad"></p>

<dd>Run with the slow core and print an execution profile.</dd><p class="pad"></p>

<dt><a name="&#45;S,_&#45;&#45;switched&#45;core"
>&#45;S, &#45;&#45;switched&#45;core</a></dt><p class="pad"></p>

<dd>TODO: This needs to be documented briefly here and also in glossary.pod.</dd><p class="pad"></p>

<dt><a name="&#45;t,_&#45;&#45;trace"
>&#45;t, &#45;&#45;trace</a></dt><p class="pad"></p>

<dd>Run with the slow core and print trace information to <b>stderr</b>. See <code lang='und' xml:lang='und'>parrot &#45;&#45;help&#45;debug</code> for available flag bits.</dd><p class="pad"></p>
</dl>

<h2><a name="VM_Options"
>VM Options <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="&#45;w,_&#45;&#45;warnings"
>&#45;w, &#45;&#45;warnings</a></dt><p class="pad"></p>

<dd>Turn on warnings. See <code lang='und' xml:lang='und'>parrot &#45;&#45;help&#45;debug</code> for available flag bits.</dd><p class="pad"></p>

<dt><a name="&#45;D,_&#45;&#45;parrot&#45;debug"
>&#45;D, &#45;&#45;parrot&#45;debug</a></dt><p class="pad"></p>

<dd>Turn on interpreter debug flag. See <code lang='und' xml:lang='und'>parrot &#45;&#45;help&#45;debug</code> for available flag bits.</dd><p class="pad"></p>

<dt><a name="&#45;&#45;gc&#45;debug"
>&#45;&#45;gc&#45;debug</a></dt><p class="pad"></p>

<dd>Turn on GC (Garbage Collection) debugging. This imposes some stress on the GC subsystem and can slow down execution considerably.</dd><p class="pad"></p>

<dt><a name="&#45;G,_&#45;&#45;no&#45;gc"
>&#45;G, &#45;&#45;no&#45;gc</a></dt><p class="pad"></p>

<dd>This turns off DOD (Dead Object Detection) and GC. This may be useful to find GC related bugs. Don&#39;t use this option for longer running programs: as memory is no longer recycled, it may quickly become exhausted.</dd><p class="pad"></p>

<dt><a name="&#45;&#45;leak&#45;test,_&#45;&#45;destroy&#45;at&#45;end"
>&#45;&#45;leak&#45;test, &#45;&#45;destroy&#45;at&#45;end</a></dt><p class="pad"></p>

<dd>Free all memory of the last interpreter. This is useful when running leak checkers.</dd><p class="pad"></p>

<dt><a name="&#45;.,_&#45;&#45;wait"
>&#45;., &#45;&#45;wait</a></dt><p class="pad"></p>

<dd>Read a keystroke before starting. This is useful when you want to attach a debugger on platforms such as Windows.</dd><p class="pad"></p>

<dt><a name="&#45;&#45;runtime&#45;prefix"
>&#45;&#45;runtime&#45;prefix</a></dt><p class="pad"></p>

<dd>Print the runtime prefix path and exit.</dd><p class="pad"></p>
</dl>

<h2><a name="&#60;file&#62;"
>&#60;file&#62; <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>If the file ends in <em lang='und' xml:lang='und'>.pbc</em> it will be interpreted immediately.</p>

<p>If the file ends in <em lang='und' xml:lang='und'>.pasm</em>, then it is parsed as PASM code. Otherwise, it is parsed as PIR code. In both cases, it will then be run, unless the <code lang='und' xml:lang='und'>&#45;o</code> flag was given.</p>

<p>If the <code lang='und' xml:lang='und'>file</code> is a single dash, input from <code lang='und' xml:lang='und'>stdin</code> is read.</p>

<h2><a name="[arguments_...]"
>[arguments ...] <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Optional arguments passed to the running program as ARGV. The program is assumed to know what to do with these.</p>

<h1><a name="Generated_files"
>Generated files <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>If JIT debugging is enabled (e.g. via <code lang='und' xml:lang='und'>&#45;&#45;parrot&#45;debug 04</code>), the following additional output files are generated:</p>

<pre lang='und' xml:lang='und'>  F&#60;file.stabs.s&#62;     stabsfile for the program
  F&#60;file.o&#62;           object file with debug information
  F&#60;EVAL_n&#62;           source of C&#60;compile&#62; op number I&#60;n&#62;
  F&#60;EVAL_n.stabs.s&#62;   stabsfile for this block
  F&#60;EVAL_n.o&#62;         object file with debug information</pre>

<p>See <em lang='und' xml:lang='und'><a href="jit.pod.html">docs/jit.pod</a></em> for further information.</p>

<h1><a name="About_runcores"
>About runcores <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>The runcore (or runloop) tells Parrot how to find the C code that implements each instruction. Parrot provides more than one way to do this, partly because no single runcore will perform optimally on all architectures (or even for all problems on a given architecture), and partly because some of the runcores have specific debugging and tracing capabilities.</p>

<p>In the default &#34;slow&#34; runcore, each opcode is a separate C function. That&#39;s pretty easy in pseudocode:</p>

<pre lang='und' xml:lang='und'>    slow_runcore( op ):
        while ( op ):
            op = op_function( op )
            check_for_events()</pre>

<p>The GC debugging runcore is similar:</p>

<pre lang='und' xml:lang='und'>    gcdebug_runcore( op ):
        while ( op ):
            perform_full_gc_run()
            op = op_function( op )
            check_for_events()</pre>

<p>Of course, this is much slower, but is extremely helpful for pinning memory corruption problems that affect GC down to single&#45;instruction resolution. See <a href='http://www.oreillynet.com/onlamp/blog/2007/10/debugging_gc_problems_in_parro.html'><a href="http://www.oreillynet.com/onlamp/blog/2007/10/debugging_gc_problems_in_parro.html">http://www.oreillynet.com/onlamp/blog/2007/10/debugging_gc_problems_in_parro.html</a></a> for more information.</p>

<p>The trace and profile cores are also based on the &#34;slow&#34; core, doing full bounds checking, and also printing runtime information to stderr.</p>

<p>The switched core eschews these tiny op functions in favor of cases in a large switch statement:</p>

<pre lang='und' xml:lang='und'>    switch_runcore( op ):
        while ( op ):
            switch *op:
                case NOP:
                    ...
                case STORE:
                    ...
                ...</pre>

<p>Depending on the C compiler implementation, this may be faster than function calling. On older systems, it may fail to compile altogether.</p>

<p>The computed&#45;goto (&#34;cgoto&#34;) runcore avoids the overhead of function calls by jumping directly to the address where each opcode&#39;s function starts. The computed&#45;goto&#45;prederef (&#34;CGP&#34;) core takes this one step further by replacing opcode numbers in the bytecode with those opfunc addresses. See &#34;Predereferencing&#34; in <em lang='und' xml:lang='und'><a href="glossary.pod.html">docs/glossary.pod</a></em> for a fuller explanation.</p>

<p>Finally, the JIT runcore uses the &#34;slow&#34; core, but also creates and jumps to JIT&#45;compiled native code for supported opcodes. &#34;cgp&#45;jit&#34; and &#34;switched&#45;jit&#34; are variations that use the CGP or switched core but run JIT code when possible.</p>

<h1><a name="Operation_table"
>Operation table <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<pre lang='und' xml:lang='und'> Command Line          Action         Output
 &#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;
 parrot x.pir          run
 parrot x.pasm         run
 parrot x.pbc          run
 &#45;o x.pasm x.pir       ass            x.pasm
 &#45;o x.pasm y.pasm      ass            x.pasm
 &#45;o x.pbc  x.pir       ass            x.pbc
 &#45;o x.pbc  x.pasm      ass            x.pbc
 &#45;o x.pbc &#45;r x.pasm    ass/run pasm   x.pbc
 &#45;o x.pbc &#45;r &#45;r x.pasm ass/run pbc    x.pbc
 &#45;o x.o    x.pbc       obj</pre>

<p>... where the possible actions are:</p>

<pre lang='und' xml:lang='und'>  run ... yes, run the program
  ass ... assemble sourcefile
  obj ..  produce native (ELF) object file for the EXEC subsystem</pre>

<h1><a name="BUGS"
>BUGS <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>Yes.</p>

<h1><a name="FILES"
>FILES <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p><em lang='und' xml:lang='und'>main.c</em></p>

<h1><a name="AUTHOR"
>AUTHOR <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>Leopold Toetsch <code lang='und' xml:lang='und'>lt@toetsch.at</code></p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../resources/parrot_small.png"
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
