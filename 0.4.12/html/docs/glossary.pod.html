<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Parrot Glossary</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Parrot Glossary</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../html/index.html">Contents</a> | <a href="../../html/docs.html">Documentation</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>docs/glossary.pod &#45; Parrot Glossary</p>

<h1><a name="SUMMARY"
>SUMMARY <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>Short descriptions of words and acronyms you might want to know because they show up in Parrot development.</p>

<h1><a name="GLOSSARY"
>GLOSSARY <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<h2><a name="AST"
>AST <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Abstract Syntax Tree.</p>

<h2><a name="bcg"
>bcg <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>bcg is an acronym for Byte Code Generation.
bcg will be part of the Parrot Compiler tools.
It will aid in coverting POST to byte code.</p>

<h2><a name="Continuations"
>Continuations <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Think of continuations as an execution &#34;context&#34;.
This context includes everything local to that execution path,
not just the stack.
It is a snapshot in time (minus global variables).
While it is similar to C&#39;s <code lang='und' xml:lang='und'>setjmp</code> (taking the continuation)/<code lang='und' xml:lang='und'>longjmp</code> (invoking the continuation),
<code lang='und' xml:lang='und'>longjmp</code>&#39;ing only works &#34;down&#34; the stack; jumping &#34;up&#34; the stack (ie,
back to a frame that has returned) is bad.
Continuations can work either way.</p>

<p>We can do two important things with continuations:</p>

<ol>
<li>Create and pass a continuation object to a subroutine,
which may recursively pass that object up the call chain until,
at some point,
the continuation can be called/executed to handle the final computation or return value.
This is pretty much tail recursion.</li><p class="pad"></p>

<li>Continuations can be taken at an arbitrary call depth,
freezing the call chain (context) at that point in time.
If we save that continuation object into a variable,
we can later reinstate the complete context by its &#34;handle&#34;.
This allows neat things like backtracking that aren&#39;t easily done in conventional stacked languages,
such as C.
Since continuations represent &#34;branches&#34; in context,
it requires an environment that uses some combination of heap&#45;based stacks,
stack trees and/or stack copying.</li><p class="pad"></p>
</ol>

<p>It is common in a system that supports continuations to implement <a href='#Co%2DRoutines'>co&#45;routines</a> on top of them.</p>

<p>A continuation is a sort of super&#45;closure.
When you take a continuation,
it makes a note of the current call stack and lexical scratchpads,
along with the current location in the code.
When you invoke a continuation,
the system drops what it&#39;s doing,
puts the call stack and scratchpads back,
and jumps to the execution point you were at when the continuation was taken.
It is,
in effect,
like you never left that point in your code.</p>

<p>Note that,
like with closures,
it only puts the *scratchpads* back in scope &#45; it doesn&#39;t do anything with the values in the variables that are in those scratchpads.</p>

<h2><a name="Co&#45;Routines"
>Co&#45;Routines <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Co&#45;routines are virtually identical to normal subroutines,
except while subroutines always execute from their starting instruction to where they return,
co&#45;routines may suspend themselves (or be suspended asynchronously if the language permits) and resume at that point later.
We can implement things like &#34;factories&#34; with co&#45;routines.
If the co&#45;routine never returns,
every time we call it,
we &#34;resume&#34; the routine.</p>

<p>A co&#45;routine is a subroutine that can stop in the middle,
and start back up later at the point you stopped.
For example:</p>

<pre lang='und' xml:lang='und'>    sub sample : coroutine {
       print &#34;A\n&#34;;
       yield;
       print &#34;B\n&#34;;
       return;
    }

    sample();
    print &#34;Foo!\n&#34;;
    sample();</pre>

<p>will print</p>

<pre lang='und' xml:lang='und'>     A
     Foo!
     B</pre>

<p>Basically, the <code lang='und' xml:lang='und'>yield</code> keyword says, &#34;Stop here, but the next time we&#39;re called, pick up at the next statement.&#34; If you return from a co&#45;routine, the next invocation starts back at the beginning. Co&#45;routines remember all their state, local variables, and suchlike things.</p>

<h2><a name="COW"
>COW <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>COW stands for Copy On Write. This is a pure speed&#45;hack technique that copies strings without actually copying the string data until it&#39;s absolutely necessary.</p>

<p>If you have a string A, and make a copy of it to get string B, the two strings should be identical, at least to start. With COW, they are, because string A and string B aren&#39;t actually two separate strings &#45; they&#39;re the same string, marked COW. If either string A or string B are changed, the system notes it and only at that point does it make a copy of the string and change it.</p>

<p>If the program never actually changes the string &#45; something that&#39;s fairly common &#45; the program need never make a copy, saving both memory and time.</p>

<h2><a name="destruction"
>destruction <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Destruction is low level memory clean up, such as calling <code lang='und' xml:lang='und'>free</code> on <code lang='und' xml:lang='und'>malloc</code>ed memory. This happens after <a href='#finalization'>&#34;finalization&#34;</a>, and if resources are adequate, may only happen as a side effect of program exit.</p>

<h2><a name="DOD"
>DOD <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Dead Object Detection is the process of sweeping through all the objects, variables, and whatnot inside of Parrot, and deciding which ones are in use and which ones aren&#39;t. The ones that aren&#39;t in use are then freed up for later reuse. (After they&#39;re destroyed, if active destruction is warranted.)</p>

<p>See also: <a href='#GC'>&#34;GC&#34;</a></p>

<h2><a name="finalization"
>finalization <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Finalization is high&#45;level, user visible cleanup of objects, such as closing an associated DB handle. Finalization reduces active objects down to passive blocks of memory, but does not actually reclaim that memory. Memory is reclaimed by the related <a href='#destruction'>&#34;destruction&#34;</a> operation, as and when necessary.</p>

<h2><a name="fotw"
>fotw <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>File of the week. A file that is designated to be focus of development for a week, aiming for code cleanups and general improvements.</p>

<h2><a name="GC"
>GC <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Garbage Collection is the process of sweeping through all the active objects, variables, and structures, marking the memory they&#39;re using as in use, and all other memory is freed up for later reuse.</p>

<p>Garbage Collection and Dead Object Detection are separate in Parrot, since we generally chew through memory segments faster than we chew through objects. (This is a characteristic peculiar to Perl and other languages that do string processing. Other languages chew through objects faster than memory)</p>

<p>See also: <a href='#DOD'>&#34;DOD&#34;</a></p>

<h2><a name="HLL"
>HLL <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>High&#45;Level Language</p>

<h2><a name="ICU"
>ICU <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>International Components for Unicode</p>

<p>ICU is a C and C++ library that provides support for Unicode on a variety of platforms. It was added to Parrot with the 0.0.8 release to provide future Unicode support.</p>

<p><a href='http://oss.software.ibm.com/icu/index.html'><a href="http://oss.software.ibm.com/icu/index.html">http://oss.software.ibm.com/icu/index.html</a></a></p>

<h2><a name="IMC"
>IMC <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Parrot InterMediate Code, or another name for PIR. A convention once arose to name input files to IMCC with the extension &#34;.imc&#34;, so the name IMC became synonymous with PIR. This file extension has since been deprecated.</p>

<p>See also <a href='#IMCC'>&#34;IMCC&#34;</a>, <a href='#PIR'>&#34;PIR&#34;</a>.</p>

<h2><a name="IMCC"
>IMCC <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Parrot&#39;s Intermediate Code Compiler, which started its life as an improved Parrot assembler, and eventually became so integrated with Parrot that it became the Parrot executable (being able to load and run PBC files, PASM files or PIR files).</p>

<p>See also <a href='#PIR'>&#34;PIR&#34;</a>.</p>

<h2><a name="JAPH"
>JAPH <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>In the Parrot context a JAPH is a small script that prints the string &#34;Just another Parrot Hacker\&#34;.</p>

<h2><a name="MRO"
>MRO <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Method resolution order</p>

<h2><a name="Native_Call_Interface"
>Native Call Interface <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>This let&#39;s Parrot talk to native &#34;C&#34; libraries, without a C&#45;compiler.</p>

<h2><a name="NCI"
>NCI <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Acronym for Native Call Interface.</p>

<h2><a name="Packfile"
>Packfile <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Another name for a PBC file, due to the names used for data structures in one of the early implementations in Perl 5.</p>

<h2><a name="PAST"
>PAST <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Acronym for Parrot Abstract Syntax Tree.</p>

<h2><a name="PBC"
>PBC <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Parrot Byte Code. The name for the &#34;executable&#34; files that can be passed to the Parrot interpreter for immediate execution (although PASM and IMC files can be executed directly, too).</p>

<p>See also <a href='#Packfile'>&#34;Packfile&#34;</a>.</p>

<h2><a name="PDD"
>PDD <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Acronym for Parrot Design Document. These documents describe the features that the Parrot interpreter should implement.</p>

<p>See also <a href='TODO#pdd00_pdd'>&#34;pdd00_pdd&#34; in pdds</a>.</p>

<h2><a name="PGE"
>PGE <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Parrot Grammar Engine.</p>

<h2><a name="PIL"
>PIL <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Pugs&#39; Intermediate Language.</p>

<h2><a name="PIR"
>PIR <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Parrot Intermediate Representation. A medium&#45;level assembly language for Parrot that hides messy details like register allocation so language compiler writers who target PIR don&#39;t have to roll their own.</p>

<p>See also <a href='#IMC'>&#34;IMC&#34;</a>.</p>

<h2><a name="PMC"
>PMC <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>PMC is an acronym for Parrot Magic Cookie. (Or Cracker, your choice.) PMC classes are the primitives that Parrot&#45;based languages use to represent their fundamental types, such as Perl&#39;s scalar values.</p>

<h2><a name="POD"
>POD <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>POD is an acronym for Plain Old Documentation. This is for now the preferred form for all kinds of documentation in Parrot. See &#34;perldoc perlpod&#34; for details.</p>

<h2><a name="POST"
>POST <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Parrot Opcode Syntax Tree.</p>

<h2><a name="Predereferencing"
>Predereferencing <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>A bytecode transformation technique which reduces the amount of pointer dereferencing done in the inner loop of the interpreter by pre&#45;converting opcode numbers into pointers to their opfuncs, and also converting the register numbers and constant numbers in the arguments to the ops into pointers.</p>

<p>The original implementation by Gregor Purdy was posted on 2001&#45;12&#45;11. On one test system, it resulted in a 22% speed increase on a test program with a tight inner loop.</p>

<p><a href='http://archive.develooper.com/perl6&#45;internals@perl.org/msg06941.html'><a href="http://archive.develooper.com/perl6&#45;internals@perl.org/msg06941.html">http://archive.develooper.com/perl6&#45;internals@perl.org/msg06941.html</a></a></p>

<p>On 2001&#45;12&#45;18, predereferencing got a speed boost (to about 47% faster than the regular DO_OP inner loop &#45;&#45; without compiler optimizations turned on). This was due to an off&#45;list (actually over lunch) suggestion by John Kennedy that instead of pre&#45;initializing the new copy of the bytecode with NULL pointers, we pre&#45;initialize it with pointers to a pseudo&#45;opfunc that does the predereferencing whenever it is encountered.</p>

<p>On 2002&#45;04&#45;11, Jason Gloudon suggested combining aspects of the Computed Goto Core and the Prederef[erencing] Core.</p>

<p><a href='http://archive.develooper.com/perl6&#45;internals@perl.org/msg07064.html'><a href="http://archive.develooper.com/perl6&#45;internals@perl.org/msg07064.html">http://archive.develooper.com/perl6&#45;internals@perl.org/msg07064.html</a></a></p>

<p>The week of 2003&#45;02&#45;09, Leopold Toetsch combined Computed Goto and Predereferencing to produce the CGP core.</p>

<p><a href='http://dev.perl.org/perl6/list&#45;summaries/2003/p6summary.2003&#45;02&#45;09.html#Week_of_the_alternative_runloops'><a href="http://dev.perl.org/perl6/list&#45;summaries/2003/p6summary.2003&#45;02&#45;09.html#Week_of_the_alternative_runloops">http://dev.perl.org/perl6/list&#45;summaries/2003/p6summary.2003&#45;02&#45;09.html#Week_of_the_alternative_runloops</a></a></p>

<p>Later, on 2003&#45;02&#45;14, Leopold Totsch and Nicholas Clark combined the JIT and the Computed Goto Prederef cores to great effect.</p>

<p><a href='http://www.perl.com/pub/a/2003/02/p6pdigest/20030216.html'><a href="http://www.perl.com/pub/a/2003/02/p6pdigest/20030216.html">http://www.perl.com/pub/a/2003/02/p6pdigest/20030216.html</a></a></p>

<h2><a name="run_core"
>run core <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>aka run loop, aka runcore. The way Parrot executes Parrot Byte Code. See <a href='TODO'>running.pod</a> on how to tell parrot which run core should be used.</p>

<h2><a name="SMOP"
>SMOP <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Simple Meta Object Protocol</p>

<p>A prototype object model written in PIR.</p>

<h2><a name="TGE"
>TGE <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Tree Grammar Engine</p>

<h2><a name="Vtable"
>Vtable <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>A table of operations attached to some data types, such as PMCs and strings. Vtables are used to avoid using switches or long <code lang='und' xml:lang='und'>if</code> chains to handle different data types. They&#39;re similar to method calls, except that their names are pre&#45;selected.</p>

<h2><a name="Warnock&#39;s_Dilemma"
>Warnock&#39;s Dilemma <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>The dilemma you face when posting a message to a public forum about something and not even getting an acknowledgment of its existence. This leaves you wondering if your problem is unimportant or previously addressed, if everyone&#39;s waiting on someone else to answer you, or if maybe your mail never actually made it to anyone else in the forum.</p>

<h1><a name="CORRECTIONS"
>CORRECTIONS <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>Please send corrections to the parrot&#45;porters mailing list.</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
