<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Object and Class semantics for Parrot</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Object and Class semantics for Parrot</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../html/index.html">Contents</a> | <a href="../../../html/docs.html">Documentation</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>docs/pdds/pdd15_objects.pod &#45; Object and Class semantics for Parrot</p>

<h1><a name="ABSTRACT"
>ABSTRACT <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>This PDD describes the semantics of Parrot&#39;s object and class systems.</p>

<h1><a name="VERSION"
>VERSION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>$Revision$</p>

<h1><a name="DEFINITIONS"
>DEFINITIONS <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<h2><a name="Object"
>Object <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>An object is a value that incorporates both data and behavior related to that data.</p>

<h2><a name="Class"
>Class <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>A class defines a pattern of characteristics and behaviors from which objects are constructed.</p>

<h2><a name="Attribute"
>Attribute <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>An attribute is a slot in an object that contains a value,
generally a PMC.
Attributes are referenced by class name/attribute name pairs.</p>

<p>Attributes are set on a class&#45;wide basis,
and all the objects of a class will have the same set of attributes.
Most OO languages don&#39;t allow attribute changes to existing classes,
but Parrot&#39;s base attribute system does allow it.
In order to safely support advanced dynamic features in HLLs,
attributes are not accessible via fixed attribute offsets,
but only via named lookup.</p>

<h2><a name="Method"
>Method <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>A method is a piece of code that you invoke by name through an object.
Methods implement the behaviour of an object.</p>

<h2><a name="Parent_class"
>Parent class <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Also called the super&#45;class.
The parent class is,
in an inheritance situation,
the class being derived from.
If A derives from B,
B is the parent class of A.</p>

<h2><a name="Child_class"
>Child class <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Also called the sub&#45;class.
The child class is,
in an inheritance situation,
the class doing the deriving.
If A derives from B,
A is the child class.</p>

<h2><a name="Role"
>Role <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>A role adds attributes and methods into a class without inheritance.
The composed class retains a list of roles applied to it (so they can be checked with <code lang='und' xml:lang='und'>does</code>),
but otherwise maintains no distinction between composed attributes and methods and those defined in the class.</p>

<h2><a name="Delegate"
>Delegate <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>An object that is transparently (to the user) embedded in another object.
Delegate objects are used in those cases where we can&#39;t inherit from a class because the class is from a different object universe.</p>

<h2><a name="Property"
>Property <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>A property is a role that only adds attributes and accessors.</p>

<p>Properties are generally assigned at runtime,
and a particular property may or may not exist on a PMC at any particular time.
Properties are not restricted to objects as such&#45;&#45;any PMC may have a property attached to it.</p>

<h2><a name="Interface"
>Interface <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>An interface is a role that only adds methods.</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<dl>
<dt><a
>&#45; The object and class system provides the flexibility to implement a core set of dynamic languages (Perl 6,
Ruby,
Python,
etc).
Other class systems may be implemented later to support other languages.</a></dt><p class="pad"></p>

<dt><a
>&#45; Classes may have an associated namespace.
(Anonymous classes are not associated with a namespace.)</a></dt><p class="pad"></p>

<dt><a name="&#45;_Classes_may_have_one_or_more_immediate_parent_classes"
>&#45; Classes may have one or more immediate parent classes</a></dt><p class="pad"></p>

<dt><a name="&#45;_Classes_may_have_a_catalog_of_attribute_names."
>&#45; Classes may have a catalog of attribute names.</a></dt><p class="pad"></p>

<dt><a name="&#45;_Classes_may_have_a_list_of_roles_they_implement"
>&#45; Classes may have a list of roles they implement</a></dt><p class="pad"></p>

<dt><a name="&#45;_Classes_can_instantiate_an_object_of_their_class"
>&#45; Classes can instantiate an object of their class</a></dt><p class="pad"></p>

<dt><a name="&#45;_Classes_can_add_and_remove_parent_classes"
>&#45; Classes can add and remove parent classes</a></dt><p class="pad"></p>

<dt><a name="&#45;_Classes_can_add_and_remove_attributes"
>&#45; Classes can add and remove attributes</a></dt><p class="pad"></p>

<dt><a name="&#45;_Classes_can_add_(but_not_remove)_roles"
>&#45; Classes can add (but not remove) roles</a></dt><p class="pad"></p>

<dt><a
>&#45; Classes are instances of a meta&#45;class and have their own sets of class methods and class attributes</a></dt><p class="pad"></p>

<dt><a
>&#45; Objects may have an array of attributes.
Attribute values may be PMCs or a low&#45;level type.</a></dt><p class="pad"></p>

<dt><a name="&#45;_Objects_have_an_associated_class."
>&#45; Objects have an associated class.</a></dt><p class="pad"></p>

<dt><a name="&#45;_Objects_may_have_a_custom_vtable_or_use_a_class&#45;wide_vtable."
>&#45; Objects may have a custom vtable or use a class&#45;wide vtable.</a></dt><p class="pad"></p>

<dt><a name="&#45;_Objects_can_call_a_method"
>&#45; Objects can call a method</a></dt><p class="pad"></p>

<dt><a name="&#45;_Objects_can_retrieve_a_method_PMC_for_a_method_(for_deferred_method_calls)"
>&#45; Objects can retrieve a method PMC for a method (for deferred method calls)</a></dt><p class="pad"></p>

<dt><a name="&#45;_Objects_can_fetch_their_class"
>&#45; Objects can fetch their class</a></dt><p class="pad"></p>

<dt><a name="&#45;_Objects_can_get_an_attribute_by_name"
>&#45; Objects can get an attribute by name</a></dt><p class="pad"></p>

<dt><a name="&#45;_Objects_can_set_an_attribute_by_name"
>&#45; Objects can set an attribute by name</a></dt><p class="pad"></p>

<dt><a
>&#45; Objects can be subclassed (note that objects may not necessarily be able to have their classes changed arbitrarily,
but making a subclass and moving the object to it is allowable)</a></dt><p class="pad"></p>

<dt><a name="&#45;_High&#45;level_objects_can_subclass_low&#45;level_PMCs"
>&#45; High&#45;level objects can subclass low&#45;level PMCs</a></dt><p class="pad"></p>
</dl>

<h1><a name="IMPLEMENTATION"
>IMPLEMENTATION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>There are four pieces to the object implementation.
There are the PMCs for the classes,
roles,
and objects,
the opcodes the engine uses to do objecty things,
the specific vtable functions used to perform those objecty things,
and the supporting code provided by the interpreter engine to do the heavy lifting.</p>

<p>Parrot,
in general,
doesn&#39;t restrict operations on objects and classes.
If a language has restrictions on what can be done with them,
the language is responsible for making sure that disallowed things do not happen.
For example,
Parrot permits multiple inheritance,
and will not stop code that adds a new parent to an existing class.
If a language doesn&#39;t allow for multiple inheritance it must not emit code which would add multiple parents to a class.
(Parrot may,
at some point,
allow imposition of runtime restrictions on a class,
but currently it doesn&#39;t.)</p>

<h2><a name="Class_PMC_API"
>Class PMC API <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>There are two PMC classes,
<code lang='und' xml:lang='und'>Class</code> and <code lang='und' xml:lang='und'>Object</code>.
Class PMCs hold all the class&#45;specific information.
Instantiating a new OO class creates a new Class PMC,
and enters the new OO class into Parrot&#39;s PMC class table,
at which point it is indistinguishable from any other PMC class.</p>

<p>It&#39;s important to note that &#39;standard&#39; classes are Class PMC instances,
or instances of a subclass of the Class PMC,
and &#39;standard&#39; objects are Object PMCs.
It isn&#39;t necessary to create a brand new low&#45;level PMC class for each OO class,
and they all share the Class or Object vtable,
respectively.</p>

<p>An instance of the Class PMC has ten internal attributes,
which are:</p>

<dl>
<dt><a name="0"
>0</a></dt><p class="pad"></p>

<dd>The class name</dd><p class="pad"></p>

<dt><a name="1"
>1</a></dt><p class="pad"></p>

<dd>A link to the class&#39;s associated namespace</dd><p class="pad"></p>

<dt><a name="2"
>2</a></dt><p class="pad"></p>

<dd>A &#34;have I been instantiated since I was last modified&#34; flag</dd><p class="pad"></p>

<dt><a name="3"
>3</a></dt><p class="pad"></p>

<dd>An array PMC of the immediate parent classes</dd><p class="pad"></p>

<dt><a name="4"
>4</a></dt><p class="pad"></p>

<dd>A cached array of all parent PMCs,
in search order (this is an optional optimization,
and can be calculated from the class&#39;s rules of inheritance,
the list of immediate parent classes,
and the parent classes&#39; rules of inheritance)</dd><p class="pad"></p>

<dt><a name="5"
>5</a></dt><p class="pad"></p>

<dd>An array PMC of the composed roles (these are Role PMCs,
not string names of roles).</dd><p class="pad"></p>

<dt><a name="6"
>6</a></dt><p class="pad"></p>

<dd>A hash PMC of the methods defined in the class or composed into the class</dd><p class="pad"></p>

<dt><a name="7"
>7</a></dt><p class="pad"></p>

<dd>A hash PMC of the overloaded PMC vtable entries for the class.</dd><p class="pad"></p>

<dt><a name="8"
>8</a></dt><p class="pad"></p>

<dd>The class attribute metadata hash.
Keys are the attribute names and the values are a hash of attribute characteristics,
including name,
type,
the class they&#39;re associated with and any flags (for example,
private).
Note that this only stores metadata for the attributes defined in this class,
and not for attributes inherited from its parents.</dd><p class="pad"></p>

<dt><a name="9"
>9</a></dt><p class="pad"></p>

<dd>The full attribute lookup table.
This associates attribute names with an index into the object&#39;s attribute storage (an array).
It includes all attributes defined in the current class and every other class that it inherits from either directly or indirectly.
The table is keyed on the name of the class where the attribute is defined,
along with the attribute name.
The value is an index into the per&#45;object attribute store.</dd><p class="pad"></p>

<dt><a name="10"
>10</a></dt><p class="pad"></p>

<dd>The attribute cache.
While the attribute lookup table defines every attribute,
whether it is visible or not with the current method resolution order (MRO),
the cache maps the names of the visible attributes directly to an index in the per&#45; object attribute store.
That saves a more costly lookup in the full attribute lookup table.</dd><p class="pad"></p>
</dl>

<p>The attribute catalog holds only the attributes defined in a particular class.
When instantiating an object,
the object data store is created as a ResizablePMCArray,
so doesn&#39;t need any specific details of the class&#39;s attribute structure.
As attributes are set in the object (based on the index in the lookup table),
the Array expands to accommodate the attribute indexes that are actually used.
In the common case,
a relatively small set near the lower index range is all that will be used.</p>

<p>When setting the attribute cache it is necessary to scan all parent classes as well as the instantiated class for attributes defined there.
The inheritance rules (MRO) for a particular HLL will determine which child class attributes override which parent class attributes.
The cache is only set on individual accesses to a particular attribute.</p>

<p>(If a parent class changes its set of attributes,
should that change appear in later instantiations of objects from child classes?
If so,
all of these classes would need to be re&#45;constructed as a result of the change; note that any already instantiated objects would refer to the old class.
NOTE: flag old classes with an &#34;updated&#34; status,
to notify objects of the old class that they should rebless themselves into the new class next time they access the old class?)</p>

<p>Class PMCs also have the &#34;I am a class&#34; flag set on them.</p>

<h3><a name="Classes,_Namespaces,_and_the_Class_Registry"
>Classes,
Namespaces,
and the Class Registry</a></h3>

<p>Extending an existing class that has been instantiated creates a new class object that replaces the old class object in the Namespace.
However,
the old class object must be kept,
as the old objects still point to it and do their method resolution and attribute lookup through that class object.</p>

<p>If a class hasn&#39;t been instantiated,
adding a method or attribute only modifies the existing class object instead of creating a new class object.
Extending a class that has been instantiated only causes the creation of a new class object the first time it&#39;s extended.
After that,
methods and attributes added to it will only modify the existing class object until it is instantiated again.</p>

<p>The Namespace always points to the most current incarnation of the class.
All the class objects that belong to a particular namespace store a pointer to that Namespace object.
They keep that pointer even if the Namespace object no longer stores a pointer to them.</p>

<p>Since any given class name may have multiple corresponding class objects,
the class registry has a much diminished role in this implementation.
Its only responsibility is maintaining a mapping of unique IDs to class objects throughout the system.
It can&#39;t be used for looking up classes by name,
because it&#39;s possible to have multiple classes with the same name in the same namespace.
The class registry may need to have names removed (since it doesn&#39;t care about names anymore).
Low&#45;level PMC types will also need entries in the namespace hierarchy.
We may eventually be able to eliminate the registry of class IDs altogether.</p>

<p>A class can be garbage collected when it has no instantiated objects and no Namespace object referencing it (to mark it as live).
When a class is garbage collected,
it should remove itself from the registry.</p>

<h3><a name="Class_Vtable_Entries"
>Class Vtable Entries</a></h3>

<p>To make this work all Classes need the following vtable entries.</p>

<dl>
<dt><a name="new()"
>new()</a></dt><p class="pad"></p>

<dd>Instantiate a new object from the class.
Set the instantiated flag on the class.</dd><p class="pad"></p>

<dt><a name="clone()"
>clone()</a></dt><p class="pad"></p>

<dd>Create an (anonymous) clone of the class.
Unset the instantiated flag on the new class.</dd><p class="pad"></p>

<dt><a name="add_method(string_*,_method_*)"
>add_method(string *,
method *)</a></dt><p class="pad"></p>

<dd>Add a method to the class.</dd><p class="pad"></p>

<dt><a name="add_attribute(string_*,_key_*)"
>add_attribute(string *,
key *)</a></dt><p class="pad"></p>

<dd>Add an attribute to the class.</dd><p class="pad"></p>

<dt><a name="add_parent(class_*)"
>add_parent(class *)</a></dt><p class="pad"></p>

<dd>Add a parent to the class.</dd><p class="pad"></p>

<dt><a name="add_role(role_*)"
>add_role(role *)</a></dt><p class="pad"></p>

<dd>Add a role to the class.</dd><p class="pad"></p>

<dt><a name="find_method(string_*)"
>find_method(string *)</a></dt><p class="pad"></p>

<dd>Returns the PMC for the named method.
If no method of this name exists,
nor can be constructed,
returns a Null PMC.</dd><p class="pad"></p>

<dd>Note that for languages which support default fallback methods,
such as Perl 5&#39;s AUTOLOAD,
this would be the place to return it if a normal lookup fails.</dd><p class="pad"></p>

<dd>Since the method list and vtable override list are stored in the class PMC,
method finding is a lookup on the class object and not a lookup in the namespace.
(This could be handled automatically whenever a class is associated with a namespace.) Just adding a sub to a namespace will not automatically make it a method of the class,
you have to call add_method too.</dd><p class="pad"></p>

<dt><a name="isa(class_*)"
>isa(class *)</a></dt><p class="pad"></p>

<dd>Returns true or false if the class passed in as a parameter is in the inheritance hierarchy of the object.
{{This should also support type names and namespace names as a parameter,
not just class objects.}}</dd><p class="pad"></p>

<dt><a name="can(string_*)"
>can(string *)</a></dt><p class="pad"></p>

<dd>Returns true or false if the class can perform the requested method.
(Including with an AUTOLOAD)</dd><p class="pad"></p>

<dt><a name="does(class_*)"
>does(class *)</a></dt><p class="pad"></p>

<dd>Returns true or false to note whether the class in question implements the interface passed in.</dd><p class="pad"></p>

<dt><a name="inspect()"
>inspect()</a></dt><p class="pad"></p>

<dd>Return a data structure of all information relevant to introspection on the class.</dd><p class="pad"></p>

<dt><a name="inspect_str(string_*)"
>inspect_str(string *)</a></dt><p class="pad"></p>

<dd>Return a PMC Hash,
Array,
String,
Integer,
or Number value with introspection information corresponding to the requested string name.
This may be overridden to report information about the internals of a class that aren&#39;t actually true (useful for mocking).
It can also be used for straight introspection capabilities even when a particular class is using keyed access to act like a hash or array or attribute access to act as an object.</dd><p class="pad"></p>

<dt><a name="remove_attribute(string_*)"
>remove_attribute(string *)</a></dt><p class="pad"></p>

<dd>Remove an attribute from the class.</dd><p class="pad"></p>

<dt><a name="remove_method(string_*)"
>remove_method(string *)</a></dt><p class="pad"></p>

<dd>Remove a method from the class.</dd><p class="pad"></p>

<dt><a name="remove_parent(string_*)"
>remove_parent(string *)</a></dt><p class="pad"></p>

<dd>Remove a parent from the class.</dd><p class="pad"></p>

<dt><a name="remove_role(string_*)"
>remove_role(string *)</a></dt><p class="pad"></p>

<dd>Remove a role from the class.</dd><p class="pad"></p>
</dl>

<p>Currently Parrot only supports mutating a class&#39; metainformation for Class classes.
This is a restriction which will be lifted at some point soon.</p>

<h3><a name="Class_Methods"
>Class Methods</a></h3>

<p>These methods are just syntactic sugar for the vtable functions.
They are not included in the Class PMC by default,
but added to Class as a role.</p>

<dl>
<dt><a name="name"
>name</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>    $P1 = $P2.name( $S3 )</pre>

<dd>The accessor for the name attribute. With no argument, it simply returns the current value for name. When passed an argument, it sets the name of the class, and also sets the association with a namespace. With no argument it only returns the current value of the name attribute.</dd><p class="pad"></p>

<dt><a name="namespace"
>namespace</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>    $P1 = $P2.namespace()</pre>

<dd>Retrieve the namespace object associated with the class.</dd><p class="pad"></p>

<dt><a name="new"
>new</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>    $P1 = $P2.new( &#39;myattrib&#39; =&#62; &#34;Foo&#34; )</pre>

<dd>Create a new instance object from the class object. It takes an optional, slurpy, named list of attributes and values to initialize the object. Passing attribute names that weren&#39;t declared in the class is an error.</dd><p class="pad"></p>

<dt><a name="add_attribute"
>add_attribute</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  $P1.add_attribute($S2)
  $P1.add_attribute($S2, $S3)
  $P1.add_attribute($S2, $P3)</pre>

<dd>Adds a single attribute to the class. It takes a simple string name and, optionally, a simple string value or key specifying a type name. (A type name just checks <code lang='und' xml:lang='und'>does</code>, and doesn&#39;t necessarily correspond to a class or role namespace.)</dd><p class="pad"></p>

<dd>If the class has already been instantiated, adding a new attribute triggers the creation of a new class, replacing the old class. See <a href='#Classes%2C_Namespaces%2C_and_the_Class_Registry'>&#34;Classes, Namespaces, and the Class Registry&#34;</a>.</dd><p class="pad"></p>

<dt><a name="attributes"
>attributes</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  $P1 = $P2.attributes()</pre>

<dd>An accessor for the attributes of the class. It returns the a Hash of all attributes, with a key of the attribute name and a value of a Hash containing the attribute&#39;s metadata. The accessor is read&#45;only.</dd><p class="pad"></p>

<dt><a name="add_method"
>add_method</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  $P1.add_method($S2, $P3)</pre>

<dd>Adds a method to the class. It takes a simple string name and a method PMC. If the method already exists (and isn&#39;t a Multi) it will replace the method with the new method and throw a warning.</dd><p class="pad"></p>

<dd>It also takes named parameters to flag whether the method is a vtable override, and whether it is anonymous (no named entry as a method, only as a vtable).</dd><p class="pad"></p>

<dt><a name="methods"
>methods</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  $P1 = $P2.methods()</pre>

<dd>An accessor for the methods of the class. It returns a Hash of all methods, with a key of the method name and a value of an invokable PMC. Note that the methods list includes any methods that were composed into the class from roles.</dd><p class="pad"></p>

<dt><a name="add_parent"
>add_parent</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  $P1.add_parent($P3)</pre>

<dd>Adds a single parent to the class. It takes an instance of the Class PMC.</dd><p class="pad"></p>

<dt><a name="parents"
>parents</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  $P1 = $P2.parents()</pre>

<dd>An accessor for the parents of the class. It returns an Array of all parents. The accessor is read&#45;only.</dd><p class="pad"></p>

<dt><a name="roles"
>roles</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  $P1 = $P2.roles()</pre>

<dd>An accessor for the roles of the class. It returns an Array of all roles. The accessor is read&#45;only.</dd><p class="pad"></p>

<dt><a name="add_role"
>add_role</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  $P1.add_role($P2, [named])</pre>

<dd>Adds a single role to the class. It takes an instance of the Role PMC as a required positional parameter, and the optional named parameters <code lang='und' xml:lang='und'>exclude</code> and <code lang='und' xml:lang='und'>alias</code>; see <a href='#Role_Conflict_Resolution'>&#34;Role Conflict Resolution&#34;</a> for more details.</dd><p class="pad"></p>

<dt><a name="subclass"
>subclass</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  $P1 = $P2.subclass($S3)</pre>

<dd>Create a subclass of $P2 with name $S3 and return it in $P1.</dd><p class="pad"></p>

<dt><a name="isa"
>isa</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  $I1 = $P2.isa($S3)</pre>

<dd>Returns true if the class name passed in as a parameter is in the inheritance hierarchy of the class (this is not the same as the inheritance hierarchy of objects instantiated from the class), false otherwise.</dd><p class="pad"></p>

<dt><a name="can"
>can</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  $I1 = $P2.can($S3)</pre>

<dd>Returns true if the class object can perform the requested method, false otherwise.</dd><p class="pad"></p>

<dt><a name="does"
>does</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  $I1 = $P2.does($S3)</pre>

<dd>Returns true if the object in question implements the role, class, type, or behavior passed in, false otherwise.</dd><p class="pad"></p>

<dt><a name="inspect"
>inspect</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  $P1 = $P2.inspect()
  $P1 = $P2.inspect($S3)</pre>

<dd>Return introspection information for the class.</dd><p class="pad"></p>
</dl>

<h2><a name="Object_PMC_API"
>Object PMC API <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p><code lang='und' xml:lang='und'>Object</code> PMCs are the actual objects, and hold all the per&#45;object instance data.</p>

<p>The Object PMC is an array of meta&#45;information and attributes. The elements of this array are:</p>

<dl>
<dt><a name="0"
>0</a></dt><p class="pad"></p>

<dd>The class PMC</dd><p class="pad"></p>

<dt><a name="1"
>1</a></dt><p class="pad"></p>

<dd>The object attribute store. This is simply an array of PMCs that provide the values for the attributes. It may be a resizable PMC array to provide lazy growth rather than allocating all needed memory for all attributes. We find the indexes into this array from the attribute cache or lookup table in the class.</dd><p class="pad"></p>
</dl>

<p>A list of the object&#39;s attributes is accessible from the class. The attribute cache is the most straightforward way to retrieve a complete list of attributes visible to the object, but the first time you introspect for a complete list the class may have to calculate the list by traversing the inheritance hierarchy.</p>

<p>Object PMCs have the &#34;I am an object&#34; flag set on them.</p>

<p>Object PMCs have no methods aside from those defined in their associated class. They do have vtable functions providing access to certain low&#45;level information about the object, method call functionality, etc. See the sections below on <a href='TODO'>Objects</a> and <a href='TODO'>Vtables</a>.</p>

<p>In addition to a value type, objects can have a container type. The container type can&#39;t be stored in the object itself, because a single object may live within multiple containers. So, the container type (when it exists) is stored in the LexPad or Namespace entry for a particular variable.</p>

<p>In a static language like C#.Net:</p>

<pre lang='und' xml:lang='und'>  B isa A
  A o1 = new B();
  B o2 = new B();

  o1.x; # retrieves A&#39;s attribute
  o2.x; # retrieves B&#39;s attribute

  o1.foo(); # calls B&#39;s method
  o2.foo(); # calls B&#39;s method</pre>

<h3><a name="Object_Vtable_Entries"
>Object Vtable Entries</a></h3>

<p>All Objects need the following vtable entries.</p>

<dl>
<dt><a name="find_method(string_*)"
>find_method(string *)</a></dt><p class="pad"></p>

<dd>Returns the PMC for the named method. If no method of this name exists, nor can be constructed, returns a Null PMC. This only passes the method search on to the object&#39;s class.</dd><p class="pad"></p>

<dt><a name="isa(class_*)"
>isa(class *)</a></dt><p class="pad"></p>

<dd>Returns true or false if the class passed in as a parameter is in the inheritance hierarchy of the object.</dd><p class="pad"></p>

<dt><a name="can(string_*)"
>can(string *)</a></dt><p class="pad"></p>

<dd>Returns true or false if the object can perform the requested method. (Including with an AUTOLOAD)</dd><p class="pad"></p>

<dt><a name="does(class_*)"
>does(class *)</a></dt><p class="pad"></p>

<dd>Returns true or false to note whether the object in question implements the interface passed in.</dd><p class="pad"></p>

<dt><a name="get_attr(STRING*)"
>get_attr(STRING*)</a></dt><p class="pad"></p>

<dd>Returns the attribute with the fully qualified name for the object.</dd><p class="pad"></p>

<dt><a name="set_attr(STRING*,_PMC_*)"
>set_attr(STRING*, PMC *)</a></dt><p class="pad"></p>

<dd>Set the attribute with the fully qualified name for the object.</dd><p class="pad"></p>

<dt><a name="get_class"
>get_class</a></dt><p class="pad"></p>

<dd>Returns the class PMC for the object.</dd><p class="pad"></p>

<dt><a name="clone"
>clone</a></dt><p class="pad"></p>

<dd>Create a clone of the object.</dd><p class="pad"></p>

<dt><a name="inspect()"
>inspect()</a></dt><p class="pad"></p>

<dd>Return a data structure of all information relevant to introspection on the object.</dd><p class="pad"></p>

<dt><a name="inspect_str(string_*)"
>inspect_str(string *)</a></dt><p class="pad"></p>

<dd>Return a PMC Hash, Array, String, Integer, or Number value of introspection information corresponding to the requested string name (such as &#39;parents&#39;). This may be overridden to report information about the internals of an object that aren&#39;t actually true (useful for mocking). It can also be used for straight introspection capabilities even when a particular object is using keyed access (to act like a hash or array) or attribute access.</dd><p class="pad"></p>
</dl>

<h2><a name="Role_PMC_API"
>Role PMC API <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>An instance of the Role PMC has five attributes, which are:</p>

<dl>
<dt><a name="0"
>0</a></dt><p class="pad"></p>

<dd>The role name</dd><p class="pad"></p>

<dt><a name="1"
>1</a></dt><p class="pad"></p>

<dd>A link to the role&#39;s associated namespace</dd><p class="pad"></p>

<dt><a name="2"
>2</a></dt><p class="pad"></p>

<dd>An array PMC of composed roles</dd><p class="pad"></p>

<dt><a name="3"
>3</a></dt><p class="pad"></p>

<dd>An array PMC of the methods defined in the role or composed into the role</dd><p class="pad"></p>

<dt><a name="4"
>4</a></dt><p class="pad"></p>

<dd>The role attribute hash. Keys are the attribute names and the values are a hash of attribute characteristics, including name, type, and the role they&#39;re associated with.</dd><p class="pad"></p>
</dl>

<h3><a name="Role_Vtable_Entries"
>Role Vtable Entries</a></h3>

<p>All Roles need the following vtable entries.</p>

<dl>
<dt><a name="add_method(string_*,_method_*)"
>add_method(string *, method *)</a></dt><p class="pad"></p>

<dd>Add a method to the role.</dd><p class="pad"></p>

<dt><a name="add_attribute(string_*,_key_*)"
>add_attribute(string *, key *)</a></dt><p class="pad"></p>

<dd>Add an attribute to the role.</dd><p class="pad"></p>

<dt><a name="add_role(role_*)"
>add_role(role *)</a></dt><p class="pad"></p>

<dd>Add a role to the role.</dd><p class="pad"></p>

<dt><a name="find_method(string_*)"
>find_method(string *)</a></dt><p class="pad"></p>

<dd>Returns the PMC for the named method. If no method of this name exists, nor can be constructed, returns a Null PMC.</dd><p class="pad"></p>

<dt><a name="can(string_*)"
>can(string *)</a></dt><p class="pad"></p>

<dd>Returns true or false if the role can perform the requested method. (Including with an AUTOLOAD)</dd><p class="pad"></p>

<dt><a name="does(class_*)"
>does(class *)</a></dt><p class="pad"></p>

<dd>Returns true or false to note whether the role in question implements the interface passed in.</dd><p class="pad"></p>

<dt><a name="clone"
>clone</a></dt><p class="pad"></p>

<dd>Create an (anonymous) clone of the role.</dd><p class="pad"></p>

<dt><a name="inspect()"
>inspect()</a></dt><p class="pad"></p>

<dd>Return a data structure of all information relevant to introspection on the role.</dd><p class="pad"></p>

<dt><a name="inspect_str(string_*)"
>inspect_str(string *)</a></dt><p class="pad"></p>

<dd>Return a PMC Hash, Array, String, Integer, or Number value of introspection information corresponding to the requested string name (such as &#39;parents&#39;).</dd><p class="pad"></p>

<dt><a name="remove_attribute(string_*)"
>remove_attribute(string *)</a></dt><p class="pad"></p>

<dd>Remove an attribute from the role.</dd><p class="pad"></p>

<dt><a name="remove_method(string_*)"
>remove_method(string *)</a></dt><p class="pad"></p>

<dd>Remove a method from the role.</dd><p class="pad"></p>

<dt><a name="remove_role(string_*)"
>remove_role(string *)</a></dt><p class="pad"></p>

<dd>Remove a role from the role.</dd><p class="pad"></p>
</dl>

<h3><a name="Role_Methods"
>Role Methods</a></h3>

<p>These methods are just syntactic sugar for the vtable functions. They are not included in the Role PMC by default, but added to Role as a role.</p>

<dl>
<dt><a name="name"
>name</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>    $P1 = $P2.name( $S3 )</pre>

<dd>The accessor for the name attribute. With no argument, it simply returns the current value for name. When passed an argument, it sets the name of the role, and also sets the association with a namespace.</dd><p class="pad"></p>

<dt><a name="namespace"
>namespace</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>    $P1 = $P2.namespace()</pre>

<dd>Retrieve the namespace object associated with the role.</dd><p class="pad"></p>

<dt><a name="attributes"
>attributes</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  $P1 = $P2.attributes()</pre>

<dd>An accessor for the attributes of the role. It returns the Hash of all attributes, with a key of the attribute name, and a value of the attribute&#39;s metadata (a Hash). The accessor is read&#45;only.</dd><p class="pad"></p>

<dt><a name="add_attribute"
>add_attribute</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  $P1.add_attribute($S2)
  $P1.add_attribute($S2, $S3)
  $P1.add_attribute($S2, $P3)</pre>

<dd>Adds a single attribute to the role. It takes a simple string name, and optionally, a simple string value or key specifying a type name. (A type name just checks <code lang='und' xml:lang='und'>does</code>, and doesn&#39;t necessarily correspond to a class or role namespace.)</dd><p class="pad"></p>

<dt><a name="add_role"
>add_role</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  $P1.add_role($P2, [named])</pre>

<dd>Adds a single role to the role. It takes an instance of the Role PMC as a required positional parameter, and the optional named parameters <code lang='und' xml:lang='und'>exclude</code> and <code lang='und' xml:lang='und'>alias</code>; see <a href='#Role_Conflict_Resolution'>&#34;Role Conflict Resolution&#34;</a> for more details.</dd><p class="pad"></p>

<dt><a name="roles"
>roles</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  $P1 = $P2.roles()</pre>

<dd>An accessor for the roles composed into the role. It returns an Array of all roles as PMC objects. If any roles that were composed into this one were themselves made up of a composition of other roles, the roles they were made up of will also be included in the value returned by this accesor. However, no role will be mentioned more than once. The accessor is read&#45;only.</dd><p class="pad"></p>

<dt><a name="add_method"
>add_method</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  $P1.add_method($S2, $P3)</pre>

<dd>Adds a method to the role. It takes a simple string name and a method PMC. If the method already exists (and isn&#39;t a Multi) it will replace the method with the new method and throw a warning.</dd><p class="pad"></p>

<dd>It also takes slurpy named parameters to flag whether the method is a vtable override, and whether its anonymous (no named entry as a method, only as a vtable).</dd><p class="pad"></p>

<dt><a name="methods"
>methods</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  $P1 = $P2.methods()</pre>

<dd>An accessor for the methods of the role. It returns a Hash of all methods, with a key of the method name and a value of an invokable PMC. The list will include methods added through composing other roles into this role. The accessor is read&#45;only.</dd><p class="pad"></p>

<dt><a name="inspect"
>inspect</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  $P1 = $P2.inspect()
  $P1 = $P2.inspect($S3)</pre>

<dd>Return introspection information for the role.</dd><p class="pad"></p>
</dl>

<h3><a name="Role_Conflict_Resolution"
>Role Conflict Resolution</a></h3>

<p>When a role is added to a class, we try to compose it right away, and throw an exception on any conflicts that are detected. A conflict occurs if two roles try to supply a method of the same name (but see the note on multi&#45;methods below). High level languages will provide varying facilities to deal with this, and Parrot provides the primitives to implement them.</p>

<p>When declaring a composed class, you can optionally supply an array of method names that will be defined by the class to resolve a conflict in its roles. This is done using the named parameter <code lang='und' xml:lang='und'>resolve</code>. This feature supports composition conflict resolution in languages such as Perl 6.</p>

<p>When adding a role to a class, you can optionally supply an array of method names from the role to exclude from the composition process. This is done using the named parameter <code lang='und' xml:lang='und'>exclude</code>. It is not an error to list a method name in this array that the role does not have. This makes it possible to implement languages that provide for explicit exclusions on a role&#45;by&#45;role basis.</p>

<p>When adding a role to a class, you can optionally specify that specific methods are to be aliased to different names within the class. This is done with the optional <code lang='und' xml:lang='und'>alias</code> named parameter. The parameter takes hash of strings, where the key is a method name in the role, and the value is the name it will have in to the class. (This is also sometimes used for conflict resolution.)</p>

<p>If you <code lang='und' xml:lang='und'>alias</code> a method, it won&#39;t automatically <code lang='und' xml:lang='und'>exclude</code> the original name from the role. You can also explicitly <code lang='und' xml:lang='und'>exclude</code> the method name, if you want a proper renaming of the method. A <code lang='und' xml:lang='und'>resolve</code> at the class level will automatically <code lang='und' xml:lang='und'>exclude</code> all methods of that name from any role composed into the class. You can <code lang='und' xml:lang='und'>alias</code> the method if you want to call it from the composed class. (You might use this if you want the resolving method to be able to call either of the conflicting methods from two composed roles.)</p>

<p>If a method in a role is a MultiSub PMC and there is either no method of that name yet OR what is in the method slot with that name is also a MultiSub PMC, there will be no error. Instead, the multi&#45;methods from the role will be added to the multi&#45;methods of the MultiSub PMC already in the class. Any attempt to combine a multi with a non&#45;multi will result in an error.</p>

<h2><a name="Opcodes"
>Opcodes <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>The following ops are provided to deal with objects. Please note that method calls are governed by Parrot&#39;s calling conventions, and as such objects, method PMCs, return continuations, and parameters must be in the right places, though some ops will put parameters where they need to go.</p>

<dl>
<dt><a name="getattribute"
>getattribute</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  $P1 = getattribute $P2, $S3</pre>

<dd>Get the attribute with the fully qualified name $S3 from object $P2 and put it in $P1.</dd><p class="pad"></p>

<dt><a name="setattribute"
>setattribute</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  setattribute $P1, $S2, $P3</pre>

<dd>Set the attribute of object $P1 with the fully qualified name $S2 to $P3</dd><p class="pad"></p>

<dt><a name="callmethod"
>callmethod</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  callmethod
  callmethod $S1</pre>

<dd>Call a method. If the method name is provided in $S1, we find the PMC for the named method and put it in the sub/method slot. If no name is provided we assume that all the calling conventions have already been set up and the method PMC is already in the proper place.</dd><p class="pad"></p>

<dt><a name="callmethodcc"
>callmethodcc</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  callmethodcc
  callmethodcc $S1</pre>

<dd>Make a method call, automatically generating a return continuation. If a method name is passed in we look up the method PMC for the object and put it in the method slot. If a method name isn&#39;t provided then we assume that things are already properly set up.</dd><p class="pad"></p>

<dt><a name="callmethodsupercc"
>callmethodsupercc</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  callmethodsupercc $S1</pre>

<dd>Make a method call, automatically generating a return continuation. A variant of <code lang='und' xml:lang='und'>callmethodcc</code> that skips over the current class when searching for the method, and only looks in the parent classes. PIR may provide some syntactic sugar for this.</dd><p class="pad"></p>

<dt><a name="callmethodnextcc"
>callmethodnextcc</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  callmethodnextcc $S1</pre>

<dd>Make a method call, automatically generating a return continuation. A variant of <code lang='und' xml:lang='und'>callmethodcc</code> that picks up an existing <code lang='und' xml:lang='und'>find_method</code> search where it left off for the current call. {{ Note: this depends on find_method being resumable, and on the context of a particular method including a pointer to the find_method call that found it. Neither may be feasible. }} PIR may provide some syntactic sugar for this.</dd><p class="pad"></p>

<dt><a name="newclass"
>newclass</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  $P1 = newclass $S2
  $P1 = newclass $S2, $P3</pre>

<dd>Create a new base class named $S2, and put the PMC for it in $P1. You may optionally pass a hash of initialization parameters for the class in $P3.</dd><p class="pad"></p>

<dt><a name="subclass"
>subclass</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  $P1 = subclass $P2, $S3</pre>

<dd>Create a new class, named $S3, which has $P2 as its immediate parent. $P2 may be either another high&#45;level class based on the Class PMC, or it may be a low&#45;level PMC such as <code lang='und' xml:lang='und'>Integer</code> or <code lang='und' xml:lang='und'>ResizablePMCArray</code>.</dd><p class="pad"></p>

<dt><a name="get_class"
>get_class</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  $P1 = get_class $S2
  $P1 = get_class $P2</pre>

<dd>Retrieve a class object for the class identified by the string name in $S2, or by the PMC key or namespace object in $P2.</dd><p class="pad"></p>

<dd>A string name looks for the class in a namespace with that name nested in the currently selected namespace. Passing in a namespace object looks for the class in that namespace object. A key looks for the class in the namespace identified by the multilevel key relative to the currently selected HLL.</dd><p class="pad"></p>

<dt><a name="addparent"
>addparent</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  addparent $P1, $P2</pre>

<dd>Add class $P2 to the end of the list of immediate parents of class $P1. Adds any attributes of $P2 (and its parent classes) that aren&#39;t already in $P1.</dd><p class="pad"></p>

<dt><a name="removeparent"
>removeparent</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  removeparent $P1, $P2</pre>

<dd>Remove class $P2 from the parent list of $P1. All parent classes of $P2 which aren&#39;t parent classes of what remains of $P1&#39;s parent list are removed, as are their attributes.</dd><p class="pad"></p>

<dt><a name="addattribute"
>addattribute</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  addattribute $P1, $S2
  addattribute $P1, $S2, $S3
  addattribute $P1, $S2, $P3</pre>

<dd>Add attribute $S2 to class or role $P1. This will add the attribute slot to all objects of class $P1, classes that inherit from class $P1, or classes that compose the role $P1, with a default value of <code lang='und' xml:lang='und'>Null</code>. It optionally takes a simple string value or key specifying a type of the attribute.</dd><p class="pad"></p>

<dt><a name="removeattribute"
>removeattribute</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  removeattribute $P1, $S2</pre>

<dd>Remove the attribute $S2 from class or role $P1. This will not remove the attribute from any objects that have already been instantiated, but it will be absent from all future objects of class $P1, of classes that inherit from class $P1, or of classes that compose the role $P1.</dd><p class="pad"></p>

<dt><a name="addrole"
>addrole</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  addrole $P1, $P2</pre>

<dd>Add role $P2 to the end of the list of roles of class or role $P1. Adds any methods and attributes of $P2 that aren&#39;t already in $P1.</dd><p class="pad"></p>

<dt><a name="inspect"
>inspect</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  $P1 = inspect $P2
  $P1 = inspect $P2, $S3</pre>

<dd>Return introspection information for the PMC. Without the optional string argument, return a data structure of all information relevant to introspection. With the optional string argument, return a PMC Hash, Array, String, Integer, or Number value with introspection information corresponding to the requested string name.</dd><p class="pad"></p>
</dl>

<h2><a name="PIR_Class_Definitions"
>PIR Class Definitions <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>PIR provides some syntactic sugar for declaring classes.</p>

<dl>
<dt><a name=":method"
>:method</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  .sub custom_method :method
    # ...
  .end</pre>

<dd>Flags the code entity as a method.</dd><p class="pad"></p>

<dt><a name=":vtable"
>:vtable</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  .sub get_integer :vtable
    # ...
  .end</pre>

<dd>Flags the code entity as a vtable override.</dd><p class="pad"></p>
</dl>

<p>:method and :vtable can be combined to indicate that a particular code entity is callable both as a method and as a vtable override.</p>

<p>If the class object has not yet been created at the point when the PIR subs are compiled, the methods and vtable overrides are temporarily stored in the associated namespace.</p>

<h2><a name="Vtable_Overriding"
>Vtable Overriding <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Classes may override the vtable functions, allowing objects of a class to behave like a primitive PMC. To use these properly at a low&#45;level requires a good working knowledge of the way Parrot works&#45;&#45;generally for higher&#45;level languages the language compiler or runtime will provide easier&#45;to&#45;use wrappers. These methods are all prototyped, and take a single fixed argument list, and return at most a single value.</p>

<p>To override a vtable function, either add the :vtable pragma to the declaration of the method, or pass a named parameter &#34;vtable&#34; into the <code lang='und' xml:lang='und'>add_method</code> method on a class or role.</p>

<h2><a name="What_The_Bytecode_Sees"
>What The Bytecode Sees <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>The bytecode is isolated from most of the internal details of the implementation. This allows both for flexibility in the implementation and forward compatibility, generally good things. It also allows for multiple concurrent interoperable object systems. The major thrust is for transparent use of objects, though most class activity (including creation of subclasses and modifications of existing classes) should be transparent as well.</p>

<h1><a name="EXAMPLES"
>EXAMPLES <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>The following examples all assume we&#39;re working with basic Object objects and Class classes.</p>

<h2><a name="Creating_a_new_class"
>Creating a new class <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>To create a new class <code lang='und' xml:lang='und'>Foo</code> which has no parent classes:</p>

<pre lang='und' xml:lang='und'>   newclass $P0, &#34;Foo&#34;</pre>

<h2><a name="Creating_a_new_class_with_multiple_parents"
>Creating a new class with multiple parents <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>To create a class <code lang='und' xml:lang='und'>Foo</code> with the parents <code lang='und' xml:lang='und'>A</code> and <code lang='und' xml:lang='und'>B</code>, the code would be:</p>

<pre lang='und' xml:lang='und'>   get_class $P0, &#34;A&#34;
   get_class $P1, &#34;B&#34;
   subclass $P2, $P0, &#34;Foo&#34;
   addparent $P2, $P1</pre>

<h2><a name="Creating_a_new_class_with_attributes"
>Creating a new class with attributes <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Adding the attributes <code lang='und' xml:lang='und'>a</code> and <code lang='und' xml:lang='und'>b</code> to the new class <code lang='und' xml:lang='und'>Foo</code>:</p>

<pre lang='und' xml:lang='und'>  $P0 = newclass &#34;Foo&#34;
  addattribute $P0, &#34;a&#34;
  addattribute $P0, &#34;b&#34;</pre>

<h2><a name="Instantiating_an_object"
>Instantiating an object <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Assuming we want an object of class <code lang='und' xml:lang='und'>Foo</code>:</p>

<pre lang='und' xml:lang='und'>  .local pmc FooClass
  .local pmc MyObject
  FooClass = get_class &#34;Foo&#34;
  MyObject = FooClass.new()</pre>

<h2><a name="Calling_a_method_on_an_object"
>Calling a method on an object <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Calling the method <code lang='und' xml:lang='und'>Xyzzy</code> on an object, assuming the PDD03 calling conventions are respected:</p>

<pre lang='und' xml:lang='und'>  callmethod &#34;Xyzzy&#34;

  set S0, &#34;Xyzzy&#34;
  callmethod</pre>

<p>Or, if a return continuation needs constructing:</p>

<pre lang='und' xml:lang='und'>  callmethodcc &#34;Xyzzy&#34;

  set S0, &#34;Xyzzy&#34;
  callmethodcc</pre>

<h2><a name="Accessing_attributes_from_within_a_class"
>Accessing attributes from within a class <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>With named access:</p>

<pre lang='und' xml:lang='und'>  getattribute $P1, $P0, &#34;Foo\x0b&#34;</pre>

<h1><a name="Explanations"
>Explanations <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>To get a new class, you can do a <code lang='und' xml:lang='und'>newclass</code>, which creates a new class with no parents besides Parrot&#39;s default super&#45;ish parent class.</p>

<p>To get a new child class, you have two potential options:</p>

<dl>
<dt><a name="Subclass_the_parent"
>Subclass the parent</a></dt><p class="pad"></p>

<dt><a name="Create_a_new_standalone_class_and_add_a_parent"
>Create a new standalone class and add a parent</a></dt><p class="pad"></p>
</dl>

<p>Both ways work. It is, however, more efficient to use the first method, and just subclass the immediate parent class of your new class.</p>

<p>When adding in extra parents in a multiple&#45;inheritance scenario, subclass the first class in the immediate parent list then use the <code lang='und' xml:lang='und'>addparent</code> op to add in the rest of the immediate parents.</p>

<h1><a name="LANGUAGE_NOTES"
>LANGUAGE NOTES <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Notes on some of the OO&#45;related needs of various languages.</p>

<h2><a name="PMCs"
>PMCs <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Ruby: Just like Smalltalk, everything is an object. I&#39;m hoping to be able to implement core Ruby classes (String, Array, Hash, Module, etc) something like this.</p>

<pre lang='und' xml:lang='und'> ParrotClass
    |
 RubyClass   String
    |         |
     \      /
    RubyString</pre>

<h2><a name="Objectspace"
>Objectspace <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Ruby: Objectspace in Ruby allows the programmer to iterate through every live object in the system. There is some debate about how to make this play nice with different garbage collection schemes.</p>

<h2><a name="Classes"
>Classes <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>A class is a collection of methods and attributes. It would be desirable, for those classes whose definition is fully known at compile time, to have a convenient way to have the class along with its attributes and methods stored into a PBC file rather than created at runtime. However, creation of new classes at runtime will be needed too.</p>

<h2><a name="Meta&#45;classes"
>Meta&#45;classes <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Ruby: Ruby has meta classes. It would be nice if classes were objects in Parrots OO model.</p>

<h2><a name="Attributes"
>Attributes <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Attributes are instance data associated with a class (or role, however those are supported). They may not always be of a type specified by a PMC, though boxing/unboxing is of course an option.</p>

<p>Perl 6: All attributes are opaque (not externally visible, even to any subclasses).</p>

<p>.Net: Attributes may be private (not externally visible), public (always externally visible), protected (only visible to subclasses) and internal (only visible inside the current assembly &#45; the closest correspondence in Parrot is perhaps only visible inside the same PBC file). Additionally, it is allowable for a subclass to introduce an attribute of the same name as the a parent class has, and they both exist depending on what type an instance of the class is currently viewed as being (read: there is a difference between the type of the reference and the type of the value).</p>

<p>Ruby: Attributes can be dynamically added and removed at runtime.</p>

<h2><a name="Methods"
>Methods <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Perl 6: Methods may be public (anyone can invoke them) or private (only invokable by the class they are defined in). Additionally, submethods are methods that do not get inherited.</p>

<p>.Net: Like attributes, methods may be public, private, protected or internal.</p>

<p>Ruby: has a method_missing that gets called when method resolution fails to find a method. Methods can be dynamically added and removed at runtime.</p>

<h2><a name="Constructors"
>Constructors <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>A constructor is run when an object is instantiated.</p>

<p>.Net: There may be many constructors for an object (provided they all have different signatures), and the correct one is called based upon the passed parameters.</p>

<h2><a name="Inheritance"
>Inheritance <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Perl 6: Multiple inheritance.</p>

<p>.Net: Single inheritance.</p>

<p>Ruby: Single inheritance but support for mixins of Ruby modules.</p>

<h2><a name="Interfaces"
>Interfaces <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>An interface specifies a set of methods that must be implemented by a class that inherits (or implements) the interface, but does not provide any form of implementation for them.</p>

<p>.Net: Interfaces are pretty much what was just describe above. XXX Need to check behavior of you implement two interfaces with methods of the same name.</p>

<h2><a name="Roles"
>Roles <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>A role consists of a set of methods and attributes. It cannot be instantiated on its own, but must be composed into a class. When this happens its methods and attributes become of that classes methods and attributes. This may happen at compile time or runtime, however when a role is composed into a class at runtime then what really happens is that a new anonymous class is created with the role composed into it and then the namespace entry for the existing class is updated to refer to the new one. Note that this means classes must be garbage collectable, with all those referred to by a namespace or with objects of that class existing being marked live.</p>

<p>Perl 6: Roles pretty much are a Perl 6 thing, so the definition above contains all that is needed. An open question is whether Parrot worry about collision detection? For compile time composition that&#39;s easy to punt to the compiler; for runtime composition, that&#39;s not so easy though.</p>

<h2><a name="Introspection_(aka_Reflection)"
>Introspection (aka Reflection) <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Perl 6: Reflection provides access to a list of methods that a class has, its parent classes and the roles it does, as well as the name of the class and its memory address. For methods, their name, signature, return type and whether the method is declared multi are available.</p>

<p>.Net: Reflection provides access to a list of attributes and methods as well as the name of the class and its parent. The types of attributes and signatures of methods are also available.</p>

<h2><a name="Inner_Classes"
>Inner Classes <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>An inner class is essentially a class defined within a class. Therefore it has access to things private to its outer class.</p>

<p>Perl 6: Inner classes are allowed, and may also be private.</p>

<p>.Net: Inner classes are allowed and may be private, public, protected or internal.</p>

<h2><a name="Delegation"
>Delegation <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Delegation is where a method call is &#34;forwarded&#34; to another class. Parrot may provide support for simple cases of it directly, or could just provide a &#34;no method matched&#34; fallback method that the compiler fills out to implement the delegation.</p>

<p>Perl 6: Delegation support is highly flexible, even allowing a regex to match method names that should be delegated to a particular object.</p>

<h2><a name="Prototype&#45;based_OO"
>Prototype&#45;based OO <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Prototype&#45;based OO has no classes. All objects are cloned from existing objects and modified. Requires lightweight singleton creation, without needing a separate class for every instance object. (Self, JavaScript, and Io are examples of prototype&#45;based 00.) An example from Io:</p>

<pre lang='und' xml:lang='und'>  Dog := Object clone # The Dog object is a clone of Object
  Dog tail := &#34;long&#34;  # it has an attribute &#39;tail&#39; with the value &#39;long&#39;
  Dog bark := method(&#34;yap&#34; print) # It has a method &#39;bark&#39;
  Dog bark  # call the method &#39;bark&#39;, printing &#39;yap&#39;</pre>

<h2><a name="Translation"
>Translation <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>The following list a set of languages, then within each language what the Parrot term translates to.</p>

<dl>
<dt><a name="Python"
>Python</a></dt><p class="pad"></p>

<dl>
<dt><a name="Attribute"
>Attribute</a></dt><p class="pad"></p>

<dd>A Python attribute maps to a Parrot property</dd><p class="pad"></p>
</dl>

<dt><a name=".NET"
>.NET</a></dt><p class="pad"></p>

<dl>
<dt><a name="Attribute"
>Attribute</a></dt><p class="pad"></p>

<dd>What .NET calls an attribute Parrot calls a property</dd><p class="pad"></p>

<dt><a name="Property"
>Property</a></dt><p class="pad"></p>

<dd>What .NET calls a property we call an attribute</dd><p class="pad"></p>
</dl>

<dt><a name="Generic_Terminology"
>Generic Terminology</a></dt><p class="pad"></p>

<dl>
<dt><a name="Instance_Variable"
>Instance Variable</a></dt><p class="pad"></p>

<dd>Instance Variables map to what we call attributes</dd><p class="pad"></p>
</dl>
</dl>

<h1><a name="ATTACHMENTS"
>ATTACHMENTS <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>None.</p>

<h1><a name="FOOTNOTES"
>FOOTNOTES <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>None.</p>

<h1><a name="REFERENCES"
>REFERENCES <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>None.</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
