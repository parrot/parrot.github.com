<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>PMCs</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">PMCs</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../../html/index.html">Contents</a> | <a href="../../../../html/docs.html">Documentation</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>docs/pdds/pddXX_pmc.pod &#45; PMCs</p>

<h1><a name="STATUS"
>STATUS <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>Proposal</p>

<h1><a name="VERSION"
>VERSION <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>$Revision$</p>

<h1><a name="ABSTRACT"
>ABSTRACT <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>This document defines Parrot Magic Cookies (PMCs).</p>

<p>[[ maybe rename PMC to PO (Parrot Objects) or such to reduce confusion with Perl5&#39;s PMC (compiled .pm files).
]]</p>

<h1><a name="TERMINOLOGY"
>TERMINOLOGY <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>This document uses <code lang='und' xml:lang='und'>OPMC</code>,
when speaking of &#34;old&#34; PMCs of Parrot Version 0.4.6 or less.
<code lang='und' xml:lang='und'>PMC</code> is the new layout as proposed in this document.</p>

<p>An <code lang='und' xml:lang='und'>attribute</code> is otherwise also known as a <code lang='und' xml:lang='und'>field</code> or structure element,
but I&#39;m using <code lang='und' xml:lang='und'>attribute</code> here because the difference of PMCs and Parrot Objects should be minimized.</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>PMCs are Parrot&#39;s low&#45;level objects implemented in C.
PMCs are small non&#45;resizable variable&#45;sized structures.
The <code lang='und' xml:lang='und'>PMC</code> itself is the common part of all PMCs.
The per&#45;PMC payload holds PMC&#45;specific attributes.</p>

<h2><a name="PMC_Layout"
>PMC Layout <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<pre lang='und' xml:lang='und'>  +&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;+
  |   vtable      |     # common PMC attribute
  +&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;+
  |   flags       |     # common PMC attribute
  +&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;+
  |   attrib_1    |     # &#34;user&#34; defined part 
  |   ...         |
  +&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;+

  #define THE_PMC \
    VTABLE *vtable; \
    UINTVAL flags</pre>

<p>An Integer Value PMC could be defined with:</p>

<pre lang='und' xml:lang='und'>  struct VInt_PMC {
    THE_PMC;
    INTVAL val;
  };</pre>

<p>Such PMC definitions are typically private to the <em lang='und' xml:lang='und'>.pmc</em> files. All access to PMCs shall be through VTABLE functions or methods. OTOH some widely used PMCs might export their attributes for public use and are then part of the Parrot API.</p>

<p>A typical <code lang='und' xml:lang='und'>VInt</code> vtable function would look like this:</p>

<pre lang='und' xml:lang='und'>  INTVAL get_integer()
    VInt_PMC *me = (VInt_PMC*)SELF;     # [1]
    return me&#45;&#62;val;
  }</pre>

<p>The <code lang='und' xml:lang='und'>OPMC</code> can be defined in terms of a PMC by rearranging the structure elements.</p>

<p>[1] The PMC compiler could provide this line automagically and define a convenience variable <code lang='und' xml:lang='und'>ME</code> similar to the current <code lang='und' xml:lang='und'>SELF</code>.</p>

<h2><a name="PMC_creation"
>PMC creation <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>PMCs are created via <code lang='und' xml:lang='und'>VTABLE_new</code> or variants of <code lang='und' xml:lang='und'>_new</code>. It&#39;s up to the PMC to initialize it&#39;s attributes. <code lang='und' xml:lang='und'>new</code> is a class method, i.e. it&#39;s called with the PMC&#39;s <code lang='und' xml:lang='und'>class</code> as <code lang='und' xml:lang='und'>SELF</code>.</p>

<pre lang='und' xml:lang='und'>  PMC* new() {
    VInt_PMC *me = new_bufferlike_header(INTERP, sizeof(VInt_PMC));
    me&#45;&#62;val = 0;
    return (PMC*)me;
  }</pre>

<p>[[ rename <code lang='und' xml:lang='und'>new_bufferlike_header</code> to something more meaningful ]]</p>

<h3><a name="Optimization"
>Optimization</a></h3>

<p>The vtable can provide a pointer to the sized header pool to possibly speedup allocation.</p>

<h3><a name="OPMC_vs._PMC_creation"
>OPMC vs. PMC creation</a></h3>

<p>PMCs with a non&#45;default <code lang='und' xml:lang='und'>new</code> method are PMCs, The old scheme via <code lang='und' xml:lang='und'>pmc_new</code> and <code lang='und' xml:lang='und'>VTABLE_init</code> provides a fallback of creating <code lang='und' xml:lang='und'>OPMCs</code>.</p>

<h1><a name="Additional_PMC_attributes"
>Additional PMC attributes <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<h2><a name="pmc&#45;&#62;_next_for_GC_/_opmc&#45;&#62;pmc_ext&#45;&#62;_next_for_GC"
>pmc&#45;&#62;_next_for_GC / opmc&#45;&#62;pmc_ext&#45;&#62;_next_for_GC <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>All PMCs that refer to other PMCs have a 3rd mandatory attribute <code lang='und' xml:lang='und'>_next_for_GC</code>, used for garbage collection, The presence of this attribute is signaled by the flag bit <code lang='und' xml:lang='und'>PObj_is_PMC_EXT_FLAG</code>.</p>

<pre lang='und' xml:lang='und'>  +&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;+
  |   vtable      |     
  +&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;+
  |   flags       |
  +&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;+
  | _next_for_GC  |
  +&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;+
  |   ...         |
  +&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;+</pre>

<h2><a name="Properties_opmc&#45;&#62;pmc_ext&#45;&#62;_metadata"
>Properties opmc&#45;&#62;pmc_ext&#45;&#62;_metadata <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>PMCs do not support properties universally, If properties are still desired, these can be implemented in one of the following ways:</p>

<p>[[ TODO define something canonical ]]</p>

<h3><a name="Per_PMC_type"
>Per PMC type</a></h3>

<p>Each PMC that wants this extra hash can just provide an attribute for it and implement the property vtable functions.</p>

<h3><a name="interpreter&#45;&#62;prop_hash"
>interpreter&#45;&#62;prop_hash</a></h3>

<p>This will be a Hash, indexed by the PMC&#39;s address, containing the property Hash. An additional flag can be provided, if such a property hash exists for a PMC. During collection of a PMC, this hash is invalidated too.</p>

<h3><a name="PropRef"
>PropRef</a></h3>

<p>A transparent <code lang='und' xml:lang='und'>Ref</code> PMC can point to a structure holding the original PMC and the property Hash.</p>

<h2><a name="Locking_or_opmc&#45;&#62;pmc_ext&#45;&#62;_synchronize"
>Locking or opmc&#45;&#62;pmc_ext&#45;&#62;_synchronize <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>PMCs do no support locking universally. Creating sharable PMCs at runtime (from standard PMCs) is again done by transparent Refs like <code lang='und' xml:lang='und'>SharedRef</code> or <code lang='und' xml:lang='und'>STMRef</code>.</p>

<h2><a name="Shared_PMCs"
>Shared PMCs <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>If needed, we can define shared PMCs by allocating the <code lang='und' xml:lang='und'>_Sync</code> structure in front of the PMC:</p>

<pre lang='und' xml:lang='und'>  +&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;+
  |   struct      |     
  |   _Sync       |     
  +&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;+ &#60;&#45;&#45;&#45; pmc points here
  |   vtable      |     
  +&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;+
  |   flags       |
  +&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;+</pre>

<p>This works of course only, if PMCs are created as <code lang='und' xml:lang='und'>shared</code> in the first place. The presence of the <code lang='und' xml:lang='und'>_Sync</code> structure is stated by a PMC flag bit.</p>

<h2><a name="PMCs_and_morphing"
>PMCs and morphing <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>PMCs (like current OPMCs), which may morph themselves, and thereby change their vtable and the meaning of their attributes shall use a union of the desired attributes, e.g.:</p>

<pre lang='und' xml:lang='und'>  struct Integer_PMC {
    THE_PMC;
    union {
      INTVAL int_val;
      FLOATVAL num_val;
      STRING *str_val;
    } u;
  };</pre>

<h1><a name="ATTACHMENTS"
>ATTACHMENTS <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>(none)</p>

<h1><a name="REFERENCES"
>REFERENCES <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<pre lang='und' xml:lang='und'>  TODO pdd02_vtables.pod
  TODO pddXX_interfaces.pod
  TODO pddXX_classes.pod
  TODO pddXX_objects.pod
  TODO pddXX_cstruct.pod   [2]</pre>

<p>[2] PMCs need a class object that defines their attributes to properly allow subclassing. The attribute definition is held by a <code lang='und' xml:lang='und'>CStruct</code> PMC, the meta class of all Parrot PMCs. It&#39;s a list of attribute names, their types, and possibly the offsets in the PMC structure. See also the <code lang='und' xml:lang='und'>UnManangedStruct</code> PMC.</p>

<h1><a name="RATIONAL"
>RATIONAL <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>Current OPMCs are too rigid: mostly either too small or too big. A lot of information is hanging off secondary malloced structures like <code lang='und' xml:lang='und'>PMC_sub</code> in the <code lang='und' xml:lang='und'>Sub</code> OPMC.</p>

<p>But more importantly, OPMCs don&#39;t properly allow subclassing. E.g.</p>

<pre lang='und' xml:lang='und'>  cl = subclass &#39;Hash&#39;, &#39;PGE::Match&#39;</pre>

<p>is currently done by creating a <code lang='und' xml:lang='und'>ParrotClass</code>. When instantiate, this is a &#34;hidden&#34; <code lang='und' xml:lang='und'>__value</code> element as first attribute, which is a pointer to the hash parent PMC. This is creating internal structures which aren&#39;t compatible, because the object attributes are differently arranged. That is, above subclassing is mainly: <code lang='und' xml:lang='und'>PGE::Match</code> <i>hasa</i> <code lang='und' xml:lang='und'>Hash</code> instead of <i>isa</i>, when it comes to attribute relationship.</p>

<p>This limitation prevents further implementation of already (at least partially) documented APIs, like the <code lang='und' xml:lang='und'>Compiler</code> one.</p>

<p>A <code lang='und' xml:lang='und'>Compiler</code> object is either a Parrot <code lang='und' xml:lang='und'>Sub</code> like <code lang='und' xml:lang='und'>PGE::P6Regex</code> or a builtin that is <code lang='und' xml:lang='und'>NCI</code> compiler like <code lang='und' xml:lang='und'>PIR</code>. But <code lang='und' xml:lang='und'>Sub</code> and <code lang='und' xml:lang='und'>NCI</code> objects are that different that even currently needed attributes aren&#39;t consistently arranged (e.g. <code lang='und' xml:lang='und'>multi_sig</code> or <code lang='und' xml:lang='und'>namespace_stash</code>). Creating proper compiler objects like <code lang='und' xml:lang='und'>PIR_Compiler</code> with common and needed <code lang='und' xml:lang='und'>Compiler</code> attributes isn&#39;t possible now.</p>

<p>[[ Well, with another one or two indirections all can be implemented, but that&#39;s just adding to code complexity. ]]</p>

<p>Please note that the mentioned <code lang='und' xml:lang='und'>Compiler</code> PMC ist just one of many PMCs that exhibit the same problem.</p>

<p>In combination with a proper metaclass for PMCs, PMCs and &#34;real&#34; Parrot objects should be able to work together seemlessly.</p>

<h1><a name="PERFORMANCE_CONSIDERATIONS"
>PERFORMANCE CONSIDERATIONS <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>Due to reduced memory consumption and reduced allocation of secondary helper structures, this change will very likely speed up Parrot performance slightly to moderate. No negative performance impact is forseeable due to these changes.</p>

<h1><a name="IMPLEMENTATION"
>IMPLEMENTATION <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>Parrot core needs very little changes to be able to deal with differently sized PMCs. All the GC infrastructure is already there for <code lang='und' xml:lang='und'>Buffer_like</code> objects, which are managed in sized header pools.</p>

<p>TBD is:</p>

<ul>
<li>Change PObj/PMC structs</li><p class="pad"></p>

<p>Rearrange PObj/Buffer/PMC struct items in such away that item #1 is vtable, #2 is flags, rest is per PObj. The easierst way to achieve this ist to waste one word and give Buffers and empty vtable.</p>

<li>Adjust GC</li><p class="pad"></p>

<p>Then remove the Buffer/PMC discerns from GC code, just treat them alike, but honor the PObj_is_PMC_FLAG.</p>
</ul>

<p>This should be all to be able to build and GC PMCs of arbitrary albeit fixed size.</p>

<p>Changing PMCs to the new scheme can be done as needed and isn&#39;t mandatory.</p>

<p><code lang='und' xml:lang='und'>OPMCs</code> attribute access is currently already done through C macros, like <code lang='und' xml:lang='und'>PMC_int_val</code> or <code lang='und' xml:lang='und'>PMC_struct_val</code>. These macros can cast the passed pointer to <code lang='und' xml:lang='und'>(OPMC*)</code>, so that all these <code lang='und' xml:lang='und'>OPMCs</code> will still be working. New PMCs shall use explicit and more verbose attribute names, which don&#39;t collide with present <code lang='und' xml:lang='und'>OPMC</code> attributes.</p>

<p>There&#39;ll be no implications to existing PASM or PIR code nor to existing dynamic PMCs.</p>

<h1><a name="ALTERNATIVE_PMC_IMPLEMENTATIONS"
>ALTERNATIVE PMC IMPLEMENTATIONS <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>I&#39;ve in another document (<em lang='und' xml:lang='und'>PMC.pod</em>) already layed out a PMC scheme optimized for generational garbage collection. The PMC layout is using also differently but fixed sized user parts of PMCs, but these are subject of one more indirection. If we see the need for optimized GC, this PMC scheme can still be implemented. We probably could take provisions that such a change is not too intrusive by cleverly using the PMC compiler and/or C macros like the proposed <code lang='und' xml:lang='und'>ME</code> in [1] above.</p>

<p>The payload of PMCs in this scheme is hanging off a <code lang='und' xml:lang='und'>pmc_body</code> pointer:</p>

<pre lang='und' xml:lang='und'>  +&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;+
  |   pmc_body    |  &#45;&#45;&#62; body (buffer) memory
  +&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;+
  |   vtable      |
  +&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;+
  |   flags       |
  +&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;+</pre>

<p>The implementation of <code lang='und' xml:lang='und'>PMC</code> might take into consideration that the PMC layout could change further.</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
