<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Conventions and Guidelines for Parrot Source</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Conventions and Guidelines for Parrot Source</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../html/index.html">Contents</a> | <a href="../../../html/docs.html">Documentation</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>docs/pdds/pdd07_codingstd.pod &#45; Conventions and Guidelines for Parrot Source Code</p>

<h1><a name="VERSION"
>VERSION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>$Revision$</p>

<h1><a name="ABSTRACT"
>ABSTRACT <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>This document describes the various rules,
guidelines and advice for those wishing to contribute to the source code of Parrot,
in such areas as code structure,
naming conventions,
comments etc.</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>One of the criticisms of Perl 5 is that its source code is impenetrable to newcomers,
due to such things as inconsistent or obscure variable naming conventions,
lack of comments in the source code,
and so on.
We don&#39;t intend to make the same mistake when writing Parrot.
Hence this document.</p>

<p>We define three classes of conventions:</p>

<dl>
<dt><a name="&#34;must&#34;"
><i>&#34;must&#34;</i></a></dt><p class="pad"></p>

<dd>Items labelled <i>must</i> are mandatory; and code will not be accepted (apart from in exceptional circumstances) unless it obeys them.</dd><p class="pad"></p>

<dt><a name="&#34;should&#34;"
><i>&#34;should&#34;</i></a></dt><p class="pad"></p>

<dd>Items labelled <i>should</i> are strong guidelines that should normally be followed unless there is a sensible reason to do otherwise.</dd><p class="pad"></p>

<dt><a name="&#34;may&#34;"
><i>&#34;may&#34;</i></a></dt><p class="pad"></p>

<dd>Items labelled <i>may</i> are tentative suggestions to be used at your discretion.</dd><p class="pad"></p>
</dl>

<p>Note that since Parrot is substantially implemented in C,
these rules apply to C language source code unless otherwise specified.</p>

<h1><a name="IMPLEMENTATION"
>IMPLEMENTATION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<h2><a name="Language_Standards_and_Portability"
>Language Standards and Portability <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<ul>
<li>C code must generally depend on only those language and library features specified by the ISO C89 standard.</li><p class="pad"></p>

<p>In addition,
C code may assume that any pointer value can be coerced to an integral type (no smaller than typedef <code lang='und' xml:lang='und'>INTVAL</code> in Parrot),
then back to its original type,
without loss.</p>

<p>C code that makes assumptions beyond these must depend on the configuration system,
either to not compile an entire non&#45;portable source where it will not work,
or to provide an appropriate #ifdef macro.</p>

<p>{{ TODO: Enumerate all other non&#45;C89 assumptions that Parrot depends on.
}}</p>

<li>Perl code must be written for Perl 5.6.1 and all later versions.</li><p class="pad"></p>

<p>Perl code may use features not available in Perl 5.6.1 only if it is not vital to Parrot,
and if it uses <code lang='und' xml:lang='und'>$^O</code> and <code lang='und' xml:lang='und'>$]</code> to degrade or fail gracefully when it is run where the features it depends on are not available.</p>
</ul>

<h2><a name="Code_Formatting"
>Code Formatting <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>The following <i>must</i> apply:</p>

<ul>
<li>Source line width is limited to 100 characters.
Exceptions can be made for technical requirements,
but not for style reasons.
And please bear in mind that very long lines <i>can</i> be hard to read.</li><p class="pad"></p>

<li>Indentation must consist only of spaces.
(Tab characters just complicate things.)</li><p class="pad"></p>

<li>C and Perl code must be indented four columns per nesting level.</li><p class="pad"></p>

<li>Preprocessor #directives must be indented two columns per nesting level,
with two exceptions: neither PARROT_IN_CORE nor the outermost _GUARD #ifdefs cause the level of indenting to increase.</li><p class="pad"></p>

<li>Labels (including case labels) must be outdented two columns relative to the code they label.</li><p class="pad"></p>

<li>Closing braces for control structures must line up vertically with the start of the control structures; e.g.
<code lang='und' xml:lang='und'>}</code> that closes an <code lang='und' xml:lang='und'>if</code> must line up with the <code lang='und' xml:lang='und'>if</code>.</li><p class="pad"></p>

<li>Long lines,
when split,
must use at least one extra level of indentation on the continued line.</li><p class="pad"></p>

<li>Cuddled <code lang='und' xml:lang='und'>else</code>s are forbidden: i.e.
avoid <code lang='und' xml:lang='und'>} else {</code> .</li><p class="pad"></p>
</ul>

<p>The following <i>should</i> apply:</p>

<ul>
<li>In function definitions,
the function name must be on the left margin,
with the return type on the previous line.</li><p class="pad"></p>

<li>In function declarations (e.g.
in header files),
the function name must be on the same line as the return type.</li><p class="pad"></p>

<li>Pointer types should be written with separation between the star and the base type,
e.g.
<code lang='und' xml:lang='und'>Interp *foo</code>,
but not e.g.
&#60;Interp* foo&#62;.</li><p class="pad"></p>

<li>To distinguish keywords from function calls visually,
there should be at least one space between a C keyword and any subsequent open parenthesis,
e.g.
<code lang='und' xml:lang='und'>return (x+y)*2</code>.
There should be no space between a function name and the following open parenthesis,
e.g.
<code lang='und' xml:lang='und'>z = foo(x+y)*2</code></li><p class="pad"></p>

<li>Use patterns of formatting to indicate patterns of semantics.
Similar items should look similar,
as the language permits.
Note that some dimensions of similarity are incidental,
not worth emphasizing; e.g.
&#34;these are all ints&#34;.</li><p class="pad"></p>

<li>Binary operators (except <code lang='und' xml:lang='und'>.</code> and <code lang='und' xml:lang='und'>&#45;&#62;</code>) should have at least one space on either side; there should be no space between unary operators and their operands; parentheses should not have space immediately after the opening parenthesis nor immediately before the closing parenthesis; commas should have at least one space after,
but not before; e.g.:</li><p class="pad"></p>

<pre lang='und' xml:lang='und'>        x = (a&#45;&#45; + b) * f(c, d / e.f)</pre>

<li>Use vertical alignment for clarity of parallelism. Compare this (bad):</li><p class="pad"></p>

<pre lang='und' xml:lang='und'>     foo = 1 + 100;
     x = 100 + 1;
     whatever = 100 + 100;</pre>

<p>... to this (good):</p>

<pre lang='und' xml:lang='und'>     foo      =   1 + 100;
     x        = 100 +   1;
     whatever = 100 + 100;</pre>

<li>Do not routinely put single statements in statement blocks.</li><p class="pad"></p>

<p>(Note that formatting consistency trumps this rule. For example, a long <code lang='und' xml:lang='und'>if</code>/<code lang='und' xml:lang='und'>else if</code> chain is easier to read if all (or none) of the conditional code is in blocks.)</p>

<li>Return values should not be parenthesized without need. It may be necessary to parenthesize a long return expression so that a smart editor will properly indent it.</li><p class="pad"></p>

<p>{{ TODO: Modify parrot.el so this rule is no longer required. }}</p>

<li>When assigning inside a conditional, use extra parentheses, e.g. <code lang='und' xml:lang='und'>if (a &#38;&#38; (b = c)) ...</code> or <code lang='und' xml:lang='und'>if ((a = b)) ...</code>.</li><p class="pad"></p>

<li>When splitting a long line at a binary operator (other than comma), the split should be <i>before</i> the operator, so that the continued line looks like one.</li><p class="pad"></p>

<li>When splitting a long line inside parentheses (or brackets), the continuation should be indented to the right of the innermost unclosed punctuation, e.g.:</li><p class="pad"></p>

<pre lang='und' xml:lang='und'>    z = foo(bar + baz(something_very_long_here
                       * something_else_very_long),
            corge);</pre>
</ul>

<h2><a name="Code_Structure"
>Code Structure <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>The following <i>must</i> apply:</p>

<ul>
<li>C code must use C&#45;style comments only, i.e. <code lang='und' xml:lang='und'>/* comment */</code>. (Not all C compilers handle C++&#45;style comments.)</li><p class="pad"></p>

<li>Structure types must have tags.</li><p class="pad"></p>

<li>Functions must have prototypes in scope at the point of use. Prototypes for extern functions must appear only in header files. If static functions are defined before use, their definitions serve as prototypes.</li><p class="pad"></p>

<li>Parameters in function prototypes must be named. These names should match the parameters in the function definition.</li><p class="pad"></p>

<li>Variable names must be included for all function parameters in the function declarations.</li><p class="pad"></p>

<li>Header files must be wrapped with guard macros to prevent header redefinition. The guard macro must begin with <code lang='und' xml:lang='und'>PARROT_</code>, followed by unique and descriptive text identifying the header file (usually the directory path and filename,) and end with a <code lang='und' xml:lang='und'>_GUARD</code> suffix. The matching <code lang='und' xml:lang='und'>#endif</code> must have the guard macro name in a comment, to prevent confusion. For example, a file named <em lang='und' xml:lang='und'>parrot/foo.h</em> might look like:</li><p class="pad"></p>

<pre lang='und' xml:lang='und'>    #ifndef PARROT_FOO_H_GUARD
    #define PARROT_FOO_H_GUARD

    #include &#34;parrot/config.h&#34;
    #ifdef PARROT_HAS_FEATURE_FOO
    #  define FOO_TYPE bar
    typedef struct foo {
        ...
    } foo_t;
    #endif /* PARROT_HAS_FEATURE_FOO */

    #endif /* PARROT_FOO_H_GUARD */</pre>
</ul>

<p>The following <i>should</i> apply</p>

<ul>
<li>Structure types should have typedefs with the same name as their tags, e.g.:</li><p class="pad"></p>

<pre lang='und' xml:lang='und'>    typedef struct Foo {
        ...
    } Foo;</pre>

<li>Avoid double negatives, e.g. <code lang='und' xml:lang='und'>#ifndef NO_FEATURE_FOO</code>.</li><p class="pad"></p>

<li>Do not compare directly against NULL, 0, or FALSE. Instead, write a boolean test, e.g. <code lang='und' xml:lang='und'>if (!foo) ...</code>.</li><p class="pad"></p>

<p>(Note: <code lang='und' xml:lang='und'>PMC *</code> values should be checked for nullity with the <code lang='und' xml:lang='und'>PMC_IS_NULL</code> macro, unfortunately leading to violations of the double&#45;negative rule.)</p>

<li>Avoid dependency on &#34;FIXME&#34; and &#34;TODO&#34; labels; if a bug must be fixed soon, use &#34;XXX&#34;, else use the external bug tracking system.</li><p class="pad"></p>
</ul>

<h2><a name="Smart_Editor_Style_Support"
>Smart Editor Style Support <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>All developers using Emacs must ensure that their Emacs instances load the elisp source file <em lang='und' xml:lang='und'>editor/parrot.el</em> before opening Parrot source files. See <a href='TODO#README.pod'>&#34;README.pod&#34; in editor</a> for instructions.</p>

<p>All source files must end with an editor instruction coda:</p>

<ul>
<li>C source files, and files largely consisting of C (e.g. yacc, lex, PMC, and opcode source files), must end with this coda:</li><p class="pad"></p>

<pre lang='und' xml:lang='und'>   /*
    * Local variables:
    *   c&#45;file&#45;style: &#34;parrot&#34;
    * End:
    * vim: expandtab shiftwidth=4:
    */</pre>

<li>Perl source files must end with this coda:</li><p class="pad"></p>

<pre lang='und' xml:lang='und'>    # Local Variables:
    #   mode: cperl
    #   cperl&#45;indent&#45;level: 4
    #   fill&#45;column: 100
    # End:
    # vim: expandtab shiftwidth=4:</pre>

<p><b>Exception</b>: Files with <code lang='und' xml:lang='und'>__END__</code> or <code lang='und' xml:lang='und'>__DATA__</code> blocks do not require the coda. This is at least until there is some consensus as to how solve the issue of using editor hints in files with such blocks.</p>

<li>PIR source files should end with this coda:</li><p class="pad"></p>

<pre lang='und' xml:lang='und'>    # Local Variables:
    #   mode: pir
    #   fill&#45;column: 100
    # End:
    # vim: expandtab shiftwidth=4:</pre>
</ul>

<p>{{ XXX &#45; Proper formatting and syntax coloring of C code under Emacs requires that Emacs know about typedefs. We should provide a simple script to update a list of typedefs, and parrot.el should read it or contain it. }}</p>

<h2><a name="Portability"
>Portability <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Parrot runs on many, many platforms, and will no doubt be ported to ever more bizarre and obscure ones over time. You should never assume an operating system, processor architecture, endian&#45;ness, size of standard type, or anything else that varies from system to system.</p>

<p>Since most of Parrot&#39;s development uses GNU C, you might accidentally depend on a GNU feature without noticing. To avoid this, know what features of gcc are GNU extensions, and use them only when they&#39;re protected by #ifdefs.</p>

<h2><a name="Defensive_Programming"
>Defensive Programming <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<h3><a name="Use_Parrot_data_structures_instead_of_C_strings_and_arrays"
>Use Parrot data structures instead of C strings and arrays</a></h3>

<p>C arrays, including strings, are very sharp tools without safety guards, and Parrot is a large program maintained by many people. Therefore:</p>

<p>Don&#39;t use a <code lang='und' xml:lang='und'>char *</code> when a Parrot STRING would suffice. Don&#39;t use a C array when a Parrot array PMC would suffice. If do use a <code lang='und' xml:lang='und'>char *</code> or C array, check and recheck your code for even the slightest possibility of buffer overflow or memory leak.</p>

<p>Note that efficiency of some low&#45;level operations may be a reason to break this rule. Be prepared to justify your choices to a jury of your peers.</p>

<h3><a name="Pass_only_unsigned_char_to_isxxx()_and_toxxx()"
>Pass only <code lang='und' xml:lang='und'>unsigned char</code> to <code lang='und' xml:lang='und'>isxxx()</code> and <code lang='und' xml:lang='und'>toxxx()</code></a></h3>

<p>Pass only values in the range of <code lang='und' xml:lang='und'>unsigned char</code> (and the special value &#45;1, a.k.a. <code lang='und' xml:lang='und'>EOF</code>) to the isxxx() and toxxx() library functions. Passing signed characters to these functions is a very common error and leads to incorrect behavior at best and crashes at worst. And under most of the compilers Parrot targets, <code lang='und' xml:lang='und'>char</code> <i>is</i> signed.</p>

<h3><a name="The_const_keyword_on_arguments"
>The <code lang='und' xml:lang='und'>const</code> keyword on arguments</a></h3>

<p>Use the <code lang='und' xml:lang='und'>const</code> keyword as often as possible on pointers. It lets the compiler know when you intend to modify the contents of something. For example, take this definition:</p>

<pre lang='und' xml:lang='und'>    int strlen(const char *p);</pre>

<p>The <code lang='und' xml:lang='und'>const</code> qualifier tells the compiler that the argument will not be modified. The compiler can then tell you that this is an uninitialized variable:</p>

<pre lang='und' xml:lang='und'>    char *p;
    int n = strlen(p);</pre>

<p>Without the <code lang='und' xml:lang='und'>const</code>, the compiler has to assume that <code lang='und' xml:lang='und'>strlen()</code> is actually initializing the contents of <code lang='und' xml:lang='und'>p</code>.</p>

<h3><a name="The_const_keyword_on_variables"
>The <code lang='und' xml:lang='und'>const</code> keyword on variables</a></h3>

<p>If you&#39;re declaring a temporary pointer, declare it <code lang='und' xml:lang='und'>const</code>, with the const to the right of the <code lang='und' xml:lang='und'>*</code>, to indicate that the pointer should not be modified.</p>

<pre lang='und' xml:lang='und'>    Wango * const w = get_current_wango();
    w&#45;&#62;min  = 0;
    w&#45;&#62;max  = 14;
    w&#45;&#62;name = &#34;Ted&#34;;</pre>

<p>This prevents you from modifying <code lang='und' xml:lang='und'>w</code> inadvertantly.</p>

<pre lang='und' xml:lang='und'>    new_wango = w++; /* Error */</pre>

<p>If you&#39;re not going to modify the target of the pointer, put a <code lang='und' xml:lang='und'>const</code> to the left of the type, as in:</p>

<pre lang='und' xml:lang='und'>    const Wango * const w = get_current_wango();
    if (n &#60; wango&#45;&#62;min || n &#62; wango&#45;&#62;max) {
        /* do something */
    }</pre>

<h3><a name="Localizing_variables"
>Localizing variables</a></h3>

<p>Declare variables in the innermost scope possible.</p>

<pre lang='und' xml:lang='und'>    if (foo) {
        int i;
        for (i = 0; i &#60; n; i++)
            do_something(i);
    }</pre>

<p>Don&#39;t reuse unrelated variables. Localize as much as possible, even if the variables happen to have the same names.</p>

<pre lang='und' xml:lang='und'>    if (foo) {
        int i;
        for (i = 0; i &#60; n; i++)
            do_something(i);
    }
    else {
        int i;
        for (i = 14; i &#62; 0; i&#45;&#45;)
            do_something_else(i * i);
    }</pre>

<p>You could hoist the <code lang='und' xml:lang='und'>int i;</code> outside the test, but then you&#39;d have an <code lang='und' xml:lang='und'>i</code> that&#39;s visible after it&#39;s used, which is confusing at best.</p>

<h2><a name="Subversion_properties"
>Subversion properties <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<h3><a name="svn:ignore"
>svn:ignore</a></h3>

<p>Sometimes new files will be created in the configuration and build process of Parrot. These files should not show up when checking the distribution with</p>

<pre lang='und' xml:lang='und'>    svn status</pre>

<p>or</p>

<pre lang='und' xml:lang='und'>    perl tools/dev/manicheck.pl</pre>

<p>The list of these ignore files can be set up with:</p>

<pre lang='und' xml:lang='und'>    svn propedit svn:ignore &#60;PATH&#62;</pre>

<p>In order to keep the two different checks synchronized, the MANIFEST and MANIFEST.SKIP file should be regenerated with:</p>

<pre lang='und' xml:lang='und'>    perl tools/dev/mk_manifest_and_skip.pl</pre>

<h3><a name="svn:mime&#45;type"
>svn:mime&#45;type</a></h3>

<p>The <code lang='und' xml:lang='und'>svn:mime&#45;type</code> property must be set to <code lang='und' xml:lang='und'>text/plain</code> for all test files, and may be set to <code lang='und' xml:lang='und'>text/plain</code> for other source code files in the repository. Using <i>auto&#45;props</i>, Subversion can automatically set this property for you on test files. To enable this option, add the following to your <em lang='und' xml:lang='und'>~/.subversion/config</em>:</p>

<pre lang='und' xml:lang='und'>    [miscellany]
    enable&#45;auto&#45;props = yes
    [auto&#45;props]
    *.t = svn:mime&#45;type=text/plain</pre>

<h3><a name="svn:keywords"
>svn:keywords</a></h3>

<p>The <code lang='und' xml:lang='und'>svn:keywords</code> property should be set to:</p>

<pre lang='und' xml:lang='und'>    Author Date Id Revision</pre>

<p>on each file with a mime&#45;type of <code lang='und' xml:lang='und'>text/plain</code>. Do this with the command:</p>

<pre lang='und' xml:lang='und'>    svn propset svn:keywords &#34;Author Date Id Revision&#34; &#60;filename&#62;</pre>

<p>The <em lang='und' xml:lang='und'><a href="../../t/distro/file_metadata.t.html">t/distro/file_metadata.t</a></em> test checks that the files needing this property have it set.</p>

<h3><a name="svn:eol&#45;style"
>svn:eol&#45;style</a></h3>

<p>The <code lang='und' xml:lang='und'>svn:eol&#45;style</code> property makes sure that whenever a file is checked out of subversion it has the correct end&#45;of&#45;line characters appropriate for the given platform. Therefore, most files should have their <code lang='und' xml:lang='und'>svn:eol&#45;style</code> property set to <code lang='und' xml:lang='und'>native</code>. However, this is not true for all files. Some input files to tests (such as the <code lang='und' xml:lang='und'>*.input</code> and <code lang='und' xml:lang='und'>*.output</code> files for PIR tests) need to have <code lang='und' xml:lang='und'>LF</code> as their <code lang='und' xml:lang='und'>svn:eol&#45;style</code> property. The current list of such files is described in <em lang='und' xml:lang='und'><a href="../../t/distro/file_metadata.t.html">t/distro/file_metadata.t</a></em>.</p>

<p>Set the <code lang='und' xml:lang='und'>svn:eol&#45;style</code> property to <code lang='und' xml:lang='und'>native</code> with the command:</p>

<pre lang='und' xml:lang='und'>    svn propset svn:eol&#45;style &#34;native&#34; &#60;filename&#62;</pre>

<p>Set the <code lang='und' xml:lang='und'>svn:eol&#45;style</code> property to <code lang='und' xml:lang='und'>LF</code> with the command:</p>

<pre lang='und' xml:lang='und'>    svn propset svn:eol&#45;style &#34;LF&#34; &#60;filename&#62;</pre>

<p>The <em lang='und' xml:lang='und'><a href="../../t/distro/file_metadata.t.html">t/distro/file_metadata.t</a></em> test checks that the files needing this property have it set.</p>

<h2><a name="CHIP_HAS_EDITED_THIS_FAR_INTO_THE_FILE"
>CHIP HAS EDITED THIS FAR INTO THE FILE <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<pre lang='und' xml:lang='und'>  +&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;+
    Everything below this point must still be reviewed
  +&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;+</pre>

<h2><a name="Naming_conventions"
>Naming conventions <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="Subsystems_and_APIs"
>Subsystems and APIs</a></dt><p class="pad"></p>

<dd>The Parrot core will be split into a number of subsystems, each with an associated API. For the purposes of naming files, data structures, etc, each subsystem will be assigned a short nickname, e.g. <i>pmc</i>, <i>gc</i>, <i>io</i>. All code within the core will belong to a subsystem; miscellaneous code with no obvious home will be placed in the special subsystem called <i>misc</i>.</dd><p class="pad"></p>

<dt><a name="Filenames"
>Filenames</a></dt><p class="pad"></p>

<dd>Filenames must be assumed to be case&#45;insensitive, in the sense that that you may not have two different files called <em lang='und' xml:lang='und'>Foo</em> and <em lang='und' xml:lang='und'>foo</em>. Normal source&#45;code filenames should be all lower&#45;case; filenames with upper&#45;case letters in them are reserved for notice&#45;me&#45;first files such as <em lang='und' xml:lang='und'>README</em>, and for files which need some sort of pre&#45;processing applied to them or which do the preprocessing &#45; e.g. a script <em lang='und' xml:lang='und'>foo.SH</em> might read <em lang='und' xml:lang='und'>foo.TEMPLATE</em> and output <em lang='und' xml:lang='und'>foo.c</em>.</dd><p class="pad"></p>

<dd>The characters making up filenames must be chosen from the ASCII set A&#45;Z,a&#45;z,0&#45;9 plus .&#45;_</dd><p class="pad"></p>

<dd>An underscore should be used to separate words rather than a hyphen (&#45;). A file should not normally have more than a single &#39;.&#39; in it, and this should be used to denote a suffix of some description. The filename must still be unique if the main part is truncated to 8 characters and any suffix truncated to 3 characters. Ideally, filenames should restricted to 8.3 in the first place, but this is not essential.</dd><p class="pad"></p>

<dd>Each subsystem <i>foo</i> should supply the following files. This arrangement is based on the assumption that each subsystem will &#45; as far as is practical &#45; present an opaque interface to all other subsystems within the core, as well as to extensions and embeddings.</dd><p class="pad"></p>

<dl>
<dt><a name="foo.h"
>foo.h</a></dt><p class="pad"></p>

<dd>This contains all the declarations needed for external users of that API (and nothing more), i.e. it defines the API. It is permissible for the API to include different or extra functionality when used by other parts of the core, compared with its use in extensions and embeddings. In this case, the extra stuff within the file is enabled by testing for the macro <code lang='und' xml:lang='und'>PERL_IN_CORE</code>.</dd><p class="pad"></p>

<dt><a name="foo_private.h"
>foo_private.h</a></dt><p class="pad"></p>

<dd>This contains declarations used internally by that subsystem, and which must only be included within source files associated the subsystem. This file defines the macro <code lang='und' xml:lang='und'>PERL_IN_FOO</code> so that code knows when it is being used within that subsystem. The file will also contain all the &#39;convenience&#39; macros used to define shorter working names for functions without the perl prefix (see below).</dd><p class="pad"></p>

<dt><a name="foo_globals.h"
>foo_globals.h</a></dt><p class="pad"></p>

<dd>This file contains the declaration of a single structure containing the private global variables used by the subsystem (see the section on globals below for more details).</dd><p class="pad"></p>

<dt><a name="foo.sym"
>foo.sym</a></dt><p class="pad"></p>

<dd>This file (format and contents TBD) contains information about global symbols associated with the subsystem, and may be used by scripts to auto&#45;generate such stuff as the include files mentioned above, linker map tables, documentation etc, based upon portability and extensibility requirements.</dd><p class="pad"></p>

<dt><a name="foo_bar.[ch]_etc"
>foo_bar.[ch] etc</a></dt><p class="pad"></p>

<dd>All other source files associated with the subsystem will have the prefix foo_</dd><p class="pad"></p>
</dl>

<dt><a name="Header_Files"
>Header Files</a></dt><p class="pad"></p>

<dd>All .h files should include the following &#34;guards&#34; to prevent multiple&#45;inclusion:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    /* file header comments */

    #if !defined(PARROT_&#60;FILENAME&#62;_H_GUARD)
    #define PARROT_&#60;FILENAME&#62;_H_GUARD

    /* body of file */

    #endif /* PARROT_&#60;FILENAME&#62;_H_GUARD */</pre>

<dt><a name="Names_of_code_entities"
>Names of code entities</a></dt><p class="pad"></p>

<dd>Code entities such as variables, functions, macros etc (apart from strictly local ones) should all follow these general guidelines.</dd><p class="pad"></p>

<ul>
<li>Multiple words or components should be separated with underscores rather than using tricks such as capitalization, e.g. <code lang='und' xml:lang='und'>new_foo_bar</code> rather than <code lang='und' xml:lang='und'>NewFooBar</code> or (gasp) <code lang='und' xml:lang='und'>newfoobar</code>.</li><p class="pad"></p>

<li>The names of entities should err on the side of verbosity, e.g. <code lang='und' xml:lang='und'>create_foo_from_bar()</code> in preference to <code lang='und' xml:lang='und'>ct_foo_bar()</code>. Avoid cryptic abbreviations wherever possible.</li><p class="pad"></p>

<li>All entities should be prefixed with the name of the subsystem they appear in, e.g. <code lang='und' xml:lang='und'>pmc_foo()</code>, <code lang='und' xml:lang='und'>struct io_bar</code>.</li><p class="pad"></p>

<li>Functions with external visibility should be of the form <code lang='und' xml:lang='und'>Parrot_foo</code>, and should only use typedefs with external visibility (or types defined in C89). Generally these functions should not be used inside the core, but this is not a hard and fast rule.</li><p class="pad"></p>

<li>Variables and structure names should be all lower&#45;case, e.g. <code lang='und' xml:lang='und'>pmc_foo</code>.</li><p class="pad"></p>

<li>Structure elements should be all lower&#45;case, and the first component of the name should incorporate the structure&#39;s name or an abbreviation of it.</li><p class="pad"></p>

<li>Typedef names should be lower&#45;case except for the first letter, e.g. <code lang='und' xml:lang='und'>Foo_bar</code>. The exception to this is when the first component is a short abbreviation, in which case the whole first component may be made uppercase for readability purposes, e.g. <code lang='und' xml:lang='und'>IO_foo</code> rather than <code lang='und' xml:lang='und'>Io_foo</code>. Structures should generally be typedefed.</li><p class="pad"></p>

<li>Macros should have their first component uppercase, and the majority of the remaining components should be likewise. Where there is a family of macros, the variable part can be indicated in lowercase, e.g. <code lang='und' xml:lang='und'>PMC_foo_FLAG</code>, <code lang='und' xml:lang='und'>PMC_bar_FLAG</code>, ....</li><p class="pad"></p>

<li>A macro which defines a flag bit should be suffixed with <code lang='und' xml:lang='und'>_FLAG</code>, e.g. <code lang='und' xml:lang='und'>PMC_readonly_FLAG</code> (although you probably want to use an <code lang='und' xml:lang='und'>enum</code> instead.)</li><p class="pad"></p>

<li>A macro which tests a flag bit should be suffixed with <code lang='und' xml:lang='und'>_TEST</code>, e.g. <code lang='und' xml:lang='und'>if (PMC_readonly_TEST(foo)) ...</code></li><p class="pad"></p>

<li>A macro which sets a flag bit should be suffixed with <code lang='und' xml:lang='und'>_SET</code>, e.g. <code lang='und' xml:lang='und'>PMC_readonly_SET(foo);</code></li><p class="pad"></p>

<li>A macro which clears a flag bit should be suffixed with <code lang='und' xml:lang='und'>_CLEAR</code>, e.g. <code lang='und' xml:lang='und'>PMC_readonly_CLEAR(foo);</code></li><p class="pad"></p>

<li>A macro defining a mask of flag bits should be suffixed with <code lang='und' xml:lang='und'>_MASK</code>, e.g. <code lang='und' xml:lang='und'>foo &#38;= ~PMC_STATUS_MASK</code> (but see notes on extensibility below).</li><p class="pad"></p>

<li>Macros can be defined to cover common flag combinations, in which case they should have <code lang='und' xml:lang='und'>_SETALL</code>, <code lang='und' xml:lang='und'>CLEARALL</code>, <code lang='und' xml:lang='und'>_TESTALL</code> or &#60;_TESTANY&#62; suffixes as appropriate, to indicate aggregate bits, e.g. <code lang='und' xml:lang='und'>PMC_valid_CLEARALL(foo)</code></li><p class="pad"></p>

<li>A macro defining an auto&#45;configuration value should be prefixed with <code lang='und' xml:lang='und'>HAS_</code>, e.g. <code lang='und' xml:lang='und'>HAS_BROKEN_FLOCK</code>, <code lang='und' xml:lang='und'>HAS_EBCDIC</code>.</li><p class="pad"></p>

<li>A macro indicating the compilation &#39;location&#39; should be prefixed with <code lang='und' xml:lang='und'>IN_</code>, e.g. <code lang='und' xml:lang='und'>PERL_IN_CORE</code>, <code lang='und' xml:lang='und'>PERL_IN_PMC</code>, <code lang='und' xml:lang='und'>PERL_IN_X2P</code>. Individual include file visitations should be marked with <code lang='und' xml:lang='und'>PERL_IN_FOO_H</code> for file foo.h</li><p class="pad"></p>

<li>A macro indicating major compilation switches should be prefixed with <code lang='und' xml:lang='und'>USE_</code>, e.g. <code lang='und' xml:lang='und'>PERL_USE_STDIO</code>, <code lang='und' xml:lang='und'>USE_MULTIPLICITY</code>.</li><p class="pad"></p>

<li>A macro that may declare stuff and thus needs to be at the start of a block should be prefixed with <code lang='und' xml:lang='und'>DECL_</code>, e.g. <code lang='und' xml:lang='und'>DECL_SAVE_STACK</code>. Note that macros which implicitly declare and then use variables are strongly discouraged, unless it is essential for portability or extensibility. The following are in decreasing preference style&#45;wise, but increasing preference extensibility&#45;wise.</li><p class="pad"></p>

<pre lang='und' xml:lang='und'>    { Stack sp = GETSTACK;  x = POPSTACK(sp) ... /* sp is an auto variable */
    { DECL_STACK(sp);  x = POPSTACK(sp); ... /* sp may or may not be auto */
    { DECL_STACK; x = POPSTACK; ... /* anybody&#39;s guess */</pre>
</ul>

<dt><a name="Global_Variables"
>Global Variables</a></dt><p class="pad"></p>

<dd>Global variables must never be accessed directly outside the subsystem in which they are used. Some other method, such as accessor functions, must be provided by that subsystem&#39;s API. (For efficiency the &#39;accessor functions&#39; may occasionally actually be macros, but then the rule still applies in spirit at least).</dd><p class="pad"></p>

<dd>All global variables needed for the internal use of a particular subsystem should all be declared within a single struct called foo_globals for subsystem foo. This structure&#39;s declaration is placed in the file foo_globals.h. Then somewhere a single compound structure will be declared which has as members the individual structures from each subsystem. Instances of this structure are then defined as a one&#45;off global variable, or as per&#45;thread instances, or whatever is required.</dd><p class="pad"></p>

<dd>[Actually, three separate structures may be required, for global, per&#45;interpreter and per&#45;thread variables.]</dd><p class="pad"></p>

<dd>Within an individual subsystem, macros are defined for each global variable of the form <code lang='und' xml:lang='und'>GLOBAL_foo</code> (the name being deliberately clunky). So we might for example have the following macros:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    /* perl_core.h or similar */

    #ifdef HAS_THREADS
    #  define GLOBALS_BASE (aTHX_&#45;&#62;globals)
    #else
    #  define GLOBALS_BASE (Perl_globals)
    #endif

    /* pmc_private.h */

    #define GLOBAL_foo   GLOBALS_BASE.pmc.foo
    #define GLOBAL_bar   GLOBALS_BASE.pmc.bar
    ... etc ...</pre>
</dl>

<h2><a name="Code_comments"
>Code comments <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>The importance of good code documentation cannot be stressed enough. To make your code understandable by others (and indeed by yourself when you come to make changes a year later :&#45;), the following conventions apply to all source files.</p>

<dl>
<dt><a name="Developer_files"
>Developer files</a></dt><p class="pad"></p>

<dd>Each source file (e.g. a <em lang='und' xml:lang='und'>foo.c</em> <em lang='und' xml:lang='und'>foo.h</em> pair), should contain inline POD documentation containing information on the implementation decisions associated with the source file. (Note that this is in contrast to PDDs, which describe design decisions). In addition, more discussive documentation can be placed in <em lang='und' xml:lang='und'>*.dev</em> files in the <em lang='und' xml:lang='und'>docs/dev</em> directory. This is the place for mini&#45;essays on how to avoid overflows in unsigned arithmetic, or on the pros and cons of differing hash algorithms, and why the current one was chosen, and how it works.</dd><p class="pad"></p>

<dd>In principle, someone coming to a particular source file for the first time should be able to read the inline documentation file and gain an immediate overview of what the source file is for, the algorithms it implements, etc.</dd><p class="pad"></p>

<dd>The POD documentation should follow the standard POD layout:</dd><p class="pad"></p>

<dl>
<dt><a name="Copyright"
>Copyright</a></dt><p class="pad"></p>

<dd>The Parrot copyright statement.</dd><p class="pad"></p>

<dt><a name="SVN"
>SVN</a></dt><p class="pad"></p>

<dd>A SVN id string.</dd><p class="pad"></p>

<dt><a name="NAME"
>NAME</a></dt><p class="pad"></p>

<dd>src/foo.c &#45; Foo</dd><p class="pad"></p>

<dt><a name="SYNOPSIS"
>SYNOPSIS</a></dt><p class="pad"></p>

<dd>When appropriate, some simple examples of usage.</dd><p class="pad"></p>

<dt><a name="DESCRIPTION"
>DESCRIPTION</a></dt><p class="pad"></p>

<dd>A description of the contents of the file, how the implementation works, data structures and algorithms, and anything that may be of interest to your successors, e.g. benchmarks of differing hash algorithms, essays on how to do integer arithmetic.</dd><p class="pad"></p>

<dt><a name="HISTORY"
>HISTORY</a></dt><p class="pad"></p>

<dd>Record major changes to the file, e.g. &#34;we moved from a linked list to a hash table implementation for storing Foos, as it was found to be much faster&#34;.</dd><p class="pad"></p>

<dt><a name="SEE_ALSO"
>SEE ALSO</a></dt><p class="pad"></p>

<dd>Links to pages and books that may contain useful info relevant to the stuff going on in the code &#45; e.g. the book you stole the hash function from.</dd><p class="pad"></p>
</dl>

<dt><a name="Per&#45;section_comments"
>Per&#45;section comments</a></dt><p class="pad"></p>

<dd>If there is a collection of functions, structures or whatever which are grouped together and have a common theme or purpose, there should be a general comment at the start of the section briefly explaining their overall purpose. (Detailed essays should be left to the developer file). If there is really only one section, then the top&#45;of&#45;file comment already satisfies this requirement.</dd><p class="pad"></p>

<dt><a name="Per&#45;entity_comments"
>Per&#45;entity comments</a></dt><p class="pad"></p>

<dd>Every non&#45;local named entity, be it a function, variable, structure, macro or whatever, must have an accompanying comment explaining its purpose. This comment must be in the special format described below, in order to allow automatic extraction by tools &#45; for example, to generate per API man pages, <b>perldoc &#45;f</b> style utilities and so on.</dd><p class="pad"></p>

<dd>Often the comment need only be a single line explaining its purpose, but sometimes more explanation may be needed. For example, &#34;return an Integer Foo to its allocation pool&#34; may be enough to demystify the function <code lang='und' xml:lang='und'>del_I_foo()</code></dd><p class="pad"></p>

<dd>Each comment should be of the form</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    /*

    =item C&#60;function(arguments)&#62;

    Description.

    =cut

    */</pre>

<dd>This inline POD documentation is parsed to HTML by running:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    % perl tools/docs/write_docs.pl &#45;s</pre>

<dt><a name="Optimizations"
>Optimizations</a></dt><p class="pad"></p>

<dd>Whenever code has deliberately been written in an odd way for performance reasons, you should point this out &#45; if nothing else, to avoid some poor schmuck trying subsequently to replace it with something &#39;cleaner&#39;.</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    /* The loop is partially unrolled here as it makes it a lot faster.
     * See the .dev file for the full details
     */</pre>

<dt><a name="General_comments"
>General comments</a></dt><p class="pad"></p>

<dd>While there is no need to go mad commenting every line of code, it is immensely helpful to provide a &#34;running commentary&#34; every 10 or so lines say; if nothing else, this makes it easy to quickly locate a specific chunk of code. Such comments are particularly useful at the top of each major branch, e.g.</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    if (FOO_bar_BAZ(**p+*q) &#60;= (r&#45;s[FOZ &#38; FAZ_MASK]) || FLOP_2(z99)) {
        /* we&#39;re in foo mode: clean up lexicals */
        ... (20 lines of gibberish) ...
    }
    else if (...) {
        /* we&#39;re in bar mode: clean up globals */
        ... (20 more lines of gibberish) ...
    }
    else {
        /* we&#39;re in baz mode: self&#45;destruct */
        ....
    }</pre>
</dl>

<h2><a name="Extensibility"
>Extensibility <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>If Perl 5 is anything to go by, the lifetime of Perl 6 will be at least seven years. During this period, the source code will undergo many major changes never envisaged by its original authors &#45; cf threads, unicode in perl 5. To this end, your code should balance out the assumptions that make things possible, fast or small, with the assumptions that make it difficult to change things in future. This is especially important for parts of the code which are exposed through APIs &#45; the requirements of src or binary compatibility for such things as extensions can make it very hard to change things later on.</p>

<p>For example, if you define suitable macros to set/test flags in a struct, then you can later add a second word of flags to the struct without breaking source compatibility. (Although you might still break binary compatibility if you&#39;re not careful.) Of the following two methods of setting a common combination of flags, the second doesn&#39;t assume that all the flags are contained within a single field:</p>

<pre lang='und' xml:lang='und'>    foo&#45;&#62;flags |= (FOO_int_FLAG | FOO_num_FLAG | FOO_str_FLAG);
    FOO_valid_value_SETALL(foo);</pre>

<p>Similarly, avoid using a char* (or {char*,length}) if it is feasible to later use a <code lang='und' xml:lang='und'>PMC *</code> at the same point: cf UTF&#45;8 hash keys in Perl 5.</p>

<p>Of course, private code hidden behind an API can play more fast and loose than code which gets exposed.</p>

<h2><a name="Performance"
>Performance <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>We want Perl to be fast. Very fast. But we also want it to be portable and extensible. Based on the 90/10 principle, (or 80/20, or 95/5, depending on who you speak to), most performance is gained or lost in a few small but critical areas of code. Concentrate your optimization efforts there.</p>

<p>Note that the most overwhelmingly important factor in performance is in choosing the correct algorithms and data structures in the first place. Any subsequent tweaking of code is secondary to this. Also, any tweaking that is done should as far as possible be platform independent, or at least likely to cause speed&#45;ups in a wide variety of environments, and do no harm elsewhere. Only in exceptional circumstances should assembly ever even be considered, and then only if generic fallback code is made available that can still be used by all other non&#45;optimized platforms.</p>

<p>Probably the dominant factor (circa 2001) that effects processor performance is the cache. Processor clock rates have increased far in excess of main memory access rates, and the only way for the processor to proceed without stalling is for most of the data items it needs to be found to hand in the cache. It is reckoned that even a 2% cache miss rate can cause a slowdown in the region of 50%. It is for this reason that algorithms and data structures must be designed to be &#39;cache&#45;friendly&#39;.</p>

<p>A typical cache may have a block size of anywhere between 4 and 256 bytes. When a program attempts to read a word from memory and the word is already in the cache, then processing continues unaffected. Otherwise, the processor is typically stalled while a whole contiguous chunk of main memory is read in and stored in a cache block. Thus, after incurring the initial time penalty, you then get all the memory adjacent to the initially read data item for free. Algorithms that make use of this fact can experience quite dramatic speedups. For example, the following pathological code ran four times faster on my machine by simply swapping <code lang='und' xml:lang='und'>i</code> and <code lang='und' xml:lang='und'>j</code>.</p>

<pre lang='und' xml:lang='und'>    int a[1000][1000];

    ... (a gets populated) ...

    int i,j,k;
    for (i=0; i&#60;1000; i++) {
        for (j=0; j&#60;1000; j++) {
            k += a[j][i];
        }
    }</pre>

<p>This all boils down to: keep things near to each other that get accessed at around the same time. (This is why the important optimizations occur in data structure and algorithm design rather than in the detail of the code.) This rule applies both to the layout of different objects relative to each other, and to the relative positioning of individual fields within a single structure.</p>

<p>If you do put an optimization in, time it on as many architectures as you can, and be suspicious of it if it slows down on any of them! Perhaps it will be slow on other architectures too (current and future). Perhaps it wasn&#39;t so clever after all? If the optimization is platform specific, you should probably put it in a platform&#45;specific function in a platform&#45;specific file, rather than cluttering the main source with zillions of #ifdefs.</p>

<p>And remember to document it.</p>

<p>Loosely speaking, Perl tends to optimize for speed rather than space, so you may want to code for speed first, then tweak to reclaim some space while not affecting performance.</p>

<h1><a name="EXEMPTIONS"
>EXEMPTIONS <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Not all files can strictly fall under these guidelines as they are automatically generated by other tools, or are external files included in the Parrot repository for convenience. Such files include the C header and source files automatically generated by (f)lex and yacc/bison, and some of the Perl modules under the <code lang='und' xml:lang='und'>lib/</code> directory.</p>

<p>To exempt a file (or directory of files) from checking by the coding standards tests, one must edit the appropriate exemption list within <code lang='und' xml:lang='und'>lib/Parrot/Distribution.pm</code> (in either of the methods <code lang='und' xml:lang='und'>is_c_exemption()</code> or <code lang='und' xml:lang='und'>is_perl_exemption()</code>). One can use wildcards in the list to exempt, for example, all files under a given directory.</p>

<h1><a name="REFERENCES"
>REFERENCES <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>The section on coding style is based on Perl 5&#39;s <em lang='und' xml:lang='und'>Porting/patching.pod</em> by Daniel Grisinger. The section on naming conventions grew from some suggestions by Paolo Molaro &#60;lupus@lettere.unipd.it&#62;. Other snippets came from various P5Pers.</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
