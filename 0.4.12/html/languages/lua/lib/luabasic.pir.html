<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Lua Basic Library</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Lua Basic Library</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../../html/index.html">Contents</a> | <a href="../../../../html/languages.html">Language Implementations</a> | <a href="../../../../html/lua.html">Lua</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>lib/luabasic.pir &#45; Lua Basic Library</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>The basic library provides some core functions to Lua.</p>

<p>See &#34;Lua 5.1 Reference Manual&#34;,
section 5.1 &#34;Basic Functions&#34;,
<a href='http://www.lua.org/manual/5.1/manual.html#5.1'><a href="http://www.lua.org/manual/5.1/manual.html#5.1">http://www.lua.org/manual/5.1/manual.html#5.1</a></a>.</p>

<h2><a name="Variables"
>Variables <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="_G"
><b><code lang='und' xml:lang='und'>_G</b></code></a></dt><p class="pad"></p>

<dd>A global variable (not a function) that holds the global environment (that is,
<code lang='und' xml:lang='und'>_G._G = _G</code>).
Lua itself does not use this variable; changing its value does not affect any environment,
nor vice&#45;versa.
(Use <code lang='und' xml:lang='und'>setfenv</code> to change environments.)</dd><p class="pad"></p>

<dt><a name="_VERSION"
><b><code lang='und' xml:lang='und'>_VERSION</b></code></a></dt><p class="pad"></p>

<dd>A global variable (not a function) that holds a string containing the current interpreter version.
The current contents of this variable is <code lang='und' xml:lang='und'>&#34;Lua 5.1&#34;</code>.</dd><p class="pad"></p>
</dl>

<h2><a name="Functions"
>Functions <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="assert_(v_[,_message])"
><b><code lang='und' xml:lang='und'>assert (v [, message])</b></code></a></dt><p class="pad"></p>

<dd>Issues an error when the value of its argument <code lang='und' xml:lang='und'>v</code> is false (i.e.,
<b>nil</b> or <b>false</b>); otherwise,
returns all its arguments.
<code lang='und' xml:lang='und'>message</code> is an error message; when absent,
it defaults to &#34;assertion failed!&#34;</dd><p class="pad"></p>

<dt><a name="collectgarbage_(opt_[,_arg])"
><b><code lang='und' xml:lang='und'>collectgarbage (opt [, arg])</b></code></a></dt><p class="pad"></p>

<dd>This function is a generic interface to the garbage collector.
It performs different functions according to its first argument,
<code lang='und' xml:lang='und'>opt</code>:</dd><p class="pad"></p>

<dl>
<dt><a name="&#34;stop&#34;"
><b>&#34;stop&#34;</b></a></dt><p class="pad"></p>

<dd>stops the garbage collector.</dd><p class="pad"></p>

<dt><a name="&#34;restart&#34;"
><b>&#34;restart&#34;</b></a></dt><p class="pad"></p>

<dd>restarts the garbage collector.</dd><p class="pad"></p>

<dt><a name="&#34;collect&#34;"
><b>&#34;collect&#34;</b></a></dt><p class="pad"></p>

<dd>performs a full garbage&#45;collection cycle.</dd><p class="pad"></p>

<dt><a name="&#34;count&#34;"
><b>&#34;count&#34;</b></a></dt><p class="pad"></p>

<dd>returns the total memory in use by Lua (in Kbytes).</dd><p class="pad"></p>

<dt><a name="&#34;step&#34;"
><b>&#34;step&#34;</b></a></dt><p class="pad"></p>

<dd>performs a garbage&#45;collection step.
The step <code lang='und' xml:lang='und'>&#34;size&#34;</code> is controlled by <code lang='und' xml:lang='und'>arg</code> (larger values mean more steps) in a non&#45;specified way.
If you want to control the step size you must tune experimentally the value of <code lang='und' xml:lang='und'>arg</code>.
Returns <b>true</b> if the step finished a collection cycle.</dd><p class="pad"></p>

<dt><a name="&#34;steppause&#34;"
><b>&#34;steppause&#34;</b></a></dt><p class="pad"></p>

<dd>sets <code lang='und' xml:lang='und'>arg</code>/100 as the new value for the <i>pause</i> of the collector.</dd><p class="pad"></p>

<dt><a name="&#34;setstepmul&#34;"
><b>&#34;setstepmul&#34;</b></a></dt><p class="pad"></p>

<dd>sets <code lang='und' xml:lang='und'>arg</code>/100 as the new value for the <i>step multiplier</i> of the collector.</dd><p class="pad"></p>
</dl>

<dd>STILL INCOMPLETE (see gc).</dd><p class="pad"></p>

<dt><a name="dofile_(filename)"
><b><code lang='und' xml:lang='und'>dofile (filename)</b></code></a></dt><p class="pad"></p>

<dd>Opens the named file and executes its contents as a Lua chunk.
When called without arguments,
<code lang='und' xml:lang='und'>dofile</code> executes the contents of the standard input (<code lang='und' xml:lang='und'>stdin</code>).
Returns all values returned by the chunk.
In case of errors,
<code lang='und' xml:lang='und'>dofile</code> propagates the error to its caller (that is,
dofile does not run in protected mode).</dd><p class="pad"></p>

<dt><a name="error_(message_[,_level])"
><b><code lang='und' xml:lang='und'>error (message [, level])</b></code></a></dt><p class="pad"></p>

<dd>Terminates the last protected function called and returns <code lang='und' xml:lang='und'>message</code> as the error message.
Function <code lang='und' xml:lang='und'>error</code> never returns.</dd><p class="pad"></p>

<dd>Usually,
<code lang='und' xml:lang='und'>error</code> adds some information about the error position at the beginning of the message.
The <code lang='und' xml:lang='und'>level</code> argument specifies how to get the error position.
With level 1 (the default),
the error position is where the <code lang='und' xml:lang='und'>error</code> function was called.
Level 2 points the error to where the function that called <code lang='und' xml:lang='und'>error</code> was called; and so on.
Passing a level 0 avoids the addition of error position information to the message.</dd><p class="pad"></p>

<dd>STILL INCOMPLETE.</dd><p class="pad"></p>

<dt><a name="getfenv_(f)"
><b><code lang='und' xml:lang='und'>getfenv (f)</b></code></a></dt><p class="pad"></p>

<dd>Returns the current environment in use by the function.
<code lang='und' xml:lang='und'>f</code> can be a Lua function or a number that specifies the function at that stack level: Level 1 is the function calling <code lang='und' xml:lang='und'>getfenv</code>.
If the given function is not a Lua function,
or if <code lang='und' xml:lang='und'>f</code> is 0,
<code lang='und' xml:lang='und'>getfenv</code> returns the global environment.
The default for <code lang='und' xml:lang='und'>f</code> is 1.</dd><p class="pad"></p>

<dt><a name="getmetatable_(object)"
><b><code lang='und' xml:lang='und'>getmetatable (object)</b></code></a></dt><p class="pad"></p>

<dd>If <code lang='und' xml:lang='und'>object</code> does not have a metatable,
returns <b>nil</b>.
Otherwise,
if the object&#39;s metatable has a <code lang='und' xml:lang='und'>&#34;__metatable&#34;</code> field,
returns the associated value.
Otherwise,
returns the metatable of the given object.</dd><p class="pad"></p>

<dt><a name="ipairs_(t)"
><b><code lang='und' xml:lang='und'>ipairs (t)</b></code></a></dt><p class="pad"></p>

<dd>Returns three values: an iterator function,
the table <code lang='und' xml:lang='und'>t</code>,
and 0,
so that the construction</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    for i,v in ipairs(t) do ... end</pre>

<dd>will iterate over the pairs (<code lang='und' xml:lang='und'>1,t[1]</code>), (<code lang='und' xml:lang='und'>2,t[2]</code>), ..., up to the first integer key with a nil value in the table.</dd><p class="pad"></p>

<dd>See <code lang='und' xml:lang='und'>next</code> for the caveats of modifying the table during its traversal.</dd><p class="pad"></p>

<dt><a name="load_(func_[,_chunkname])"
><b><code lang='und' xml:lang='und'>load (func [, chunkname])</b></code></a></dt><p class="pad"></p>

<dd>Loads a chunk using function <code lang='und' xml:lang='und'>func</code> to get its pieces. Each call to <code lang='und' xml:lang='und'>func</code> must return a string that concatenates with previous results. A return of <b>nil</b> (or no value) signals the end of the chunk.</dd><p class="pad"></p>

<dd>If there are no errors, returns the compiled chunk as a function; otherwise, returns <b>nil</b> plus the error message. The environment of the returned function is the global environment.</dd><p class="pad"></p>

<dd><code lang='und' xml:lang='und'>chunkname</code> is used as the chunk name for error messages and debug information.</dd><p class="pad"></p>

<dd>NOT YET IMPLEMENTED.</dd><p class="pad"></p>

<dt><a name="loadfile_([filename])"
><b><code lang='und' xml:lang='und'>loadfile ([filename])</b></code></a></dt><p class="pad"></p>

<dd>Similar to <code lang='und' xml:lang='und'>load</code>, but gets the chunk from file <code lang='und' xml:lang='und'>filename</code> or from the standard input, if no file name is given.</dd><p class="pad"></p>

<dt><a name="loadstring_(string_[,_chunkname])"
><b><code lang='und' xml:lang='und'>loadstring (string [, chunkname])</b></code></a></dt><p class="pad"></p>

<dd>Similar to <code lang='und' xml:lang='und'>load</code>, but gets the chunk from the given string.</dd><p class="pad"></p>

<dd>To load and run a given string, use the idiom</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    assert(loadstring(s))()</pre>

<dt><a name="next_(table_[,_index])"
><b><code lang='und' xml:lang='und'>next (table [, index])</b></code></a></dt><p class="pad"></p>

<dd>Allows a program to traverse all fields of a table. Its first argument is a table and its second argument is an index in this table. <code lang='und' xml:lang='und'>next</code> returns the next index of the table and its associated value. When called with <b>nil</b> as its second argument, <code lang='und' xml:lang='und'>next</code> returns an initial index and its associated value. When called with the last index, or with <b>nil</b> in an empty table, <code lang='und' xml:lang='und'>next</code> returns <b>nil</b>. If the second argument is absent, then it is interpreted as <b>nil</b>. In particular, you can use <code lang='und' xml:lang='und'>next(t)</code> to check whether a table is empty.</dd><p class="pad"></p>

<dd>Lua has no declaration of fields. There is no difference between a field not present in a table or a field with value <b>nil</b>. Therefore, <code lang='und' xml:lang='und'>next</code> only considers fields with non&#45;<b>nil</b> values. The order in which the indices are enumerated is not specified, <i>even for numeric indices</i>. (To traverse a table in numeric order, use a numerical for or the <code lang='und' xml:lang='und'>ipairs</code> function.)</dd><p class="pad"></p>

<dd>The behavior of <code lang='und' xml:lang='und'>next</code> is <i>undefined</i> if, during the traversal, you assign any value to a non&#45;existent field in the table. You may however modify existing fields. In particular, you may clear existing fields.</dd><p class="pad"></p>

<dt><a name="pairs_(t)"
><b><code lang='und' xml:lang='und'>pairs (t)</b></code></a></dt><p class="pad"></p>

<dd>Returns three values: the <code lang='und' xml:lang='und'>next</code> function, the table <code lang='und' xml:lang='und'>t</code>, and <b>nil</b>, so that the construction</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    for k,v in pairs(t) do ... end</pre>

<dd>will iterate over all key&#45;&#45;value pairs of table <code lang='und' xml:lang='und'>t</code>.</dd><p class="pad"></p>

<dd>See <code lang='und' xml:lang='und'>next</code> for the caveats of modifying the table during its traversal.</dd><p class="pad"></p>

<dt><a name="pcall_(f,_arg1,_arg2,_...)"
><b><code lang='und' xml:lang='und'>pcall (f, arg1, arg2, ...)</b></code></a></dt><p class="pad"></p>

<dd>Calls function <code lang='und' xml:lang='und'>f</code> with the given arguments in protected mode. This means that any error inside <code lang='und' xml:lang='und'>f</code> is not propagated; instead, <code lang='und' xml:lang='und'>pcall</code> catches the error and returns a status code. Its first result is the status code (a boolean), which is <b>true</b> if the call succeeds without errors. In such case, <code lang='und' xml:lang='und'>pcall</code> also returns all results from the call, after this first result. In case of any error, <code lang='und' xml:lang='und'>pcall</code> returns <b>false</b> plus the error message.</dd><p class="pad"></p>

<dt><a name="print_(e1,_e2,_...)"
><b><code lang='und' xml:lang='und'>print (e1, e2, ...)</b></code></a></dt><p class="pad"></p>

<dd>Receives any number of arguments, and prints their values to <code lang='und' xml:lang='und'>stdout</code>, using the <code lang='und' xml:lang='und'>tostring</code> function to convert them to strings. <code lang='und' xml:lang='und'>print</code> is not intended for formatted output, but only as a quick way to show a value, typically for debugging. For formatted output, use <code lang='und' xml:lang='und'>string.format</code>.</dd><p class="pad"></p>

<dt><a name="rawequal_(v1,_v2)"
><b><code lang='und' xml:lang='und'>rawequal (v1, v2)</b></code></a></dt><p class="pad"></p>

<dd>Checks whether <code lang='und' xml:lang='und'>v1</code> is equal to <code lang='und' xml:lang='und'>v2</code>, without invoking any metamethod. Returns a boolean.</dd><p class="pad"></p>

<dt><a name="rawget_(table,_index)"
><b><code lang='und' xml:lang='und'>rawget (table, index)</b></code></a></dt><p class="pad"></p>

<dd>Gets the real value of <code lang='und' xml:lang='und'>table[index]</code>, without invoking any metamethod. <code lang='und' xml:lang='und'>table</code> must be a table; <code lang='und' xml:lang='und'>index</code> is any value different from <b>nil</b>.</dd><p class="pad"></p>

<dt><a name="rawset_(table,_index,_value)"
><b><code lang='und' xml:lang='und'>rawset (table, index, value)</b></code></a></dt><p class="pad"></p>

<dd>Sets the real value of <code lang='und' xml:lang='und'>table[index]</code> to value, without invoking any metamethod. <code lang='und' xml:lang='und'>table</code> must be a table, <code lang='und' xml:lang='und'>index</code> is any value different from <b>nil</b>, and <code lang='und' xml:lang='und'>value</code> is any Lua value.</dd><p class="pad"></p>

<dd>This function returns <code lang='und' xml:lang='und'>table</code>.</dd><p class="pad"></p>

<dt><a name="select_(index,_...)"
><b><code lang='und' xml:lang='und'>select (index, ...)</b></code></a></dt><p class="pad"></p>

<dd>If <code lang='und' xml:lang='und'>index</code> is a number, returns all arguments after argument number <code lang='und' xml:lang='und'>index</code>. Otherwise, <code lang='und' xml:lang='und'>index</code> must be the string <code lang='und' xml:lang='und'>&#34;#&#34;</code>, and <code lang='und' xml:lang='und'>select</code> returns the total number of extra arguments it received.</dd><p class="pad"></p>

<dt><a name="setfenv_(f,_table)"
><b><code lang='und' xml:lang='und'>setfenv (f, table)</b></code></a></dt><p class="pad"></p>

<dd>Sets the environment to be used by the given function. <code lang='und' xml:lang='und'>f</code> can be a Lua function or a number that specifies the function at that stack level: Level 1 is the function calling <code lang='und' xml:lang='und'>setfenv</code>. <code lang='und' xml:lang='und'>setfenv</code> returns the given function.</dd><p class="pad"></p>

<dd>As a special case, when <code lang='und' xml:lang='und'>f</code> is 0 <code lang='und' xml:lang='und'>setfenv</code> changes the environment of the running thread. In this case, <code lang='und' xml:lang='und'>setfenv</code> returns no values.</dd><p class="pad"></p>

<dd>STILL INCOMPLETE.</dd><p class="pad"></p>

<dt><a name="setmetatable_(table,_metatable)"
><b><code lang='und' xml:lang='und'>setmetatable (table, metatable)</b></code></a></dt><p class="pad"></p>

<dd>Sets the metatable for the given table. (You cannot change the metatable of other types from Lua.) If metatable is <b>nil</b>, removes the metatable of the given table. If the original metatable has a <code lang='und' xml:lang='und'>&#34;__metatable&#34;</code> field, raises an error.</dd><p class="pad"></p>

<dd>This function returns <code lang='und' xml:lang='und'>table</code>.</dd><p class="pad"></p>

<dt><a name="tonumber_(e_[,_base])"
><b><code lang='und' xml:lang='und'>tonumber (e [, base])</b></code></a></dt><p class="pad"></p>

<dd>Tries to convert its argument to a number. If the argument is already a number or a string convertible to a number, then <code lang='und' xml:lang='und'>tonumber</code> returns that number; otherwise, it returns <b>nil</b>.</dd><p class="pad"></p>

<dd>An optional argument specifies the base to interpret the numeral. The base may be any integer between 2 and 36, inclusive. In bases above 10, the letter &#145;A&#146; (in either upper or lower case) represents 10, &#145;B&#146; represents 11, and so forth, with &#145;Z&#146; representing 35. In base 10 (the default), the number may have a decimal part, as well as an optional exponent part. In other bases, only unsigned integers are accepted.</dd><p class="pad"></p>

<dt><a name="tostring_(e)"
><b><code lang='und' xml:lang='und'>tostring (e)</b></code></a></dt><p class="pad"></p>

<dd>Receives an argument of any type and converts it to a string in a reasonable format. For complete control of how numbers are converted, use <code lang='und' xml:lang='und'>format</code>.</dd><p class="pad"></p>

<dd>If the metatable of e has a <code lang='und' xml:lang='und'>&#34;__tostring&#34;</code> field, <code lang='und' xml:lang='und'>tostring</code> calls the corresponding value with <code lang='und' xml:lang='und'>e</code> as argument, and uses the result of the call as its result.</dd><p class="pad"></p>

<dt><a name="type_(v)"
><b><code lang='und' xml:lang='und'>type (v)</b></code></a></dt><p class="pad"></p>

<dd>Returns the type of its only argument, coded as a string. The possible results of this function are <code lang='und' xml:lang='und'>&#34;nil&#34;</code> (a string, not the value <b>nil</b>), <code lang='und' xml:lang='und'>&#34;number&#34;</code>, <code lang='und' xml:lang='und'>&#34;string&#34;</code>, <code lang='und' xml:lang='und'>&#34;boolean&#34;</code>, <code lang='und' xml:lang='und'>&#34;table&#34;</code>, <code lang='und' xml:lang='und'>&#34;function&#34;</code>, <code lang='und' xml:lang='und'>&#34;thread&#34;</code>, and <code lang='und' xml:lang='und'>&#34;userdata&#34;</code>.</dd><p class="pad"></p>

<dt><a name="unpack_(list_[,_i_[,_j]])"
><b><code lang='und' xml:lang='und'>unpack (list [, i [, j]])</b></code></a></dt><p class="pad"></p>

<dd>Returns the elements from the given table. This function is equivalent to</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    return list[i], list[i+1], ..., list[j]</pre>

<dd>except that the above code can be written only for a fixed number of elements. By default, <code lang='und' xml:lang='und'>i</code> is 1 and <code lang='und' xml:lang='und'>j</code> is the length of the list, as defined by the length operator.</dd><p class="pad"></p>

<dt><a name="xpcall_(f,_err)"
><b><code lang='und' xml:lang='und'>xpcall (f, err)</b></code></a></dt><p class="pad"></p>

<dd>This function is similar to <code lang='und' xml:lang='und'>pcall</code>, except that you can set a new error handler.</dd><p class="pad"></p>

<dd><code lang='und' xml:lang='und'>xpcall</code> calls function <code lang='und' xml:lang='und'>f</code> in protected mode, using <code lang='und' xml:lang='und'>err</code> as the error handler. Any error inside <code lang='und' xml:lang='und'>f</code> is not propagated; instead, <code lang='und' xml:lang='und'>xpcall</code> catches the error, calls the <code lang='und' xml:lang='und'>err</code> function with the original error object, and returns a status code. Its first result is the status code (a boolean), which is true if the call succeeds without errors. In this case, <code lang='und' xml:lang='und'>xpcall</code> also returns all results from the call, after this first result. In case of any error, <code lang='und' xml:lang='und'>xpcall</code> returns false plus the result from <code lang='und' xml:lang='und'>err</code>.</dd><p class="pad"></p>
</dl>

<h1><a name="AUTHORS"
>AUTHORS <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>Francois Perrad.</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
