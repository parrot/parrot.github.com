<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Class and object</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Class and object</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../html/index.html">Contents</a> | <a href="../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>objects.c &#45; Class and object</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>Handles class and object manipulation.</p>

<h2><a name="Functions"
>Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="INTVAL_Parrot_get_vtable_index(Interp_*,_STRING_*name)"
><b><code lang='und' xml:lang='und'>INTVAL Parrot_get_vtable_index(Interp *, STRING *name)</b></code></a></dt><p class="pad"></p>

<dd>Return index if <code lang='und' xml:lang='und'>name</code> is a valid vtable slot name.</dd><p class="pad"></p>

<dt><a name="static_PMC*_find_vtable_meth_ns(Interp_*interp,_PMC_*ns,_INTVAL_vtable_index)"
><b><code lang='und' xml:lang='und'>static PMC *find_vtable_meth_ns(Interp *interp, PMC *ns, INTVAL vtable_index)</b></code></a></dt><p class="pad"></p>

<dd>Return sub PMC if a method with the vtable name exists in ns</dd><p class="pad"></p>

<dt><a name="PMC*_Parrot_find_vtable_meth(Interp*_interp,_PMC_*pmc,_STRING_*meth)"
><b><code lang='und' xml:lang='und'>PMC *Parrot_find_vtable_meth(Interp *interp, PMC *pmc, STRING *meth)</b></code></a></dt><p class="pad"></p>

<dd>Given pmc,
run through its mro looking for the meth vtable method Return the vtable method PMC if found</dd><p class="pad"></p>

<dt><a name="STRING*_readable_name(Interp_*interp,_PMC_*name)"
><b><code lang='und' xml:lang='und'>STRING *readable_name(Interp *interp, PMC *name)</b></code></a></dt><p class="pad"></p>

<dd>Given a String or Key PMC return the STRING* representation</dd><p class="pad"></p>

<dt><a name="_static_void_fail_if_exist(Interp_*interp,_PMC_*name)"
><b><code lang='und' xml:lang='und'> static void fail_if_exist(Interp *interp, PMC *name)</b></code></a></dt><p class="pad"></p>

<dd>Throws an exception if a PMC or class with the same name already exists.</dd><p class="pad"></p>

<dt><a name="static_void_create_deleg_pmc_vtable(Interp_*,_PMC_*_class,_PMC_*class_name,_int_full)"
><b><code lang='und' xml:lang='und'>static void create_deleg_pmc_vtable(Interp *, PMC *_class, PMC *class_name, int full)</b></code></a></dt><p class="pad"></p>

<dd>Create a vtable that dispatches either to the contained PMC in the first attribute (deleg_pmc) or to an overridden method (delegate),
depending on the existence of the method for this class.</dd><p class="pad"></p>

<dt><a name="const_char*_Parrot_MMD_method_name(Interp*,_INTVAL)"
><b><code lang='und' xml:lang='und'>const char *Parrot_MMD_method_name(Interp*, INTVAL)</b></code></a></dt><p class="pad"></p>

<dd>Return the method name for the given MMD enum.</dd><p class="pad"></p>

<dt><a name="INTVAL_Parrot_MMD_method_idx(Interp*,_STRING_*)"
><b><code lang='und' xml:lang='und'>INTVAL Parrot_MMD_method_idx(Interp*, STRING *)</b></code></a></dt><p class="pad"></p>

<dd>Return the MMD function number for method name or &#45;1 on failure.</dd><p class="pad"></p>

<dd>TODO allow dynamic expansion at runtime.</dd><p class="pad"></p>

<dt><a name="PMC_*_Parrot_single_subclass(Interp_*interp,_PMC_*base_class,_PMC_*child_class_name)"
><b><code lang='und' xml:lang='und'>PMC *Parrot_single_subclass(Interp *interp, PMC *base_class, PMC *child_class_name)</b></code></a></dt><p class="pad"></p>

<dd>Subclass a class.
Single parent class,
nice and straightforward.
If <code lang='und' xml:lang='und'>child_class</code> is <code lang='und' xml:lang='und'>NULL</code>,
this is an anonymous subclass we&#39;re creating,
function.</dd><p class="pad"></p>

<dt><a name="void_Parrot_new_class(Interp_*interp,_PMC_*_class,_PMC_*class_name)"
><b><code lang='und' xml:lang='und'>void Parrot_new_class(Interp *interp, PMC *_class, PMC *class_name)</b></code></a></dt><p class="pad"></p>

<dd>Creates a new class,
named <code lang='und' xml:lang='und'>class_name</code>.</dd><p class="pad"></p>

<dt><a name="PMC_*_Parrot_class_lookup(Interp_*interp,_STRING_*class_name)"
><b><code lang='und' xml:lang='und'>PMC *Parrot_class_lookup(Interp *interp, STRING *class_name)</b></code></a></dt><p class="pad"></p>

<dt><a name="PMC_*_Parrot_class_lookup_p(Interp_*interp,_PMC_*class_name)"
><b><code lang='und' xml:lang='und'>PMC *Parrot_class_lookup_p(Interp *interp, PMC *class_name)</b></code></a></dt><p class="pad"></p>

<dd>Looks for the class named <code lang='und' xml:lang='und'>class_name</code> and returns it if it exists.
Otherwise it returns <code lang='und' xml:lang='und'>PMCNULL</code>.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>static void parrot_class_register(Interp *interp, PMC *class_name, PMC *new_class, PMC *mro)</b></code></a></dt><p class="pad"></p>

<dd>This is the way to register a new Parrot class as an instantiable type.
Doing this involves putting it in the class hash,
setting its vtable so that the <code lang='und' xml:lang='und'>init</code> method initializes objects of the class rather than the class itself,
and adding it to the interpreter&#39;s base type table so you can create a new <code lang='und' xml:lang='und'>foo</code> in PASM like this: <code lang='und' xml:lang='und'>new Px, foo</code>.</dd><p class="pad"></p>

<dt><a name="void_Parrot_instantiate_object(Interp_*interp,_PMC_*object,_PMC_*init)"
><b><code lang='und' xml:lang='und'>void Parrot_instantiate_object(Interp *interp, PMC *object, PMC *init)</b></code></a></dt><p class="pad"></p>

<dd>Creates a Parrot object.
Takes a passed&#45;in class PMC that has sufficient information to describe the layout of the object and,
well,
makes the darned object.</dd><p class="pad"></p>

<dt><a name="PMC_*_Parrot_add_parent(Interp_*interp,_PMC_*_class,_PMC_*parent)"
><b><code lang='und' xml:lang='und'>PMC *Parrot_add_parent(Interp *interp, PMC *_class, PMC *parent)</b></code></a></dt><p class="pad"></p>

<dd>Add the parent class to the current class&#39; parent list.
This also involved adding all the parent&#39;s parents,
as well as all attributes of the parent classes that we&#39;re adding in.</dd><p class="pad"></p>

<dd>The MRO (method resolution order) is the C3 algorithm used by Perl6 and Python (&#62;= 2.3).
See also: <a href='http://pugs.blogs.com/pugs/2005/07/day_165_r5671_j.html'><a href="http://pugs.blogs.com/pugs/2005/07/day_165_r5671_j.html">http://pugs.blogs.com/pugs/2005/07/day_165_r5671_j.html</a></a></dd><p class="pad"></p>

<dt><a name="PMC_*_Parrot_remove_parent(Interp_*interp,_PMC_*removed_class,_PMC_*existing_class)"
><b><code lang='und' xml:lang='und'>PMC *Parrot_remove_parent(Interp *interp, PMC *removed_class, PMC *existing_class)</b></code></a></dt><p class="pad"></p>

<dd>This currently does nothing but return <code lang='und' xml:lang='und'>NULL</code>.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PMC *Parrot_multi_subclass(Interp *interp, PMC *base_class_array, STRING *child_class_name)</b></code></a></dt><p class="pad"></p>

<dd>This currently does nothing but return <code lang='und' xml:lang='und'>NULL</code>.</dd><p class="pad"></p>

<dt><a name="INTVAL_Parrot_object_isa(Interp_*interp,_PMC_*pmc,_PMC_*cl)"
><b><code lang='und' xml:lang='und'>INTVAL Parrot_object_isa(Interp *interp, PMC *pmc, PMC *cl)</b></code></a></dt><p class="pad"></p>

<dd>Return whether the object <code lang='und' xml:lang='und'>pmc</code> is an instance of class <code lang='und' xml:lang='und'>cl</code>.</dd><p class="pad"></p>

<dt><a name="PMC_*_Parrot_new_method_cache(Interp_*interp)"
><b><code lang='und' xml:lang='und'>PMC *Parrot_new_method_cache(Interp *interp)</b></code></a></dt><p class="pad"></p>

<dd>This should create and return a new method cache PMC.</dd><p class="pad"></p>

<dd>Currently it does nothing but return <code lang='und' xml:lang='und'>NULL</code>.</dd><p class="pad"></p>

<dt><a name="PMC_*_Parrot_find_method_with_cache(Interp_*interp,_PMC_*_class,_STRING_*method_name)"
><b><code lang='und' xml:lang='und'>PMC *Parrot_find_method_with_cache(Interp *interp, PMC *_class, STRING *method_name)</b></code></a></dt><p class="pad"></p>

<dd>Find a method PMC for a named method,
given the class PMC,
current interp,
and name of the method.</dd><p class="pad"></p>

<dd>This routine should use the current scope&#39;s method cache,
if there is one.
If not,
it creates a new method cache.
Or,
rather,
it will when we&#39;ve got that bit working.
For now it unconditionally goes and looks up the name in the global stash.</dd><p class="pad"></p>

<dt><a name="PMC_*_Parrot_find_method_direct(Interp_*interp,_PMC_*_class,_STRING_*method_name)"
><b><code lang='und' xml:lang='und'>PMC *Parrot_find_method_direct(Interp *interp, PMC *_class, STRING *method_name)</b></code></a></dt><p class="pad"></p>

<dd>Find a method PMC for a named method,
given the class PMC,
current interpreter,
and name of the method.
Don&#39;t use a possible method cache.</dd><p class="pad"></p>

<dt><a name="void_Parrot_invalidate_method_cache(Interp_*,_STRING_*_class)"
>void Parrot_invalidate_method_cache(Interp *,
STRING *_class)</a></dt><p class="pad"></p>

<dd>Clear method cache for the given class.
If class is NULL,
caches for all classes are invalidated.</dd><p class="pad"></p>

<dt><a name="void_Parrot_note_method_offset(Interp_*interp,_UINTVAL_offset,_PMC_*method)"
><b><code lang='und' xml:lang='und'>void Parrot_note_method_offset(Interp *interp, UINTVAL offset, PMC *method)</b></code></a></dt><p class="pad"></p>

<dd>Notes where in the hierarchy we just found a method.
Used so that we can do a next and continue the search through the hierarchy for the next instance of this method.</dd><p class="pad"></p>

<dd>*/ void Parrot_note_method_offset(Interp *interp,
UINTVAL offset,
PMC *method) { }</dd><p class="pad"></p>

<dd>/*</dd><p class="pad"></p>

<dt><a name="INTVAL_Parrot_add_attribute(Interp_*interp,_PMC*__class,_STRING*_attr)"
><b><code lang='und' xml:lang='und'>INTVAL Parrot_add_attribute(Interp *interp, PMC *_class, STRING *attr)</b></code></a></dt><p class="pad"></p>

<dd>Adds the attribute <code lang='und' xml:lang='und'>attr</code> to the class.</dd><p class="pad"></p>

<dt><a name="PMC_*_Parrot_get_attrib_by_num(Interp_*interp,_PMC_*object,_INTVAL_attrib)"
><b><code lang='und' xml:lang='und'>PMC *Parrot_get_attrib_by_num(Interp *interp, PMC *object, INTVAL attrib)</b></code></a></dt><p class="pad"></p>

<dd>Returns attribute number <code lang='und' xml:lang='und'>attrib</code> from <code lang='und' xml:lang='und'>object</code>.
Presumably the code is asking for the correct attribute number.</dd><p class="pad"></p>

<dt><a name="PMC_*_Parrot_get_attrib_by_str(Interp_*interp,_PMC_*object,_STRING_*attr)"
><b><code lang='und' xml:lang='und'>PMC *Parrot_get_attrib_by_str(Interp *interp, PMC *object, STRING *attr)</b></code></a></dt><p class="pad"></p>

<dd>Returns attribute with full qualified name <code lang='und' xml:lang='und'>attr</code> from <code lang='und' xml:lang='und'>object</code>.</dd><p class="pad"></p>

<dt><a name="PMC_*_Parrot_set_attrib_by_num(Interp_*interp,_PMC_*object,_INTVAL_attrib,_PMC_*value)"
><b><code lang='und' xml:lang='und'>PMC *Parrot_set_attrib_by_num(Interp *interp, PMC *object, INTVAL attrib, PMC *value)</b></code></a></dt><p class="pad"></p>

<dd>Set attribute number <code lang='und' xml:lang='und'>attrib</code> from <code lang='und' xml:lang='und'>object</code> to <code lang='und' xml:lang='und'>value</code>.
Presumably the code is asking for the correct attribute number.</dd><p class="pad"></p>

<dt><a name="PMC_*_Parrot_set_attrib_by_str(Interp_*interp,_PMC_*object,_STRING_*attr,_PMC_*value)"
><b><code lang='und' xml:lang='und'>PMC *Parrot_set_attrib_by_str(Interp *interp, PMC *object, STRING *attr, PMC *value)</b></code></a></dt><p class="pad"></p>

<dd>Sets attribute with full qualified name <code lang='und' xml:lang='und'>attr</code> from <code lang='und' xml:lang='und'>object</code> to <code lang='und' xml:lang='und'>value</code>.</dd><p class="pad"></p>

<dt><a name="PMC_*Parrot_find_class_constructor(Interp_*interp,_STRING_*_class,_INTVAL_classtoken)"
><b><code lang='und' xml:lang='und'>PMC *Parrot_find_class_constructor(Interp *interp, STRING *_class, INTVAL classtoken)</b></code></a></dt><p class="pad"></p>

<dd>Find and return the constructor method PMC for the named sub.
The classtoken is an identifier for the class used for fast lookup,
or 0 if you don&#39;t have an identifier token.
Which,
as they&#39;re currently undefined,
is pretty likely</dd><p class="pad"></p>

<dt><a name="PMC*_Parrot_ComputeMRO_C3(Interp_*interp,_PMC_*_class)"
><b><code lang='und' xml:lang='und'>PMC *Parrot_ComputeMRO_C3(Interp *interp, PMC *_class)</b></code></a></dt><p class="pad"></p>

<dd>Computes the C3 linearization for the given class.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>void Parrot_ComposeRole(Interp *interp, PMC *role, PMC *exclude, int got_exclude, PMC *alias, int got_alias, PMC *methods_hash, PMC *roles_list)</b></code></a></dt><p class="pad"></p>

<dd>Used by the Class and Object PMCs internally to compose a role into either of them.
The <code lang='und' xml:lang='und'>role</code> parameter is the role that we are composing into the class or role.
<code lang='und' xml:lang='und'>methods_hash</code> is the hash of method names to invokable PMCs that contains the methods the class or role has.
<code lang='und' xml:lang='und'>roles_list</code> is the list of roles the the class or method does.</dd><p class="pad"></p>

<dd>The <code lang='und' xml:lang='und'>role</code> parameter is only dealt with by its external interface.
Whether this routine is usable by any other object system implemented in Parrot very much depends on how closely the role composition semantics they want are to the default implementation.</dd><p class="pad"></p>
</dl>

<h1><a name="SEE_ALSO"
>SEE ALSO <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p><em lang='und' xml:lang='und'>include/parrot/objects.h</em>,
<em lang='und' xml:lang='und'><a href="../docs/pdds/pdd15_objects.pod.html">docs/pdds/pdd15_objects.pod</a></em>.</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
