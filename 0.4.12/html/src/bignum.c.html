<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>A decimal arithmetic library Parrot</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">A decimal arithmetic library Parrot</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../html/index.html">Contents</a> | <a href="../../html/bignum.html">Big Number Arithmetic</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>src/bignum.c &#45; A decimal arithmetic library Parrot</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>This code is intended for inclusion in the parrot project,
and also for backporting into Perl5 (as a CPAN module).
Any patches to this code will likely find their way back to the Mother Ship,
as it were.</p>

<p>There is a good deal of scope for improving the speed of this code,
modifications are encouraged as long as the extended regression tests continue to pass.
Alex Gough,
2002</p>

<p><i>It was a very inconvenient habit of kittens (Alice had once made the remark) that,
whatever you say to them,
they always purr.
&#34;If they would only purr for `yes,&#39; and mew for `no,&#39; or any rule of that sort,&#34; she had said,
&#34;so that one could keep up a conversation!
But how can you talk with a person if they always say the same thing?&#34;</i></p>

<p><i>On this occasion the kitten only purred: and it was impossible to guess whether it meant `yes&#39; or `no&#39;.</i></p>

<h2><a name="When_in_parrot"
>When in parrot <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>When the library is used within parrot,
all calls expect an additional first argument of an interpreter,
for the purposes of memory allocation,
some internal macros do not (getd/setd and CHECK(O|U)FLOW.</p>

<p>If you&#39;re being useful and inserting proper rapid fillins,
start with the <code lang='und' xml:lang='und'>BN_i*</code> methods,
but make sure any errors can still be thrown.</p>

<h2><a name="Macros"
>Macros <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Access digits,
macros assume length given.</p>

<dl>
<dt><a name="BN_setd(BIGNUM*,_pos,_value)"
><b><code lang='und' xml:lang='und'>BN_setd(BIGNUM*, pos, value)</b></code></a></dt><p class="pad"></p>

<dd>Set digit at <code lang='und' xml:lang='und'>pos</code> (zero is lsd) to <code lang='und' xml:lang='und'>value</code>.</dd><p class="pad"></p>

<dt><a name="int_BN_getd(BIGNUM*,_pos)"
><b><code lang='und' xml:lang='und'>int BN_getd(BIGNUM*, pos)</b></code></a></dt><p class="pad"></p>

<dd>Get value of digit at <code lang='und' xml:lang='und'>pos</code>.</dd><p class="pad"></p>

<dt><a name="CHECK_OVERFLOW(bn,_incr,_context)"
><b><code lang='und' xml:lang='und'>CHECK_OVERFLOW(bn, incr, context)</b></code></a></dt><p class="pad"></p>

<dd>If increasing the exponent of <code lang='und' xml:lang='und'>bn</code> by <code lang='und' xml:lang='und'>incr</code> will cause overflow (as decided by <code lang='und' xml:lang='und'>elimit</code>),
returns true.</dd><p class="pad"></p>

<dt><a name="CHECK_UNDERFLOW(bn,_decrement,_context)"
><b><code lang='und' xml:lang='und'>CHECK_UNDERFLOW(bn, decrement, context)</b></code></a></dt><p class="pad"></p>

<dd>If subtracting <code lang='und' xml:lang='und'>decrement</code> (a positive number) from the exponent of <code lang='und' xml:lang='und'>bn</code> would cause underflow,
returns true.</dd><p class="pad"></p>
</dl>

<p>Special Values</p>

<dl>
<dt><a name="am_INF(bn)"
><b><code lang='und' xml:lang='und'>am_INF(bn)</b></code></a></dt><p class="pad"></p>

<dd>True if <code lang='und' xml:lang='und'>bn</code> is +Infinity or &#45;Infinity.</dd><p class="pad"></p>

<dt><a name="am_NAN(bn)"
><b><code lang='und' xml:lang='und'>am_NAN(bn)</b></code></a></dt><p class="pad"></p>

<dd>True if <code lang='und' xml:lang='und'>bn</code> is either a quiet or signalling NaN.</dd><p class="pad"></p>

<dt><a name="am_sNAN(bn)"
><b><code lang='und' xml:lang='und'>am_sNAN(bn)</b></code></a></dt><p class="pad"></p>

<dd>True if <code lang='und' xml:lang='und'>bn</code> is a signalling NaN.</dd><p class="pad"></p>

<dt><a name="am_qNAN(bn)"
><b><code lang='und' xml:lang='und'>am_qNAN(bn)</b></code></a></dt><p class="pad"></p>

<dd>True if <code lang='und' xml:lang='und'>bn</code> is a quiet NaN.</dd><p class="pad"></p>
</dl>

<h2><a name="Creation_and_Memory_Management_Functions"
>Creation and Memory Management Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="BIGNUM*_BN_new(PINTD__INTVAL_length)"
><b><code lang='und' xml:lang='und'>BIGNUM *BN_new(PINTD_ INTVAL length)</b></code></a></dt><p class="pad"></p>

<dd>Create a new <code lang='und' xml:lang='und'>BIGNUM</code>.
<code lang='und' xml:lang='und'>length</code> is number of <i>decimal</i> digits required.
The bignumber will be equal to zero.</dd><p class="pad"></p>

<dt><a name="void_BN_grow(PINTD__BIGNUM_*in,_INTVAL_length)"
><b><code lang='und' xml:lang='und'>void BN_grow(PINTD_ BIGNUM *in, INTVAL length)</b></code></a></dt><p class="pad"></p>

<dd>Grows bn so that it can contain <code lang='und' xml:lang='und'>length</code> <i>decimal</i> digits,
does not modify the value of the bignumber.</dd><p class="pad"></p>

<dt><a name="void_BN_destroy(PINTD__BIGNUM_*bn)"
><b><code lang='und' xml:lang='und'>void BN_destroy(PINTD_ BIGNUM *bn)</b></code></a></dt><p class="pad"></p>

<dd>Frees all the memory used by the BIGNUM.</dd><p class="pad"></p>

<dt><a name="BN_CONTEXT*_BN_create_context(PINTD__INTVAL_precision)"
><b><code lang='und' xml:lang='und'>BN_CONTEXT *BN_create_context(PINTD_ INTVAL precision)</b></code></a></dt><p class="pad"></p>

<dd>Creates a new context object,
with specified <i>precision</i>,
other fields are initialised as follows:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'> elimit   = BN_HARD_EXPN_LIMIT (defined during configure)
 rounding = ROUND_HALF_UP
 extended = 1
 flags    = 0
 traps    = Division by zero, invalid operation, overflow, underflow
            and rounded are enabled.
            Lost digits and inexact are disabled.</pre>

<dd>The context object can be destroyed with <code lang='und' xml:lang='und'>free()</code>.</dd><p class="pad"></p>

<dt><a name="INTVAL_BN_set_digit(PINT__BIGNUM*_bn,_INTVAL_pos,_INTVAL_value)"
><b><code lang='und' xml:lang='und'>INTVAL BN_set_digit(PINT_ BIGNUM *bn, INTVAL pos, INTVAL value)</b></code></a></dt><p class="pad"></p>

<dd>Sets digit at <code lang='und' xml:lang='und'>pos</code> (zero based) to <code lang='und' xml:lang='und'>value</code>. Number is grown if digits &#62; allocated space are accessed, but intermediate digits will have undefined values. If <code lang='und' xml:lang='und'>pos</code> is beyond <code lang='und' xml:lang='und'>digits</code> then <code lang='und' xml:lang='und'>digits</code> is also updated.</dd><p class="pad"></p>

<dt><a name="INTVAL_BN_get_digit(PINTD__BIGNUM*_bn,_INTVAL_pos)"
><b><code lang='und' xml:lang='und'>INTVAL BN_get_digit(PINTD_ BIGNUM *bn, INTVAL pos)</b></code></a></dt><p class="pad"></p>

<dd>Get the value of the decimal digit at <code lang='und' xml:lang='und'>pos</code>, returns &#45;1 if <code lang='und' xml:lang='und'>pos</code> is out of bounds.</dd><p class="pad"></p>

<dt><a name="int_BN_set_inf(PINTD__BIGNUM*_bn)"
><b><code lang='und' xml:lang='und'>int BN_set_inf(PINTD_ BIGNUM *bn)</b></code></a></dt><p class="pad"></p>

<dt><a name="int_BN_set_qNAN(PINTD__BIGNUM*_bn)"
><b><code lang='und' xml:lang='und'>int BN_set_qNAN(PINTD_ BIGNUM *bn)</b></code></a></dt><p class="pad"></p>

<dt><a name="int_BN_set_sNAN(PINTD__BIGNUM*_bn)"
><b><code lang='und' xml:lang='und'>int BN_set_sNAN(PINTD_ BIGNUM *bn)</b></code></a></dt><p class="pad"></p>

<dd>Sets its argument to appropriate value.</dd><p class="pad"></p>

<dd>Infinity is represented as having zero digits, an undefined exponent and private <code lang='und' xml:lang='und'>flags</code> set to <code lang='und' xml:lang='und'>BN_inf_FLAGS</code>.</dd><p class="pad"></p>

<dd>sNAN is represented as having zero digits, an undefined exponent, an undefined sign and both qNAN and sNAN bits set.</dd><p class="pad"></p>

<dd>qNAN is represented as having zero digits, an undefined exponent and only the qNAN bit set.</dd><p class="pad"></p>

<dt><a name="int_BN_set_verybig(PINTD__BIGNUM*_bn,_BN_CONTEXT_*context)"
><b><code lang='und' xml:lang='und'>int BN_set_verybig(PINTD_ BIGNUM *bn, BN_CONTEXT *context)</b></code></a></dt><p class="pad"></p>

<dd>Used when an operation has overflowed, sets <code lang='und' xml:lang='und'>bn</code> according to <code lang='und' xml:lang='und'>context&#45;&#62;rounding</code> and the sign of <code lang='und' xml:lang='und'>bn</code>:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'> ROUND_HALF_UP, ROUND_HALF_EVEN =&#62; sign Infinity
 ROUND_DOWN =&#62; sign, largest finite number in given precision (or Inf, if
                 infinite precision is specified)
 ROUND_CEILING =&#62; same as round down, if sign is 1, +Inf otherwise
 ROUND_FLOOR =&#62; same as round down, if sign is 0, &#45;Inf otherwise</pre>

<dt><a name="BIGNUM*_BN_copy(PINTD__BIGNUM*_one,_BIGNUM*_two)"
><b><code lang='und' xml:lang='und'>BIGNUM *BN_copy(PINTD_ BIGNUM *one, BIGNUM *two)</b></code></a></dt><p class="pad"></p>

<dd>Copies two into one, returning one for convenience.</dd><p class="pad"></p>

<dt><a name="BIGNUM*_BN_new_from_int(PINTD__INTVAL_value)"
><b><code lang='und' xml:lang='und'>BIGNUM *BN_new_from_int(PINTD_ INTVAL value)</b></code></a></dt><p class="pad"></p>

<dd>Create a new bignum from a (signed) integer value (<code lang='und' xml:lang='und'>INTVAL</code>) We assume that the implementation limits are somewhat larger than those required to store a single integer into a bignum.</dd><p class="pad"></p>

<dt><a name="void_BN_PRINT_DEBUG(BIGNUM_*bn,_char*_mesg)"
><b><code lang='und' xml:lang='und'>void BN_PRINT_DEBUG(BIGNUM *bn, char *mesg)</b></code></a></dt><p class="pad"></p>

<dd>Dump the bignum for testing, along with a little message.</dd><p class="pad"></p>

<dt><a name="INTVAL_BN_nonfatal(PINTD__BN_CONTEXT_*context,_BN_EXCEPTIONS_except,_char_*msg)"
><b><code lang='und' xml:lang='und'>INTVAL BN_nonfatal(PINTD_ BN_CONTEXT *context, BN_EXCEPTIONS except, char *msg)</b></code></a></dt><p class="pad"></p>

<dd>When an exceptional condition occurs after which execution could continue. If context specifies that death occurs, then so be it.</dd><p class="pad"></p>

<dt><a name="void_BN_exception(PINTD__BN_EXCEPTIONS_exception,_const_char*_message)"
><b><code lang='und' xml:lang='und'>void BN_exception(PINTD_ BN_EXCEPTIONS exception, const char *message)</b></code></a></dt><p class="pad"></p>

<dd>Throw `exception&#39;. Should be accessed via a <code lang='und' xml:lang='und'>BN_EXCEPT</code> macro, this version is provided until Parrot exceptions are sorted out properly.</dd><p class="pad"></p>

<dt><a name="INTVAL_BN_to_scientific_string(PINTD__BIGNUM*bn,_char_**dest)"
><b><code lang='und' xml:lang='und'>INTVAL BN_to_scientific_string(PINTD_ BIGNUM*bn, char **dest)</b></code></a></dt><p class="pad"></p>

<dd>Converts bn into a scientific representation, stored in dest.</dd><p class="pad"></p>

<dt><a name="INTVAL_BN_to_engineering_string(PINTD__BIGNUM*bn,_char_**dest)"
><b><code lang='und' xml:lang='und'>INTVAL BN_to_engineering_string(PINTD_ BIGNUM*bn, char **dest)</b></code></a></dt><p class="pad"></p>

<dd>Converts <code lang='und' xml:lang='und'>*bn</code> into a engineering representation, stored in <code lang='und' xml:lang='und'>**dest</code>.</dd><p class="pad"></p>

<dd>These functions return <code lang='und' xml:lang='und'>char*</code> strings only, parrot may want to reimplement these so that locales and the like are nicely coped with.</dd><p class="pad"></p>

<dd>Any reimplementation should be in a seperate file, this section of the main file can be <code lang='und' xml:lang='und'>#ifdef</code>ed out if this is done.</dd><p class="pad"></p>

<dd>Memory pointed to by <code lang='und' xml:lang='und'>dest</code> is not freed by this function.</dd><p class="pad"></p>

<dt><a name="INTVAL_BN_to_scieng_string(PINTD__BIGNUM*_bn,_char_**dest,_int_eng)"
><b><code lang='und' xml:lang='und'>INTVAL BN_to_scieng_string(PINTD_ BIGNUM *bn, char **dest, int eng)</b></code></a></dt><p class="pad"></p>

<dd>Does the heavy string handling work, <code lang='und' xml:lang='und'>eng</code> defines the conversion to perform.</dd><p class="pad"></p>

<dt><a name="BIGNUM*_BN_from_string(PINTD__char*_s2,_BN_CONTEXT_*context)"
><b><code lang='und' xml:lang='und'>BIGNUM *BN_from_string(PINTD_ char *s2, BN_CONTEXT *context)</b></code></a></dt><p class="pad"></p>

<dd>Convert a scientific string to a BIGNUM. This function deals entirely with common&#45;or&#45;garden C byte strings, so the library can work anywhere. Another version will be eventually required to cope with the parrot string fun.</dd><p class="pad"></p>

<dd>This is the Highly Pedantic string conversion. If <code lang='und' xml:lang='und'>context</code> has <code lang='und' xml:lang='und'>extended</code> as a true value, then the full range of extended number is made available, and any string which does not match the numeric syntax is converted to a quiet NaN.</dd><p class="pad"></p>

<dd>Does not yet check for exponent overflow.</dd><p class="pad"></p>

<dt><a name="int_BN_strip_lead_zeros(PINTD__BIGNUM*_bn,_BN_CONTEXT_*context)"
><b><code lang='und' xml:lang='und'>int BN_strip_lead_zeros(PINTD_ BIGNUM *bn, BN_CONTEXT *context)</b></code></a></dt><p class="pad"></p>

<dd>Removes any zeros before the msd and after the lsd.</dd><p class="pad"></p>

<dt><a name="int_BN_strip_tail_zeros(PINTD__BIGNUM_*bn,_BN_CONTEXT_*context)"
><b><code lang='und' xml:lang='und'>int BN_strip_tail_zeros(PINTD_ BIGNUM *bn, BN_CONTEXT *context)</b></code></a></dt><p class="pad"></p>

<dd>Removes trailing zeros and increases the exponent appropriately. Does not remove zeros before the decimal point.</dd><p class="pad"></p>

<dt><a name="int_BN_make_integer(PINTD__BIGNUM*_bn,_BN_CONTEXT*_context)"
><b><code lang='und' xml:lang='und'>int BN_make_integer(PINTD_ BIGNUM *bn, BN_CONTEXT *context)</b></code></a></dt><p class="pad"></p>

<dd>Convert the number to a plain integer <i>if</i> precision such that this is possible.</dd><p class="pad"></p>

<dt><a name="int_BN_really_zero(PINTD__BIGNUM*_bn,_int_allow_neg_zero)"
><b><code lang='und' xml:lang='und'>int BN_really_zero(PINTD_ BIGNUM *bn, int allow_neg_zero)</b></code></a></dt><p class="pad"></p>

<dd>Sets any number which should be zero to a canonical zero.</dd><p class="pad"></p>

<dd>To check if a number is equal to zero, use <code lang='und' xml:lang='und'>BN_is_zero()</code>.</dd><p class="pad"></p>

<dt><a name="void_BN_round(PINTD__BIGNUM_*bn,_BN_CONTEXT*_context)"
><b><code lang='und' xml:lang='und'>void BN_round(PINTD_ BIGNUM *bn, BN_CONTEXT *context)</b></code></a></dt><p class="pad"></p>

<dd>Rounds <code lang='und' xml:lang='und'>*bn</code> according to <code lang='und' xml:lang='und'>*context</code>.</dd><p class="pad"></p>

<dt><a name="int_BN_iround(PINTD__BIGNUM_*bn,_BN_CONTEXT*_context)"
><b><code lang='und' xml:lang='und'>int BN_iround(PINTD_ BIGNUM *bn, BN_CONTEXT *context)</b></code></a></dt><p class="pad"></p>

<dd>Rounds victim according to context.</dd><p class="pad"></p>

<dd>Round assumes that any leading zeros are significant (after an addition operation, for instance).</dd><p class="pad"></p>

<dd>If <code lang='und' xml:lang='und'>precision</code> is positive, the digit string is rounded to have no more than <code lang='und' xml:lang='und'>precision</code> digits. If <code lang='und' xml:lang='und'>precision</code> is equal to zero, the number is treated as an integer, and any digits after the number&#39;s decimal point are removed. If <code lang='und' xml:lang='und'>precision</code> is negative, the number is rounded so that there are no more than &#45; <code lang='und' xml:lang='und'>precision</code> digits after the decimal point.</dd><p class="pad"></p>

<dd>eg. for 1.234567E+3 with rounding of <code lang='und' xml:lang='und'>ROUND_DOWN</code></dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    precision:  4 =&#62;  1.234E+3      1234
    precision:  6 =&#62;  1.234567E+3   1234.56
    precision:  9 =&#62;  1.234567E+3   1234.567
    precision:  0 =&#62;  1234          1234
    precision: &#45;1 =&#62;  1.2345E+3     1234.5
    precision: &#45;9 =&#62;  1.234567E+3   1234.567</pre>

<dt><a name="int_BN_round_up(PINTD__BIGNUM_*bn,_BN_CONTEXT*_context)"
><b><code lang='und' xml:lang='und'>int BN_round_up(PINTD_ BIGNUM *bn, BN_CONTEXT *context)</b></code></a></dt><p class="pad"></p>

<dd>Truncates coefficient of <code lang='und' xml:lang='und'>bn</code> to have <code lang='und' xml:lang='und'>precision</code> digits, then adds 1 to the last digits and carries until done. Do not call this function with non&#45;positive values of <code lang='und' xml:lang='und'>precision</code>.</dd><p class="pad"></p>

<dt><a name="int_BN_round_down(PINT__BIGNUM_*bn,_BN_CONTEXT*_context)"
><b><code lang='und' xml:lang='und'>int BN_round_down(PINT_ BIGNUM *bn, BN_CONTEXT *context)</b></code></a></dt><p class="pad"></p>

<dd>Truncates the coefficient of <code lang='und' xml:lang='und'>bn</code> to have <code lang='und' xml:lang='und'>precision</code> digits. Do not call this function with non&#45;positive precision.</dd><p class="pad"></p>

<dt><a name="void_BN_round_as_integer(PINTD__BIGNUM_*bn,_BN_CONTEXT_*context)"
><b><code lang='und' xml:lang='und'>void BN_round_as_integer(PINTD_ BIGNUM *bn, BN_CONTEXT *context)</b></code></a></dt><p class="pad"></p>

<dd><code lang='und' xml:lang='und'>precision</code> must be less than one. This rounds so that <code lang='und' xml:lang='und'>expn</code> is at least <code lang='und' xml:lang='und'>precision</code>. Name is slightly misleading.</dd><p class="pad"></p>
</dl>

<h2><a name="Arithmetic_operations"
>Arithmetic operations <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Operations are performed like this:</p>

<dl>
<dt><a name="Rounding"
>Rounding</a></dt><p class="pad"></p>

<dd>Both operands are rounded to have no more than <code lang='und' xml:lang='und'>context&#45;&#62;precision</code> digits.</dd><p class="pad"></p>

<dt><a name="Computation"
>Computation</a></dt><p class="pad"></p>

<dd>The operation is computed.</dd><p class="pad"></p>

<dt><a name="Rounding_of_result"
>Rounding of result</a></dt><p class="pad"></p>

<dd>The result is then rounded to context&#45;&#62;precision digits.</dd><p class="pad"></p>

<dt><a name="Conversion_to_zero_and_integerisation"
>Conversion to zero and integerisation</a></dt><p class="pad"></p>

<dd>If the result is equal to zero, it is made exactly zero.</dd><p class="pad"></p>

<dd>Where the length of the coefficient + the exponent of the result is less than context&#45;&#62;precision, the result is converted into an integer.</dd><p class="pad"></p>
</dl>

<p>The general form for all arithmetic operations is:</p>

<pre lang='und' xml:lang='und'>    void BN_operation(result, one, two, context)</pre>

<dl>
<dt><a
><b><code lang='und' xml:lang='und'>int BN_arith_setup(PINTD_ BIGNUM *result, BIGNUM *one, BIGNUM *two, BN_CONTEXT *context, BN_SAVE_PREC *restore)</b></code></a></dt><p class="pad"></p>

<dd>Rounds one and two ready for arithmetic operation.</dd><p class="pad"></p>

<dd>We assume that an operation might extend the digit buffer with zeros on either side, but not tamper with the actual digits of the number, we can then easily return the number to the correct (but still rounded) representation in _cleanup later</dd><p class="pad"></p>

<dd>If you can promise that you will not modify the representation of one and two during your operation, then you may pass <code lang='und' xml:lang='und'>&#38;restore</code> as a <code lang='und' xml:lang='und'>NULL</code> pointer to both setup and cleanup.</dd><p class="pad"></p>

<dd>If overflow or underflow occurs during rounding, the numbers will be modified to the appropriate representation and will not be restorable.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>int BN_arith_cleanup(PINTD_ BIGNUM *result, BIGNUM *one, BIGNUM *two, BN_CONTEXT *context, BN_SAVE_PREC *restore)</b></code></a></dt><p class="pad"></p>

<dd>Rounds <code lang='und' xml:lang='und'>result</code>, <code lang='und' xml:lang='und'>one</code>, <code lang='und' xml:lang='und'>two</code>, checks for zeroness and makes integers. Fixes <code lang='und' xml:lang='und'>one</code> and <code lang='und' xml:lang='und'>two</code> so they don&#39;t gain precision by mistake.</dd><p class="pad"></p>

<dt><a name="int_BN_align(PINTD__BIGNUM*_one,_BIGNUM*_two)"
><b><code lang='und' xml:lang='und'>int BN_align(PINTD_ BIGNUM *one, BIGNUM *two)</b></code></a></dt><p class="pad"></p>

<dd>Adds zero digits so that decimal points of each number are at the same place.</dd><p class="pad"></p>

<dt><a name="void_BN_add(PINTD__BIGNUM*_result,_BIGNUM_*one,_BIGNUM_*two,_BN_CONTEXT_*context)"
><b><code lang='und' xml:lang='und'>void BN_add(PINTD_ BIGNUM *result, BIGNUM *one, BIGNUM *two, BN_CONTEXT *context)</b></code></a></dt><p class="pad"></p>

<dd>Adds one to two, returning value in result.</dd><p class="pad"></p>

<dt><a name="int_BN_iadd(PINTD__BIGNUM*_result,_BIGNUM_*one,_BIGNUM_*two,_BN_CONTEXT_*context)"
><b><code lang='und' xml:lang='und'>int BN_iadd(PINTD_ BIGNUM *result, BIGNUM *one, BIGNUM *two, BN_CONTEXT *context)</b></code></a></dt><p class="pad"></p>

<dd>Adds together two aligned big numbers with coefficients of equal length. Returns a result without reference to the signs of its arguments. Cannot cope with special values.</dd><p class="pad"></p>

<dt><a name="void_BN_subtract(PINTD__BIGNUM*_result,_BIGNUM_*one,_BIGNUM_*two,_BN_CONTEXT_*context)"
><b><code lang='und' xml:lang='und'>void BN_subtract(PINTD_ BIGNUM *result, BIGNUM *one, BIGNUM *two, BN_CONTEXT *context)</b></code></a></dt><p class="pad"></p>

<dd>Subtracts <code lang='und' xml:lang='und'>*two</code> from <code lang='und' xml:lang='und'>*one</code>, returning value in <code lang='und' xml:lang='und'>*result</code>.</dd><p class="pad"></p>

<dt><a name="int_BN_isubtract(PINTD__BIGNUM*_result,_BIGNUM_*one,_BIGNUM_*two,_BN_CONTEXT_*context)"
><b><code lang='und' xml:lang='und'>int BN_isubtract(PINTD_ BIGNUM *result, BIGNUM *one, BIGNUM *two, BN_CONTEXT *context)</b></code></a></dt><p class="pad"></p>

<dd>Subtracts two from one, assumes both numbers have positive aligned coefficients of equal length. Sets sign of result as appropriate. Cannot cope with special values.</dd><p class="pad"></p>

<dt><a name="void_BN_plus(PINTD__BIGNUM*_result,_BIGNUM_*one,_BN_CONTEXT_*context)"
><b><code lang='und' xml:lang='und'>void BN_plus(PINTD_ BIGNUM *result, BIGNUM *one, BN_CONTEXT *context)</b></code></a></dt><p class="pad"></p>

<dd>Perform unary <code lang='und' xml:lang='und'>+</code> on <code lang='und' xml:lang='und'>*one</code>. Does all the rounding and what have you.</dd><p class="pad"></p>

<dt><a name="void_BN_minus(PINTD__BIGNUM*_result,_BIGNUM_*one,_BN_CONTEXT_*context)"
><b><code lang='und' xml:lang='und'>void BN_minus(PINTD_ BIGNUM *result, BIGNUM *one, BN_CONTEXT *context)</b></code></a></dt><p class="pad"></p>

<dd>Perform unary <code lang='und' xml:lang='und'>&#45;</code> (minus) on <code lang='und' xml:lang='und'>*one</code>. Does all the rounding and what have you.</dd><p class="pad"></p>

<dt><a name="void_BN_compare(PINT__BIGNUM*_result,_BIGNUM_*one,_BIGNUM_*two,_BN_CONTEXT_*context)"
><b><code lang='und' xml:lang='und'>void BN_compare(PINT_ BIGNUM *result, BIGNUM *one, BIGNUM *two, BN_CONTEXT *context)</b></code></a></dt><p class="pad"></p>

<dd>Numerically compares <code lang='und' xml:lang='und'>*one</code> and <code lang='und' xml:lang='und'>*two</code>, storing the result (as a BIGNUM) in <code lang='und' xml:lang='und'>*result</code>.</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    result = 1  =&#62; one &#62; two
    result = &#45;1 =&#62; two &#62; one
    result = 0  =&#62; one == two</pre>

<dt><a name="void_BN_multiply(PINTD__BIGNUM*_result,_BIGNUM_*one,_BIGNUM_*two,_BN_CONTEXT_*context)"
><b><code lang='und' xml:lang='und'>void BN_multiply(PINTD_ BIGNUM *result, BIGNUM *one, BIGNUM *two, BN_CONTEXT *context)</b></code></a></dt><p class="pad"></p>

<dd>Multiplies <code lang='und' xml:lang='und'>*one</code> and <code lang='und' xml:lang='und'>*two</code>, storing the result in <code lang='und' xml:lang='und'>*result</code>.</dd><p class="pad"></p>

<dt><a name="int_BN_imultiply(PINTD__BIGNUM*_result,_BIGNUM_*one,_BIGNUM_*two,_BN_CONTEXT_*context)"
><b><code lang='und' xml:lang='und'>int BN_imultiply(PINTD_ BIGNUM *result, BIGNUM *one, BIGNUM *two, BN_CONTEXT *context)</b></code></a></dt><p class="pad"></p>

<dd>Multiplication without the rounding and other set up.</dd><p class="pad"></p>

<dt><a name="void_BN_divide(PINTD__BIGNUM*_result,_BIGNUM_*one,_BIGNUM_*two,_BN_CONTEXT_*context)"
><b><code lang='und' xml:lang='und'>void BN_divide(PINTD_ BIGNUM *result, BIGNUM *one, BIGNUM *two, BN_CONTEXT *context)</b></code></a></dt><p class="pad"></p>

<dd>Divide two into one, storing up to <code lang='und' xml:lang='und'>precision</code> digits in result. Performs own rounding. We also assume that this function <b>will not be used</b> to produce a BigInt. That is the job of <code lang='und' xml:lang='und'>divide_integer()</code>.</dd><p class="pad"></p>

<dd>If you want to divide two integers to produce a float, you must do so with <code lang='und' xml:lang='und'>precision</code> greater than the number of significant digits in either operand. If you want the result to be an integer or a numer with a fixed fractional part</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>void BN_divide_integer(PINTD_ BIGNUM *result, BIGNUM *one, BIGNUM *two, BN_CONTEXT *context)</b></code></a></dt><p class="pad"></p>

<dd>Places the integer part of <code lang='und' xml:lang='und'>*one</code> divided by <code lang='und' xml:lang='und'>*two</code> into <code lang='und' xml:lang='und'>*result</code>.</dd><p class="pad"></p>

<dt><a name="void_BN_remainder(PINTD__BIGNUM*_result,_BIGNUM_*one,_BIGNUM_*two,_BN_CONTEXT_*context)"
><b><code lang='und' xml:lang='und'>void BN_remainder(PINTD_ BIGNUM *result, BIGNUM *one, BIGNUM *two, BN_CONTEXT *context)</b></code></a></dt><p class="pad"></p>

<dd>Places the remainder from divide&#45;integer (above) into <code lang='und' xml:lang='und'>*result</code>.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>BN_idivide(PINT_ BIGNUM *result, BIGNUM *one, BIGNUM *two, BN_CONTEXT *context, BN_DIV_ENUM operation, BIGNUM *rem)</b></code></a></dt><p class="pad"></p>

<dd>Does the heavy work for the various division wossnames.</dd><p class="pad"></p>

<dt><a name="INTVAL_BN_comp(PINTD__BIGNUM_*one,_BIGNUM_*two,_BN_CONTEXT*_context)"
><b><code lang='und' xml:lang='und'>INTVAL BN_comp(PINTD_ BIGNUM *one, BIGNUM *two, BN_CONTEXT *context)</b></code></a></dt><p class="pad"></p>

<dd>Comparison with no rounding etc.</dd><p class="pad"></p>

<dt><a name="void_BN_power(PINTD__BIGNUM*_result,_BIGNUM*_bignum,_BIGNUM*_expn,_BN_CONTEXT*_context)"
><b><code lang='und' xml:lang='und'>void BN_power(PINTD_ BIGNUM *result, BIGNUM *bignum, BIGNUM *expn, BN_CONTEXT *context)</b></code></a></dt><p class="pad"></p>

<dd>Calculate <code lang='und' xml:lang='und'>result</code> = <code lang='und' xml:lang='und'>bignum</code> to the power of <code lang='und' xml:lang='und'>*expn</code>;</dd><p class="pad"></p>

<dt><a name="void_BN_rescale(PINTD__BIGNUM*_result,_BIGNUM*_one,_BIGNUM*_two,_BN_CONTEXT*_context)"
><b><code lang='und' xml:lang='und'>void BN_rescale(PINTD_ BIGNUM *result, BIGNUM *one, BIGNUM *two, BN_CONTEXT *context)</b></code></a></dt><p class="pad"></p>

<dd>Rescales <code lang='und' xml:lang='und'>*one</code> to have an exponent of <code lang='und' xml:lang='und'>*two</code>.</dd><p class="pad"></p>

<dt><a name="INTVAL_BN_to_int(PINT__BIGNUM*_bn,_BN_CONTEXT*_context)"
><b><code lang='und' xml:lang='und'>INTVAL BN_to_int(PINT_ BIGNUM *bn, BN_CONTEXT *context)</b></code></a></dt><p class="pad"></p>

<dd>Converts the bignum into an integer, raises overflow if an exact representation cannot be created.</dd><p class="pad"></p>

<dt><a name="INTVAL_BN_is_zero(BIGNUM*_foo,_BN_CONTEXT*_context)"
><b><code lang='und' xml:lang='und'>INTVAL BN_is_zero(BIGNUM *foo, BN_CONTEXT *context)</b></code></a></dt><p class="pad"></p>

<dd>Returns a boolean value indicating whether <code lang='und' xml:lang='und'>*foo</code> is zero.</dd><p class="pad"></p>
</dl>

<h1><a name="TODO"
>TODO <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>This is currently not used yet. Parrot has no BigNum support yet.</p>

<p>Parrot string playing, exception raising</p>

<p>==head1 SEE ALSO</p>

<p><em lang='und' xml:lang='und'>docs/docs/pdds/draft/pdd14_bignum.pod</em>, <a href='https://rt.perl.org/rt3/Ticket/Display.html?id=36330'>https://rt.perl.org/rt3/Ticket/Display.html?id=36330</a></p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
