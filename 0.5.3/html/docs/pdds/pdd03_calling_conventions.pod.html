<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
    <HEAD>
        <TITLE>Parrot Calling Conventions</TITLE>
        <LINK REL="stylesheet" TYPE="text/css"
            HREF="../../../resources/perl.css"
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY>
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Parrot Calling Conventions</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../html/index.html">Contents</a> | <a href="../../../html/docs.html">Documentation</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>docs/pdds/pdd03_calling_conventions.pod &#45; Parrot Calling Conventions</p>

<h1><a name="ABSTRACT"
>ABSTRACT <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Parrot&#39;s inter&#45;routine calling conventions.</p>

<h1><a name="VERSION"
>VERSION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>$Revision$</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>This document describes how to pass arguments from registers to subroutines,
and how subroutines can extract their parameters into registers for use.</p>

<p>Since Parrot&#39;s calling conventions are continuation&#45;based,
there is arguably very little difference between a call and a return.
Because of this,
the conversion rules are the same regardless of whether code is invoking a subroutine or a return continuation.</p>

<h2><a name="Common_Features_of_Argument/Return_Opcodes"
>Common Features of Argument/Return Opcodes <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>There are four opcodes involved in parameter and return value propagation:</p>

<ul>
<li><code lang='und' xml:lang='und'>set_args</code>,
for passing arguments;</li><p class="pad"></p>

<li><code lang='und' xml:lang='und'>set_returns</code>,
for returning values;</li><p class="pad"></p>

<li><code lang='und' xml:lang='und'>get_params</code>,
for accepting parameters; and</li><p class="pad"></p>

<li><code lang='und' xml:lang='und'>get_results</code>,
for accepting return values.</li><p class="pad"></p>
</ul>

<p>FAQ: Given Parrot&#39;s internal use of continuation&#45;passing style [&#34;CPS&#34;],
it would be possible to use one pair of opcodes for both call and return,
since under CPS returns <i>are</i> calls.
And perhaps someday we will have only two opcodes.
But for now,
certain efficiency hacks are easier with four opcodes.)</p>

<p>The common syntax of these opcodes is:</p>

<pre lang='und' xml:lang='und'> &#60;set_opcode&#62; &#34;flags0, flags1, ..., flagsN&#34;, VAL0, VAL1, ... VALN
 &#60;get_opcode&#62; &#34;flags0, flags1, ..., flagsN&#34;, REG0, REG1, ... REGN
 &#60;get_opcode&#62; &#34;..., 0x200, flags0, ...&#34;, ..., &#34;name&#34;, REG0, ...</pre>

<p>The flags string is a literal quoted string denoting a list of zero or more comma&#45;separated integers. Integers may be specified either in decimal, or if prefixed with &#34;0b&#34;/&#34;0x&#34;, in binary/hexadecimal. There must be exactly one integer for each value or register given.</p>

<p>For documentation purposes we&#39;ll number the bits 0 (low) through 30 (high). Bit 31 (and higher, where available) will not be used.</p>

<p>Some values and registers do not correspond directly to values passed or received. (See the descriptions of the OPT_FLAG and NAMED bits, below.)</p>

<h3><a name="Flag_Words;_Common_Flag_Word_Bits"
>Flag Words; Common Flag Word Bits</a></h3>

<p>Each integer in the flag string controls the processing of the corresponding value or register.</p>

<p>These bits of each flag word have common meanings for all argument/ return&#45;value opcodes:</p>

<pre lang='und' xml:lang='und'>    0&#45;3   TYPE
               0b0000 = I
               0b0001 = S
               0b0010 = P
               0b0011 = N</pre>

<p>Don&#39;t set these bits yourself; the assembler will do it.</p>

<h2><a name="Passing_Arguments,_Returning_Values"
>Passing Arguments, Returning Values <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Just before calling a subroutine with <code lang='und' xml:lang='und'>invokecc</code> or calling a method with <code lang='und' xml:lang='und'>call_methodcc</code>, use the <code lang='und' xml:lang='und'>set_args</code> opcode to tell Parrot where the subroutine&#39;s or method&#39;s arguments will come from and how they should be expanded by the target.</p>

<p>Similarly, just before returning from such a subroutine or method, use the <code lang='und' xml:lang='und'>set_returns</code> opcode to tell Parrot where the return values will come from and how to expand them for the caller&#39;s use.</p>

<h3><a name="Flag_Word_Bits_For_&#39;Setting&#39;"
>Flag Word Bits For &#39;Setting&#39;</a></h3>

<p>These bits of each flag word have these meanings specific to <code lang='und' xml:lang='und'>set_args</code> and <code lang='und' xml:lang='und'>set_returns</code>:</p>

<dl>
<dt><a name="4_CONSTANT"
>4 <b><code lang='und' xml:lang='und'>CONSTANT</b></code></a></dt><p class="pad"></p>

<dd>The value is a literal constant, not a register. (Don&#39;t set this bit yourself; the assembler will do it.)</dd><p class="pad"></p>

<dt><a name="5_FLAT_(P_only)"
>5 <b><code lang='und' xml:lang='und'>FLAT</b></code> (P only)</a></dt><p class="pad"></p>

<dd>If this bit is set on a PMC value, then the PMC must be an aggregate. The contents of the aggregate, rather than the aggregate itself, will be passed.</dd><p class="pad"></p>

<dd>If the <code lang='und' xml:lang='und'>NAMED</code> bit is also set, the aggregate will be used as a hash; its contents, as key/value pairs, will be passed as named parameters. The PMC must implement the full hash interface. {{ RT#45367: Limit the required interface. }}</dd><p class="pad"></p>

<dd>If the <code lang='und' xml:lang='und'>NAMED</code> bit is not set, the aggregate will be used as an array; its contents will be passed as positional parameters.</dd><p class="pad"></p>

<dd>The meaning of this bit is undefined when applied to integer, number, and string values.</dd><p class="pad"></p>

<dt><a name="6_(unused)"
>6 (unused)</a></dt><p class="pad"></p>

<dt><a name="7_(unused)"
>7 (unused)</a></dt><p class="pad"></p>

<dt><a name="8_(unused)"
>8 (unused)</a></dt><p class="pad"></p>

<dt><a name="9_NAMED_(FLAT_or_string_constant_only)"
>9 <b><code lang='und' xml:lang='und'>NAMED</b></code> (<b><code lang='und' xml:lang='und'>FLAT</b></code> or string constant only)</a></dt><p class="pad"></p>

<dd>When the FLAT bit is also set, behavior is as described above in the &#34;FLAT&#34; section. Otherwise, this bit may only be set on a unique string constant specifying the name of the next argument (or returned value).</dd><p class="pad"></p>
</dl>

<h2><a name="Accepting_Parameters,_Accepting_Return_Values"
>Accepting Parameters, Accepting Return Values <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>As the <i>first opcode</i> in a subroutine that will be called with <code lang='und' xml:lang='und'>invokecc</code> or a method that will be called with <code lang='und' xml:lang='und'>call_methodcc</code>, use the <code lang='und' xml:lang='und'>get_params</code> opcode to tell Parrot where the subroutine&#39;s or method&#39;s arguments should be stored and how they should be expanded.</p>

<p>Similarly, just <i>before</i> (yes, <i>before</i>) calling such a subroutine or method, use the <code lang='und' xml:lang='und'>get_results</code> opcode to tell Parrot where the return values should be stored and how to expand them for your use.</p>

<p>NOTE: It should be obvious, but in case it&#39;s not: You must name only registers as targets of these opcodes, not constants. (You can&#39;t store anything into a constant. That would make it a variable.)</p>

<h3><a name="Flag_Word_Bits_For_&#39;Getting&#39;"
>Flag Word Bits For &#39;Getting&#39;</a></h3>

<p>These bits of each flag word have these meanings specific to <code lang='und' xml:lang='und'>get_params</code> and <code lang='und' xml:lang='und'>get_results</code>:</p>

<dl>
<dt><a name="4_(unused)"
>4 (unused)</a></dt><p class="pad"></p>

<dt><a name="5_SLURPY_(P_only)"
>5 <b><code lang='und' xml:lang='und'>SLURPY</b></code> (P only)</a></dt><p class="pad"></p>

<dd>If this bit is set on a P register, then it will be populated with an aggregate that will contain all of the remaining values that have not already been stored in other registers.</dd><p class="pad"></p>

<dd>All such values will be converted to PMCs according to the detailed rules below, and those PMCs will be stored into the new aggregate.</dd><p class="pad"></p>

<dd>If the <code lang='und' xml:lang='und'>NAMED</code> bit is also set, the aggregate will be the HLL&#45;specific hash type and the contents will be all unassigned _named_ parameters.</dd><p class="pad"></p>

<dd>If the <code lang='und' xml:lang='und'>NAMED</code> bit is not set, the aggregate will be the HLL&#45;specific array type and the contents will be all unassigned positional parameters.</dd><p class="pad"></p>

<dt><a name="6_(unused)"
>6 (unused)</a></dt><p class="pad"></p>

<dt><a name="7_OPTIONAL"
>7 <b><code lang='und' xml:lang='und'>OPTIONAL</b></code></a></dt><p class="pad"></p>

<dd>If this bit is set on a register for which no value has been passed, no exception will be raised; rather, the register will be set to a default value: a Null PMC for P, an empty string for S, or zero for N or I.</dd><p class="pad"></p>

<dt><a name="8_OPT_FLAG_(I_only)"
>8 <b><code lang='und' xml:lang='und'>OPT_FLAG</b></code> (I only)</a></dt><p class="pad"></p>

<dd>An I register with this bit set is set to one if the immediately preceding <b>OPTIONAL</b> register received a value; otherwise, it is set to zero. If the preceding register was not marked <b>OPTIONAL</b>, the behavior is undefined; but we promise you won&#39;t like it.</dd><p class="pad"></p>

<dt><a name="8_READONLY_(P_only)"
>8 <b><code lang='und' xml:lang='und'>READONLY</b></code> (P only)</a></dt><p class="pad"></p>

<dd><i>XXX &#45; PROPOSED ONLY &#45; XXX</i></dd><p class="pad"></p>

<dd>If this bit is set on a P register that receives a value, Parrot will ensure that the final value in the P register is read&#45;only (i.e. will not permit modification). If the received value was a mutable PMC, then Parrot will create and set the register to a {not yet invented} read&#45;only PMC wrapper around the original PMC.</dd><p class="pad"></p>

<dd>Future Notes: Parrot&#39;s algorithm for deciding what is writable may be simplistic. In initial implementations, it may assume that any PMC not of a known read&#45;only&#45;wrapper type is mutable. Later it may allow the HLL to provide the test. But we must beware overdesigning this; any HLL with a truly complex notion of read&#45;only probably needs to do this kind of wrapping itself.</dd><p class="pad"></p>

<dt><a name="8_(unused_for_S_and_N)"
>8 (unused for S and N)</a></dt><p class="pad"></p>

<dt><a name="9_NAMED_(SLURPY_or_string_constant_only)"
>9 <b><code lang='und' xml:lang='und'>NAMED</b></code> (<b><code lang='und' xml:lang='und'>SLURPY</b></code> or string constant only)</a></dt><p class="pad"></p>

<dd>When the SLURPY bit is also set, behavior is as described above in the &#34;SLURPY&#34; section. Otherwise, this bit may only be set on a unique string constant specifying the name of the next argument (or returned value).</dd><p class="pad"></p>
</dl>

<h3><a name="Overflow_and_underflow"
>Overflow and underflow</a></h3>

<p>If too many or too few values are provided for the given target registers, Parrot by default will throw an exception for <code lang='und' xml:lang='und'>get_params</code>, but not for <code lang='und' xml:lang='und'>get_results</code>. This error behavior can be controlled via the <code lang='und' xml:lang='und'>errorson</code> and <code lang='und' xml:lang='und'>errorsoff</code> opcodes using <code lang='und' xml:lang='und'>PARROT_ERRORS_PARAM_COUNT_FLAG</code> for <code lang='und' xml:lang='und'>get_params</code> and <code lang='und' xml:lang='und'>PARROT_ERRORS_RESULT_COUNT_FLAG</code> for <code lang='und' xml:lang='und'>get_results</code>. (It is not possible to control underflow behavior separately from overflow.)</p>

<p>Note that if the final target is a P register with FLAT set, then overflow can never occur. Similarly, if all target registers are marked <b>OPTIONAL</b>, then underflow is impossible.</p>

<p>Note also that when these errors are off, any excess destination registers in the case of underflow are left untouched, rather than being reset to zero or null. Excess registers explicitly marked <b>OPTIONAL</b> are always reset, regardless of the error flag settings.</p>

<p>RT#45357 &#45; which exception? We really could use an exception subsystem. Oh, wait, that&#39;s my job. Never mind. &#45;&#45;Chip</p>

<h3><a name="Ordering_of_named_values_(outgoing)"
>Ordering of named values (outgoing)</a></h3>

<p>Named values (arguments, or values to return) must be listed textually after all the positional values. <code lang='und' xml:lang='und'>FLAT</code> and non&#45;<code lang='und' xml:lang='und'>FLAT</code> values may be mixed in any order.</p>

<h3><a name="Ordering_of_named_targets_(incoming)"
>Ordering of named targets (incoming)</a></h3>

<p>Named targets (parameters, or returned values) must appear <i>after</i> all the positional targets. A <code lang='und' xml:lang='und'>SLURPY</code> positional target, if present, must be the last positional target; a <code lang='und' xml:lang='und'>SLURPY</code> named target, if present, must be the last named target.</p>

<p>So the acceptable ordering of targets is:</p>

<ul>
<li>positional non&#45;SLURPY (any number)</li><p class="pad"></p>

<li>positional SLURPY array (optional)</li><p class="pad"></p>

<li>NAMED non&#45;SLURPY (any number)</li><p class="pad"></p>

<li>NAMED SLURPY hash (optional)</li><p class="pad"></p>
</ul>

<h3><a name="Mixing_named_and_positional_values"
>Mixing named and positional values</a></h3>

<p>Positional targets can only be filled with positional values.</p>

<p>Named targets can be filled with either positional or named values. However, if a named target was already filled by a positional value, and then a named value is also given, this is an overflow error.</p>

<h3><a name="Type_Conversions"
>Type Conversions</a></h3>

<p>Unlike the <code lang='und' xml:lang='und'>set_*</code> opcodes, the <code lang='und' xml:lang='und'>get_*</code> opcodes must perform conversion from one register type to another. Here are the conversion rules:</p>

<ul>
<li>When the target is an I, N, or S register, storage will behave like an <code lang='und' xml:lang='und'>assign</code> (standard conversion).</li><p class="pad"></p>

<li>When the target and source are both P registers, storage will behave like a <code lang='und' xml:lang='und'>set</code> (pass by reference).</li><p class="pad"></p>

<li>When the target is a P register and the source is an integer, the P will be set to a new Integer[1] which has been <code lang='und' xml:lang='und'>assign</code>ed the given integer.</li><p class="pad"></p>

<li>When the target is a P register and the source is a number, the P will be set to a new Float[1] which has been <code lang='und' xml:lang='und'>assign</code>ed the given number.</li><p class="pad"></p>

<li>When the target is a P register and the source is a string, the P will be set to a new String[1] which has been <code lang='und' xml:lang='und'>assign</code>ed the given string.</li><p class="pad"></p>
</ul>

<p>[1] or some other type specified by the current HLL type map, which may substitute an alternative type for each default low&#45;level Parrot type (array, hash, string, number, etc.).</p>

<h1><a name="BUGS"
>BUGS <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Required features are missing:</p>

<ul>
<li>Specific exceptions to throw for specific errors.</li><p class="pad"></p>
</ul>

<h1><a name="PIR_SYNTAX_EXAMPLES"
>PIR SYNTAX EXAMPLES <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<h2><a name="Function_Calls"
>Function Calls <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<pre lang='und' xml:lang='und'>  foo(1, i)                       # 2 positional arguments
  foo(x, ar :flat, y)             # flattening array
  foo(p, &#39;key&#39; =&#62; value)          # named argument
  foo(p, value :named(&#39;key&#39;))     # the same
  foo(kw :named :flat)            # a flattening hash

  # all together now: three positional (one flat) with two named (one flat)
  foo(a, b, c :flat, &#39;x&#39; =&#62; 3, &#39;y&#39; =&#62; 4, z :flat :named(&#39;z&#39;))</pre>

<h2><a name="Parameters"
>Parameters <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<pre lang='und' xml:lang='und'>  .param int i                    # positional parameter
  .param pmc argv :slurpy         # slurpy array
  .param pmc value :named(&#39;key&#39;)  # named parameter
  .param int x :optional          # optional parameter
  .param int has_x :opt_flag      # flag 0/1 x was passed
  .param pmc kw :slurpy :named    # slurpy hash</pre>

<h2><a name="Return_Values"
>Return Values <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<pre lang='und' xml:lang='und'>  .return (i, ar: flat, value :named(&#39;key&#39;) )</pre>

<h2><a name="Call_Results"
>Call Results <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<pre lang='und' xml:lang='und'>  x = foo()                       # single result
  (i, j :optional, ar :slurpy, value :named(&#39;key&#39;) ) = foo()</pre>

<h1><a name="ATTACHMENTS"
>ATTACHMENTS <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>None.</p>

<h1><a name="REFERENCES"
>REFERENCES <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p><a href='TODO'>pdd23_exceptions.pod</a></p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../resources/parrot_small.png"
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
