<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
    <HEAD>
        <TITLE>Strings and character sets</TITLE>
        <LINK REL="stylesheet" TYPE="text/css"
            HREF="../../../../resources/perl.css"
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY>
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Strings and character sets</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../../html/index.html">Contents</a> | <a href="../../../../html/docs.html">Documentation</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>docs/pdds/pdd28_character_sets.pod &#45; Strings and character sets</p>

<h1><a name="ABSTRACT"
>ABSTRACT <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>This PDD describes the conventions expected for users of Parrot strings,
including but not limited to support for multiple character sets,
encodings and languages.</p>

<h1><a name="VERSION"
>VERSION <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>$Revision$</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>Here is a summary of the design decisions described in this PDD.</p>

<ul>
<li>Parrot supports multiple string formats,
and so users of Parrot strings must be aware at all times of string encoding issues and how these relate to the string interface.</li><p class="pad"></p>

<li>The native Parrot string format is an array of 32&#45;bit Unicode codepoints in <b>grapheme normalization form</b>.
(NFG)</li><p class="pad"></p>

<li>NFG is defined as a normalization which allocates at most one codepoint to each visible character.</li><p class="pad"></p>

<li>An interface is defined for interacting with Parrot strings and converting between character sets and encodings.</li><p class="pad"></p>
</ul>

<h2><a name="Definitions"
>Definitions <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Here is a brief definition of some of the technical terms in this PDD.
For more detailed description,
see any of the links at the bottom of this PDD.</p>

<dl>
<dt><a name="character"
>character</a></dt><p class="pad"></p>

<dd>A character is &#34;the abstract description of a symbol&#34;.
It&#39;s the smallest chunk of text a computer knows how to deal with.
Of course internally to the computer,
a character (just like everything else) is a number,
so you need to define...</dd><p class="pad"></p>

<dt><a name="character_set"
>character set</a></dt><p class="pad"></p>

<dd>A character set is officially a deprecated term,
with Unicode preferring the concepts of <i>character repertoire</i> (a collection of characters) and <i>character code</i> (a mapping which tells you what number represents which character in the repertoire).
We still use it,
though,
to mean the standard which defines both a repertoire and a code.</dd><p class="pad"></p>

<dt><a name="codepoint"
>codepoint</a></dt><p class="pad"></p>

<dd>A codepoint is the numeric representation of a character according to a given character set.
So in ASCII,
the character <code lang='und' xml:lang='und'>A</code> has codepoint 0x41.</dd><p class="pad"></p>

<dt><a name="combining_character"
>combining character</a></dt><p class="pad"></p>

<dd>A combining character is a Unicode concept.
It is a character which modifies the preceding character.
For instance,
accents,
lines,
circles,
boxes,
etc.
which are not to be displayed on their own,
but to be &#34;composed&#34; with the preceding character.</dd><p class="pad"></p>

<dt><a name="grapheme"
>grapheme</a></dt><p class="pad"></p>

<dd>A grapheme is our concept.
It is a character followed by all of its combining characters; on other words,
one or more characters forming a visible whole when displayed.
Parrot must support languages which manipulate strings grapheme&#45;by&#45;grapheme,
and since graphemes are the highest&#45;level interpretation of a &#34;character&#34;,
they&#39;re very useful for converting between character sets.</dd><p class="pad"></p>

<dt><a name="encoding"
>encoding</a></dt><p class="pad"></p>

<dd>An encoding determines how a codepoint is represented inside a computer.
Simple encodings like ASCII define that the codepoints 0&#45;127 simply live as their numeric equivalents inside an eight&#45;bit bytes.
Other fixed&#45;width encodings like UTF&#45;16 use more bytes to encode more codepoints.
Variable&#45;width encodings like UTF&#45;8 use one byte for codepoints 0&#45;127,
two bytes for codepoints 127&#45;2047,
and so on.</dd><p class="pad"></p>
</dl>

<h2><a name="Encoding_awareness"
>Encoding awareness <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Parrot was designed from the outset to support multiple string formats: multiple character sets and multiple encodings.
Unlike other such projects,
we don&#39;t standardize on Unicode internally.
This is because for the majority of use cases,
it&#39;s still far more efficient to deal with whatever input data the user sends us,
which,
equally in the majority of use cases,
is something like ASCII &#45; or at least,
some kind of byte&#45;based rather than character&#45;based encoding.</p>

<p>So internally,
consumers of Parrot strings have to be aware that there is a plurality of string encodings going on inside Parrot.
(Producers of Parrot strings can do whatever is most efficient for them.) The implications of this for the internal API will be detailed in the implementation section below,
but to put it in simple terms: if you find yourself writing <code lang='und' xml:lang='und'>*s++</code> or any other C string idioms,
you need to stop and think if that&#39;s what you really mean.
Not everything is byte&#45;based any more.</p>

<p>However,
we&#39;re going to try to make it as easy for <code lang='und' xml:lang='und'>*s++</code>&#45;minded people as possible,
and part of that is the declaration of a Parrot native string format.
You don&#39;t have to use it,
but if you do all your dreams will come true.</p>

<h2><a name="Native_string_format"
>Native string format <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Dealing with variable&#45;byte encodings is not fun; for instance,
you need to do a bunch of computations every time you traverse a string.
In order to make programming a lot easier,
we define a Parrot native string format to be an array of unsigned 32&#45;bit Unicode codepoints.
This is equivalent to UCS&#45;4 except for the normalization form semantics described below.</p>

<p>This means that <b>if</b> you&#39;ve done the necessary checks,
and hence you know you&#39;re dealing with a Parrot native string,
then you can continue to program in the usual C idioms &#45; for the most part.
Of course you&#39;ll need to be careful with your comparisons,
since what you&#39;ll be getting back will be a <code lang='und' xml:lang='und'>Parrot_Rune</code> instead of a <code lang='und' xml:lang='und'>char</code>.</p>

<h2><a name="Grapheme_normalization_form"
>Grapheme normalization form <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Unicode characters can be expressed in a number of different ways according to the Unicode Standard.
This is partly to do with maintaining compatibility with existing character encodings.
For instance,
in Serbo&#45;Croatian and Slovenian,
there&#39;s a letter which looks like an <code lang='und' xml:lang='und'>i</code> without the dot but with two grave (<code lang='und' xml:lang='und'>`</code>) accents.
If you have an especially good POD renderer,
you can see it here: &#521;.</p>

<p>There are two ways you can represent this in Unicode.
You can use character 0x209,
also known as <code lang='und' xml:lang='und'>LATIN SMALL LETTER I WITH DOUBLE GRAVE</code>,
which does the job all in one go.
This is called a &#34;composed&#34; character,
as opposed to its equivalent decomposed sequence: <code lang='und' xml:lang='und'>LATIN SMALL LETTER I</code> (0x69) followed by <code lang='und' xml:lang='und'>COMBINING DOUBLE GRAVE ACCENT</code> (0x30F).</p>

<p>Unicode standardises in a number of &#34;normalization forms&#34; which repesentation you should use.
We&#39;re using an extension of Normalization Form C,
which says basically,
decompose everything,
then re&#45;compose as much as you can.
So if you see the integer stream <code lang='und' xml:lang='und'>0x69 0x30F</code>,
it needs to be replaced by <code lang='und' xml:lang='und'>0x209</code>.
This means that Parrot string data structures need to keep track of what normalization form a given string is in,
and Parrot must provide functions to convert between normalization forms.</p>

<p>Now,
Serbo&#45;Croat is sometimes also written with Cyrillic letters rather than Latin letters.
The Cyrillic equivalent of the above character is not part of Unicode,
but would be specified as a decomposed pair <code lang='und' xml:lang='und'>CYRILLIC SMALL LETTER I</code> (0x438) <code lang='und' xml:lang='und'>COMBINING DOUBLE GRAVE ACCENT</code> (0x30F).
(This PDD does not require Parrot to convert strings between differing political sensibilities.) However,
it is still visible as one character and despite being expressed even in NFC as two characters,
is still a single character as far as a human reader is concerned.</p>

<p>Hence we introduce the distinction between a &#34;character&#34; and a &#34;grapheme&#34;.
This is a Parrot distinction &#45; it does not exist in the Unicode Standard.</p>

<p>When a regular expression engine from one of Parrot&#39;s target languages wishes to match a grapheme,
then NFC is clearly not normalized enough.
This is why we have defined a further normalization stage,
NFG &#45; Normalization Form for Graphemes.</p>

<p>NFG uses out&#45;of&#45;band signalling in the string to refer the conforming implementation to a decomposition table.
UCS&#45;4 specifies an encoding for Unicode codepoints from 0 to 0x7FFFFFFF.
In other words,
any codepoints with the first bit set are undefined.
We define these out&#45;of&#45;band codepoints as indexes into a lookup table,
which maps between a temporary ID and its associated decomposition.</p>

<p>In practice,
this goes as follows: Assuming our Russified Serbo&#45;Croat string is the first string that Parrot sees,
when it is converted to Parrot&#39;s default format,
it would be normalized to a single character having the codepoint <code lang='und' xml:lang='und'>0xFFFFFFFFF</code>.
(In other words,
&#45;1; grapheme table entries count backwards to allow Parrot to check if a character is a grapheme using a single sign&#45;comparison operation) At the same time,
Parrot would insert an entry into the global grapheme table,
<code lang='und' xml:lang='und'>Parrot_grapheme_table</code>,
at array index 0,
consisting of the bytestream <code lang='und' xml:lang='und'>0x00000438 0x000000030F</code> &#45; that is,
the Unicode decomposition of the grapheme.</p>

<p>This has one big advantage: applications which don&#39;t care about graphemes can just pass the codepoint around as if it&#39;s any other number &#45; uh,
character.
Only applications which care about the specific properties of Unicode characters need to take the overload of peeking inside the array and reading the decomposition.</p>

<p>Individual languages may need to think carefully about their concept of,
for instance,
&#34;the length of a string&#34; to determine whether or not they need to visit the lookup table for these strings.
At any rate,
Parrot should provide both grapheme&#45;aware and codepoint&#45;aware iterators for string traversal.</p>

<h2><a name="The_Parrot_internal_character_type"
>The Parrot internal character type <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>The other advantage of NFG is that it gives us a single value that can unambiguously be passed between any charset/encoding pair: any variable typed <code lang='und' xml:lang='und'>Parrot_Rune</code> is defined to be a <code lang='und' xml:lang='und'>Parrot_UInt4</code> Unicode codepoint where values &#62;= 0x80000000 are understood to be entries into the global <code lang='und' xml:lang='und'>Parrot_grapheme_table</code> array.</p>

<p>Strings in Parrot&#39;s native string format will <i>probably</i> be an array of <code lang='und' xml:lang='und'>Parrot_Rune</code>s.
(It is possible that native strings may want to carry around their own grapheme tables rather than use the global one; in which case,
their codepoints are better off called <code lang='und' xml:lang='und'>Parrot_UInt4</code>s,
to reserve the interpretation of the <code lang='und' xml:lang='und'>Parrot_Rune</code> type.
But let&#39;s burn that bridge when we come to it.)</p>

<p>Because <code lang='und' xml:lang='und'>Parrot_Rune</code>s are a single unambiguous representation of a character at the highest level Parrot will be required to support &#45; that is,
in principle,
any character from any character set can be represented by at most one <code lang='und' xml:lang='und'>Parrot_Rune</code> &#45; they are perfect as an intermediate character representation for converting between string types.</p>

<h2><a name="Some_useful_statistics_for_optimizers"
>Some useful statistics for optimizers <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>I took a large sample of highly mixed Unicode data,
generated by taking the contents of English Wikipedia and removing 99% of the pure&#45;ASCII content,
and looked at the distribution of UTF&#45;8 bytes per character.</p>

<pre lang='und' xml:lang='und'>    1 bytes: 116324899
    2 bytes: 19229506
    3 bytes: 12198853
    4 bytes: 4170</pre>

<p>There is a possible methodological problem here in that English Wikipedia is more likely to contain content from languages &#34;close&#34; to English and transliterations into Latin letters using accented forms rather than &#34;exotic&#34; scripts. Nevertheless, as a first approximation it appears that a majority of the world&#39;s data still fits in one byte of UTF&#45;8, but once you pass one byte, two or three UTF&#45;8 bytes are (very roughly speaking) equally likely.</p>

<h1><a name="IMPLEMENTATION"
>IMPLEMENTATION <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<h2><a name="Division_of_labour_between_&#34;charset&#34;_and_&#34;encoding&#34;"
>Division of labour between &#34;charset&#34; and &#34;encoding&#34; <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Character sets and encodings are related but separate concepts. An encoding is the lower&#45;level representation of a string&#39;s data, whereas the character set determines higher&#45;level semantics. Typically, character set functions will ask a string&#39;s encoding functions to retrieve data from the string, and then process the retrieved data.</p>

<p>In (rare) cases where a character set has a particularly strong link to an encoding, (ISO8859&#45;X with fixed 8&#45;bit being the prime example) then the character set functions may, for optimization purposes, contain code which bypasses the encoding functions and handles the string data directly. However, an encoding check <b>MUST</b> still be made and equivalent code to do things &#34;the slow way&#34; must be included if the check fails.</p>

<h2><a name="The_global_grapheme_table"
>The global grapheme table <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>When constructing strings in NFG, graphemes not expressible as a single character in Unicode are represented by a grapheme ID which looks up into the global grapheme table. When Parrot comes across a grapheme, it must first determine whether or not the grapheme already has an entry in the grapheme table. Therefore the table cannot strictly be an array, as that would make lookup inefficient. The grapheme table is represented, then, as both an array and a hash structure. The array gives forward&#45;lookup and the hash allows reverse lookup. Converting a string of characters into a grapheme ID can be demonstrated with the following Perl 5 pseudocode, for the grapheme <code lang='und' xml:lang='und'>0x438 0x30F</code>:</p>

<pre lang='und' xml:lang='und'>   $codepoint = ($grapheme_lookup&#45;&#62;{0x438}{0x30F} ||= do {
                   push @grapheme_table, &#34;\x{438}\x{30F}&#34;;
                   ~ $#grapheme_table;
                });
   push @string, $codepoint; </pre>

<h2><a name="Implications_for_string_implementation"
>Implications for string implementation <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>To provide an area for encoding&#45;specific information, such as the current normalisation form, the <code lang='und' xml:lang='und'>parrot_string_representation_t</code> is to be re&#45;worked as a void pointer to an encoding&#45;specific representation structure. For instance, one such structure for the Parrot native encoding may look like this:</p>

<pre lang='und' xml:lang='und'>    typedef Parrot_UInt4 Parrot_Rune;

    typedef struct parrot_native_representation_t {
        normalization_form_t normalization,
        ...
    };</pre>

<h2><a name="String_access_API"
>String access API <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>It is hard to fully lay out a list of what string functions will be required as this will obviously be determined by use. This PDD assumes for the moment that the current string functions will on the whole be maintained, but will be adapted to use the ideas described here &#45; particularly the use of <code lang='und' xml:lang='und'>Parrot_Rune</code> as an intermediary character representation, the addition of normalization form structures and the <code lang='und' xml:lang='und'>Parrot_grapheme_table</code>.</p>

<h3><a name="Conversions_between_normalization_form,_encoding_and_charset"
>Conversions between normalization form, encoding and charset</a></h3>

<p>Given the existence of a single unambiguous character type, there is no need for a large and complicated set of string conversion functions. All conversion will be done with a function called <code lang='und' xml:lang='und'>string_slow_copy</code>:</p>

<pre lang='und' xml:lang='und'>    INTVAL string_slow_copy(STRING* src, STRING* dst)</pre>

<p>To convert a string from one format to another, simply create a new empty string with the required attributes, and pass the source string and this new string to <code lang='und' xml:lang='und'>string_slow_copy</code>. This function creates two string iterators and calls <code lang='und' xml:lang='und'>get_and_advance</code> on the source string&#39;s iterator to read each character in turn into a <code lang='und' xml:lang='und'>Parrot_Rune</code>, and then calls <code lang='und' xml:lang='und'>set_and_advance</code> on the destination string&#39;s iterator to append the character. This will intrinsically perform a conversion using <code lang='und' xml:lang='und'>Parrot_Rune</code>s as the intermediary.</p>

<p>Note that <code lang='und' xml:lang='und'>encoding_get_codepoint</code> on strings which are not in NFG may need to read ahead multiple characters in order to turn them into a single grapheme, in order to return a <code lang='und' xml:lang='und'>Parrot_Rune</code>.</p>

<h2><a name="String_programming_checklist"
>String programming checklist <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<ul>
<li>Are you manipulating the string data directly? It&#39;s OK to do this if you know that the string is in Parrot&#39;s native format and you&#39;re using <code lang='und' xml:lang='und'>Parrot_Rune</code>s. It&#39;s generally not OK to do this otherwise.</li><p class="pad"></p>

<li>Related to the above, if you see <code lang='und' xml:lang='und'>*s++</code> in code you&#39;ve just written, then warning bells should be sounding.</li><p class="pad"></p>

<li><code lang='und' xml:lang='und'>Parrot_Rune</code>s are guaranteed to be Unicode codepoints up to <code lang='und' xml:lang='und'>0x7FFFFFFF</code> and Parrot graphemes above that. Nothing else is guaranteed to be in Unicode; operations which require understanding the semantics of the string must go through the character set structure.</li><p class="pad"></p>

<li>Similarly, operations which required understanding of the layout of the string must go through the encoding structure.</li><p class="pad"></p>
</ul>

<h1><a name="REFERENCES"
>REFERENCES <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p><a href="http://plan9.bell&#45;labs.com/sys/doc/utf.html">http://plan9.bell&#45;labs.com/sys/doc/utf.html</a> &#45; Plan 9&#39;s Runes are not dissimilar to Parrot&#39;s Runes, and this is a good introduction to the Unicode world. (Also available at <a href="http://sirviente.9grid.es/sources/plan9/sys/doc/utf.ps">http://sirviente.9grid.es/sources/plan9/sys/doc/utf.ps</a> )</p>

<p><a href="http://www.unicode.org/reports/tr15/">http://www.unicode.org/reports/tr15/</a> &#45; The Unicode Consortium&#39;s explanation of different normalization forms.</p>

<p>&#34;Unicode: A Primer&#34;, Tony Graham &#45; Arguably the most readable book on how Unicode works.</p>

<p>&#34;Advanced Perl Programming&#34;, Chapter 6, &#34;Unicode&#34;</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../../resources/parrot_small.png"
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
