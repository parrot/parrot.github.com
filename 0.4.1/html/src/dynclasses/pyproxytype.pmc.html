<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Python Proxy Type</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Python Proxy Type</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../html/index.html">Contents</a> | <a href="../../../html/dynapmc.html">Dynamic PMCs</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>classes/pyproxytype.pmc &#45; Python Proxy Type</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>This is the type that you get when you subclass a non&#45;PyClass (i.e.,
a builtin PyObject,
like PyInt).</p>

<p>Invoking instances of this type (which is Python&#39;s way of instantiating instances) actually causes two objects to be created: one of type PyClass (the &#34;proxy&#34;),
and one of intended class (the &#34;real object&#34;).</p>

<p>The one &#34;trick&#34; is that the an additional parent is inserted into the inheritance hierarchy of type PyProxyClass.
The sole function of PyProxyClass is to delegate of all method and attribute calls back onto the real object.</p>

<p>The combination of PyClass,
PyProxyClass,
and PyObject allows subclasses of builtins to redefine methods.
This is because PyClass knows how to translate Parrot calls (like &#34;get_string&#34;) into Python methods (like &#34;__str__&#34;),
find_method on PyClass knows how to look up the inheritance chain,
and having a PyProxyClass on the top of the chain knows how to forward such method talls to a PyObject,
which in turn knows how to map Python method calls onto Parrot calls.</p>

<p>While this seems like a lot of work,
lets consider all the cases:</p>

<pre lang='und' xml:lang='und'>  &#34;pure&#34; builtins (not subclassed by Python):
     * operations like indexing and addition are done at Parrot
       speeds with no lookaside to see if methods have been
       overridden.
     * explict calls to methods (such as __str__) are relatively
       rare, but are handled by an NCI method which maps between 
       Python and Parrot syntax and semantics.

  &#34;pure&#34; Python classes (base class is object):
     * operations like addition are relatively rare, but are
       accomplished by an NCI method which maps between Python
       and Parrot syntax and semantics.
     * explicit calls to methods directly check the set of
       properties (currently a hash) for each class.

  &#34;mixed&#34; classes (base class is builin &#45; relatively rare):
     * operations like indexing and addition require a
       mapping to Python method names, an inheritance search,
       and mapping back to Parrot method names.
     * explicit calls to methods require only the ProxyClass and
       a mapping to Parrot methods.</pre>

<h2><a name="Methods"
>Methods <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="void*_invoke(void_*next)"
><b><code lang='und' xml:lang='und'>void *invoke(void *next)</b></code></a></dt><p class="pad"></p>

<dd>Create a new object and proxy. Note: invokes <code lang='und' xml:lang='und'>invoke</code> on the object without touching any parrot registers... this enables initializers with arguments to be run.</dd><p class="pad"></p>

<dt><a name="PMC*_subclass(STRING_*name)"
><b><code lang='und' xml:lang='und'>PMC *subclass(STRING *name)</b></code></a></dt><p class="pad"></p>

<dd>Create a subclass of the given class. Note that this merely creates a new PyType... all the interesting details that make it a subclass need to be filled in.</dd><p class="pad"></p>
</dl>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
