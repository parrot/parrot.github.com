<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
    <HEAD>
        <TITLE>Regex stack handling routines</TITLE>
        <LINK REL="stylesheet" TYPE="text/css"
            HREF="../../resources/perl.css"
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY>
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Regex stack handling routines</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../html/index.html">Contents</a> | <a href="../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>src/intlists.c &#45; Regex stack handling routines</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>intlist emulation code,
calls routines in <em><a href="list.c.html">src/list.c</a></em>.</p>

<p>Here is the original documentation for intlist:</p>

<p>The basic data structure is a variant of a doubly&#45;linked list of &#39;chunks&#39;,
where a chunk is a <code>Buffer</code> header subclass containing the link pointers and other metadata for the chunk.
As expected from it being a <code>Buffer</code> header,
the <code>PObj_bufstart</code> field points to the actual array of <code>INTVAL</code>s.
The handle used by external code for one of these IntLists is just a pointer to a chunk,
always called &#39;list&#39; in this code.</p>

<p>For now,
all of the chunks are fixed&#45;length in size.
(That could easily be changed,
at the cost of another integer in each header.)</p>

<p>Notice that I said &#39;variant&#39; of a doubly&#45;linked list.
That is because if you start at &#39;list&#39; and follow prev pointers,
you will loop through all the used nodes of the list,
as usual.
But if you follow next pointers instead,
you might find a spare node hanging off the last node in the list (the last node is always <code>list&#45;&#62;prev</code>,
so if there is a spare node,
it will be at <code>list&#45;&#62;prev&#45;&#62;next</code>.
If no spare exists,
then <code>list&#45;&#62;prev&#45;&#62;next==list</code>.)</p>

<p>The first node in the list may be partly full; the intermediate nodes are always completely full; and the last node may be partly full.
Each node has a <code>.start</code> field,
giving the offset of the first valid element (always zero except for possibly the first node),
and a <code>.end</code> field,
giving one past the offset of the last valid element (always equal to <code>INTLIST_CHUNK_SIZE</code> except for possibly the last node).</p>

<p>To make it concrete,
let&#39;s walk through some sample operations.
To push onto the end of the list,
first find the last chunk: <code>list&#45;&#62;prev</code>.
Then if <code>chunk&#45;&#62;end &#60; INTLIST_CHUNK_SIZE</code>,
there is space to fit another element and so just stick it in.
If not,
we must add a chunk to the end of the list.
If there is a spare,
just link it fully into the list (forming a conventional doubly&#45;linked list).
Otherwise,
create a new chunk and link it fully into the list.
Easy enough.</p>

<p>To pop something off the end,
first go to the end chunk (<code>list&#45;&#62;prev</code>).
Pop off an element and decrement <code>.end</code> if the chunk is nonempty.
If it is empty,
make that last chunk into the spare (discarding the previous spare).
Then go to the previous chunk,
which is guaranteed to have <code>.end</code> set to <code>INTLIST_CHUNK_SIZE</code>,
and return <code>data[.end&#45;&#45;]</code>.</p>

<p>The length of the list is always cached in the overall header chunk.
If an operation changes which chunk is the header (i.e.,
shift or unshift),
then the length is copied to the new header.</p>

<p>Invariants:</p>

<p>There is always space in <code>list&#45;&#62;prev</code> to insert an element.</p>

<p>The &#39;list&#39; chunk is never empty unless the entire list is empty.</p>

<p>In combination,
the above invariants imply that the various operations are implemented as:</p>

<dl>
<dt><a name="push"
><b><code>push</b></code></a></dt>
Write element,
push a new chunk if necessary.
<dt><a name="pop"
><b><code>pop</b></code></a></dt>
Check to see if we have to back up a chunk,
read element.
<dt><a name="shift"
><b><code>shift</b></code></a></dt>
Read element,
discard chunk and advance if necessary.
<dt><a name="unshift"
><b><code>unshift</b></code></a></dt>
Unshift a chunk if necessary,
write element.</dl>

<p>Direct aka indexed access of intlist data:</p>

<p>The classic method would be to walk the <code>intlist&#45;&#62;next</code> pointers (or optimized,
the <code>&#45;&#62;prev</code> pointers if an index near the end is requested) and locate the chunk,
that holds the wanted list item.</p>

<p>To speed things up,
especially for bigger lists,
there are additional fields in the &#39;list&#39; (the head chunk):</p>

<dl>
<dt><a name="chunk_list"
><b><code>chunk_list</b></code></a></dt>
Holds pointers to individual chunks.
<dt><a name="collect_runs"
><b><code>collect_runs</b></code></a></dt>
<code>collect_runs</code> counter,
when <code>chunk_list</code> was rebuilt last.
<dt><a name="n_chunks"
><b><code>n_chunks</b></code></a></dt>
Used length in <code>chunk_list</code></dl>

<p>If on any indexed access interpreter&#39;s collect_runs is different,
the chunks might have been moved,
so the chunk_list has to be rebuilt.</p>

<p>Getting data outside the array dimensions will return the value <code>NULL</code>,
which will <code>SIGSEGV</code>,
the intlist did an explicit exception,
so there is not much difference.
Of course,
a check for valid pointers could be added here.</p>

<h2><a name="Functions"
>Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="void_intlist_mark"
><b><code>void intlist_mark</b></code></a></dt>
Marks the list as live.
<dt><a name="IntList_*_intlist_clone"
><b><code>IntList *intlist_clone</b></code></a></dt>
Returns a clone of the list.
<dt><a name="IntList_*_intlist_new"
><b><code>IntList *intlist_new</b></code></a></dt>
Returns a new list.
<dt><a name="INTVAL_intlist_length"
><b><code>INTVAL intlist_length</b></code></a></dt>
Returns the length of the list.
<dt><a name="void_intlist_assign"
><b><code>void intlist_assign</b></code></a></dt>
Assigns &#60;val&#62; to the item at <code>idx</code>.
<dt><a name="void_intlist_push"
><b><code>void intlist_push</b></code></a></dt>
Pushes <code>val</code> on the end of the list.
<dt><a name="void_intlist_unshift"
><b><code>void intlist_unshift</b></code></a></dt>
Pushes <code>val</code> on the front of the list.
<dt><a name="INTVAL_intlist_pop"
><b><code>INTVAL intlist_pop</b></code></a></dt>
Popping/shifting into a sparse hole returns 0.
<dt><a name="INTVAL_intlist_shift"
><b><code>INTVAL intlist_shift</b></code></a></dt>
Removes and returns the first item on the list.
<dt><a name="INTVAL_intlist_get"
><b><code>INTVAL intlist_get</b></code></a></dt>
Returns the item at <code>idx</code>.</dl>

<h1><a name="SEE_ALSO"
>SEE ALSO <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p><em>include/parrot/intlist.h</em>,
<em><a href="list.c.html">src/list.c</a></em> and <em>include/parrot/list.h</em>.</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../resources/parrot_small.png"
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
