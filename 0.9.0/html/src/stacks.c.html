<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
    <HEAD>
        <TITLE>Stack handling routines for Parrot</TITLE>
        <LINK REL="stylesheet" TYPE="text/css"
            HREF="../../resources/perl.css"
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY>
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Stack handling routines for Parrot</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../html/index.html">Contents</a> | <a href="../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>src/stacks.c &#45; Stack handling routines for Parrot</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>The stack is stored as a linked list of chunks (<code>Stack_Chunk</code>),
where each chunk has room for one entry.</p>

<h2><a name="Functions"
>Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="void_stack_system_init"
><b><code>void stack_system_init</b></code></a></dt>
Called from <code>make_interpreter()</code> to initialize the interpreter&#39;s register stacks.
<dt><a name="Stack_Chunk_t_*_cst_new_stack_chunk"
><b><code>Stack_Chunk_t *cst_new_stack_chunk</b></code></a></dt>
Get a new chunk either from the freelist or allocate one.
<dt><a name="Stack_Chunk_t_*_new_stack"
><b><code>Stack_Chunk_t *new_stack</b></code></a></dt>
Create a new stack and name it.
<code>stack&#45;&#62;name</code> is used for debugging/error reporting.
<dt><a name="void_mark_stack"
><b><code>void mark_stack</b></code></a></dt>
Mark entries in a stack structure during DOD.
<dt><a name="void_stack_destroy"
><b><code>void stack_destroy</b></code></a></dt>
stack_destroy() doesn&#39;t need to do anything,
since GC does it all.
<dt><a name="size_t_stack_height"
><b><code>size_t stack_height</b></code></a></dt>
Returns the height of the stack.
The maximum &#34;depth&#34; is height &#45; 1.
<dt><a name="Stack_Entry_t_*_stack_entry"
><b><code>Stack_Entry_t *stack_entry</b></code></a></dt>
If <code>depth &#62;= 0</code>,
return the entry at that depth from the top of the stack,
with 0 being the top entry.
If <code>depth &#60; 0</code>,
then return the entry <code>|depth|</code> entries from the bottom of the stack.
Returns <code>NULL</code> if <code>|depth| </code> number&#62; of entries in stack.
<dt><a name="Stack_Entry_t*_stack_prepare_push"
><b><code>Stack_Entry_t *stack_prepare_push</b></code></a></dt>
Return a pointer,
where new entries go for push.
<dt><a name="void_stack_push"
><b><code>void stack_push</b></code></a></dt>
Push something on the generic stack.Note that the cleanup pointer,
if non&#45;<code>NULL</code>,
points to a routine that&#39;ll be called when the entry is removed from the stack.
This is handy for those cases where you need some sort of activity to take place when an entry is removed,
such as when you push a lexical lock onto the call stack,
or localize (or tempify,
or whatever we&#39;re calling it) variable or something.*/PARROT_EXPORT void stack_push(PARROT_INTERP,
ARGMOD(Stack_Chunk_t **stack_p),
ARGIN(void *thing),
Stack_entry_type type,
NULLOK(Stack_cleanup_method cleanup)) { ASSERT_ARGS(stack_push) Stack_Entry_t * const entry = (Stack_Entry_t *)stack_prepare_push(interp,
stack_p);
<pre>    /* Remember the type */
    entry&#45;&#62;entry_type = type;

    /* Remember the cleanup function */
    entry&#45;&#62;cleanup = cleanup;

    /* Store our thing */
    switch (type) {
        case STACK_ENTRY_MARK:
            UVal_int(entry&#45;&#62;entry) = *(INTVAL *)thing;
            break;
        case STACK_ENTRY_DESTINATION:
            UVal_ptr(entry&#45;&#62;entry) = thing;
            break;
        case STACK_ENTRY_ACTION:
        case STACK_ENTRY_PMC:
            UVal_pmc(entry&#45;&#62;entry) = (PMC *)thing;
            break;
        default:
            Parrot_ex_throw_from_c_args(interp, NULL, ERROR_BAD_STACK_TYPE,
                &#34;Invalid Stack_Entry_type!&#34;);
    }
}</pre>
/*
<dt><a name="Stack_Entry_t*_stack_prepare_pop"
><b><code>Stack_Entry_t *stack_prepare_pop</b></code></a></dt>
Return a pointer, where new entries are popped off.
<dt><a name="void_*_stack_pop"
><b><code>void *stack_pop</b></code></a></dt>
Pop off an entry and return a pointer to the contents.*/PARROT_EXPORT PARROT_CAN_RETURN_NULL void * stack_pop(PARROT_INTERP, ARGMOD(Stack_Chunk_t **stack_p), ARGOUT_NULLOK(void *where), Stack_entry_type type) { ASSERT_ARGS(stack_pop) Stack_Chunk_t *cur_chunk = *stack_p; Stack_Entry_t * const entry = (Stack_Entry_t *)stack_prepare_pop(interp, stack_p);
<pre>    /* Types of 0 mean we don&#39;t care */
    if (type &#38;&#38; entry&#45;&#62;entry_type != type)
        Parrot_ex_throw_from_c_args(interp, NULL, ERROR_BAD_STACK_TYPE,
            &#34;Wrong type on top of stack!\n&#34;);

    /* Cleanup routine? */
    if (entry&#45;&#62;cleanup != STACK_CLEANUP_NULL)
        (*entry&#45;&#62;cleanup) (interp, entry);

    /* Sometimes the caller cares what the value was */
    if (where) {
        /* Snag the value */
        switch (type) {
        case STACK_ENTRY_MARK:
            *(INTVAL *)where   = UVal_int(entry&#45;&#62;entry);
            break;
        case STACK_ENTRY_DESTINATION:
            *(void **)where    = UVal_ptr(entry&#45;&#62;entry);
            break;
        case STACK_ENTRY_ACTION:
        case STACK_ENTRY_PMC:
            *(PMC **)where     = UVal_pmc(entry&#45;&#62;entry);
            break;
        default:
            Parrot_ex_throw_from_c_args(interp, NULL, ERROR_BAD_STACK_TYPE,
                &#34;Wrong type on top of stack!\n&#34;);
        }
    }

    /* recycle this chunk to the free list if it&#39;s otherwise unreferenced */
    if (cur_chunk&#45;&#62;refcount &#60;= 0) {
        Small_Object_Pool * const pool = cur_chunk&#45;&#62;pool;

        pool&#45;&#62;dod_object(interp, pool, (PObj *)cur_chunk);
        pool&#45;&#62;add_free_object(interp, pool, (PObj *)cur_chunk);
    }

    return where;
}</pre>
/*
<dt><a name="void_*_pop_dest"
><b><code>void *pop_dest</b></code></a></dt>
Pop off a destination entry and return a pointer to the contents.
<dt><a name="void_*_stack_peek"
><b><code>void *stack_peek</b></code></a></dt>
Peek at stack and return pointer to entry and the type of the entry.
<dt><a name="Stack_entry_type_get_entry_type"
><b><code>Stack_entry_type get_entry_type</b></code></a></dt>
Returns the stack entry type of <code>entry</code>.
<dt><a name="void_Parrot_dump_dynamic_environment"
><b><code>void Parrot_dump_dynamic_environment</b></code></a></dt>
Print a representation of the dynamic stack to the standard error (using <code>Parrot_io_eprintf</code>). This is used only temporarily for debugging.
<dt><a name="static_void_run_cleanup_action"
><b><code>static void run_cleanup_action</b></code></a></dt>
Runs the sub PMC from the Stack_Entry_t pointer with an INTVAL arg of 0. Used in <code>Parrot_push_action</code>.
<dt><a name="void_Parrot_push_action"
><b><code>void Parrot_push_action</b></code></a></dt>
Pushes an action handler onto the dynamic environment.
<dt><a name="void_Parrot_push_mark"
><b><code>void Parrot_push_mark</b></code></a></dt>
Push a cleanup mark onto the dynamic environment.
<dt><a name="void_Parrot_pop_mark"
><b><code>void Parrot_pop_mark</b></code></a></dt>
Pop items off the dynamic environment up to the mark.</dl>

<h1><a name="SEE_ALSO"
>SEE ALSO <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p><em>include/parrot/stacks.h</em> and <em>include/parrot/enums.h</em>.</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../resources/parrot_small.png"
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
