<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
    <HEAD>
        <TITLE>A decimal arithmetic library Parrot</TITLE>
        <LINK REL="stylesheet" TYPE="text/css"
            HREF="../../resources/perl.css"
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY>
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">A decimal arithmetic library Parrot</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../html/index.html">Contents</a> | <a href="../../html/bignum.html">Big Number Arithmetic</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>src/bignum.c &#45; A decimal arithmetic library Parrot</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>This code is intended for inclusion in the parrot project,
and also for backporting into Perl5 (as a CPAN module).
Any patches to this code will likely find their way back to the Mother Ship,
as it were.</p>

<p>There is a good deal of scope for improving the speed of this code,
modifications are encouraged as long as the extended regression tests continue to pass.
Alex Gough,
2002</p>

<p><i>It was a very inconvenient habit of kittens (Alice had once made the remark) that,
whatever you say to them,
they always purr.
&#34;If they would only purr for `yes&#39;,
and mew for `no&#39;,
or any rule of that sort&#34;,
she had said,
&#34;so that one could keep up a conversation!
But how can you talk with a person if they always say the same thing?&#34;</i></p>

<p><i>On this occasion the kitten only purred: and it was impossible to guess whether it meant `yes&#39; or `no&#39;.</i></p>

<h2><a name="When_in_parrot"
>When in parrot <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>When the library is used within parrot,
all calls expect an additional first argument of an interpreter,
for the purposes of memory allocation,
some internal macros do not (getd/setd and CHECK(O|U)FLOW.</p>

<p>If you&#39;re being useful and inserting proper rapid fillins,
start with the <code>BN_i*</code> methods,
but make sure any errors can still be thrown.</p>

<h2><a name="Macros"
>Macros <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Access digits,
macros assume length given.</p>

<dl>
<dt><a name="BN_setd(BIGNUM*,_pos,_value)"
><b><code>BN_setd(BIGNUM*, pos, value)</b></code></a></dt>
Set digit at <code>pos</code> (zero is lsd) to <code>value</code>.
<dt><a name="int_BN_getd(BIGNUM*,_pos)"
><b><code>int BN_getd(BIGNUM*, pos)</b></code></a></dt>
Get value of digit at <code>pos</code>.
<dt><a name="CHECK_OVERFLOW(bn,_incr,_context)"
><b><code>CHECK_OVERFLOW(bn, incr, context)</b></code></a></dt>
If increasing the exponent of <code>bn</code> by <code>incr</code> will cause overflow (as decided by <code>elimit</code>),
returns true.
<dt><a name="CHECK_UNDERFLOW(bn,_decrement,_context)"
><b><code>CHECK_UNDERFLOW(bn, decrement, context)</b></code></a></dt>
If subtracting <code>decrement</code> (a positive number) from the exponent of <code>bn</code> would cause underflow,
returns true.</dl>

<p>Special Values</p>

<dl>
<dt><a name="am_INF(bn)"
><b><code>am_INF(bn)</b></code></a></dt>
True if <code>bn</code> is +Infinity or &#45;Infinity.
<dt><a name="am_NAN(bn)"
><b><code>am_NAN(bn)</b></code></a></dt>
True if <code>bn</code> is either a quiet or signalling NaN.
<dt><a name="am_sNAN(bn)"
><b><code>am_sNAN(bn)</b></code></a></dt>
True if <code>bn</code> is a signalling NaN.
<dt><a name="am_qNAN(bn)"
><b><code>am_qNAN(bn)</b></code></a></dt>
True if <code>bn</code> is a quiet NaN.
<dt><a name="char*_BN_lazydbprint(BIGNUM*_foo)"
><b><code>char *BN_lazydbprint(BIGNUM *foo)</b></code></a></dt>
For the sake of debugging</dl>

<h2><a name="Creation_and_Memory_Management_Functions"
>Creation and Memory Management Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="BIGNUM*_BN_new(PINTD__INTVAL_length)"
><b><code>BIGNUM *BN_new(PINTD_ INTVAL length)</b></code></a></dt>
Create a new <code>BIGNUM</code>.
<code>length</code> is number of <i>decimal</i> digits required.
The bignumber will be equal to zero.
<dt><a name="void_BN_grow(PINTD__NOTNULL(BIGNUM_*in),_INTVAL_length)"
><b><code>void BN_grow(PINTD_ NOTNULL(BIGNUM *in), INTVAL length)</b></code></a></dt>
Grows bn so that it can contain <code>length</code> <i>decimal</i> digits,
does not modify the value of the bignumber.
<dt><a name="void_BN_destroy(PINTD__BIGNUM_*bn)"
><b><code>void BN_destroy(PINTD_ BIGNUM *bn)</b></code></a></dt>
Frees all the memory used by the BIGNUM.
<dt><a name="BN_CONTEXT*_BN_create_context(PINTD__INTVAL_precision)"
><b><code>BN_CONTEXT *BN_create_context(PINTD_ INTVAL precision)</b></code></a></dt>
Creates a new context object,
with specified <i>precision</i>,
other fields are initialised as follows:
<pre> elimit   = BN_HARD_EXPN_LIMIT (defined during configure)
 rounding = ROUND_HALF_UP
 extended = 1
 flags    = 0
 traps    = Division by zero, invalid operation, overflow, underflow
            and rounded are enabled.
            Lost digits and inexact are disabled.</pre>
The context object can be destroyed with <code>free()</code>.
<dt><a name="INTVAL_BN_set_digit(PINT__BIGNUM*_bn,_INTVAL_pos,_INTVAL_value)"
><b><code>INTVAL BN_set_digit(PINT_ BIGNUM *bn, INTVAL pos, INTVAL value)</b></code></a></dt>
Sets digit at <code>pos</code> (zero based) to <code>value</code>. Number is grown if digits &#62; allocated space are accessed, but intermediate digits will have undefined values. If <code>pos</code> is beyond <code>digits</code> then <code>digits</code> is also updated.
<dt><a name="INTVAL_BN_get_digit(PINTD__BIGNUM*_bn,_INTVAL_pos)"
><b><code>INTVAL BN_get_digit(PINTD_ BIGNUM *bn, INTVAL pos)</b></code></a></dt>
Get the value of the decimal digit at <code>pos</code>, returns &#45;1 if <code>pos</code> is out of bounds.
<dt><a name="int_BN_set_inf(PINTD__BIGNUM*_bn)"
><b><code>int BN_set_inf(PINTD_ BIGNUM *bn)</b></code></a></dt>

<dt><a name="int_BN_set_qNAN(PINTD__BIGNUM*_bn)"
><b><code>int BN_set_qNAN(PINTD_ BIGNUM *bn)</b></code></a></dt>

<dt><a name="int_BN_set_sNAN(PINTD__BIGNUM*_bn)"
><b><code>int BN_set_sNAN(PINTD_ BIGNUM *bn)</b></code></a></dt>
Sets its argument to appropriate value.Infinity is represented as having zero digits, an undefined exponent and private <code>flags</code> set to <code>BN_inf_FLAGS</code>.sNAN is represented as having zero digits, an undefined exponent, an undefined sign and both qNAN and sNAN bits set.qNAN is represented as having zero digits, an undefined exponent and only the qNAN bit set.
<dt><a name="int_BN_set_verybig(PINTD__BIGNUM*_bn,_BN_CONTEXT_*context)"
><b><code>int BN_set_verybig(PINTD_ BIGNUM *bn, BN_CONTEXT *context)</b></code></a></dt>
Used when an operation has overflowed, sets <code>bn</code> according to <code>context&#45;&#62;rounding</code> and the sign of <code>bn</code>:
<pre> ROUND_HALF_UP, ROUND_HALF_EVEN =&#62; sign Infinity
 ROUND_DOWN =&#62; sign, largest finite number in given precision (or Inf, if
                 infinite precision is specified)
 ROUND_CEILING =&#62; same as round down, if sign is 1, +Inf otherwise
 ROUND_FLOOR =&#62; same as round down, if sign is 0, &#45;Inf otherwise</pre>

<dt><a name="BIGNUM*_BN_copy(PINTD__BIGNUM*_one,_BIGNUM*_two)"
><b><code>BIGNUM *BN_copy(PINTD_ BIGNUM *one, BIGNUM *two)</b></code></a></dt>
Copies two into one, returning one for convenience.
<dt><a name="BIGNUM*_BN_new_from_int(PINTD__INTVAL_value)"
><b><code>BIGNUM *BN_new_from_int(PINTD_ INTVAL value)</b></code></a></dt>
Create a new bignum from a (signed) integer value (<code>INTVAL</code>) We assume that the implementation limits are somewhat larger than those required to store a single integer into a bignum.
<dt><a name="void_BN_PRINT_DEBUG(BIGNUM_*bn,_char*_mesg)"
><b><code>void BN_PRINT_DEBUG(BIGNUM *bn, char *mesg)</b></code></a></dt>
Dump the bignum for testing, along with a little message.
<dt><a name="INTVAL_BN_nonfatal(PINTD__BN_CONTEXT_*context,_BN_EXCEPTIONS_except,_const_char_*msg)"
><b><code>INTVAL BN_nonfatal(PINTD_ BN_CONTEXT *context, BN_EXCEPTIONS except, const char *msg)</b></code></a></dt>
When an exceptional condition occurs after which execution could continue. If context specifies that death occurs, then so be it.
<dt><a name="void_BN_exception(PINTD__BN_EXCEPTIONS_exception,_const_char*_message)"
><b><code>void BN_exception(PINTD_ BN_EXCEPTIONS exception, const char *message)</b></code></a></dt>
Throw `exception&#39;. Should be accessed via a <code>BN_EXCEPT</code> macro, this version is provided until Parrot exceptions are sorted out properly.
<dt><a name="INTVAL_BN_to_scientific_string(PINTD__BIGNUM*bn,_char_**dest)"
><b><code>INTVAL BN_to_scientific_string(PINTD_ BIGNUM*bn, char **dest)</b></code></a></dt>
Converts bn into a scientific representation, stored in dest.
<dt><a name="INTVAL_BN_to_engineering_string(PINTD__BIGNUM*bn,_char_**dest)"
><b><code>INTVAL BN_to_engineering_string(PINTD_ BIGNUM*bn, char **dest)</b></code></a></dt>
Converts <code>*bn</code> into a engineering representation, stored in <code>**dest</code>.These functions return <code>char*</code> strings only, parrot may want to reimplement these so that locales and the like are nicely coped with.Any reimplementation should be in a seperate file, this section of the main file can be <code>#ifdef</code>ed out if this is done.Memory pointed to by <code>dest</code> is not freed by this function.
<dt><a name="INTVAL_BN_to_scieng_string(PINTD__BIGNUM*_bn,_char_**dest,_int_eng)"
><b><code>INTVAL BN_to_scieng_string(PINTD_ BIGNUM *bn, char **dest, int eng)</b></code></a></dt>
Does the heavy string handling work, <code>eng</code> defines the conversion to perform.
<dt><a name="BIGNUM*_BN_from_string(PINTD__char*_s2,_BN_CONTEXT_*context)"
><b><code>BIGNUM *BN_from_string(PINTD_ char *s2, BN_CONTEXT *context)</b></code></a></dt>
Convert a scientific string to a BIGNUM. This function deals entirely with common&#45;or&#45;garden C byte strings, so the library can work anywhere. Another version will be eventually required to cope with the parrot string fun.This is the Highly Pedantic string conversion. If <code>context</code> has <code>extended</code> as a true value, then the full range of extended number is made available, and any string which does not match the numeric syntax is converted to a quiet NaN.Does not yet check for exponent overflow.
<dt><a name="int_BN_strip_lead_zeros(PINTD__BIGNUM*_bn,_BN_CONTEXT_*context)"
><b><code>int BN_strip_lead_zeros(PINTD_ BIGNUM *bn, BN_CONTEXT *context)</b></code></a></dt>
Removes any zeros before the msd and after the lsd.
<dt><a name="int_BN_strip_tail_zeros(PINTD__BIGNUM_*bn,_BN_CONTEXT_*context)"
><b><code>int BN_strip_tail_zeros(PINTD_ BIGNUM *bn, BN_CONTEXT *context)</b></code></a></dt>
Removes trailing zeros and increases the exponent appropriately. Does not remove zeros before the decimal point.
<dt><a name="int_BN_make_integer(PINTD__BIGNUM*_bn,_BN_CONTEXT*_context)"
><b><code>int BN_make_integer(PINTD_ BIGNUM *bn, BN_CONTEXT *context)</b></code></a></dt>
Convert the number to a plain integer <i>if</i> precision such that this is possible.
<dt><a name="int_BN_really_zero(PINTD__BIGNUM*_bn,_int_allow_neg_zero)"
><b><code>int BN_really_zero(PINTD_ BIGNUM *bn, int allow_neg_zero)</b></code></a></dt>
Sets any number which should be zero to a canonical zero.To check if a number is equal to zero, use <code>BN_is_zero()</code>.
<dt><a name="void_BN_round(PINTD__BIGNUM_*bn,_BN_CONTEXT*_context)"
><b><code>void BN_round(PINTD_ BIGNUM *bn, BN_CONTEXT *context)</b></code></a></dt>
Rounds <code>*bn</code> according to <code>*context</code>.
<dt><a name="int_BN_iround(PINTD__BIGNUM_*bn,_BN_CONTEXT*_context)"
><b><code>int BN_iround(PINTD_ BIGNUM *bn, BN_CONTEXT *context)</b></code></a></dt>
Rounds victim according to context.Round assumes that any leading zeros are significant (after an addition operation, for instance).If <code>precision</code> is positive, the digit string is rounded to have no more than <code>precision</code> digits. If <code>precision</code> is equal to zero, the number is treated as an integer, and any digits after the number&#39;s decimal point are removed. If <code>precision</code> is negative, the number is rounded so that there are no more than &#45; <code>precision</code> digits after the decimal point.eg. for 1.234567E+3 with rounding of <code>ROUND_DOWN</code>
<pre>    precision:  4 =&#62;  1.234E+3      1234
    precision:  6 =&#62;  1.234567E+3   1234.56
    precision:  9 =&#62;  1.234567E+3   1234.567
    precision:  0 =&#62;  1234          1234
    precision: &#45;1 =&#62;  1.2345E+3     1234.5
    precision: &#45;9 =&#62;  1.234567E+3   1234.567</pre>

<dt><a name="int_BN_round_up(PINTD__BIGNUM_*bn,_BN_CONTEXT*_context)"
><b><code>int BN_round_up(PINTD_ BIGNUM *bn, BN_CONTEXT *context)</b></code></a></dt>
Truncates coefficient of <code>bn</code> to have <code>precision</code> digits, then adds 1 to the last digits and carries until done. Do not call this function with non&#45;positive values of <code>precision</code>.
<dt><a name="int_BN_round_down(PINT__BIGNUM_*bn,_BN_CONTEXT*_context)"
><b><code>int BN_round_down(PINT_ BIGNUM *bn, BN_CONTEXT *context)</b></code></a></dt>
Truncates the coefficient of <code>bn</code> to have <code>precision</code> digits. Do not call this function with non&#45;positive precision.
<dt><a name="void_BN_round_as_integer(PINTD__BIGNUM_*bn,_BN_CONTEXT_*context)"
><b><code>void BN_round_as_integer(PINTD_ BIGNUM *bn, BN_CONTEXT *context)</b></code></a></dt>
<code>precision</code> must be less than one. This rounds so that <code>expn</code> is at least <code>precision</code>. Name is slightly misleading.</dl>

<h2><a name="Arithmetic_operations"
>Arithmetic operations <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Operations are performed like this:</p>

<dl>
<dt><a name="Rounding"
>Rounding</a></dt>
Both operands are rounded to have no more than <code>context&#45;&#62;precision</code> digits.
<dt><a name="Computation"
>Computation</a></dt>
The operation is computed.
<dt><a name="Rounding_of_result"
>Rounding of result</a></dt>
The result is then rounded to context&#45;&#62;precision digits.
<dt><a name="Conversion_to_zero_and_integerisation"
>Conversion to zero and integerisation</a></dt>
If the result is equal to zero, it is made exactly zero.Where the length of the coefficient + the exponent of the result is less than context&#45;&#62;precision, the result is converted into an integer.</dl>

<p>The general form for all arithmetic operations is:</p>

<pre>    void BN_operation(result, one, two, context)</pre>

<dl>
<dt><a name="int_BN_arith_setup(PINTD__BIGNUM*_result,_BIGNUM_*one,_BIGNUM_*two,_BN_CONTEXT_*context,_BN_SAVE_PREC*_restore)"
><b><code>int BN_arith_setup(PINTD_ BIGNUM *result, BIGNUM *one, BIGNUM *two, BN_CONTEXT *context, BN_SAVE_PREC *restore)</b></code></a></dt>
Rounds one and two ready for arithmetic operation.We assume that an operation might extend the digit buffer with zeros on either side, but not tamper with the actual digits of the number, we can then easily return the number to the correct (but still rounded) representation in _cleanup laterIf you can promise that you will not modify the representation of one and two during your operation, then you may pass <code>&#38;restore</code> as a <code>NULL</code> pointer to both setup and cleanup.If overflow or underflow occurs during rounding, the numbers will be modified to the appropriate representation and will not be restorable.
<dt><a name="int_BN_arith_cleanup(PINTD__BIGNUM*_result,_BIGNUM_*one,_BIGNUM_*two,_BN_CONTEXT_*context,_BN_SAVE_PREC*_restore)"
><b><code>int BN_arith_cleanup(PINTD_ BIGNUM *result, BIGNUM *one, BIGNUM *two, BN_CONTEXT *context, BN_SAVE_PREC *restore)</b></code></a></dt>
Rounds <code>result</code>, <code>one</code>, <code>two</code>, checks for zeroness and makes integers. Fixes <code>one</code> and <code>two</code> so they don&#39;t gain precision by mistake.
<dt><a name="int_BN_align(PINTD__BIGNUM*_one,_BIGNUM*_two)"
><b><code>int BN_align(PINTD_ BIGNUM *one, BIGNUM *two)</b></code></a></dt>
Adds zero digits so that decimal points of each number are at the same place.
<dt><a name="void_BN_add(PINTD__BIGNUM*_result,_BIGNUM_*one,_BIGNUM_*two,_BN_CONTEXT_*context)"
><b><code>void BN_add(PINTD_ BIGNUM *result, BIGNUM *one, BIGNUM *two, BN_CONTEXT *context)</b></code></a></dt>
Adds one to two, returning value in result.
<dt><a name="int_BN_iadd(PINTD__BIGNUM*_result,_BIGNUM_*one,_BIGNUM_*two,_BN_CONTEXT_*context)"
><b><code>int BN_iadd(PINTD_ BIGNUM *result, BIGNUM *one, BIGNUM *two, BN_CONTEXT *context)</b></code></a></dt>
Adds together two aligned big numbers with coefficients of equal length. Returns a result without reference to the signs of its arguments. Cannot cope with special values.
<dt><a name="void_BN_subtract(PINTD__BIGNUM*_result,_BIGNUM_*one,_BIGNUM_*two,_BN_CONTEXT_*context)"
><b><code>void BN_subtract(PINTD_ BIGNUM *result, BIGNUM *one, BIGNUM *two, BN_CONTEXT *context)</b></code></a></dt>
Subtracts <code>*two</code> from <code>*one</code>, returning value in <code>*result</code>.
<dt><a name="int_BN_isubtract(PINTD__BIGNUM*_result,_BIGNUM_*one,_BIGNUM_*two,_BN_CONTEXT_*context)"
><b><code>int BN_isubtract(PINTD_ BIGNUM *result, BIGNUM *one, BIGNUM *two, BN_CONTEXT *context)</b></code></a></dt>
Subtracts two from one, assumes both numbers have positive aligned coefficients of equal length. Sets sign of result as appropriate. Cannot cope with special values.
<dt><a name="void_BN_plus(PINTD__BIGNUM*_result,_BIGNUM_*one,_BN_CONTEXT_*context)"
><b><code>void BN_plus(PINTD_ BIGNUM *result, BIGNUM *one, BN_CONTEXT *context)</b></code></a></dt>
Perform unary <code>+</code> on <code>*one</code>. Does all the rounding and what have you.
<dt><a name="void_BN_minus(PINTD__BIGNUM*_result,_BIGNUM_*one,_BN_CONTEXT_*context)"
><b><code>void BN_minus(PINTD_ BIGNUM *result, BIGNUM *one, BN_CONTEXT *context)</b></code></a></dt>
Perform unary <code>&#45;</code> (minus) on <code>*one</code>. Does all the rounding and what have you.
<dt><a name="void_BN_compare(PINT__BIGNUM*_result,_BIGNUM_*one,_BIGNUM_*two,_BN_CONTEXT_*context)"
><b><code>void BN_compare(PINT_ BIGNUM *result, BIGNUM *one, BIGNUM *two, BN_CONTEXT *context)</b></code></a></dt>
Numerically compares <code>*one</code> and <code>*two</code>, storing the result (as a BIGNUM) in <code>*result</code>.
<pre>    result = 1  =&#62; one &#62; two
    result = &#45;1 =&#62; two &#62; one
    result = 0  =&#62; one == two</pre>

<dt><a name="void_BN_multiply(PINTD__BIGNUM*_result,_BIGNUM_*one,_BIGNUM_*two,_BN_CONTEXT_*context)"
><b><code>void BN_multiply(PINTD_ BIGNUM *result, BIGNUM *one, BIGNUM *two, BN_CONTEXT *context)</b></code></a></dt>
Multiplies <code>*one</code> and <code>*two</code>, storing the result in <code>*result</code>.
<dt><a name="int_BN_imultiply(PINTD__BIGNUM*_result,_BIGNUM_*one,_BIGNUM_*two,_BN_CONTEXT_*context)"
><b><code>int BN_imultiply(PINTD_ BIGNUM *result, BIGNUM *one, BIGNUM *two, BN_CONTEXT *context)</b></code></a></dt>
Multiplication without the rounding and other set up.
<dt><a name="void_BN_divide(PINTD__BIGNUM*_result,_BIGNUM_*one,_BIGNUM_*two,_BN_CONTEXT_*context)"
><b><code>void BN_divide(PINTD_ BIGNUM *result, BIGNUM *one, BIGNUM *two, BN_CONTEXT *context)</b></code></a></dt>
Divide two into one, storing up to <code>precision</code> digits in result. Performs own rounding. We also assume that this function <b>will not be used</b> to produce a BigInt. That is the job of <code>divide_integer()</code>.If you want to divide two integers to produce a float, you must do so with <code>precision</code> greater than the number of significant digits in either operand. If you want the result to be an integer or a numer with a fixed fractional part
<dt><a name="void_BN_divide_integer(PINTD__BIGNUM*_result,_BIGNUM_*one,_BIGNUM_*two,_BN_CONTEXT_*context)"
><b><code>void BN_divide_integer(PINTD_ BIGNUM *result, BIGNUM *one, BIGNUM *two, BN_CONTEXT *context)</b></code></a></dt>
Places the integer part of <code>*one</code> divided by <code>*two</code> into <code>*result</code>.
<dt><a name="void_BN_remainder(PINTD__BIGNUM*_result,_BIGNUM_*one,_BIGNUM_*two,_BN_CONTEXT_*context)"
><b><code>void BN_remainder(PINTD_ BIGNUM *result, BIGNUM *one, BIGNUM *two, BN_CONTEXT *context)</b></code></a></dt>
Places the remainder from divide&#45;integer (above) into <code>*result</code>.
<dt><a name="int_BN_idivide(PINT__BIGNUM_*result,_BIGNUM_*one,_BIGNUM_*two,_BN_CONTEXT_*context,_BN_DIV_ENUM_operation,_BIGNUM_*rem)"
><b><code>int BN_idivide(PINT_ BIGNUM *result, BIGNUM *one, BIGNUM *two, BN_CONTEXT *context, BN_DIV_ENUM operation, BIGNUM *rem)</b></code></a></dt>
Does the heavy work for the various division wossnames.
<dt><a name="INTVAL_BN_comp(PINTD__BIGNUM_*one,_BIGNUM_*two,_BN_CONTEXT*_context)"
><b><code>INTVAL BN_comp(PINTD_ BIGNUM *one, BIGNUM *two, BN_CONTEXT *context)</b></code></a></dt>
Comparison with no rounding etc.
<dt><a name="void_BN_power(PINTD__BIGNUM*_result,_BIGNUM*_bignum,_BIGNUM*_expn,_BN_CONTEXT*_context)"
><b><code>void BN_power(PINTD_ BIGNUM *result, BIGNUM *bignum, BIGNUM *expn, BN_CONTEXT *context)</b></code></a></dt>
Calculate <code>result</code> = <code>bignum</code> to the power of <code>*expn</code>;
<dt><a name="void_BN_rescale(PINTD__BIGNUM*_result,_BIGNUM*_one,_BIGNUM*_two,_BN_CONTEXT*_context)"
><b><code>void BN_rescale(PINTD_ BIGNUM *result, BIGNUM *one, BIGNUM *two, BN_CONTEXT *context)</b></code></a></dt>
Rescales <code>*one</code> to have an exponent of <code>*two</code>.
<dt><a name="INTVAL_BN_to_int(PINT__BIGNUM*_bn,_BN_CONTEXT*_context)"
><b><code>INTVAL BN_to_int(PINT_ BIGNUM *bn, BN_CONTEXT *context)</b></code></a></dt>
Converts the bignum into an integer, raises overflow if an exact representation cannot be created.
<dt><a name="INTVAL_BN_is_zero(BIGNUM*_foo,_BN_CONTEXT*_context)"
><b><code>INTVAL BN_is_zero(BIGNUM *foo, BN_CONTEXT *context)</b></code></a></dt>
Returns a boolean value indicating whether <code>*foo</code> is zero.</dl>

<h1><a name="TODO"
>TODO <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>This is currently not used yet. Parrot has no BigNum support yet.</p>

<p>Parrot string playing, exception raising</p>

<p>==head1 SEE ALSO</p>

<p><em>docs/docs/pdds/draft/pdd14_bignum.pod</em>, <a href='https://rt.perl.org/rt3/Ticket/Display.html?id=36330'>https://rt.perl.org/rt3/Ticket/Display.html?id=36330</a></p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../resources/parrot_small.png"
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
