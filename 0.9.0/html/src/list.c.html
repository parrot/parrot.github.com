<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
    <HEAD>
        <TITLE>List aka array routines</TITLE>
        <LINK REL="stylesheet" TYPE="text/css"
            HREF="../../resources/perl.css"
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY>
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">List aka array routines</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../html/index.html">Contents</a> | <a href="../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>src/list.c &#45; List aka array routines</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>List is roughly based on concepts of IntList (thanks to Steve),
so I don&#39;t repeat them here.</p>

<p>Especially the same invariants hold,
except an empty list is really empty,
meaning,
push does first check for space.</p>

<p>The main differences are:</p>

<p>&#45; List can hold items of different size,
it&#39;s suitable for ints and PMCs ...,
calculations are still done in terms of items.
The item_size is specified at list creation time with the &#34;type&#34; argument.</p>

<p>If you later store different item types in the list,
as stated initially,
you&#39;ll get probably not what you want &#45; so don&#39;t do this.</p>

<p>&#45; List does auto grow.
The caller may implement a different behaviour if she likes.</p>

<p>&#45; Error checking for out of bounds access is minimal,
caller knows better,
what should be done.</p>

<p>&#45; List structure itself is different from List_chunk,
implying:</p>

<ul>
<li>end of list is not <code>list&#45;&#62;prev</code> but <code>list&#45;&#62;end</code></li>

<li>start of list is list&#45;&#62;first</li>

<li>the list of chunks is not closed,
detecting the end is more simple</li>

<li>no spare is keeped,
didn&#39;t improve due to size constraints</li>

<li>the List object itself doesn&#39;t move around for shift/unshift</li>
</ul>

<p>&#45; list chunks don&#39;t have <code>&#45;&#62;start</code> and <code>&#45;&#62;end</code> fields.
Instead the list has <code>&#45;&#62;start</code>,
which is start of first chunk,
and <code>&#45;&#62;cap</code>,
the total usable capacity in the list.</p>

<p>&#45; number of items in chunks are not fixed,
but there is a mode using same sized chunks</p>

<h2><a name="Grow_policy"
>Grow policy <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="enum_grow_fixed"
><b><code>enum_grow_fixed</b></code></a></dt>
All chunks are of <code>MAX_ITEMS</code> size,
chosen,
when the first access to the array is indexed and beyond <code>MIN_ITEMS</code> and below 10 * <code>MAX_ITEMS</code>If the first access is beyond 10 * <code>MAX_ITEMS</code> a sparse chunk will be created.To avoid this &#45; and the performance penalty &#45; set the array size before setting elements.
<pre>    new P0, &#39;Array&#39;
    set P0, 100000  # sets fixed sized, no sparse</pre>
This is only meaningful, if a lot of the entries are used too.
<dt><a name="enum_grow_growing"
><b><code>enum_grow_growing</b></code></a></dt>
Chunk sizes grow from <code>MIN_ITEMS</code> to <code>MAX_ITEMS</code>, this will be selected for pushing data on an empty array.
<dt><a name="enum_grow_mixed"
><b><code>enum_grow_mixed</b></code></a></dt>
Mixture of above chunk types and when sparse chunks are present, or after insert and delete.The chunks hold the information, how many chunks are of the same type, beginning from the current, and how many items are included in this range. See <code>get_chunk</code> below for details.</dl>

<h2><a name="Sparse_lists"
>Sparse lists <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>To save memory, List can handle sparse arrays. This code snippet:</p>

<p>new P0, &#39;IntList&#39; set P0[1000000], 42</p>

<p>generates 3 List_chunks, one at the beginning of the array, a big sparse chunk and a chunk for the actual data.</p>

<p>Setting values inside sparse chunks changes them to real chunks. For poping/shifting inside sparse chunks, s. return value below.</p>

<h2><a name="Chunk_types"
>Chunk types <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="fixed_items"
><b><code>fixed_items</b></code></a></dt>
Have allocated space, size is a power of 2, consecutive chunks are same sized.
<dt><a name="grow_items"
><b><code>grow_items</b></code></a></dt>
Same, but consecutive chunks are growing.
<dt><a name="no_power_2"
><b><code>no_power_2</b></code></a></dt>
Have allocated space but any size.
<dt><a name="sparse"
><b><code>sparse</b></code></a></dt>
Only dummy allocation, <code>chunk&#45;&#62;items</code> holds the items of this sparse hole.</dl>

<h2><a name="Data_types"
>Data types <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>A List can hold various datatypes. See <em>src/datatypes.h</em> for the enumeration of types.</p>

<p>Not all are yet implemented in <code>list_set</code>/<code>list_item</code>, see the <code>switch()</code>.</p>

<p>Arbitrary length data:</p>

<p>Construct initializer with:</p>

<dl>
<dt><a name="enum_type_sized"
><b><code>enum_type_sized</b></code></a></dt>

<dt><a name="item_size_(in_bytes)"
><b><code>item_size</b></code> (in bytes)</a></dt>

<dt><a name="items_per_chunk_(rounded_up_to_power_of_2,_default_MAX_ITEMS)"
><b><code>items_per_chunk</b></code> (rounded up to power of 2, default <b><code>MAX_ITEMS</b></code>)</a></dt>
</dl>

<p>In <code>list_assign</code> the values are copied into the array, <code>list_get</code> returns a pointer as for all other data types.</p>

<p>See <em>src/list_2.t</em> and <code>list_new_init()</code>.</p>

<h2><a name="Return_value"
>Return value <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>List get functions return a <code>(void*)</code> pointer to the location of the stored data. The caller has to extract the value from this pointer.</p>

<p>For non existent data beyond the dimensions of the array a <code>NULL</code> pointer is returned.</p>

<p>For non existing data inside sparse holes, a pointer <code>(void*)&#45;1</code> is returned.</p>

<p>The caller can decide to assume these data as undef or 0 or whatever is appropriate.</p>

<h2><a name="Testing"
>Testing <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>See <em>t/src/{int, }list.c</em> and <em>t/pmc/{int, }list.t</em>.</p>

<p>Also all array usage depends on list.</p>

<h2><a name="Functions"
>Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="static_List_chunk_*_allocate_chunk"
><b><code>static List_chunk *allocate_chunk</b></code></a></dt>
Makes a new chunk, and allocates <code>size</code> bytes for buffer storage from the generic memory pool. The chunk holds <code>items</code> items. Marks the chunk as being part of <code>list&#45;&#62;container</code>, if it exists, for the purposes of GC. Does not install the chunk into <code>list&#45;&#62;container</code> yet.
<dt><a name="static_void_rebuild_chunk_ptrs"
><b><code>static void rebuild_chunk_ptrs</b></code></a></dt>
Rebuilds <code>list</code> and updates/optimizes chunk usage. Deletes empty chunks, counts chunks and fixes <code>prev</code> pointers.
<dt><a name="static_void_rebuild_sparse"
><b><code>static void rebuild_sparse</b></code></a></dt>
Combines together adjacent sparse chunks in <code>list</code>.
<dt><a name="static_void_rebuild_other"
><b><code>static void rebuild_other</b></code></a></dt>
Combines together adjacent irregular chunks in <code>list</code>.
<dt><a name="static_void_rebuild_fix_ends"
><b><code>static void rebuild_fix_ends</b></code></a></dt>
Resets some values in <code>list</code> and the lists&#39;s first chunk. Called by <code>rebuild_chunk_list()</code>.
<dt><a name="static_UINTVAL_rebuild_chunk_list"
><b><code>static UINTVAL rebuild_chunk_list</b></code></a></dt>
Optimises <code>list</code> when it&#39;s been modified in some way. Combines adjacent chunks if they are both sparse or irregular. Updates the grow policies and computes list statistics.
<dt><a name="static_List_chunk_*_alloc_next_size"
><b><code>static List_chunk *alloc_next_size</b></code></a></dt>
Calculates the size and number of items for the next chunk and allocates it. Adds the number of allocated items to the list&#39;s total, but does not directly add the chunk to the <code>list</code>.
<dt><a name="static_List_chunk_*_add_chunk"
><b><code>static List_chunk *add_chunk</b></code></a></dt>
Adds a new chunk to the <code>list</code>. If <code>where</code> is 0, the chunk is added to the front of the list. If 0, it is added to the end of the list.
<dt><a name="UINTVAL_ld"
><b><code>UINTVAL ld</b></code></a></dt>
Calculates log2(x), or a useful approximation thereof. Stolen from <em>src/malloc.c</em>.
<dt><a name="static_List_chunk_*_get_chunk"
><b><code>static List_chunk *get_chunk</b></code></a></dt>
Get the chunk for <code>idx</code>, also update the <code>idx</code> to point into the chunk.This routine will be called for every operation on list, so it&#39;s optimized to be fast and needs an up&#45;to&#45;date chunk statistic. <code>rebuild_chunk_list</code> provides the necessary chunk statistics.The scheme of operations is:
<pre>    if all_chunks_are_MAX_ITEMS
         chunk = chunk_list[ idx / MAX_ITEMS ]
         idx =   idx % MAX_ITEMS
         done.

    chunk = first
    repeat
         if (index &#60; chunk&#45;&#62;items)
             done.

     if (index &#62;= items_in_chunk_block)
         index &#45;= items_in_chunk_block
         chunk += chunks_in_chunk_block
         continue

     calc chunk and index in this block
     done.</pre>
One chunk_block consists of chunks of the same type: fixed, growing or other. So the time to look up a chunk doesn&#39;t depend on the array length, but on the complexity of the array. <code>rebuild_chunk_list</code> tries to reduce the complexity, but may fail, if you e.g. do a prime sieve by actually <code>list_delet</code>ing the none prime numbers.The complexity of the array is how many different <code>chunk_blocks</code> are there. They come from:&#45; initially fixed: 1&#45; initially growing: 2&#45; first unshift: 1 except for initially fixed arrays&#45; insert: 1 &#45; 3&#45; delete: 1 &#45; 2&#45; sparse hole: 3 (could be 2, code assumes access at either end now)There could be some optimizer, that, after detecting almost only indexed access after some time, does reorganize the array to be all <code>MAX_ITEMS</code> sized, when this would improve performance.
<dt><a name="static_void_split_chunk"
><b><code>static void split_chunk</b></code></a></dt>
Splits a sparse chunk, so that we have&#45; allocated space at <code>idx</code>if sparse is big:&#45; <code>MAX_ITEMS</code> near <code>idx</code> and if there is still sparse space after the real chunk, this also <code>n*MAX_ITEMS</code> sized, so that consecutive writing would make <code>MAX_ITEMS</code> sized real chunks.
<dt><a name="static_void_list_set"
><b><code>static void list_set</b></code></a></dt>
Sets <code>item</code> of type <code>type</code> in chunk at <code>idx</code>.
<dt><a name="static_void_*_list_item"
><b><code>static void *list_item</b></code></a></dt>
Get the pointer to the item of type <code>type</code> in the chunk at <code>idx</code>.
<dt><a name="static_void_list_append"
><b><code>static void list_append</b></code></a></dt>
Adds one or more chunks to end of list.</dl>

<h2><a name="Public_Interface_Functions"
>Public Interface Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="List_*_list_new"
><b><code>List *list_new</b></code></a></dt>
Returns a new list of type <code>type</code>.
<dt><a name="void_list_pmc_new"
><b><code>void list_pmc_new</b></code></a></dt>
Creates a new list containing PMC* values in <code>PMC_data(container)</code>.
<dt><a name="List_*_list_new_init"
><b><code>List *list_new_init</b></code></a></dt>
<code>list_new_init()</code> uses these initializers:
<pre>    0 ... size (set initial size of list)
    1 ... array dimensions (multiarray)
    2 ... type (overriding type parameter)
    3 ... item_size for enum_type_sized
    4 ... items_per_chunk</pre>
After getting these values out of the key/value pairs, a new array with these values is stored in user_data, where the keys are explicit.
<dt><a name="void_list_pmc_new_init"
><b><code>void list_pmc_new_init</b></code></a></dt>
Creates a new list of PMC* values in <code>PMC_data(container)</code>.
<dt><a name="List_*_list_clone"
><b><code>List *list_clone</b></code></a></dt>
Returns a clone of the <code>other</code> list.TODO &#45; Barely tested. Optimize new array structure, fixed if big.
<dt><a name="void_list_mark"
><b><code>void list_mark</b></code></a></dt>
Marks the list and its contents as live for the memory management system.
<dt><a name="void_list_visit"
><b><code>void list_visit</b></code></a></dt>
This is used by freeze/thaw to visit the contents of the list.<code>pinfo</code> is the visit info, (see include/parrot/pmc_freeze.h&#62;).
<dt><a name="INTVAL_list_length"
><b><code>INTVAL list_length</b></code></a></dt>
Returns the length of the list.
<dt><a name="void_list_set_length"
><b><code>void list_set_length</b></code></a></dt>
Sets the length of the list to <code>len</code>.
<dt><a name="void_list_insert"
><b><code>void list_insert</b></code></a></dt>
Makes room for <code>n_items</code> at <code>idx</code>.
<dt><a name="void_list_delete"
><b><code>void list_delete</b></code></a></dt>
Deletes <code>n_items</code> at <code>idx</code>.
<dt><a name="void_list_push"
><b><code>void list_push</b></code></a></dt>
Pushes <code>item</code> of type <code>type</code> on to the end of the list.
<dt><a name="void_list_unshift"
><b><code>void list_unshift</b></code></a></dt>
Pushes <code>item</code> of type <code>type</code> on to the start of the list.
<dt><a name="void_*_list_pop"
><b><code>void *list_pop</b></code></a></dt>
Removes and returns the last item of type <code>type</code> from the end of the list.
<dt><a name="void_*_list_shift"
><b><code>void *list_shift</b></code></a></dt>
Removes and returns the first item of type <code>type</code> from the start of the list.
<dt><a name="void_list_assign"
><b><code>void list_assign</b></code></a></dt>
Assigns <code>item</code> of type <code>type</code> to index <code>idx</code>.
<dt><a name="void_*_list_get"
><b><code>void *list_get</b></code></a></dt>
Returns the item of type <code>type</code> at index <code>idx</code>.
<dt><a name="void_list_splice"
><b><code>void list_splice</b></code></a></dt>
Replaces <code>count</code> items starting at <code>offset</code> with the items in <code>value</code>.If <code>count</code> is 0 then the items in <code>value</code> will be inserted after <code>offset</code>.</dl>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../resources/parrot_small.png"
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
