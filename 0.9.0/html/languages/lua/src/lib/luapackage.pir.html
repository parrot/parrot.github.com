<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
    <HEAD>
        <TITLE>Lua Package Library</TITLE>
        <LINK REL="stylesheet" TYPE="text/css"
            HREF="../../../../../resources/perl.css"
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY>
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Lua Package Library</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../../../html/index.html">Contents</a> | <a href="../../../../../html/languages.html">Language Implementations</a> | <a href="../../../../../html/lua.html">Lua</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../../../resources/up.gif'></a></a></h1>

<p>lib/luapackage.pir &#45; Lua Package Library</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../../../resources/up.gif'></a></a></h1>

<p>The package library provides basic facilities for loading and building modules in Lua.
It exports two of its functions directly in the global environment: <code>require</code> and <code>module</code>.
Everything else is exported in a table <code>package</code>.</p>

<p>See &#34;Lua 5.1 Reference Manual&#34;,
section 5.3 &#34;Modules&#34;,
<a href='http://www.lua.org/manual/5.1/manual.html#5.3'><a href="http://www.lua.org/manual/5.1/manual.html#5.3">http://www.lua.org/manual/5.1/manual.html#5.3</a></a>.</p>

<h2><a name="Functions_&#38;_Variables"
>Functions &#38; Variables <a href='#_top'><img alt='^' border=0 src='../../../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="module_(name_[,_...])"
><b><code>module (name [, ...])</b></code></a></dt>
Creates a module.
If there is a table in <code>package.loaded[name]</code>,
this table is the module.
Otherwise,
if there is a global table <code>t</code> with the given name,
this table is the module.
Otherwise creates a new table <code>t</code> and sets it as the value of the global <code>name</code> and the value of <code>package.loaded[name]</code>.
This function also initializes <code>t._NAME</code> with the given name,
<code>t._M</code> with the module (<code>t</code> itself),
and <code>t._PACKAGE</code> with the package name (the full module name minus last component; see below).
Finally,
<code>module</code> sets <code>t</code> as the new environment of the current function and the new value of <code>package.loaded[name]</code>,
so that <code>require</code> returns <code>t</code>.If <code>name</code> is a compound name (that is,
one with components separated by dots),
<code>module</code> creates (or reuses,
if they already exist) tables for each component.
For instance,
if <code>name</code> is <code>a.b.c</code>,
then <code>module</code> stores the module table in field <code>c</code> of field <code>b</code> of global <code>a</code>.This function may receive optional <i>options</i> after the module name,
where each option is a function to be applied over the module.
<dt><a name="require_(modname)"
><b><code>require (modname)</b></code></a></dt>
Loads the given module.
The function starts by looking into the table <code>package.loaded</code> to determine whether <code>modname</code> is already loaded.
If it is,
then <code>require</code> returns the value stored at <code>package.loaded[modname]</code>.
Otherwise,
it tries to find a <i>loader</i> for the module.To find a loader,
first <code>require</code> queries <code>package.preload[modname]</code>.
If it has a value,
this value (which should be a function) is the loader.
Otherwise <code>require</code> searches for a Lua loader using the path stored in <code>package.path</code>.
If that also fails,
it searches for a C loader using the path stored in <code>package.cpath</code>.
If that also fails,
it tries an all&#45;in&#45;one loader (see below).If there is any error loading or running the module,
or if it cannot find any loader for the module,
then <code>require</code> signals an error.
<dt><a name="package.cpath"
><b><code>package.cpath</b></code></a></dt>
The path used by <code>require</code> to search for a C loader.Lua initializes the C path <code>package.cpath</code> in the same way it initializes the Lua path <code>package.path</code>,
using the environment variable <code>LUA_CPATH</code> (plus another default path).NOT USED (see package.pbcpath).
<dt><a name="package.loaded"
><b><code>package.loaded</b></code></a></dt>
A table used by <code>require</code> to control which modules are already loaded.
When you require a module <code>modname</code> and <code>package.loaded[modname]</code> is not false,
<code>require</code> simply returns the value stored there.
<dt><a name="package.loadlib_(libname,_funcname)"
><b><code>package.loadlib (libname, funcname)</b></code></a></dt>
Dynamically links the host program with the C library <code>libname</code>.
Inside this library,
looks for a function <code>funcname</code> and returns this function as a C function.This is a low&#45;level function.
It completely bypasses the package and module system.
Unlike <code>require</code>,
it does not perform any path searching and does not automatically adds extensions.
<code>libname</code> must be the complete file name of the C library,
including if necessary a path and extension.
<code>funcname</code> must be the exact name exported by the C library .NOT YET IMPLEMENTED.
<dt><a name="package.path"
><b><code>package.path</b></code></a></dt>
The path used by <code>require</code> to search for a Lua loader.At start&#45;up,
Lua initializes this variable with the value of the environment variable <code>LUA_PATH</code> or with a default path,
if the environment variable is not defined.
Any <code>&#34;;;&#34;</code> in the value of the environment variable is replaced by the default path.A path is a sequence of <i>templates</i> separated by semicolons.
For each template,
<code>require</code> will change each interrogation mark in the template by <code>filename</code>,
which is <code>modname</code> with each dot replaced by a <code>&#34;directory separator&#34;</code> (such as <code>&#34;/&#34;</code> in Unix); then it will try to load the resulting file name.
So,
for instance,
if the Lua path is
<pre>  &#34;./?.lua;./?.lc;/usr/local/?/init.lua&#34;</pre>
the search for a Lua loader for module <code>foo</code> will try to load the files <code>./foo.lua</code>, <code>./foo.lc</code>, and <code>/usr/local/foo/init.lua</code>, in that order.STILL INCOMPLETE (see default).
<dt><a name="package.pbcpath"
><b><code>package.pbcpath</b></code></a></dt>
The path used by <code>require</code> to search for a PBC loader.STILL INCOMPLETE (see default).
<dt><a name="package.preload"
><b><code>package.preload</b></code></a></dt>
A table to store loaders for specific modules (see <code>require</code>).
<dt><a name="package.seeall_(module)"
><b><code>package.seeall (module)</b></code></a></dt>
Sets a metatable for <code>module</code> with its <code>__index</code> field referring to the global environment, so that this module inherits values from the global environment. To be used as an option to function <code>module</code>.</dl>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../../../resources/parrot_small.png"
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
