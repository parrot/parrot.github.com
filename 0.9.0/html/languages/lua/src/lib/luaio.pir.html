<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
    <HEAD>
        <TITLE>Lua Input/Output Library</TITLE>
        <LINK REL="stylesheet" TYPE="text/css"
            HREF="../../../../../resources/perl.css"
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY>
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Lua Input/Output Library</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../../../html/index.html">Contents</a> | <a href="../../../../../html/languages.html">Language Implementations</a> | <a href="../../../../../html/lua.html">Lua</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../../../resources/up.gif'></a></a></h1>

<p>lib/luaio.pir &#45; Lua Input/Output Library</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../../../resources/up.gif'></a></a></h1>

<p>The I/O library provides two different styles for file manipulation.
The first one uses implicit file descriptors,
that is,
there are operations to set a default input file and a default output file,
and all input/output operations are over those default files.
The second style uses explicit file descriptors.</p>

<p>When using implicit file descriptors,
all operations are supplied by table <code>io</code>.
When using explicit file descriptors,
the operation <code>io.open</code> returns a file descriptor and then all operations are supplied as methods by the file descriptor (see <em>languages/lua/lib/luafile.pir</em>).</p>

<p>The table <code>io</code> also provides three predefined file descriptors with their usual meanings from C: <code>io.stdin</code>,
<code>io.stdout</code>,
and <code>io.stderr</code>.</p>

<p>Unless otherwise stated,
all I/O functions return <b>nil</b> on failure (plus an error message as a second result) and some value different from <b>nil</b> on success.</p>

<p>See &#34;Lua 5.1 Reference Manual&#34;,
section 5.7 &#34;Input and Ouput Facilities&#34;,
<a href='http://www.lua.org/manual/5.1/manual.html#5.7'><a href="http://www.lua.org/manual/5.1/manual.html#5.7">http://www.lua.org/manual/5.1/manual.html#5.7</a></a>.</p>

<h2><a name="Functions"
>Functions <a href='#_top'><img alt='^' border=0 src='../../../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="io.close_([file])"
><b><code>io.close ([file])</b></code></a></dt>
Equivalent to <code>file:close()</code>.
Without a <code>file</code>,
closes the default output file.
<dt><a name="io.flush_()"
><b><code>io.flush ()</b></code></a></dt>
Equivalent to <code>file:flush</code> over the default output file.
<dt><a name="io.input_([file])"
><b><code>io.input ([file])</b></code></a></dt>
When called with a file name,
it opens the named file (in text mode),
and sets its handle as the default input file.
When called with a file handle,
it simply sets that file handle as the default input file.
When called without parameters,
it returns the current default input file.In case of errors this function raises the error,
instead of returning an error code.
<dt><a name="io.lines_([filename])"
><b><code>io.lines ([filename])</b></code></a></dt>
Opens the given file name in read mode and returns an iterator function that,
each time it is called,
returns a new line from the file.
Therefore,
the construction
<pre>    for line in io.lines(filename) do ... end</pre>
will iterate over all lines of the file. When the iterator function detects the end of file, it returns <b>nil</b> (to finish the loop) and automatically closes the file.The call <code>io.lines()</code> (without a file name) is equivalent to <code>io.input():lines()</code>, that is, it iterates over the lines of the default input file. In this case it does not close the file when the loop ends.
<dt><a name="io.open_(filename_[,_mode])"
><b><code>io.open (filename [, mode])</b></code></a></dt>
This function opens a file, in the mode specified in the string <code>mode</code>. It returns a new file handle, or, in case of errors, <b>nil</b> plus an error message.The <code>mode</code> string can be any of the following:
<dl>
<dt><a name="&#34;r&#34;"
><b>&#34;r&#34;</b></a></dt>
read mode (the default);
<dt><a name="&#34;w&#34;"
><b>&#34;w&#34;</b></a></dt>
write mode;
<dt><a name="&#34;a&#34;"
><b>&#34;a&#34;</b></a></dt>
append mode;
<dt><a name="&#34;r+&#34;"
><b>&#34;r+&#34;</b></a></dt>
update mode, all previous data is preserved;
<dt><a name="&#34;w+&#34;"
><b>&#34;w+&#34;</b></a></dt>
update mode, all previous data is erased;
<dt><a name="&#34;a+&#34;"
><b>&#34;a+&#34;</b></a></dt>
append update mode, previous data is preserved, writing is only allowed at the end of file.</dl>
The <code>mode</code> string may also have a <code>b</code> at the end, which is needed in some systems to open the file in binary mode. This string is exactly what is used in the standard C function <code>fopen</code>.
<dt><a name="io.output_([file])"
><b><code>io.output ([file])</b></code></a></dt>
Similar to <code>io.input</code>, but operates over the default output file.
<dt><a name="io.popen_([prog_[,_mode]])"
><b><code>io.popen ([prog [, mode]])</b></code></a></dt>
Starts program <code>prog</code> in a separated process and returns a file handle that you can use to read data from this program (if <code>mode</code> is <code>&#34;r&#34;</code>, the default) or to write data to this program (if <code>mode</code> is <code>&#34;w&#34;</code>).This function is system dependent and is not available on all platforms.NOT YET IMPLEMENTED.
<dt><a name="io.read_(format1,_...)"
><b><code>io.read (format1, ...)</b></code></a></dt>
Equivalent to <code>io.input():read</code>.
<dt><a name="io.tmpfile_()"
><b><code>io.tmpfile ()</b></code></a></dt>
Returns a handle for a temporary file. This file is open in update mode and it is automatically removed when the program ends.
<dt><a name="io.type_(obj)"
><b><code>io.type (obj)</b></code></a></dt>
Checks whether <code>obj</code> is a valid file handle. Returns the string <code>&#34;file&#34;</code> if <code>obj</code> is an open file handle, <code>&#34;closed file&#34;</code> if <code>obj</code> is a closed file handle, and <b>nil</b> if <code>obj</code> is not a file handle.
<dt><a name="io.write_(value1,_...)"
><b><code>io.write (value1, ...)</b></code></a></dt>
Equivalent to <code>io.output():write</code>.</dl>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../../../resources/parrot_small.png"
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
