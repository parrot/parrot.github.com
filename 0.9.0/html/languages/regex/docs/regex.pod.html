<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
    <HEAD>
        <TITLE>Irregular expressions and how to implement &#39;em (WORK IN PROGRESS)</TITLE>
        <LINK REL="stylesheet" TYPE="text/css"
            HREF="../../../../resources/perl.css"
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY>
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Irregular expressions and how to implement &#39;em (WORK IN PROGRESS)</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../../html/index.html">Contents</a> | <a href="../../../../html/languages.html">Language Implementations</a> | <a href="../../../../html/regex.html">Regex</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="TITLE"
>TITLE <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>Irregular expressions and how to implement &#39;em (WORK IN PROGRESS)</p>

<h1><a name="OVERVIEW"
>OVERVIEW <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>This document describes how the languages/regex compiler implements perl5/6&#45;style regular expressions.
I know; I really should come up with a better name than &#34;languages/regex&#34;.</p>

<h1><a name="PHILOSOPHY"
>PHILOSOPHY <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>Everything must be implemented with primitive operations.
The compiler should be language&#45;agnostic,
for both the input and output.
Operations are implemented independently.
Control flow is explicit: operations maintain their own state and do direct jumps to the next operation (or back to the previous,
when failing).
Optimizations should apply as generally as possible.</p>

<h1><a name="STAGES"
>STAGES <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>The input to the compiler is a tree containing the expression to be compiled.
This tree is traversed to gather information for optimization,
optimized,
and then converted to a simple list of operators.
This list is then itself optimized with a peephole optimizer,
and finally converted to the target language.</p>

<p>The initial tree is constructed out of what are called &#34;tree ops&#34;,
and are compiled into different (simpler) ops referred to as &#34;list ops&#34;.
Dumb names,
but simple,
yes?</p>

<h1><a name="EXAMPLE"
>EXAMPLE <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>We&#39;ll compile the expression (a|bc)* down to the list ops,
ignoring optimizations.</p>

<p>The tree representing that expression is:</p>

<pre>  star
    alternate
      literal(a)
      sequence
        literal(b)
        literal(c)</pre>

<h2><a name="REWRITING_A_GREEDY_CLOSURE_(R*)"
>REWRITING A GREEDY CLOSURE (R*) <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>First, we apply the &#39;star&#39; rewrite rule. This rule says R* is converted to</p>

<pre> 1   start: push 0
 2    loop: R or next
 3          push 1
 4          goto loop
 5    back: popint &#45;&#62; $temp
 6          if ($temp) goto R.back
 7          goto lastback
 8    next:</pre>

<p>This is a sequence of list ops that are expected to be run sequentially. It is entered at the top, and on success will end up at the &#39;next&#39; label. On failure, control should transfer to &#39;lastback&#39;, which is a label passed into the rewrite engine from a previous rewrite that is used to inform the previous tree op that matching has failed. &#39;back&#39; is the label for the &#39;star&#39; tree op, which will be used as the &#39;lastback&#39; for the subsequent op. (&#39;loop&#39; is a local label used only within this rewritten code segment.) &#39;next&#39;, &#39;back&#39;, and &#39;lastback&#39; are common to all rewrite rules.</p>

<p>Let&#39;s walk through the code line by line.</p>

<p>Line 1 is pushing a value onto the regex stack. The regex stack should *not* be the same stack used for control flow or subroutine parameter passing in the host language; it should be an independent stack that can be manipulated independently of the regular stack(s). In Parrot, normally an IntList PMC would be used. The zero value will be used in this case to record that we have not yet matched any occurrences of the subexpression R. We will see later how this is used.</p>

<p>Line 2 is really a placeholder for the recursively rewritten ops for the subexpression R. The &#39;or next&#39; assigns the &#39;lastback&#39; label for the rewrite of R; intuitively, &#34;R or SOMELABEL means &#34;try to match R, and if you fail, clean up any partial state and then jump to SOMELABEL.&#34;</p>

<p>Line 3 records the fact that we have matched R at least once. Remember, the rewrite rule for R will allow control flow to continue past the generated code if it succeeds (effectively, line 3 will end up prefixed with the &#39;next&#39; label for the R rewrite).</p>

<p>Line 4 goes back to the top of the loop and tries to match another R. At this point, we can see basically how this rewrite rule will work: it attempts to match R as many times as possible. When it finally fails, it will jump to the &#39;next&#39; label to continue matching the rest of the overall regular expression. That corresponds with how a backtracking regular expression engine is supposed to behave.</p>

<p>Line 5 says what to do if the remainder of the regular expression fails. It will be returned from this rewrite rule and most probably used as the &#39;lastback&#39; of the next subexpression in a sequence. To the expression R* that is currently being rewritten, it means to backtrack and try to find a different way of matching R*. If this is confusing, consider what happens with the perl code <code>&#34;eek!&#34; =~ /e*ek/</code>. First, as many e&#39;s as possible are matched; in this case, that means 2. Then the engine tries to match another &#39;e&#39;, which fails (we already used up both e&#39;s on the e* match.) So, it backs up and tries to find another way of matching e*. In this case, it&#39;s possible by matching only one e instead of both. So it continues again to the remainder of the expression, trying to match another &#39;e&#39; (which succeeds) and then a &#39;k&#39; (which also succeeds). At this point, we stop, because the entire expression has been matched successfully. If the pattern had instead been /e*ej/, then the same thing would have happened up until we tried to match the &#39;k&#39;, which would fail. So it would undo the &#39;e&#39; match and try yet another way to match e*. This attempt would succeed yet again, this time by matching zero occurrences of &#39;e&#39; (remember, * means zero or more). It would continue, trying once again to match &#34;ej&#34;, and would once again fail. Finally, it would try one last time to match e*, which would fail because every possible way has already been tried. It would propagate this failure back to e*&#39;s predecessor (just like the &#39;ej&#39; did to its predecessor), which in this case is the overall expression, so the whole expression would fail.</p>

<p>Back to our rewrite example, still on line 5. The following expression has failed to match, so we need to find another way of matching the current expression (if possible). So we pop our signal value off of the regex stack, and test whether we matched any R&#39;s to begin with. If so, then we try to match the last&#45;matched R in a different way, by jumping to its &#39;back&#39; label. (Think of the example /(a|b)*/ &#45;&#45; you&#39;d want to try matching &#34;aaa&#34;, and then &#34;aab&#34; if that failed. Only if both of those failed would you go onto things like &#34;aa&#34;, &#34;ab&#34;, etc.)</p>

<p>Popping the signal value off of the regex stack actually serves two different purposes. The first is described in the previous paragraph: the value is needed to figure out whether we have any matched R&#39;s to backtrack through. The second purpose is to clean up after ourselves. Part of the duty of the &#39;back&#39; label is to restore the program&#39;s state to what it was before the current subexpression attempted to match. The two main parts of that state are the position marker within the input string, and the regex stack. The &#34;languages/regex&#34; compiler makes the policy that every rewrite rule must clean up after itself (and *only* itself). That means that, since this rewrite rule does not modify the input position pointer, it should not undo any changes to it either. That responsibility is left to the rewrite rules that actually consume input themselves, such as literal character matches (which advance the pointer by one when they match, and back it up by one when they backtrack).</p>

<p>Line 7 is reached if we have never successfully matched any R (or did, but have backtracked back past all of them.) It means that the overall R* rule has failed, and we should backtrack to the caller&#39;s &#39;lastback&#39; label.</p>

<p>Line 8 is just a label for the beginning of the subsequent expression, used here only so that we have somewhere to jump to.</p>

<p>So there&#39;s the whole rewrite rule &#45;&#45; but there&#39;s something missing. Think about the expression /a*/. If given an input string three characters long, it should try to match &#34;aaa&#34;, then &#34;aa&#34;, then &#34;a&#34;, and then finally &#34;&#34;. Where in this rewrite rule do we &#34;unmatch&#34; an &#39;a&#39;? It should be in the &#39;back&#39; label, because we only want to unmatch things if the following expression fails.</p>

<p>And that is exactly where it is. When we jump to R.back, it will undo whatever it previously did (in the case of /a*/, it will back up the position marker in the input string by one character). The only other evidence that we every matched the extra &#39;a&#39; is the marker value that we pushed onto the regex stack, and we undo that too. So if R.back is unable to find another way of matching R (and it never will, in the case of /a/, since there&#39;s only one way that it could ever match), then it will jump to the WHATEVER label in the &#34;or WHATEVER&#34; clause. But by the time it reaches WHATEVER, it will have completely undone the last (failed) match of R.</p>

<h2><a name="REWRITING_AN_ALTERNATION_(R|S)"
>REWRITING AN ALTERNATION (R|S) <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Whew. So we now know how to rewrite R*. To continue with our example &#45;&#45; you remember our original example, right? &#45;&#45; we need to now compile /a|bc/. We will do this with a rewrite rule for alternation, which covers any /R|S/ expression.</p>

<pre>   R|S &#45;&#62; start: R or tryS
                 push 0
                 goto next
           tryS: S or lastback
                 push 1
                 goto next
           back: popint &#45;&#62; I0
                 eq I0, 0, R.back
                 goto S.back
           next:</pre>

<p>(This could be very slightly simplified, but the form given is easily extended to R|S|T|U|...)</p>

<p>In many ways, this is very similar to the R* case. I will describe it in more general terms.</p>

<p>This rewrite rule first attempts to match R. If R matches, then R&#39;s partial state will be stored onto the regex stack, and we&#39;ll push a zero on top of the stack so that when we backtrack, we know whether we should try to match R in a different way, or whether R has already been matched every way possible and we should backtrack into S instead. If (or once) R fails, we&#39;ll try matching S, which in turn will leave its partial state on the stack, and we&#39;ll push a one marker on top of it.</p>

<p>When the following expression fails and jumps to our &#39;back&#39; label, we&#39;ll first pop the marker off the stack to figure out which expression was currently being matched. We&#39;ll then jump to the appropriate backtracking label within that expression.</p>

<p>I&#39;m guessing your head is hurting about as much as mine right now, so I&#39;ll throw in one more thing to see if I can make it completely explode. Notice that this expression never jumps directly to &#39;lastback&#39; itself. Instead, it passes &#39;lastback&#39; into the rewriter for a subexpression, so that the subexpression&#39;s failure will trigger an immediate jump to the &#39;lastback&#39; label. This works only because all rewriters follow the policies previously described: in particular, a subexpression is responsible for cleaning up its partial state before failing and jumping to its &#39;lastback&#39; label. So in the example of R|S above, the only information on the regex stack at the point S.back is jumped to (S.back refers to S&#39;s &#39;back&#39; label, by the way) is the partial state of S. So once S fails, there will be no trace of it on the stack, and hence no trace of the R|S match either. (This is also true of R failing; however, the rewrite rule for R was passed &#39;tryS&#39; as its &#39;lastback&#39; label, so the state difference is stored within the generated code itself, and need not be on the stack.)</p>

<p>If you&#39;re still reading at this point, then either your head did not explode, or I am now writing for whoever wiped your brains off of the ceiling and was curious as to what caused to catastrophe. So, let&#39;s go on to the simplest rewrite rule of all, and almost the only one that actually does any work:</p>

<h2><a name="REWRITING_A_SINGLE&#45;CHARACTER_MATCH"
>REWRITING A SINGLE&#45;CHARACTER MATCH <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Now we have to match the trivial expression /a/. This is easy, right? You just do &#34;if input[pos] != &#39;a&#39;, then goto lastback&#34;, right?</p>

<p>Wrong. But it&#39;s not too bad:</p>

<pre>    &#39;a&#39; &#45;&#62; start: if pos &#62;= length(input), goto lastback
                  if input[pos] != &#39;a&#39;, goto lastback
                  pos++
                  goto next
            back: pos&#45;&#45;
                  goto lastback
            next:</pre>

<p>Notice that the pos variable is incremented on a match, and restored on backtracking. This follows the policy I described above, but notice that it is not the only (or even the fastest) way to do it. For example, consider &#39;a*&#39;. If &#39;a&#39; matches 50 times but the whole expression ultimately fails, &#39;a&#39; will have to be unmatched 50 times. But remember the rewrite rule for &#39;*&#39;? It saves a signal value saying whether its subexpression has matched yet or not. But what if it used &#39;pos&#39; as the signal value? Then instead of popping the value into a temporary variable and testing it for zero, it could pop the value directly into &#39;pos&#39; (and test it for zero instead). Of course, that only works at the beginning of the string, but you could push the offset of pos from the beginning of when you tried to match &#39;a*&#39; or whatever.</p>

<p>The real problem is that this violates the philosophy of generating each expression independently &#45;&#45; the rewrite rule for R* would change depending on exactly what R is. Maintaining a dozen different rewrite rules for every tree operator would be a major pain in the posterior.</p>

<h2><a name="REWRITING_THE_SEQUENCE_RS"
>REWRITING THE SEQUENCE RS <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>We now know how to rewrite everything in the sample expression except for the &#39;sequence&#39; tree op. The specific case of /bc/ is easy, but let&#39;s consider the more general RS. It becomes:</p>

<pre> start: R or lastback
        S or R.back
        goto next
  back: goto S.back
  next:</pre>

<p>Actually, that&#39;s probably not really the way it&#39;s implemented. Too many jumps. More likely, &#39;back&#39; would be set equal to &#39;S.back&#39;, and it would just be:</p>

<pre> start: R or lastback
        S or R.back
  next: </pre>

<p>Yay, no excess jumps!</p>

<h2><a name="LIES!!_ALL_LIES!!!"
>LIES!! ALL LIES!!! <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>(scanning)</p>

<h2><a name="OPTIMIZATIONS"
>OPTIMIZATIONS <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>If you put all that together, you get a lot of code. 34 lines, if I&#39;m counting correctly. More, in fact, than is strictly necessary. Here is something closer to the minimum necessary for the subexpression /(a|bc)*/:</p>

<pre> start: push 0
  loop: if pos &#62;= length(input) goto next
        if input[pos] == &#39;a&#39; goto gotA
        if input[pos] == &#39;b&#39; goto gotB
  fail: pop $temp
        if $temp == 0 goto lastback
        pos &#45;= $temp
        goto next
  gotA: pos++
        push 1
        goto loop
  gotB: if pos+1 &#62;= length(input) goto fail
        if input[pos+1] != &#39;c&#39; goto fail
        pos += 2
        push 2
        goto loop
  back: goto fail (or really, make back == fail)
  next:</pre>

<p>There are some small bits of cheating in there (<code>if pos+1 </code>= length&#62;), but if you complain about those then I&#39;ll convert the tests for &#39;a&#39; and &#39;b&#39; into a jump table keyed off of input[pos], so phbbttt!!</p>

<p>So what happened? What inefficiencies led us to the code that was twice as long?</p>

<p>Well, one thing has been previously mentioned: if we discard the notion of being able to rewrite tree ops independently of each other, then we gain back some of the slop. (Here, we use the usual stack state that the star operator keeps to store the size the subexpression matched &#45;&#45; either 1 or 2, or zero to flag the beginning of the whole search.) But that doesn&#39;t actually buy very much.</p>

<p>A major difference with the optimized code is that it makes use of the fact that if /a/ matches at one point in the input string, we know that /bc/ will not, and vice versa. That means that we don&#39;t need to keep track of which alternative we used in order to backtrack correctly, because if one alternative matches and then is backtracked through, we need not bother to try the other alternative; we know the whole alternation will fail. And that simplifies alternation immensely &#45;&#45; we don&#39;t need to remember anything on the stack, so we don&#39;t need to undo any alternation&#45;specific state either.</p>

<p>Notice that these optimizations aren&#39;t horribly complicated; they are a fairly natural consequence of noticing certain properties about the expression being compiled. If we added in a preprocessing step that scans through the whole op tree to detect these exploitable situations, we might even be able to automate them. That is exactly what &#34;languages/regex&#34; does, although it currently only implements a small handful of optimizations.</p>

<h1><a name="GENERAL_REWRITING"
>GENERAL REWRITING <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>So now we&#39;ve seen several examples of rewrite rules. I will now describe rewrite rules in general, and lay out the contract that a rewrite must follow in order to be used within the overall system.</p>

<h2><a name="CONTROL_FLOW_API"
>CONTROL FLOW API <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>A rewrite rule must define four control flow points, two incoming and two outgoing: the initial entry point when attempting to process the match (&#39;start&#39;); the exit point where the following match is begun (&#39;next&#39;); the entry point when backtracking through the rewrite code to attempt the match in a different way (&#39;back&#39;); and the exit label to use when the match fails completely and must backtrack through the calling expression (&#39;lastback&#39;).</p>

<h2><a name="STATE_MAINTENANCE"
>STATE MAINTENANCE <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Various bits of state are modified during regular expression matching: the regex stack, the position within the input string, registers, the control (return address) stack, and the &#34;normal&#34; stack. All of these must be restored to their original values at the appropriate times.</p>

<p>Call the state of the world at &#39;start&#39; the initial state. When a rewritten section transfers control to the &#39;lastback&#39; label, the state should be restored to (or unchanged from) the initial state. This is similar to a regular &#34;callee&#45;save&#34; policy.</p>

<p>At the &#39;back&#39; point, the state is guaranteed to be identical to the state at the &#39;next&#39; point (thanks to the above rule holding for the subsequent rewrites.)</p>

<p>The state is allowed to change arbitrarily between &#39;start&#39; and &#39;next&#39;, as long as the first condition holds (i.e., as long as it&#39;s still possible to restore the full initial state before jumping to &#39;lastback&#39;). Obviously, this also means that the state can change arbitrarily between &#39;back&#39; and &#39;lastback&#39; (it had better be able to, because &#39;back&#39; == &#39;next&#39; != &#39;start&#39; == &#39;lastback&#39;).</p>

<p>Notice that the possible paths of control flow through a rewrite rule are:</p>

<pre>  start &#45;&#62; next
  start &#45;&#62; lastback
  back &#45;&#62; next
  back &#45;&#62; lastback</pre>

<p>This implies that local variables are dangerous. A rewrite may use a temporary variable if its value only needs to be preserved within the four paths listed above, but no variable will hold its value across the external paths of next&#45;&#62;back or lastback&#45;&#62;start. An example of where this applies is the rewrite rule for <code>m..n</code>. The simplistic way of implementing this would be to keep a local variable which counts the number of times that R has matched so far. However, this variable will not persist across next&#45;&#62;back (especially if the overall expression re&#45;enters the same rewrite rule, as in (<code>m..n</code>)*!) So it must be saved somewhere before leaving via &#39;next&#39;, and that somewhere pretty much has to be a stack. Upon re&#45;entering via &#39;back&#39;, the value will need to be restored (or at the very least popped off the stack, in order to maintain the same state at &#39;lastback&#39; as existed at &#39;start&#39;.) So that&#39;s all fine, but also notice that <b>a different local variable must be used for each instance of that rewrite rule</b>. So local variables are not local to a subroutine; they are local to the code generated for a particular rewrite, and the &#34;locality&#34; must be managed manually when that code is exited or entered.</p>

<p>Also, these local variables must also be considered to be regular local variables, i.e. they must be preserved across function calls. After all, the function containing the current regular expression may be re&#45;entered through a recursive call. (Yes, you can call arbitrary code from within regular expressions.)</p>

<h2><a name="RAMIFICATIONS"
>RAMIFICATIONS <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Hmm. You can call arbitrary code from within regular expressions? What must that code look like?</p>

<p>Well, for a start, the code must be able to be backtracked through. That means either it shouldn&#39;t do anything that needs to be undone, or it should export an interface (which here means &#34;entry point&#34;) by which it can be backtracked through. Also, it really shouldn&#39;t cause any irreversible side effects, because then it&#39;s going to be impossible to write the backtracking code.</p>

<p>Let&#39;s consider the case of a regular subroutine that wants to get called at some point in the match. The rewrite rule for sub foo() would be:</p>

<pre>  start: save local variables to stack
         call foo
         restore local variables from stack
         goto next
   back: save local variables to stack
         call unfoo
         restore local variables from stack
         goto lastback</pre>

<p>But that assumes the presence of an unfoo() routine that is able to undo whatever foo did. Another possibility would be to add a parameter to foo() that indicates whether we are calling it normally, or for the purpose of backtracking.</p>

<p>A question you may ask at this point is: so if it&#39;s that straightforward, why not implement all of the rewrite rules as subroutine calls and forget about all of this weird unstructured &#39;next&#39;, &#39;back&#39;, and &#39;lastback&#39; junk?</p>

<p>The answer is that you could &#45;&#45; but it&#39;s pretty nasty for everything but the &#34;leaf&#34; rules that do not contain subexpressions. The problem with subexpressions is that you have to be able to backtrack into them, which means that they need to be able to resume processing as if they had succeeded the first time. Huh? What? Well, here&#39;s my first attempt at reimplementing R* as a perl subroutine:</p>

<pre> sub Star::match {
     my ($expr, $entry, $stack) = @_;
     my $R_result;
     if ($entry eq &#39;start&#39;) {
         push @$stack, 0;
         while (1) {
             LOOP:
             $R_result = $expr&#45;&#62;subexpr&#45;&#62;match(&#39;start&#39;, $stack);
             return &#39;next&#39; if ($R_result eq &#39;lastback&#39;);
             push @$stack, 1;
         }
     } else { # $entry eq &#39;back&#39;
         my $temp = pop @$stack;
         return &#39;lastback&#39; if $temp == 0;
         $R_result = $expr&#45;&#62;subexpr&#45;&#62;match(&#39;back&#39;, $stack);
         goto LOOP;
     }
 }</pre>

<p>Notice the $entry being passed in. That&#39;s necessary because rewrite rules have two entry points: regular entry (&#39;start&#39;) and backtracking (&#39;back&#39;). The subroutine also returns two possible values: &#39;next&#39; or &#39;lastback&#39;. They correspond to whether the matching succeeded or failed. (It would make more sense to just return true or false, but I wanted to demonstrate the connection to the previous R* rewrite rule.)</p>

<p>The nastiness comes in when the subexpression $expr&#45;&#62;subexpr is backtracked into (i.e., invoked with $entry eq &#39;back&#39;). We need to resume processing exactly as if we had succeeded in matching the subexpression in the first place. That&#39;s kinda weird, but a natural use for a goto. Don&#39;t like gotos? Okay:</p>

<pre> sub Star::match {
     my ($expr, $entry, $stack) = @_;
     push(@$stack, 0) if $entry eq &#39;start&#39;;
     while (1) {
         my $R_result;
         if ($entry eq &#39;start&#39;) {
             $R_result = $expr&#45;&#62;R&#45;&#62;match(&#39;start&#39;, $stack);
         } else { # $entry eq &#39;back&#39;
             my $temp = pop @$stack;
             return &#39;lastback&#39; if $temp == 0;
             $R_result = $expr&#45;&#62;R&#45;&#62;match(&#39;back&#39;, $stack);
         }
         return &#39;next&#39; if ($R_result eq &#39;lastback&#39;);
         push @$stack, 1;
     }
 }</pre>

<p>or, if you forget about using similar labels:</p>

<pre> sub Star::match {
     my ($expr, $stack, $backtracking) = @_;
     push(@$stack, 0) if not $backtracking;
     while (1) {
         if ($backtracking) {
             return if pop(@$stack) == 0; # Ran out of R&#39;s to unmatch
             $expr&#45;&#62;R&#45;&#62;match($stack, &#39;backtrack&#39;) or return 1;
         } else {
             $expr&#45;&#62;R&#45;&#62;match($stack) or return 1;
         }
         push @$stack, 1;
     }
 }</pre>

<p>If you stare at that long enough, it&#39;ll start to make a certain amount of sense &#45;&#45; not much, but some. It is useful for seeing why local variables are so tricky. Any local variables in this routine are nicely preserved over the call to the subexpression R, but during the course of matching, this entire routine may return and be re&#45;called multiple times for the same star. That makes it hard to do things like count the number of times R has matched so far, for example. (You&#39;d have to remember that on the regex $stack.)</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../../resources/parrot_small.png"
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
