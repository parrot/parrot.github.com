<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
    <HEAD>
        <TITLE>Untitled</TITLE>
        <LINK REL="stylesheet" TYPE="text/css"
            HREF="../../../../../resources/perl.css"
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY>
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Untitled</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../../../html/index.html">Contents</a> | <a href="../../../../../html/languages.html">Language Implementations</a> | <a href="../../../../../html/squaak.html">Squaak</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<p>class Squaak::Grammar::Actions;</p>

<p>method TOP($/,
$key) { our @?BLOCK; our $?BLOCK;</p>

<pre>    if $key eq &#39;open&#39; {
        ## create the top&#45;level block here; any top&#45;level variable
        ## declarations are entered into this block&#39;s symbol table.
        ## Note that TOP *must* deliver a PAST::Block with blocktype
        ## &#34;declaration&#34;.
        $?BLOCK := PAST::Block.new( :blocktype(&#39;declaration&#39;), :node($/) );
        $?BLOCK.symbol_defaults( :scope(&#39;package&#39;) );
        @?BLOCK.unshift($?BLOCK);
    }
    else {
        ## retrieve the block created in the &#34;if&#34; section in this method.
        my $past := @?BLOCK.shift();

        for $&#60;stat_or_def&#62; {
            $past.push($($_));
        }
        make $past;
    }
}</pre>

<p>method stat_or_def($/, $key) { make $( $/{$key} ); }</p>

<p>method statement($/, $key) { make $( $/{$key} ); }</p>

<p>method if_statement($/) { my $cond := $( $&#60;expression&#62; ); my $then := $( $&#60;block&#62; ); my $past := PAST::Op.new( $cond, $then, :pasttype(&#39;if&#39;), :node($/) );</p>

<pre>    ## if there&#39;s an else clause, add it to the PAST node.
    if $&#60;else&#62; {
        $past.push( $( $&#60;else&#62;[0] ) );
    }
    make $past;
}</pre>

<p>method while_statement($/) { my $cond := $( $&#60;expression&#62; ); my $body := $( $&#60;block&#62; ); make PAST::Op.new( $cond, $body, :pasttype(&#39;while&#39;), :node($/) ); }</p>

<p>## for var &#60;ident&#62; = &#60;expr1&#62; , &#60;expr2&#62; do &#60;block&#62; end ## ## translates to: ## do ## var &#60;ident&#62; = &#60;expr1&#62; ## while &#60;ident&#62; &#60;= &#60;expr2&#62; do ## &#60;block&#62; ## &#60;ident&#62; = &#60;ident&#62; + 1 ## end ## end ## method for_statement($/) { our $?BLOCK; our @?BLOCK;</p>

<pre>    my $init := $( $&#60;for_init&#62; );

    ## cache the name of the loop variable
    my $itername := $init.name();

    ## create another PAST::Var node for the loop variable, this one is used
    ## for the loop condition; the node in $init has a isdecl(1) flag and a
    ## viviself object; $init represents the declaration of the loop var,
    ## $iter represents the loop variable in normal usage.
    my $iter := PAST::Var.new( :name($itername), :scope(&#39;lexical&#39;), :node($/) );

    ## the body of the loop consists of the statements written by the user and
    ## the increment instruction of the loop iterator.

    my $body := @?BLOCK.shift();
    $?BLOCK  := @?BLOCK[0];
    for $&#60;statement&#62; {
        $body.push($($_));
    }

    ## if a step was specified, use that; otherwise, use the default of +1.
    ## Note that a negative step will NOT work (unless YOU fix that :&#45;) ).
    ##
    my $step;
    if $&#60;step&#62; {
        my $stepsize := $( $&#60;step&#62;[0] );
        $step := PAST::Op.new( $iter, $stepsize, :pirop(&#39;add&#39;), :node($/) );
    }
    else { ## default is increment by 1
        $step := PAST::Op.new( $iter, :pirop(&#39;inc&#39;), :node($/) );
    }
    $body.push($step);

    ## while loop iterator &#60;= end&#45;expression
    my $cond := PAST::Op.new( $iter, $( $&#60;expression&#62; ), :name(&#39;infix:&#60;=&#39;) );
    my $loop := PAST::Op.new( $cond, $body, :pasttype(&#39;while&#39;), :node($/) );

    make PAST::Stmts.new( $init, $loop, :node($/) );
}</pre>

<p>method for_init($/) { our $?BLOCK; our @?BLOCK;</p>

<pre>    ## create a new scope here, so that we can add the loop variable
    ## to this block here, which is convenient.
    $?BLOCK := PAST::Block.new( :blocktype(&#39;immediate&#39;), :node($/) );
    @?BLOCK.unshift($?BLOCK);

    my $iter := $( $&#60;identifier&#62; );
    ## set a flag that this identifier is being declared
    $iter.isdecl(1);
    $iter.scope(&#39;lexical&#39;);
    ## the identifier is initialized with this expression
    $iter.viviself( $( $&#60;expression&#62; ) );

    ## enter the loop variable as a local into the symbol table.
    $?BLOCK.symbol($iter.name(), :scope(&#39;lexical&#39;));

    make $iter;
}</pre>

<p>method try_statement($/) { ## get the try block my $try := $( $&#60;try&#62; );</p>

<pre>    ## create a new PAST::Stmts node for the catch block;
    ## note that no PAST::Block is created, as this currently
    ## has problems with the exception object. For now this will do.
    my $catch := PAST::Stmts.new( :node($/) );
    $catch.push( $( $&#60;catch&#62; ) );

    ## get the exception identifier;
    my $exc := $( $&#60;exception&#62; );
    $exc.isdecl(1);
    $exc.scope(&#39;lexical&#39;);
    $exc.viviself( PAST::Val.new( :value(0) ) );

    ## generate instruction to retrieve the exception objct (and the exception message,
    ## that is passed automatically in PIR, this is stored into $S0 (but not used).
    my $pir := &#34;    .get_results (%r)\n&#34;
             ~ &#34;    store_lex &#39;&#34; ~ $exc.name() ~ &#34;&#39;, %r&#34;;

    $catch.unshift( PAST::Op.new( :inline($pir), :node($/) ) );
    ## do the declaration of the exception object as a lexical here:
    $catch.unshift( $exc );

    make PAST::Op.new( $try, $catch, :pasttype(&#39;try&#39;), :node($/) );
}</pre>

<p>method exception($/) { our $?BLOCK;</p>

<pre>    my $exc := $( $&#60;identifier&#62; );
    ## the exception identifier is local to the exception handler
    $?BLOCK.symbol($exc.name(), :scope(&#39;lexical&#39;));
    make $exc;
}</pre>

<p>method throw_statement($/) { make PAST::Op.new( $( $&#60;expression&#62; ), :pirop(&#39;throw&#39;), :node($/) ); }</p>

<p>method block($/, $key) { our $?BLOCK; ## the current block our @?BLOCK; ## the scope stack</p>

<pre>    if $key eq &#39;open&#39; {
        $?BLOCK := PAST::Block.new( :blocktype(&#39;immediate&#39;), :node($/) );
        @?BLOCK.unshift($?BLOCK);
    }
    else {
        ## retrieve the current block, remove it from the scope stack
        ## and restore the &#34;current&#34; block.
        my $past := @?BLOCK.shift();
        $?BLOCK  := @?BLOCK[0];

        for $&#60;statement&#62; {
            $past.push($($_));
        }
        make $past
    }
}</pre>

<p>method return_statement($/) { my $expr := $( $&#60;expression&#62; ); make PAST::Op.new( $expr, :pasttype(&#39;return&#39;), :node($/) ); }</p>

<p>method do_block($/) { make $( $&#60;block&#62; ); }</p>

<p>method assignment($/) { my $rhs := $( $&#60;expression&#62; ); my $lhs := $( $&#60;primary&#62; ); $lhs.lvalue(1); make PAST::Op.new( $lhs, $rhs, :pasttype(&#39;bind&#39;), :node($/) ); }</p>

<p>method sub_definition($/) { our @?BLOCK; our $?BLOCK;</p>

<pre>    ## note that $&#60;parameters&#62; creates a new PAST::Block.
    my $past := $( $&#60;parameters&#62; );
    my $name := $( $&#60;identifier&#62; );

    ## set the function name
    $past.name( $name.name() );
    for $&#60;statement&#62; {
        $past.push($($_));
    }

    ## remove the block from the scope stack
    ## and restore the &#34;current&#34; block
    @?BLOCK.shift();
    $?BLOCK := @?BLOCK[0];

    $past.control(&#39;return_pir&#39;);
    make $past;
}</pre>

<p>method variable_declaration($/) { our $?BLOCK;</p>

<pre>    my $past := $( $&#60;identifier&#62; );
    $past.isdecl(1);
    $past.scope(&#39;lexical&#39;);

    ## if there&#39;s an initialization value, use it to viviself the variable.
    if $&#60;expression&#62; {
        $past.viviself( $( $&#60;expression&#62;[0] ) );
    }
    else { ## otherwise initialize to undef.
        $past.viviself( &#39;Undef&#39; );
    }

    ## cache this identifier&#39;s name
    my $name := $past.name();

    ## if the symbol is already declared, emit an error. Otherwise,
    ## enter it into the current block&#39;s symbol table.
    if $?BLOCK.symbol($name) {
        $/.panic(&#34;Error: symbol &#34; ~ $name ~ &#34; was already defined\n&#34;);
    }
    else {
        $?BLOCK.symbol($name, :scope(&#39;lexical&#39;));
    }
    make $past;
}</pre>

<p>method parameters($/) { our $?BLOCK; our @?BLOCK;</p>

<pre>    my $past := PAST::Block.new( :blocktype(&#39;declaration&#39;), :node($/) );
    for $&#60;identifier&#62; {
        my $param := $( $_ );
        $param.scope(&#39;parameter&#39;);
        $past.push($param);

        ## enter the parameter as a lexical into the block&#39;s symbol table
        $past.symbol($param.name(), :scope(&#39;lexical&#39;));
    }

    ## set this block as the current block, and store it on the scope stack
    $?BLOCK := $past;
    @?BLOCK.unshift($past);

    make $past;
}</pre>

<p>method sub_call($/) { my $invocant := $( $&#60;primary&#62; ); my $past := $( $&#60;arguments&#62; ); ## set the invocant as the first child of the PAST::Op(:pasttype(&#39;call&#39;)) node $past.unshift( $invocant ); make $past; }</p>

<p>method arguments($/) { my $past := PAST::Op.new( :pasttype(&#39;call&#39;), :node($/) ); for $&#60;expression&#62; { $past.push($($_)); } make $past; }</p>

<p>method primary($/) { my $past := $( $&#60;identifier&#62; ); for $&#60;postfix_expression&#62; { my $expr := $( $_ ); ## set the current $past as the first child of $expr; ## $expr is either a key or an index; both are &#34;keyed&#34; ## variable access, where the first child is assumed ## to be the aggregate. $expr.unshift($past); $past := $expr; } make $past; }</p>

<p>method postfix_expression($/, $key) { make $( $/{$key} ); }</p>

<p>method key($/) { my $key := $( $&#60;expression&#62; );</p>

<pre>    make PAST::Var.new( $key, :scope(&#39;keyed&#39;),
                              :vivibase(&#39;Hash&#39;),
                              :viviself(&#39;Undef&#39;),
                              :node($/) );</pre>

<p>}</p>

<p>method member($/) { my $member := $( $&#60;identifier&#62; ); ## x.y is syntactic sugar for x{&#34;y&#34;}, so stringify the identifier: my $key := PAST::Val.new( :returns(&#39;String&#39;), :value($member.name()), :node($/) );</p>

<pre>    ## the rest of this method is the same as method key() above.
    make PAST::Var.new( $key, :scope(&#39;keyed&#39;),
                              :vivibase(&#39;Hash&#39;),
                              :viviself(&#39;Undef&#39;),
                              :node($/) );
}</pre>

<p>method index($/) { my $index := $( $&#60;expression&#62; );</p>

<pre>    make PAST::Var.new( $index, :scope(&#39;keyed&#39;),
                                :vivibase(&#39;ResizablePMCArray&#39;),
                                :viviself(&#39;Undef&#39;),
                                :node($/) );
}</pre>

<p>method named_field($/) { my $past := $( $&#60;expression&#62; ); my $name := $( $&#60;string_constant&#62; ); ## the passed expression is in fact a named argument, ## use the named() accessor to set that name. $past.named($name); make $past; }</p>

<p>method array_constructor($/) { ## use the parrot calling conventions to ## create an array, ## using the &#34;anonymous&#34; sub !array ## (which is not a valid Squaak name) my $past := PAST::Op.new( :name(&#39;!array&#39;), :pasttype(&#39;call&#39;), :node($/) ); for $&#60;expression&#62; { $past.push($($_)); } make $past; }</p>

<p>method hash_constructor($/) { ## use the parrot calling conventions to ## create a hash, using the &#34;anonymous&#34; sub ## !hash (which is not a valid Squaak name) my $past := PAST::Op.new( :name(&#39;!hash&#39;), :pasttype(&#39;call&#39;), :node($/) ); for $&#60;named_field&#62; { $past.push($($_)); } make $past; }</p>

<p>method term($/, $key) { make $( $/{$key} ); }</p>

<p>method identifier($/) { my $name := ~$/; ## instead of ~$/, you can also write ~$&#60;ident&#62;, as an identifier ## uses the built&#45;in &#60;ident&#62; rule to match identifiers. make PAST::Var.new( :name($name), :viviself(&#39;Undef&#39;), :node($/) ); }</p>

<p>method integer_constant($/) { make PAST::Val.new( :value( ~$/ ), :returns(&#39;Integer&#39;), :node($/) ); }</p>

<p>method float_constant($/) { make PAST::Val.new( :value( ~$/ ), :returns(&#39;Float&#39;), :node($/) ); }</p>

<p>method string_constant($/) { make PAST::Val.new( :value( $($&#60;string_literal&#62;) ), :returns(&#39;String&#39;), :node($/) ); }</p>

<p>## Handle the operator precedence table. method expression($/, $key) { if ($key eq &#39;end&#39;) { make $($&#60;expr&#62;); } else { my $past := PAST::Op.new( :name($&#60;type&#62;), :pasttype($&#60;top&#62;&#60;pasttype&#62;), :pirop($&#60;top&#62;&#60;pirop&#62;), :lvalue($&#60;top&#62;&#60;lvalue&#62;), :node($/) ); for @($/) { $past.push( $($_) ); } make $past; } }</p>

<p># Local Variables: # mode: cperl # cperl&#45;indent&#45;level: 4 # fill&#45;column: 100 # End: # vim: expandtab shiftwidth=4:</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../../../resources/parrot_small.png"
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
