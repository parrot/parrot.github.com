<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
    <HEAD>
        <TITLE>Untitled</TITLE>
        <LINK REL="stylesheet" TYPE="text/css"
            HREF="../../../../../resources/perl.css"
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY>
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Untitled</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../../../html/index.html">Contents</a> | <a href="../../../../../html/languages.html">Language Implementations</a> | <a href="../../../../../html/lolcode.html">lolcode</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<p>class lolcode::Grammar::Actions;</p>

<p>method TOP($/) { my $block := $( $&#60;block&#62; ); $block.symbol(&#39;IT&#39;,
:scope(&#39;lexical&#39;)); my $it := PAST::Var.new( :name( &#39;IT&#39; ),
:scope(&#39;lexical&#39;),
:viviself(&#39;Undef&#39;),
:isdecl(1)); $block.unshift($it); $block.hll(&#39;lolcode&#39;); make $block; }</p>

<p>method statement ($/,
$key) { if (($key eq &#39;expression&#39;)&#38;&#38;($&#60;expression&#62;&#60;tokens&#62;[0]&#60;identifier&#62; ne &#39;VISIBLE&#39;)) { my $it := PAST::Var.new( :name( &#39;IT&#39; ),
:scope(&#39;lexical&#39;),
:viviself(&#39;Undef&#39;)); my $past := PAST::Op.new( :pasttype(&#39;bind&#39;),
:node( $/ ) ); $past.push( $it ); $past.push( $( $&#60;expression&#62; ) ); make $past; } else { make $( $/{$key} ); # For now } }</p>

<p>method declare($/) { our $?BLOCK;</p>

<pre>    my $name := ~$&#60;variable&#62;&#60;identifier&#62;;

    my $var := PAST::Var.new( :name( $name ),
                        :viviself(&#39;Undef&#39;),
                        :node( $/ )
                    );

    my $scope := &#39;lexical&#39;;
    if $&#60;scope&#62;[0] {
        if ~$&#60;scope&#62;[0] eq &#39;FARAWAY&#39; {
            $scope := &#39;package&#39;;
        }
    }

    $var.scope(~$scope);
    unless $?BLOCK.symbol($name) {
        $?BLOCK.symbol($name, :scope($scope));
        $var.isdecl(1);
    }

    if ($&#60;expression&#62;) {
        $var.isdecl(1);
        # XXX Someone clever needs to refactor this into C&#60;assign&#62;
        my $past := PAST::Op.new( :pasttype(&#39;bind&#39;), :node( $/ ) );
        $past.push( $var );
        $past.push( $( $&#60;expression&#62;[0] ) );
        make $past;
    }
    else {
        make $var;
    }
}</pre>

<p>method assign($/) { my $past := PAST::Op.new( :pasttype(&#39;bind&#39;), :node( $/ ) ); $past.push( $( $&#60;variable&#62; ) ); $past.push( $( $&#60;expression&#62; ) ); make $past; }</p>

<p>method function($/,$key) { our $?BLOCK; if $key eq &#39;params&#39; { our $?BLOCK_SIGNATURE; my $arglist; $arglist := PAST::Stmts.new(); # if there are any parameters, get the PAST for each of them and # adjust the scope to parameter. for $&#60;parameters&#62; { my $param := PAST::Var.new(:name(~$_&#60;identifier&#62;), :scope(&#39;parameter&#39;), :node($($_))); $param.isdecl(1); $arglist.push($param); } $?BLOCK_SIGNATURE := $arglist; } elsif $key eq &#39;block&#39; { my $block := $( $&#60;block&#62; ); $block.blocktype(&#39;declaration&#39;); $?BLOCK.symbol(~$&#60;variable&#62;&#60;identifier&#62;, :arity($block.arity()));</p>

<pre>        my $it := PAST::Var.new( :name( &#39;IT&#39; ), :scope(&#39;lexical&#39;), :viviself(&#39;Undef&#39;), :isdecl(1));
        $block[1].unshift($it);

        $it := PAST::Var.new( :name( &#39;IT&#39; ), :scope(&#39;lexical&#39;));
        $block[1].push($it);
        $block.name(~$&#60;variable&#62;&#60;identifier&#62;);
        make $block;
        #my $past := PAST::Op.new( :pasttype(&#39;bind&#39;), :node( $/ ) );
        #$($&#60;variable&#62;).isdecl(1);
        #$past.push( $( $&#60;variable&#62; ) );
        #$past.push( $block );
        #make $past;
    }</pre>

<p>}</p>

<p>method ifthen($/) { my $count := +$&#60;expression&#62; &#45; 1; my $expr := $( $&#60;expression&#62;[$count] ); my $then := $( $&#60;block&#62;[$count] ); $then.blocktype(&#39;immediate&#39;); my $past := PAST::Op.new( $expr, $then, :pasttype(&#39;if&#39;), :node( $/ ) ); if ( $&#60;else&#62; ) { my $else := $( $&#60;else&#62;[0] ); $else.blocktype(&#39;immediate&#39;); $past.push( $else ); } while ($count != 0) { $count := $count &#45; 1; $expr := $( $&#60;expression&#62;[$count] ); $then := $( $&#60;block&#62;[$count] ); $then.blocktype(&#39;immediate&#39;); $past := PAST::Op.new( $expr, $then, $past, :pasttype(&#39;if&#39;), :node( $/ ) ); } $expr := $past.shift(); my $it := PAST::Var.new( :name( &#39;IT&#39; ), :scope(&#39;lexical&#39;), :viviself(&#39;Undef&#39;)); my $bind := PAST::Op.new( :pasttype(&#39;bind&#39;), :node( $/ ) ); $bind.push( $it ); $bind.push( $expr ); $past.unshift( $it ); my $past := PAST::Stmts.new( $bind, $past, :node( $/ ) ); make $past; }</p>

<p>method switch($/) { my $count := +$&#60;value&#62; &#45; 1; my $val := $( $&#60;value&#62;[$count] ); my $then := $( $&#60;block&#62;[$count] ); my $it := PAST::Var.new( :name( &#39;IT&#39; ), :scope(&#39;lexical&#39;), :viviself(&#39;Undef&#39;)); my $expr := PAST::Op.new(:pasttype(&#39;call&#39;), :name(&#39;BOTH SAEM&#39;), $it, $val); $then.blocktype(&#39;immediate&#39;); my $past := PAST::Op.new( $expr, $then, :pasttype(&#39;if&#39;), :node( $/ ) ); if ( $&#60;else&#62; ) { my $else := $( $&#60;else&#62;[0] ); $else.blocktype(&#39;immediate&#39;); $past.push( $else ); } while ($count != 0) { $count := $count &#45; 1; $val := $( $&#60;value&#62;[$count] ); $expr := PAST::Op.new(:pasttype(&#39;call&#39;), :name(&#39;BOTH SAEM&#39;), $it, $val); $then := $( $&#60;block&#62;[$count] ); $then.blocktype(&#39;immediate&#39;); $past := PAST::Op.new( $expr, $then, $past, :pasttype(&#39;if&#39;), :node( $/ ) ); } #$expr := $past.shift(); #my $it := PAST::Var.new( :name( &#39;IT&#39; ), :scope(&#39;lexical&#39;), :viviself(&#39;Undef&#39;)); #my $bind := PAST::Op.new( :pasttype(&#39;bind&#39;), :node( $/ ) ); #$bind.push( $it ); #$bind.push( $expr ); #$past.unshift( $it ); my $past := PAST::Stmts.new( $past, :node( $/ ) ); make $past; }</p>

<p>method block($/,$key) { our $?BLOCK; our @?BLOCK; if $key eq &#39;open&#39; { our $?BLOCK_SIGNATURE; $?BLOCK := PAST::Block.new( PAST::Stmts.new(), :node($/), :lexical(1) ); @?BLOCK.unshift($?BLOCK); my $iter := $?BLOCK_SIGNATURE.iterator(); $?BLOCK.arity(0); for $iter { $?BLOCK.arity($?BLOCK.arity() + 1); $?BLOCK[0].push($_); $?BLOCK.symbol($_.name(), :scope(&#39;lexical&#39;)); } } elsif $key eq &#39;close&#39; { #my $past := PAST::Block.new( :blocktype(&#39;declaration&#39;), :node( $/ ) ); my $past := @?BLOCK.shift(); $?BLOCK := @?BLOCK[0]; my $stmts := PAST::Stmts.new( :node( $/ ) ); for $&#60;statement&#62; { $stmts.push( $( $_ ) ); } $past.push($stmts); make $past; } }</p>

<p>method value($/, $key) { make $( $/{$key} ); }</p>

<p>method bang($/) { make PAST::Val.new( :value( ~$/ ), :returns(&#39;String&#39;), :node($/) ); }</p>

<p>sub find_in_blocks($name) { our $?BLOCK; our @?BLOCK; if $?BLOCK.symbol(~$name) { return $?BLOCK.symbol($name); } for @?BLOCK { if $_.symbol(~$name) { return $_.symbol($name); } } return 0; }</p>

<p>sub is_sub($name) { my $sym := find_in_blocks($name); if $sym &#38;&#38; defined($sym&#60;arity&#62;) { return 1; } my $lex := lookup($name); if lookup_class($lex) eq &#39;Sub&#39; { return 1; } return 0; }</p>

<p>sub get_item($name) { if is_sub($name) { return PAST::Op.new( :name($name), :pasttype(&#39;call&#39;) ); } else { my $var := PAST::Var.new(:name($name)); my $sym := find_in_blocks($name); if $sym &#38;&#38; defined($sym&#60;scope&#62;) { $var&#60;scope&#62; := $sym&#60;scope&#62; } return $var; } }</p>

<p>sub get_arity($name) { my $sym := find_in_blocks($name); if $sym { return $sym&#60;arity&#62;; } else { my $lex := lookup($name); my $ii := get_inspect_info($lex); if $ii&#60;pos_slurpy&#62; { return &#45;1; } else { return $lex.arity(); } } }</p>

<p>method expression($/) { my @subs; my @vals; my @arity; my $mkay := &#39;mkay&#39;;</p>

<pre>    for $&#60;tokens&#62; {
        if($_&#60;identifier&#62;) {
            my $name := ~$_&#60;identifier&#62;;
            my $item := get_item($name);
            if is_sub($name) {
                my $arity := get_arity($name);
                $item&#60;arity&#62; := $arity;
                @subs.push($item);
                @arity.unshift($arity + 0);
                if @arity[0] == &#45;1 { @vals.push($mkay) }
            }
            else {
                @vals.push($item);
                if defined(@arity[0]) {@arity[0]&#45;&#45;};
            }
        }
        else {
            my $item := $( $_ );
            @vals.push($item);
            if defined(@arity[0]) {@arity[0]&#45;&#45;};
        }

        while defined(@arity[0]) &#38;&#38; @arity[0] == 0 {
            my $sub := @subs.pop();
            @arity.shift();
            my $arity := $sub&#60;arity&#62; + 0;
            while $arity &#62; 0 {
                $sub.unshift(@vals.pop());
                $arity&#45;&#45;;
            }
            @vals.push($sub);
            if defined(@arity[0]) {@arity[0]&#45;&#45;};
        }
    }

    if @vals[0] eq $mkay {
        @vals.shift();
        my $sub := @subs.pop();
        while +@vals {
            $sub.unshift(@vals.pop());
        }
        @vals.push($sub);
    }
    make @vals[0];
}</pre>

<p>method integer($/) { make PAST::Val.new( :value( ~$/ ), :returns(&#39;Integer&#39;), :node($/) ); }</p>

<p>method float($/) { make PAST::Val.new( :value( ~$/ ), :returns(&#39;Float&#39;), :node($/) ); }</p>

<p>method boolean($/) { if (~$/ eq &#39;FAIL&#39; ) { make PAST::Val.new( :value( 0 ), :returns(&#39;Boolean&#39;), :node($/) ); } else { make PAST::Val.new( :value( 1 ), :returns(&#39;Boolean&#39;), :node($/) ); } }</p>

<p>method quote($/) { make PAST::Val.new( :value( $($&#60;yarn_literal&#62;) ), :node($/) ); }</p>

<p>method variable ($/) { if ($&#60;identifier&#62; eq &#39;IT&#39;) { make PAST::Var.new( :name( &#39;IT&#39; ), :scope(&#39;lexical&#39;), :viviself(&#39;Undef&#39;)); } else { our $?BLOCK;</p>

<pre>        my $var := PAST::Var.new( :name( $&#60;identifier&#62; ),
                            :scope(&#39;lexical&#39;),
                            :viviself(&#39;Undef&#39;),
                            :node( $/ )
                        );
        if $?BLOCK.symbol($&#60;identifier&#62;) {
            my $scope := &#39;&#39; ~ $?BLOCK.symbol($&#60;identifier&#62;)&#60;scope&#62;;
            $var.scope(~$scope);
        }
        else {
            our @?BLOCK;
            my $exists := 0;
            my $scope;
            for @?BLOCK {
                if $_ {
                    my $sym_table := $_.symbol(~$&#60;identifier&#62;);
                    if $sym_table {
                        $exists := 1;
                        $scope := &#39;&#39; ~ $sym_table&#60;scope&#62;;
                    }
                }
            }
            if $exists == 0 {
                $var.scope(&#39;package&#39;);
            }
            else {
                $var.scope($scope);
            }
        }

        make $var;
    }
}</pre>

<p># Local Variables: # mode: cperl # cperl&#45;indent&#45;level: 4 # fill&#45;column: 100 # End: # vim: expandtab shiftwidth=4:</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../../../resources/parrot_small.png"
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
