<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
    <HEAD>
        <TITLE>PHP spl  Library</TITLE>
        <LINK REL="stylesheet" TYPE="text/css"
            HREF="../../../../../resources/perl.css"
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY>
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">PHP spl  Library</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../../../html/index.html">Contents</a> | <a href="../../../../../html/languages.html">Language Implementations</a> | <a href="../../../../../html/pipp.html">Pipp</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../../../resources/up.gif'></a></a></h1>

<p>php_spl.pir &#45; PHP spl Library</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../../../resources/up.gif'></a></a></h1>

<h2><a name="Functions"
>Functions <a href='#_top'><img alt='^' border=0 src='../../../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="void_AppendIterator::__construct()"
><b><code>void AppendIterator::__construct()</b></code></a></dt>
Create an AppendIteratorNOT IMPLEMENTED.
<dt><a name="void_AppendIterator::append(Iterator_it)"
><b><code>void AppendIterator::append(Iterator it)</b></code></a></dt>
Append an iteratorNOT IMPLEMENTED.
<dt><a name="ArrayIterator_AppendIterator::getArrayIterator()"
><b><code>ArrayIterator AppendIterator::getArrayIterator()</b></code></a></dt>
Get access to inner ArrayIteratorNOT IMPLEMENTED.
<dt><a name="int_AppendIterator::getIteratorIndex()"
><b><code>int AppendIterator::getIteratorIndex()</b></code></a></dt>
Get index of iteratorNOT IMPLEMENTED.
<dt><a name="void_AppendIterator::next()"
><b><code>void AppendIterator::next()</b></code></a></dt>
Forward to next elementNOT IMPLEMENTED.
<dt><a name="void_AppendIterator::rewind()"
><b><code>void AppendIterator::rewind()</b></code></a></dt>
Rewind to the first iterator and rewind the first iterator,
tooNOT IMPLEMENTED.
<dt><a name="bool_AppendIterator::valid()"
><b><code>bool AppendIterator::valid()</b></code></a></dt>
Check if the current state is validNOT IMPLEMENTED.
<dt><a name="mixed|NULL_ArrayIterator::current()"
><b><code>mixed|NULL ArrayIterator::current()</b></code></a></dt>
Return current array entryNOT IMPLEMENTED.
<dt><a name="mixed|NULL_ArrayIterator::key()"
><b><code>mixed|NULL ArrayIterator::key()</b></code></a></dt>
Return current array keyNOT IMPLEMENTED.
<dt><a name="void_ArrayIterator::next()"
><b><code>void ArrayIterator::next()</b></code></a></dt>
Move to next entryNOT IMPLEMENTED.
<dt><a name="void_ArrayIterator::rewind()"
><b><code>void ArrayIterator::rewind()</b></code></a></dt>
Rewind array back to the startNOT IMPLEMENTED.
<dt><a name="void_ArrayIterator::seek(int_$position)"
><b><code>void ArrayIterator::seek(int $position)</b></code></a></dt>
Seek to position.NOT IMPLEMENTED.
<dt><a name="bool_ArrayIterator::valid()"
><b><code>bool ArrayIterator::valid()</b></code></a></dt>
Check whether array contains more entriesNOT IMPLEMENTED.
<dt><a name="void_ArrayObject::__construct(array|object_ar_=_array()_[,_int_flags_=_0_[,_string_iterator_class_=_&#34;ArrayIterator&#34;]])"
><b><code>void ArrayObject::__construct(array|object ar = array() [, int flags = 0 [, string iterator_class = &#34;ArrayIterator&#34;]])</b></code></a></dt>
proto void ArrayIterator::__construct(array|object ar = array() [,
int flags = 0]) Cronstructs a new array iterator from a path.NOT IMPLEMENTED.
<dt><a name="void_ArrayObject::append(mixed_$newval)"
><b><code>void ArrayObject::append(mixed $newval)</b></code></a></dt>
proto void ArrayIterator::append(mixed $newval) Appends the value (cannot be called for objects).NOT IMPLEMENTED.
<dt><a name="int_ArrayObject::asort()"
><b><code>int ArrayObject::asort()</b></code></a></dt>
proto int ArrayIterator::asort() Sort the entries by values.NOT IMPLEMENTED.
<dt><a name="int_ArrayObject::count()"
><b><code>int ArrayObject::count()</b></code></a></dt>
proto int ArrayIterator::count() Return the number of elements in the Iterator.NOT IMPLEMENTED.
<dt><a name="Array|Object_ArrayObject::exchangeArray(Array|Object_ar_=_array())"
><b><code>Array|Object ArrayObject::exchangeArray(Array|Object ar = array())</b></code></a></dt>
Replace the referenced array or object with a new one and return the old one (right now copy &#45; to be changed)NOT IMPLEMENTED.
<dt><a name="int_ArrayObject::getFlags()"
><b><code>int ArrayObject::getFlags()</b></code></a></dt>
Get flagsNOT IMPLEMENTED.
<dt><a name="ArrayIterator_ArrayObject::getIterator()"
><b><code>ArrayIterator ArrayObject::getIterator()</b></code></a></dt>
Create a new iterator from a ArrayObject instanceNOT IMPLEMENTED.
<dt><a name="string_ArrayObject::getIteratorClass()"
><b><code>string ArrayObject::getIteratorClass()</b></code></a></dt>
Get the class used in getIterator.NOT IMPLEMENTED.
<dt><a name="int_ArrayObject::ksort()"
><b><code>int ArrayObject::ksort()</b></code></a></dt>
proto int ArrayIterator::ksort() Sort the entries by key.NOT IMPLEMENTED.
<dt><a name="int_ArrayObject::natcasesort()"
><b><code>int ArrayObject::natcasesort()</b></code></a></dt>
proto int ArrayIterator::natcasesort() Sort the entries by key using case insensitive &#34;natural order&#34; algorithm.NOT IMPLEMENTED.
<dt><a name="int_ArrayObject::natsort()"
><b><code>int ArrayObject::natsort()</b></code></a></dt>
proto int ArrayIterator::natsort() Sort the entries by values using &#34;natural order&#34; algorithm.NOT IMPLEMENTED.
<dt><a name="bool_ArrayObject::offsetExists(mixed_$index)"
><b><code>bool ArrayObject::offsetExists(mixed $index)</b></code></a></dt>
proto bool ArrayIterator::offsetExists(mixed $index) Returns whether the requested $index exists.NOT IMPLEMENTED.
<dt><a name="mixed_ArrayObject::offsetGet(mixed_$index)"
><b><code>mixed ArrayObject::offsetGet(mixed $index)</b></code></a></dt>
proto mixed ArrayIterator::offsetGet(mixed $index) Returns the value at the specified $index.NOT IMPLEMENTED.
<dt><a name="void_ArrayObject::offsetSet(mixed_$index,_mixed_$newval)"
><b><code>void ArrayObject::offsetSet(mixed $index, mixed $newval)</b></code></a></dt>
proto void ArrayIterator::offsetSet(mixed $index,
mixed $newval) Sets the value at the specified $index to $newval.NOT IMPLEMENTED.
<dt><a name="void_ArrayObject::offsetUnset(mixed_$index)"
><b><code>void ArrayObject::offsetUnset(mixed $index)</b></code></a></dt>
proto void ArrayIterator::offsetUnset(mixed $index) Unsets the value at the specified $index.NOT IMPLEMENTED.
<dt><a name="void_ArrayObject::setFlags(int_flags)"
><b><code>void ArrayObject::setFlags(int flags)</b></code></a></dt>
Set flagsNOT IMPLEMENTED.
<dt><a name="void_ArrayObject::setIteratorClass(string_iterator_class)"
><b><code>void ArrayObject::setIteratorClass(string iterator_class)</b></code></a></dt>
Set the class used in getIterator.NOT IMPLEMENTED.
<dt><a name="int_ArrayObject::uasort(callback_cmp_function)"
><b><code>int ArrayObject::uasort(callback cmp_function)</b></code></a></dt>
proto int ArrayIterator::uasort(callback cmp_function) Sort the entries by values user defined function.NOT IMPLEMENTED.
<dt><a name="int_ArrayObject::uksort(callback_cmp_function)"
><b><code>int ArrayObject::uksort(callback cmp_function)</b></code></a></dt>
proto int ArrayIterator::uksort(callback cmp_function) Sort the entries by key using user defined function.NOT IMPLEMENTED.
<dt><a name="void_CachingIterator::__construct(Iterator_it_[,_flags_=_CIT_CALL_TOSTRING])"
><b><code>void CachingIterator::__construct(Iterator it [, flags = CIT_CALL_TOSTRING])</b></code></a></dt>
Construct a CachingIterator from an IteratorNOT IMPLEMENTED.
<dt><a name="string_CachingIterator::__toString()"
><b><code>string CachingIterator::__toString()</b></code></a></dt>
Return the string representation of the current elementNOT IMPLEMENTED.
<dt><a name="void_CachingIterator::count()"
><b><code>void CachingIterator::count()</b></code></a></dt>
Number of cached elementsNOT IMPLEMENTED.
<dt><a name="bool_CachingIterator::getCache()"
><b><code>bool CachingIterator::getCache()</b></code></a></dt>
Return the cacheNOT IMPLEMENTED.
<dt><a name="int_CachingIterator::getFlags()"
><b><code>int CachingIterator::getFlags()</b></code></a></dt>
Return the internal flagsNOT IMPLEMENTED.
<dt><a name="bool_CachingIterator::hasNext()"
><b><code>bool CachingIterator::hasNext()</b></code></a></dt>
Check whether the inner iterator has a valid next elementNOT IMPLEMENTED.
<dt><a name="void_CachingIterator::next()"
><b><code>void CachingIterator::next()</b></code></a></dt>
Move the iterator forwardNOT IMPLEMENTED.
<dt><a name="bool_CachingIterator::offsetExists(mixed_index)"
><b><code>bool CachingIterator::offsetExists(mixed index)</b></code></a></dt>
Return whether the requested index existsNOT IMPLEMENTED.
<dt><a name="string_CachingIterator::offsetGet(mixed_index)"
><b><code>string CachingIterator::offsetGet(mixed index)</b></code></a></dt>
Return the internal cache if usedNOT IMPLEMENTED.
<dt><a name="void_CachingIterator::offsetSet(mixed_index,_mixed_newval)"
><b><code>void CachingIterator::offsetSet(mixed index, mixed newval)</b></code></a></dt>
Set given index in cacheNOT IMPLEMENTED.
<dt><a name="void_CachingIterator::offsetUnset(mixed_index)"
><b><code>void CachingIterator::offsetUnset(mixed index)</b></code></a></dt>
Unset given index in cacheNOT IMPLEMENTED.
<dt><a name="void_CachingIterator::rewind()"
><b><code>void CachingIterator::rewind()</b></code></a></dt>
Rewind the iteratorNOT IMPLEMENTED.
<dt><a name="void_CachingIterator::setFlags(int_flags)"
><b><code>void CachingIterator::setFlags(int flags)</b></code></a></dt>
Set the internal flagsNOT IMPLEMENTED.
<dt><a name="bool_CachingIterator::valid()"
><b><code>bool CachingIterator::valid()</b></code></a></dt>
Check whether the current element is validNOT IMPLEMENTED.
<dt><a name="void_DirectoryIterator::__construct(string_path)"
><b><code>void DirectoryIterator::__construct(string path)</b></code></a></dt>
Cronstructs a new dir iterator from a path.NOT IMPLEMENTED.
<dt><a name="DirectoryIterator_DirectoryIterator::current()"
><b><code>DirectoryIterator DirectoryIterator::current()</b></code></a></dt>
Return this (needed for Iterator interface)NOT IMPLEMENTED.
<dt><a name="string_DirectoryIterator::getBasename([string_$suffix])"
><b><code>string DirectoryIterator::getBasename([string $suffix])</b></code></a></dt>
Returns filename component of current dir entryNOT IMPLEMENTED.
<dt><a name="RecursiveDirectoryIterator_DirectoryIterator::getChildren()"
><b><code>RecursiveDirectoryIterator DirectoryIterator::getChildren()</b></code></a></dt>
Returns an iterator for the current entry if it is a directoryNOT IMPLEMENTED.
<dt><a name="string_DirectoryIterator::getFilename()"
><b><code>string DirectoryIterator::getFilename()</b></code></a></dt>
Return filename of current dir entryNOT IMPLEMENTED.
<dt><a name="bool_DirectoryIterator::isDot()"
><b><code>bool DirectoryIterator::isDot()</b></code></a></dt>
Returns true if current entry is &#39;.&#39; or &#39;..&#39;NOT IMPLEMENTED.
<dt><a name="string_DirectoryIterator::key()"
><b><code>string DirectoryIterator::key()</b></code></a></dt>
Return current dir entryNOT IMPLEMENTED.
<dt><a name="void_DirectoryIterator::next()"
><b><code>void DirectoryIterator::next()</b></code></a></dt>
Move to next entryNOT IMPLEMENTED.
<dt><a name="void_DirectoryIterator::rewind()"
><b><code>void DirectoryIterator::rewind()</b></code></a></dt>
Rewind dir back to the startNOT IMPLEMENTED.
<dt><a name="string_DirectoryIterator::valid()"
><b><code>string DirectoryIterator::valid()</b></code></a></dt>
Check whether dir contains more entriesNOT IMPLEMENTED.
<dt><a name="void_EmptyIterator::current()"
><b><code>void EmptyIterator::current()</b></code></a></dt>
Throws exception BadMethodCallExceptionNOT IMPLEMENTED.
<dt><a name="void_EmptyIterator::key()"
><b><code>void EmptyIterator::key()</b></code></a></dt>
Throws exception BadMethodCallExceptionNOT IMPLEMENTED.
<dt><a name="void_EmptyIterator::next()"
><b><code>void EmptyIterator::next()</b></code></a></dt>
Does nothingNOT IMPLEMENTED.
<dt><a name="void_EmptyIterator::rewind()"
><b><code>void EmptyIterator::rewind()</b></code></a></dt>
Does nothingNOT IMPLEMENTED.
<dt><a name="false_EmptyIterator::valid()"
><b><code>false EmptyIterator::valid()</b></code></a></dt>
Return falseNOT IMPLEMENTED.
<dt><a name="void_FilterIterator::__construct(Iterator_it)"
><b><code>void FilterIterator::__construct(Iterator it)</b></code></a></dt>
Create an Iterator from another iteratorNOT IMPLEMENTED.
<dt><a name="mixed_FilterIterator::current()"
><b><code>mixed FilterIterator::current()</b></code></a></dt>
proto mixed CachingIterator::current() proto mixed LimitIterator::current() proto mixed ParentIterator::current() proto mixed IteratorIterator::current() proto mixed NoRewindIterator::current() proto mixed AppendIterator::current() Get the current element valueNOT IMPLEMENTED.
<dt><a name="Iterator_FilterIterator::getInnerIterator()"
><b><code>Iterator FilterIterator::getInnerIterator()</b></code></a></dt>
proto Iterator CachingIterator::getInnerIterator() proto Iterator LimitIterator::getInnerIterator() proto Iterator ParentIterator::getInnerIterator() Get the inner iteratorNOT IMPLEMENTED.
<dt><a name="mixed_FilterIterator::key()"
><b><code>mixed FilterIterator::key()</b></code></a></dt>
proto mixed CachingIterator::key() proto mixed LimitIterator::key() proto mixed ParentIterator::key() proto mixed IteratorIterator::key() proto mixed NoRewindIterator::key() proto mixed AppendIterator::key() Get the current keyNOT IMPLEMENTED.
<dt><a name="void_FilterIterator::next()"
><b><code>void FilterIterator::next()</b></code></a></dt>
Move the iterator forwardNOT IMPLEMENTED.
<dt><a name="void_FilterIterator::rewind()"
><b><code>void FilterIterator::rewind()</b></code></a></dt>
Rewind the iteratorNOT IMPLEMENTED.
<dt><a name="bool_FilterIterator::valid()"
><b><code>bool FilterIterator::valid()</b></code></a></dt>
proto bool ParentIterator::valid() proto bool IteratorIterator::valid() proto bool NoRewindIterator::valid() Check whether the current element is validNOT IMPLEMENTED.
<dt><a name="void_InfiniteIterator::__construct(Iterator_it)"
><b><code>void InfiniteIterator::__construct(Iterator it)</b></code></a></dt>
Create an iterator from another iteratorNOT IMPLEMENTED.
<dt><a name="void_InfiniteIterator::next()"
><b><code>void InfiniteIterator::next()</b></code></a></dt>
Prevent a call to inner iterators rewind() (internally the current data will be fetched if valid())NOT IMPLEMENTED.
<dt><a name="void_IteratorIterator::__construct(Traversable_it)"
><b><code>void IteratorIterator::__construct(Traversable it)</b></code></a></dt>
Create an iterator from anything that is traversableNOT IMPLEMENTED.
<dt><a name="_LimitIterator::__construct(Iterator_it_[,_int_offset,_int_count])"
><b><code> LimitIterator::__construct(Iterator it [, int offset, int count])</b></code></a></dt>
Construct a LimitIterator from an Iterator with a given starting offset and optionally a maximum countNOT IMPLEMENTED.
<dt><a name="int_LimitIterator::getPosition()"
><b><code>int LimitIterator::getPosition()</b></code></a></dt>
Return the current positionNOT IMPLEMENTED.
<dt><a name="void_LimitIterator::next()"
><b><code>void LimitIterator::next()</b></code></a></dt>
Move the iterator forwardNOT IMPLEMENTED.
<dt><a name="void_LimitIterator::rewind()"
><b><code>void LimitIterator::rewind()</b></code></a></dt>
Rewind the iterator to the specified starting offsetNOT IMPLEMENTED.
<dt><a name="void_LimitIterator::seek(int_position)"
><b><code>void LimitIterator::seek(int position)</b></code></a></dt>
Seek to the given positionNOT IMPLEMENTED.
<dt><a name="bool_LimitIterator::valid()"
><b><code>bool LimitIterator::valid()</b></code></a></dt>
Check whether the current element is validNOT IMPLEMENTED.
<dt><a name="void_NoRewindIterator::__construct(Iterator_it)"
><b><code>void NoRewindIterator::__construct(Iterator it)</b></code></a></dt>
Create an iterator from another iteratorNOT IMPLEMENTED.
<dt><a name="mixed_NoRewindIterator::current()"
><b><code>mixed NoRewindIterator::current()</b></code></a></dt>
Return inner iterators current()NOT IMPLEMENTED.
<dt><a name="mixed_NoRewindIterator::key()"
><b><code>mixed NoRewindIterator::key()</b></code></a></dt>
Return inner iterators key()NOT IMPLEMENTED.
<dt><a name="void_NoRewindIterator::next()"
><b><code>void NoRewindIterator::next()</b></code></a></dt>
Return inner iterators next()NOT IMPLEMENTED.
<dt><a name="void_NoRewindIterator::rewind()"
><b><code>void NoRewindIterator::rewind()</b></code></a></dt>
Prevent a call to inner iterators rewind()NOT IMPLEMENTED.
<dt><a name="bool_NoRewindIterator::valid()"
><b><code>bool NoRewindIterator::valid()</b></code></a></dt>
Return inner iterators valid()NOT IMPLEMENTED.
<dt><a name="void_ParentIterator::__construct(RecursiveIterator_it)"
><b><code>void ParentIterator::__construct(RecursiveIterator it)</b></code></a></dt>
Create a ParentIterator from a RecursiveIteratorNOT IMPLEMENTED.
<dt><a name="void_ParentIterator::next()"
><b><code>void ParentIterator::next()</b></code></a></dt>
proto void IteratorIterator::next() proto void NoRewindIterator::next() Move the iterator forwardNOT IMPLEMENTED.
<dt><a name="void_ParentIterator::rewind()"
><b><code>void ParentIterator::rewind()</b></code></a></dt>
proto void IteratorIterator::rewind() Rewind the iteratorNOT IMPLEMENTED.
<dt><a name="object_RecursiveArrayIterator::getChildren()"
><b><code>object RecursiveArrayIterator::getChildren()</b></code></a></dt>
Create a sub iterator for the current element (same class as $this)NOT IMPLEMENTED.
<dt><a name="bool_RecursiveArrayIterator::hasChildren()"
><b><code>bool RecursiveArrayIterator::hasChildren()</b></code></a></dt>
Check whether current element has children (e.g.
is an array)NOT IMPLEMENTED.
<dt><a name="void_RecursiveCachingIterator::__construct(RecursiveIterator_it_[,_flags_=_CIT_CALL_TOSTRING])"
><b><code>void RecursiveCachingIterator::__construct(RecursiveIterator it [, flags = CIT_CALL_TOSTRING])</b></code></a></dt>
Create an iterator from a RecursiveIteratorNOT IMPLEMENTED.
<dt><a name="RecursiveCachingIterator_RecursiveCachingIterator::getChildren()"
><b><code>RecursiveCachingIterator RecursiveCachingIterator::getChildren()</b></code></a></dt>
Return the inner iterator&#39;s children as a RecursiveCachingIteratorNOT IMPLEMENTED.
<dt><a name="bool_RecursiveCachingIterator::hasChildren()"
><b><code>bool RecursiveCachingIterator::hasChildren()</b></code></a></dt>
Check whether the current element of the inner iterator has childrenNOT IMPLEMENTED.
<dt><a name="void_RecursiveDirectoryIterator::__construct(string_path_[,_int_flags])"
><b><code>void RecursiveDirectoryIterator::__construct(string path [, int flags])</b></code></a></dt>
Cronstructs a new dir iterator from a path.NOT IMPLEMENTED.
<dt><a name="string_RecursiveDirectoryIterator::current()"
><b><code>string RecursiveDirectoryIterator::current()</b></code></a></dt>
Return getFilename(),
getFileInfo() or $this depending on flagsNOT IMPLEMENTED.
<dt><a name="void_RecursiveDirectoryIterator::getSubPath()"
><b><code>void RecursiveDirectoryIterator::getSubPath()</b></code></a></dt>
Get sub pathNOT IMPLEMENTED.
<dt><a name="void_RecursiveDirectoryIterator::getSubPathname()"
><b><code>void RecursiveDirectoryIterator::getSubPathname()</b></code></a></dt>
Get sub path and file nameNOT IMPLEMENTED.
<dt><a name="bool_RecursiveDirectoryIterator::hasChildren([bool_$allow_links_=_false])"
><b><code>bool RecursiveDirectoryIterator::hasChildren([bool $allow_links = false])</b></code></a></dt>
Returns whether current entry is a directory and not &#39;.&#39; or &#39;..&#39;NOT IMPLEMENTED.
<dt><a name="string_RecursiveDirectoryIterator::key()"
><b><code>string RecursiveDirectoryIterator::key()</b></code></a></dt>
Return getPathname() or getFilename() depending on flagsNOT IMPLEMENTED.
<dt><a name="void_RecursiveDirectoryIterator::next()"
><b><code>void RecursiveDirectoryIterator::next()</b></code></a></dt>
Move to next entryNOT IMPLEMENTED.
<dt><a name="void_RecursiveDirectoryIterator::rewind()"
><b><code>void RecursiveDirectoryIterator::rewind()</b></code></a></dt>
Rewind dir back to the startNOT IMPLEMENTED.
<dt><a name="void_RecursiveFilterIterator::__construct(RecursiveIterator_it)"
><b><code>void RecursiveFilterIterator::__construct(RecursiveIterator it)</b></code></a></dt>
Create a RecursiveFilterIterator from a RecursiveIteratorNOT IMPLEMENTED.
<dt><a name="RecursiveFilterIterator_RecursiveFilterIterator::getChildren()"
><b><code>RecursiveFilterIterator RecursiveFilterIterator::getChildren()</b></code></a></dt>
Return the inner iterator&#39;s children contained in a RecursiveFilterIteratorNOT IMPLEMENTED.
<dt><a name="bool_RecursiveFilterIterator::hasChildren()"
><b><code>bool RecursiveFilterIterator::hasChildren()</b></code></a></dt>
Check whether the inner iterator&#39;s current element has childrenNOT IMPLEMENTED.
<dt><a
><b><code>void RecursiveIteratorIterator::__construct(RecursiveIterator|IteratorAggregate it [, int mode = RIT_LEAVES_ONLY [, int flags = 0]])</b></code></a></dt>
Creates a RecursiveIteratorIterator from a RecursiveIterator.NOT IMPLEMENTED.
<dt><a name="void_RecursiveIteratorIterator::beginChildren()"
><b><code>void RecursiveIteratorIterator::beginChildren()</b></code></a></dt>
Called when recursing one level downNOT IMPLEMENTED.
<dt><a name="RecursiveIterator_RecursiveIteratorIterator::beginIteration()"
><b><code>RecursiveIterator RecursiveIteratorIterator::beginIteration()</b></code></a></dt>
Called when iteration begins (after first rewind() call)NOT IMPLEMENTED.
<dt><a name="RecursiveIterator_RecursiveIteratorIterator::callGetChildren()"
><b><code>RecursiveIterator RecursiveIteratorIterator::callGetChildren()</b></code></a></dt>
Return children of current elementNOT IMPLEMENTED.
<dt><a name="bool_RecursiveIteratorIterator::callHasChildren()"
><b><code>bool RecursiveIteratorIterator::callHasChildren()</b></code></a></dt>
Called for each element to test whether it has childrenNOT IMPLEMENTED.
<dt><a name="mixed_RecursiveIteratorIterator::current()"
><b><code>mixed RecursiveIteratorIterator::current()</b></code></a></dt>
Access the current element valueNOT IMPLEMENTED.
<dt><a name="void_RecursiveIteratorIterator::endChildren()"
><b><code>void RecursiveIteratorIterator::endChildren()</b></code></a></dt>
Called when end recursing one levelNOT IMPLEMENTED.
<dt><a name="RecursiveIterator_RecursiveIteratorIterator::endIteration()"
><b><code>RecursiveIterator RecursiveIteratorIterator::endIteration()</b></code></a></dt>
Called when iteration ends (when valid() first returns falseNOT IMPLEMENTED.
<dt><a name="int_RecursiveIteratorIterator::getDepth()"
><b><code>int RecursiveIteratorIterator::getDepth()</b></code></a></dt>
Get the current depth of the recursive iterationNOT IMPLEMENTED.
<dt><a name="RecursiveIterator_RecursiveIteratorIterator::getInnerIterator()"
><b><code>RecursiveIterator RecursiveIteratorIterator::getInnerIterator()</b></code></a></dt>
The current active sub iteratorNOT IMPLEMENTED.
<dt><a name="int|false_RecursiveIteratorIterator::getMaxDepth()"
><b><code>int|false RecursiveIteratorIterator::getMaxDepth()</b></code></a></dt>
Return the maximum accepted depth or false if any depth is allowedNOT IMPLEMENTED.
<dt><a name="RecursiveIterator_RecursiveIteratorIterator::getSubIterator([int_level])"
><b><code>RecursiveIterator RecursiveIteratorIterator::getSubIterator([int level])</b></code></a></dt>
The current active sub iterator or the iterator at specified levelNOT IMPLEMENTED.
<dt><a name="mixed_RecursiveIteratorIterator::key()"
><b><code>mixed RecursiveIteratorIterator::key()</b></code></a></dt>
Access the current keyNOT IMPLEMENTED.
<dt><a name="void_RecursiveIteratorIterator::next()"
><b><code>void RecursiveIteratorIterator::next()</b></code></a></dt>
Move forward to the next elementNOT IMPLEMENTED.
<dt><a name="void_RecursiveIteratorIterator::nextElement()"
><b><code>void RecursiveIteratorIterator::nextElement()</b></code></a></dt>
Called when the next element is availableNOT IMPLEMENTED.
<dt><a name="void_RecursiveIteratorIterator::rewind()"
><b><code>void RecursiveIteratorIterator::rewind()</b></code></a></dt>
Rewind the iterator to the first element of the top level inner iterator.NOT IMPLEMENTED.
<dt><a name="void_RecursiveIteratorIterator::setMaxDepth([$max_depth_=_&#45;1])"
><b><code>void RecursiveIteratorIterator::setMaxDepth([$max_depth = &#45;1])</b></code></a></dt>
Set the maximum allowed depth (or any depth if pmax_depth = &#45;1]NOT IMPLEMENTED.
<dt><a name="bool_RecursiveIteratorIterator::valid()"
><b><code>bool RecursiveIteratorIterator::valid()</b></code></a></dt>
Check whether the current position is validNOT IMPLEMENTED.
<dt><a
><b><code>void RecursiveRegexIterator::__construct(RecursiveIterator it, string regex [, int mode [, int flags [, int preg_flags]]])</b></code></a></dt>
Create an RecursiveRegexIterator from another recursive iterator and a regular expressionNOT IMPLEMENTED.
<dt><a name="RecursiveRegexIterator_RecursiveRegexIterator::getChildren()"
><b><code>RecursiveRegexIterator RecursiveRegexIterator::getChildren()</b></code></a></dt>
Return the inner iterator&#39;s children contained in a RecursiveRegexIteratorNOT IMPLEMENTED.
<dt><a name="void_RegexIterator::__construct(Iterator_it,_string_regex_[,_int_mode_[,_int_flags_[,_int_preg_flags]]])"
><b><code>void RegexIterator::__construct(Iterator it, string regex [, int mode [, int flags [, int preg_flags]]])</b></code></a></dt>
Create an RegexIterator from another iterator and a regular expressionNOT IMPLEMENTED.
<dt><a name="bool_RegexIterator::accept()"
><b><code>bool RegexIterator::accept()</b></code></a></dt>
Match (string)current() against regular expressionNOT IMPLEMENTED.
<dt><a name="bool_RegexIterator::getFlags()"
><b><code>bool RegexIterator::getFlags()</b></code></a></dt>
Returns current operation flagsNOT IMPLEMENTED.
<dt><a name="bool_RegexIterator::getFlags()"
><b><code>bool RegexIterator::getFlags()</b></code></a></dt>
Returns current PREG flags (if in use or NULL)NOT IMPLEMENTED.
<dt><a name="bool_RegexIterator::getMode()"
><b><code>bool RegexIterator::getMode()</b></code></a></dt>
Returns current operation modeNOT IMPLEMENTED.
<dt><a name="bool_RegexIterator::setFlags(int_new_flags)"
><b><code>bool RegexIterator::setFlags(int new_flags)</b></code></a></dt>
Set operation flagsNOT IMPLEMENTED.
<dt><a name="bool_RegexIterator::setMode(int_new_mode)"
><b><code>bool RegexIterator::setMode(int new_mode)</b></code></a></dt>
Set new operation modeNOT IMPLEMENTED.
<dt><a name="bool_RegexIterator::setPregFlags(int_new_flags)"
><b><code>bool RegexIterator::setPregFlags(int new_flags)</b></code></a></dt>
Set PREG flagsNOT IMPLEMENTED.
<dt><a name="int_SimpleXMLIterator::count()"
><b><code>int SimpleXMLIterator::count()</b></code></a></dt>
Get number of child elementsNOT IMPLEMENTED.
<dt><a name="SimpleXMLIterator_SimpleXMLIterator::current()"
><b><code>SimpleXMLIterator SimpleXMLIterator::current()</b></code></a></dt>
Get current elementNOT IMPLEMENTED.
<dt><a name="SimpleXMLIterator_SimpleXMLIterator::getChildren()"
><b><code>SimpleXMLIterator SimpleXMLIterator::getChildren()</b></code></a></dt>
Get child element iteratorNOT IMPLEMENTED.
<dt><a name="bool_SimpleXMLIterator::hasChildren()"
><b><code>bool SimpleXMLIterator::hasChildren()</b></code></a></dt>
Check whether element has children (elements)NOT IMPLEMENTED.
<dt><a name="string_SimpleXMLIterator::key()"
><b><code>string SimpleXMLIterator::key()</b></code></a></dt>
Get name of current child elementNOT IMPLEMENTED.
<dt><a name="void_SimpleXMLIterator::next()"
><b><code>void SimpleXMLIterator::next()</b></code></a></dt>
Move to next elementNOT IMPLEMENTED.
<dt><a name="void_SimpleXMLIterator::rewind()"
><b><code>void SimpleXMLIterator::rewind()</b></code></a></dt>
Rewind to first elementNOT IMPLEMENTED.
<dt><a name="bool_SimpleXMLIterator::valid()"
><b><code>bool SimpleXMLIterator::valid()</b></code></a></dt>
Check whether iteration is validNOT IMPLEMENTED.
<dt><a name="void_SplFileInfo::__construct(string_file_name)"
><b><code>void SplFileInfo::__construct(string file_name)</b></code></a></dt>
Cronstructs a new SplFileInfo from a path.NOT IMPLEMENTED.
<dt><a name="int_SplFileInfo::getATime()"
><b><code>int SplFileInfo::getATime()</b></code></a></dt>
Get last access time of fileNOT IMPLEMENTED.
<dt><a name="string_SplFileInfo::getBasename([string_$suffix])"
><b><code>string SplFileInfo::getBasename([string $suffix])</b></code></a></dt>
Returns filename component of pathNOT IMPLEMENTED.
<dt><a name="int_SplFileInfo::getCTime()"
><b><code>int SplFileInfo::getCTime()</b></code></a></dt>
Get inode modification time of fileNOT IMPLEMENTED.
<dt><a name="SplFileInfo_SplFileInfo::getFileInfo([string_$class_name])"
><b><code>SplFileInfo SplFileInfo::getFileInfo([string $class_name])</b></code></a></dt>
Get/copy file infoNOT IMPLEMENTED.
<dt><a name="string_SplFileInfo::getFilename()"
><b><code>string SplFileInfo::getFilename()</b></code></a></dt>
Return filename onlyNOT IMPLEMENTED.
<dt><a name="int_SplFileInfo::getGroup()"
><b><code>int SplFileInfo::getGroup()</b></code></a></dt>
Get file groupNOT IMPLEMENTED.
<dt><a name="int_SplFileInfo::getInode()"
><b><code>int SplFileInfo::getInode()</b></code></a></dt>
Get file inodeNOT IMPLEMENTED.
<dt><a name="string_SplFileInfo::getLinkTarget()"
><b><code>string SplFileInfo::getLinkTarget()</b></code></a></dt>
Return the target of a symbolic linkNOT IMPLEMENTED.
<dt><a name="int_SplFileInfo::getMTime()"
><b><code>int SplFileInfo::getMTime()</b></code></a></dt>
Get last modification time of fileNOT IMPLEMENTED.
<dt><a name="int_SplFileInfo::getOwner()"
><b><code>int SplFileInfo::getOwner()</b></code></a></dt>
Get file ownerNOT IMPLEMENTED.
<dt><a name="string_SplFileInfo::getPath()"
><b><code>string SplFileInfo::getPath()</b></code></a></dt>
Return the pathNOT IMPLEMENTED.
<dt><a name="SplFileInfo_SplFileInfo::getPathInfo([string_$class_name])"
><b><code>SplFileInfo SplFileInfo::getPathInfo([string $class_name])</b></code></a></dt>
Get/copy file infoNOT IMPLEMENTED.
<dt><a name="string_SplFileInfo::getPathname()"
><b><code>string SplFileInfo::getPathname()</b></code></a></dt>
Return path and filenameNOT IMPLEMENTED.
<dt><a name="int_SplFileInfo::getPerms()"
><b><code>int SplFileInfo::getPerms()</b></code></a></dt>
Get file permissionsNOT IMPLEMENTED.
<dt><a name="string_SplFileInfo::getRealPath()"
><b><code>string SplFileInfo::getRealPath()</b></code></a></dt>
Return the resolved pathNOT IMPLEMENTED.
<dt><a name="int_SplFileInfo::getSize()"
><b><code>int SplFileInfo::getSize()</b></code></a></dt>
Get file sizeNOT IMPLEMENTED.
<dt><a name="string_SplFileInfo::getType()"
><b><code>string SplFileInfo::getType()</b></code></a></dt>
Get file typeNOT IMPLEMENTED.
<dt><a name="bool_SplFileInfo::isDir()"
><b><code>bool SplFileInfo::isDir()</b></code></a></dt>
Returns true if file is directoryNOT IMPLEMENTED.
<dt><a name="bool_SplFileInfo::isExecutable()"
><b><code>bool SplFileInfo::isExecutable()</b></code></a></dt>
Returns true if file is executableNOT IMPLEMENTED.
<dt><a name="bool_SplFileInfo::isFile()"
><b><code>bool SplFileInfo::isFile()</b></code></a></dt>
Returns true if file is a regular fileNOT IMPLEMENTED.
<dt><a name="bool_SplFileInfo::isLink()"
><b><code>bool SplFileInfo::isLink()</b></code></a></dt>
Returns true if file is symbolic linkNOT IMPLEMENTED.
<dt><a name="bool_SplFileInfo::isReadable()"
><b><code>bool SplFileInfo::isReadable()</b></code></a></dt>
Returns true if file can be readNOT IMPLEMENTED.
<dt><a name="bool_SplFileInfo::isWritable()"
><b><code>bool SplFileInfo::isWritable()</b></code></a></dt>
Returns true if file can be writtenNOT IMPLEMENTED.
<dt><a name="SplFileObject_SplFileInfo::openFile([string_mode_=_&#39;r&#39;_[,_bool_use_include_path_[,_resource_context]]])"
><b><code>SplFileObject SplFileInfo::openFile([string mode = &#39;r&#39; [, bool use_include_path [, resource context]]])</b></code></a></dt>
Open the current fileNOT IMPLEMENTED.
<dt><a name="void_SplFileInfo::setFileClass([string_class_name])"
><b><code>void SplFileInfo::setFileClass([string class_name])</b></code></a></dt>
Class to use in openFile()NOT IMPLEMENTED.
<dt><a name="void_SplFileInfo::setInfoClass([string_class_name])"
><b><code>void SplFileInfo::setInfoClass([string class_name])</b></code></a></dt>
Class to use in getFileInfo(),
getPathInfo()NOT IMPLEMENTED.
<dt><a name="void_SplFileObject::__construct(string_filename_[,_string_mode_=_&#39;r&#39;_[,_bool_use_include_path_[,_resource_context]]]])"
><b><code>void SplFileObject::__construct(string filename [, string mode = &#39;r&#39; [, bool use_include_path [, resource context]]]])</b></code></a></dt>
Construct a new file objectNOT IMPLEMENTED.
<dt><a name="string_SplFileObject::current()"
><b><code>string SplFileObject::current()</b></code></a></dt>
Return current line from fileNOT IMPLEMENTED.
<dt><a name="void_SplFileObject::eof()"
><b><code>void SplFileObject::eof()</b></code></a></dt>
Return whether end of file is reachedNOT IMPLEMENTED.
<dt><a name="bool_SplFileObject::fflush()"
><b><code>bool SplFileObject::fflush()</b></code></a></dt>
Flush the fileNOT IMPLEMENTED.
<dt><a name="int_SplFileObject::fgetc()"
><b><code>int SplFileObject::fgetc()</b></code></a></dt>
Get a character form the fileNOT IMPLEMENTED.
<dt><a name="array_SplFileObject::fgetcsv([string_delimiter_[,_string_enclosure]])"
><b><code>array SplFileObject::fgetcsv([string delimiter [, string enclosure]])</b></code></a></dt>
Return current line as csvNOT IMPLEMENTED.
<dt><a name="string_SplFileObject::fgets()"
><b><code>string SplFileObject::fgets()</b></code></a></dt>
Rturn next line from fileNOT IMPLEMENTED.
<dt><a name="string_SplFileObject::fgetss([string_allowable_tags])"
><b><code>string SplFileObject::fgetss([string allowable_tags])</b></code></a></dt>
Get a line from file pointer and strip HTML tagsNOT IMPLEMENTED.
<dt><a name="bool_SplFileObject::flock(int_operation_[,_int_&#38;wouldblock])"
><b><code>bool SplFileObject::flock(int operation [, int &#38;wouldblock])</b></code></a></dt>
Portable file lockingNOT IMPLEMENTED.
<dt><a name="int_SplFileObject::fpassthru()"
><b><code>int SplFileObject::fpassthru()</b></code></a></dt>
Output all remaining data from a file pointerNOT IMPLEMENTED.
<dt><a name="bool_SplFileObject::fscanf(string_format_[,_string_...])"
><b><code>bool SplFileObject::fscanf(string format [, string ...])</b></code></a></dt>
Implements a mostly ANSI compatible fscanf()NOT IMPLEMENTED.
<dt><a name="int_SplFileObject::fseek(int_pos_[,_int_whence_=_SEEK_SET])"
><b><code>int SplFileObject::fseek(int pos [, int whence = SEEK_SET])</b></code></a></dt>
Return current file positionNOT IMPLEMENTED.
<dt><a name="bool_SplFileObject::fstat()"
><b><code>bool SplFileObject::fstat()</b></code></a></dt>
Stat() on a filehandleNOT IMPLEMENTED.
<dt><a name="int_SplFileObject::ftell()"
><b><code>int SplFileObject::ftell()</b></code></a></dt>
Return current file positionNOT IMPLEMENTED.
<dt><a name="bool_SplFileObject::ftruncate(int_size)"
><b><code>bool SplFileObject::ftruncate(int size)</b></code></a></dt>
Truncate file to &#39;size&#39; lengthNOT IMPLEMENTED.
<dt><a name="mixed_SplFileObject::fwrite(string_str_[,_int_length])"
><b><code>mixed SplFileObject::fwrite(string str [, int length])</b></code></a></dt>
Binary&#45;safe file writeNOT IMPLEMENTED.
<dt><a name="bool_SplFileObject::getChildren()"
><b><code>bool SplFileObject::getChildren()</b></code></a></dt>
Read NULLNOT IMPLEMENTED.
<dt><a name="array_SplFileObject::getCsvControl()"
><b><code>array SplFileObject::getCsvControl()</b></code></a></dt>
Get the delimiter and enclosure character used in fgetcsvNOT IMPLEMENTED.
<dt><a name="int_SplFileObject::getFlags()"
><b><code>int SplFileObject::getFlags()</b></code></a></dt>
Get file handling flagsNOT IMPLEMENTED.
<dt><a name="int_SplFileObject::getMaxLineLen()"
><b><code>int SplFileObject::getMaxLineLen()</b></code></a></dt>
Get maximum line lengthNOT IMPLEMENTED.
<dt><a name="bool_SplFileObject::hasChildren()"
><b><code>bool SplFileObject::hasChildren()</b></code></a></dt>
Return falseNOT IMPLEMENTED.
<dt><a name="int_SplFileObject::key()"
><b><code>int SplFileObject::key()</b></code></a></dt>
Return line numberNOT IMPLEMENTED.
<dt><a name="void_SplFileObject::next()"
><b><code>void SplFileObject::next()</b></code></a></dt>
Read next lineNOT IMPLEMENTED.
<dt><a name="void_SplFileObject::rewind()"
><b><code>void SplFileObject::rewind()</b></code></a></dt>
Rewind the file and read the first lineNOT IMPLEMENTED.
<dt><a name="void_SplFileObject::seek(int_line_pos)"
><b><code>void SplFileObject::seek(int line_pos)</b></code></a></dt>
Seek to specified lineNOT IMPLEMENTED.
<dt><a name="void_SplFileObject::setCsvControl([string_delimiter_=_&#39;,&#39;_[,_string_enclosure_=_&#39;&#34;&#39;]])"
><b><code>void SplFileObject::setCsvControl([string delimiter = &#39;,&#39; [, string enclosure = &#39;&#34;&#39;]])</b></code></a></dt>
Set the delimiter and enclosure character used in fgetcsvNOT IMPLEMENTED.
<dt><a name="void_SplFileObject::setFlags(int_flags)"
><b><code>void SplFileObject::setFlags(int flags)</b></code></a></dt>
Set file handling flagsNOT IMPLEMENTED.
<dt><a name="void_SplFileObject::setMaxLineLen(int_max_len)"
><b><code>void SplFileObject::setMaxLineLen(int max_len)</b></code></a></dt>
Set maximum line lengthNOT IMPLEMENTED.
<dt><a name="void_SplFileObject::valid()"
><b><code>void SplFileObject::valid()</b></code></a></dt>
Return !eof()NOT IMPLEMENTED.
<dt><a name="void_SplObjectStorage::attach($obj)"
><b><code>void SplObjectStorage::attach($obj)</b></code></a></dt>
Attaches an object to the storage if not yet containedNOT IMPLEMENTED.
<dt><a name="bool_SplObjectStorage::contains($obj)"
><b><code>bool SplObjectStorage::contains($obj)</b></code></a></dt>
Determine whethe an object is contained in the storageNOT IMPLEMENTED.
<dt><a name="int_SplObjectStorage::count()"
><b><code>int SplObjectStorage::count()</b></code></a></dt>
Determine number of objects in storageNOT IMPLEMENTED.
<dt><a name="mixed_SplObjectStorage::current()"
><b><code>mixed SplObjectStorage::current()</b></code></a></dt>
NOT IMPLEMENTED.
<dt><a name="void_SplObjectStorage::detach($obj)"
><b><code>void SplObjectStorage::detach($obj)</b></code></a></dt>
Detaches an object from the storageNOT IMPLEMENTED.
<dt><a name="mixed_SplObjectStorage::key()"
><b><code>mixed SplObjectStorage::key()</b></code></a></dt>
NOT IMPLEMENTED.
<dt><a name="void_SplObjectStorage::next()"
><b><code>void SplObjectStorage::next()</b></code></a></dt>
NOT IMPLEMENTED.
<dt><a name="void_SplObjectStorage::rewind()"
><b><code>void SplObjectStorage::rewind()</b></code></a></dt>
NOT IMPLEMENTED.
<dt><a name="string_SplObjectStorage::serialize()"
><b><code>string SplObjectStorage::serialize()</b></code></a></dt>
NOT IMPLEMENTED.
<dt><a name="void_SplObjectStorage::unserialize(string_serialized)"
><b><code>void SplObjectStorage::unserialize(string serialized)</b></code></a></dt>
NOT IMPLEMENTED.
<dt><a name="bool_SplObjectStorage::valid()"
><b><code>bool SplObjectStorage::valid()</b></code></a></dt>
NOT IMPLEMENTED.
<dt><a name="void_SplTempFileObject::__construct([int_max_memory])"
><b><code>void SplTempFileObject::__construct([int max_memory])</b></code></a></dt>
Construct a new temp file objectNOT IMPLEMENTED.
<dt><a name="array_class_implements(mixed_what_[,_bool_autoload_])"
><b><code>array class_implements(mixed what [, bool autoload ])</b></code></a></dt>
Return all classes and interfaces implemented by SPLNOT IMPLEMENTED.
<dt><a name="array_class_parents(object_instance)"
><b><code>array class_parents(object instance)</b></code></a></dt>
Return an array containing the names of all parent classesNOT IMPLEMENTED.
<dt><a name="int_iterator_apply(Traversable_it,_mixed_function_[,_mixed_params])"
><b><code>int iterator_apply(Traversable it, mixed function [, mixed params])</b></code></a></dt>
Calls a function for every element in an iteratorNOT IMPLEMENTED.
<dt><a name="int_iterator_count(Traversable_it)"
><b><code>int iterator_count(Traversable it)</b></code></a></dt>
Count the elements in an iteratorNOT IMPLEMENTED.
<dt><a name="array_iterator_to_array(Traversable_it_[,_bool_use_keys_=_true])"
><b><code>array iterator_to_array(Traversable it [, bool use_keys = true])</b></code></a></dt>
Copy the iterator into an arrayNOT IMPLEMENTED.
<dt><a name="void_spl_autoload(string_class_name_[,_string_file_extensions])"
><b><code>void spl_autoload(string class_name [, string file_extensions])</b></code></a></dt>
Default implementation for __autoload()NOT IMPLEMENTED.
<dt><a name="void_spl_autoload_call(string_class_name)"
><b><code>void spl_autoload_call(string class_name)</b></code></a></dt>
Try all registerd autoload function to load the requested classNOT IMPLEMENTED.
<dt><a name="string_spl_autoload_extensions([string_file_extensions])"
><b><code>string spl_autoload_extensions([string file_extensions])</b></code></a></dt>
Register and return default file extensions for spl_autoloadNOT IMPLEMENTED.
<dt><a name="false|array_spl_autoload_functions()"
><b><code>false|array spl_autoload_functions()</b></code></a></dt>
Return all registered __autoload() functionnsNOT IMPLEMENTED.
<dt><a name="bool_spl_autoload_register([mixed_autoload_function_=_&#34;spl_autoload&#34;_[,_throw_=_true]])"
><b><code>bool spl_autoload_register([mixed autoload_function = &#34;spl_autoload&#34; [, throw = true]])</b></code></a></dt>
Register given function as __autoload() implementationNOT IMPLEMENTED.
<dt><a name="bool_spl_autoload_unregister(mixed_autoload_function)"
><b><code>bool spl_autoload_unregister(mixed autoload_function)</b></code></a></dt>
Unregister given function as __autoload() implementationNOT IMPLEMENTED.
<dt><a name="array_spl_classes()"
><b><code>array spl_classes()</b></code></a></dt>
Return an array containing the names of all clsses and interfaces defined in SPLNOT IMPLEMENTED.
<dt><a name="string_spl_object_hash(object_obj)"
><b><code>string spl_object_hash(object obj)</b></code></a></dt>
Return hash id for given objectNOT IMPLEMENTED.</dl>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../../../resources/parrot_small.png"
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
