<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
    <HEAD>
        <TITLE>Readme file for PIRC compiler.</TITLE>
        <LINK REL="stylesheet" TYPE="text/css"
            HREF="../../../resources/perl.css"
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY>
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Readme file for PIRC compiler.</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../html/index.html">Contents</a> | <a href="../../../html/compilers.html">Compilers</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>README.txt &#45; Readme file for PIRC compiler.</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>PIRC is a fresh implementation of the PIR language using Bison and Flex.
Its main features are:</p>

<ul>
<li>thread&#45;safety,
so it is reentrant.</li>

<li>strength reduction,
implemented in the parser.</li>

<li>constant folding,
implemented in the parser.</li>

<li>checks for proper use of op arguments in PIR syntax (disallowing,
e.g.: $S0 = print)</li>

<li>allow multiple heredocs in subroutine invocations (like: foo(&#60;&#60;&#39;A&#39;,
&#60;&#60;&#39;B&#39;,
&#60;&#60;&#39;C&#39;) )</li>

<li>register usage optimization</li>
</ul>

<h2><a name="Compiling_and_Running"
>Compiling and Running <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<h3><a name="Windows_using_Microsoft_Visual_Studio"
>Windows using Microsoft Visual Studio</a></h3>

<p>To compile PIRC on windows using MSVC:</p>

<pre>   nmake</pre>

<p>When running PIRC, it needs the shared library <code>libparrot</code>; an easy way to do this is copy <code>libparrot.dll</code> in the Parrot root directory to <code>compilers/pirc/src</code>.</p>

<p>Running PIRC is as easy as:</p>

<pre> pirc test.pir</pre>

<p>See &#39;pirc &#45;h&#39; for help.</p>

<h3><a name="Linux_using_GCC"
>Linux using GCC</a></h3>

<p>The Makefile should work fine on Linux:</p>

<pre> cd compilers/pirc &#38;&#38; make</pre>

<p>When running PIRC, it needs the shared library <code>libparrot</code>; in order to let PIRC find it, set the path as follows:</p>

<pre> export LD_LIBRARY_PATH=../../../blib/lib</pre>

<p>Running is as easy as:</p>

<pre> ./pirc test.pir</pre>

<h2><a name="Overview"
>Overview <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>The new Bison/Flex based implementation of the PIR compiler is designed as a two&#45;stage compiler:</p>

<dl>
<dt><a name="1._Heredoc_preprocessor"
>1. Heredoc preprocessor</a></dt>

<dt><a name="2._PIR_compiler"
>2. PIR compiler</a></dt>
</dl>

<h2><a name="Heredoc_preprocessing"
>Heredoc preprocessing <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>The heredoc preprocessor takes the input as written by the PIR programmer, and flattens out all heredoc strings. An example is shown below to illustrate this concept:</p>

<p>The following input:</p>

<pre> .sub main
   $S0 = &#60;&#60;&#39;EOS&#39;
 This is a heredoc string
   divided
     over
       five
         lines.
 EOS
 .end</pre>

<p>is transformed into:</p>

<pre> .sub
   $S0 = &#34;This is a heredoc string\n  divided\n    over\n      five\n        lines.\n&#34;
 .end</pre>

<p>In order to allow <code>.include</code>d file to have heredoc strings, the heredoc preprocessor also handles the <code>.include</code> directive, even though logically this is a macro function. See the discussion below for how the <code>.include</code> directive works.</p>

<h2><a name="PIR_compilers"
>PIR compilers <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>The PIR compiler parses the output of the heredoc preprocessor. PIRC&#39;s lexer also handles macros.</p>

<p>The macro layer basically implements text replacements. The following directives are handled:</p>

<dl>
<dt><a name=".macro"
><b><code>.macro</b></code></a></dt>

<dt><a name=".macro_const"
><b><code>.macro_const</b></code></a></dt>

<dt><a name=".macro_local"
><b><code>.macro_local</b></code></a></dt>

<dt><a name=".macro_label"
><b><code>.macro_label</b></code></a></dt>
</dl>

<h3><a name=".include"
><code>.include</code></a></h3>

<p>The <code>.include</code> directive takes a string argument, which is the name of a file. The contents of this file are inserted at the point where the <code>.include</code> directive is written. To illustrate this, consider the following example:</p>

<pre> main.pir:
 ========================
 .sub main
   print &#34;hi\n&#34;
   foo()
 .end

 .include &#34;lib.pir&#34;
 ========================

 lib.pir:
 ========================
 .sub foo
   print &#34;foo\n&#34;
 .end
 ========================</pre>

<p>This will result in the following output:</p>

<pre> .sub main
   print &#34;hi\n&#34;
   foo()
 .end

 .sub foo
   print &#34;foo\n&#34;
 .end</pre>

<h3><a name=".macro"
><code>.macro</code></a></h3>

<p>The macro directive starts a macro definition. The macro preprocessor implements the expansion of macros. For instance, given the following input:</p>

<pre> .macro say(msg)
   print .msg
   print &#34;\n&#34;
 .endm

 .sub main
   .say(&#34;hi there!&#34;)
 .end</pre>

<p>will result in this output:</p>

<pre> .sub main
   print &#34;hi there!&#34;
   print &#34;\n&#34;
 .end</pre>

<h3><a name=".macro_const"
><code>.macro_const</code></a></h3>

<p>The <code>.macro_const</code> directive is similar to the <code>.macro</code> directive, except that a <code>.macro_const</code> is just a simplified <code>.macro</code>; it merely gives a name to some constant:</p>

<pre> .macro_const PI 3.14

 .sub main
   print &#34;PI is approximately: &#34;
   print .PI
   print &#34;\n&#34;
 .end</pre>

<p>This will result in the output:</p>

<pre> .sub main
   print &#34;PI is approximately: &#34;
   print 3.14
   print &#34;\n&#34;
 .end</pre>

<h3><a name="PIR_compiler"
>PIR compiler</a></h3>

<p>As Parrot instructions are polymorphic, the PIR compiler is responsible for selecting the right variant of the instruction. The selection is based on the types of the operands. For instance:</p>

<pre> set $I0, 42</pre>

<p>will select the <code>set_i_ic</code> instruction: this is the <code>set</code> instruction, taking an integer (i) result operand and an integer constant (ic) operand. Other examples are:</p>

<pre> $P0[1] = 42           &#45;&#45;&#62; set_p_kic_ic # kic = key integer constant
 $I0 = $P0[&#34;hi&#34;]       &#45;&#45;&#62; set_i_p_kc   # kc = key constant from constant table
 $P1 = new &#34;Hash&#34;      &#45;&#45;&#62; new_p_sc     # sc = string constant</pre>

<h3><a name="Constant_folding"
>Constant folding</a></h3>

<p>Expressions that can be evaluated at compile&#45;time are pre&#45;evaluated, saving calculations during runtime. Some constant&#45;folding is required, as Parrot depends on this. For instance:</p>

<pre> add $I0, 1, 2</pre>

<p>is not a valid Parrot instruction; there is no <code>add_i_ic_ic</code> instruction. Instead, this will be translated to:</p>

<pre> set $I0, 3</pre>

<p>which, as was explained earlier, will select the <code>set_i_ic</code> instruction.</p>

<p>The conditional branch instructions are also pre&#45;evaluated, if possible. For instance, consider the following statement:</p>

<pre> if 1 &#60; 2 goto L1</pre>

<p>It is clear during compile time, that 1 is smaller than 2; so instead of evaluating this during runtime, we know for sure that the branch to label <code>L1</code> will be made, effectively replacing the above statement by:</p>

<pre> goto L1</pre>

<p>Likewise, if it&#39;s clear that certain instructions don&#39;t have any effect, they can be removed altogether:</p>

<pre> if 1 &#62; 2 goto L1        &#45;&#45;&#62; nop  # nop is no opcode.
 $I0 = $I0 + 0           &#45;&#45;&#62; nop</pre>

<p>Another type of optimization is the selection of (slightly) more efficient variants of instructions. For instance, consider the following instruction:</p>

<pre> $I0 = $I0 + $I1</pre>

<p>which is actually syntactic sugar for:</p>

<pre> add $I0, $I0, $I1</pre>

<p>In C one would write (ignoring the fact that $I0 and $I0 are not a valid C identifiers):</p>

<pre> $I0 += $I1</pre>

<p>which is in fact valid PIR as well. When the PIR parser sees an instruction of this form, it will automatically select the variant with 2 operands instead of the 3&#45;operand variant. So:</p>

<pre> add $I0, $I0, $1    # $I0 is an out operand</pre>

<p>will be optimized, as if you had written:</p>

<pre> add $I0, $I1        # $I0 is an in/out operand</pre>

<p>The PIR parser can do even more improvements, if it sees opportunity to do so. Consider the following statement:</p>

<pre> $I0 = $I0 + 1</pre>

<p>or, in Parrot assembly syntax:</p>

<pre> add $I0, $I0, 1</pre>

<p>Again, in C one would write (again ignoring the valid identifier issue): <code>$I0++</code>, or in other words, <code>incrementing</code> the given identifier. Parrot has <code>inc</code> and <code>dec</code> instructions built&#45;in as well, so that the above statement <code>$I0 = $I0 + 1</code> can be optimized to:</p>

<pre> inc $I0</pre>

<h3><a name="Vanilla_Register_Allocator"
>Vanilla Register Allocator</a></h3>

<p>The PIR compiler implements a vanilla register allocator. This means that each declared <code>.local</code> or <code>.param</code> symbol, and each PIR register ($Px, $Sx, $Ix, $Nx) is assigned a unique PASM register, that is associated with the original symbol or PIR register throughout the subroutine.</p>

<p>PIRC has a register optimizer, which can optimize the register usage. Run PIRC with the <code>&#45;r</code> option to activate this. The register optimizer is implemented using a Linear Scan Register allocator.</p>

<p>The implementation of the vanilla register allocator is done in the PIR symbol management module (<code>pirsymbol.c</code>).</p>

<h2><a name="Register_optimizer"
>Register optimizer <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>PIRC has a register optimizer, which uses a Linear Scan Register algorithm. For each symbolic register, a live&#45;interval object is created, which has an <i>start</i> and <i>end</i> point, indicating the first and last usage of that symbolic register in the sub. The register optimizer figures out when symbolic registers don&#39;t overlap, in which case they can use the same register (assuming they&#39;re of the same type).</p>

<h2><a name="Status"
>Status <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Bytecode generation is done, but there is the occasional bug. These are reported in trac.parrot.org.</p>

<h1><a name="IMPLEMENTATION"
>IMPLEMENTATION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>The directory compilers/pirc has a number of subdirectories:</p>

<dl>
<dt><a name="doc_&#45;_contains_documentation."
>doc &#45; contains documentation.</a></dt>

<dt><a
>heredoc &#45; contains the implementation of the heredoc preprocessor. This is now integrated with pirc/src. It now only has a driver program to build a stand&#45;alone heredoc preprocessor.</a></dt>

<dt><a name="src_&#45;_contains_the_Bison/Flex_implementation_of_PIRC"
>src &#45; contains the Bison/Flex implementation of PIRC</a></dt>

<dt><a name="t_&#45;_for_tests._Tests_input_is_fed_into_Parrot_after_compilation,_which_will_run_the_code."
>t &#45; for tests. Tests input is fed into Parrot after compilation, which will run the code.</a></dt>

<dt><a
>macro &#45; contains the old implementation of the macro preprocessor. This is now integrated with pirc/src. These files are kept as a reference until the macro preprocessor in pirc/src is completed.</a></dt>
</dl>

<h1><a name="MAKING_CHANGES"
>MAKING CHANGES <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>If you want to make changes to the lexer of parser files, you will need the Flex and/or Bison programs. There are ports available for Windows, but I don&#39;t know whether they&#39;re any good. I use Cygwin&#39;s tools.</p>

<h2><a name="Updating_the_lexer"
>Updating the lexer <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>The heredoc preprocessor is implemented in <code>hdocprep.l</code>, and can be regenerated using:</p>

<pre>   cd compilers/pirc/src
   flex hdocprep.l</pre>

<p>PIRC&#39;s normal lexer is implemented in <code>pir.l</code>, and can be regenerated using:</p>

<pre>   cd compilers/pirc/src
   flex pir.l</pre>

<h2><a name="Updating_the_parser"
>Updating the parser <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>The parser is implemented in <code>pir.y</code>, and can be regenerated using:</p>

<pre>   cd compilers/pirc/src
   bison pir.y</pre>

<h1><a name="NOTES"
>NOTES <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<h2><a name="Cygwin_processable_lexer_spec."
>Cygwin processable lexer spec. <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>The file <code>pir.l</code> from which the lexer is generated is <i>not</i> processable by Cygwin&#39;s default version of Flex. In order to make a reentrant lexer, a newer version is needed, which can be downloaded from the link below.</p>

<p><a href='http://sourceforge.net/project/downloading.php?groupname=flex&#38;filename=flex&#45;2.5.33.tar.gz&#38;use_mirror=belnet'><a href="http://sourceforge.net/project/downloading.php?groupname=flex&#38;filename=flex&#45;2.5.33.tar.gz&#38;use_mirror=belnet">http://sourceforge.net/project/downloading.php?groupname=flex&#38;filename=flex&#45;2.5.33.tar.gz&#38;use_mirror=belnet</a></a></p>

<p>Just do:</p>

<pre> $ ./configure
 $ make</pre>

<p>Then make sure to overwrite the supplied flex binary.</p>

<h1><a name="BUGS"
>BUGS <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Having a look at this implementation would be greatly appreciated, and any resulting feedback even more :&#45;). Please post bug reports in trac.parrot.org.</p>

<h1><a name="SEE_ALSO"
>SEE ALSO <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>See also:</p>

<ul>
<li><code>languages/PIR</code> for a PGE based implementation.</li>

<li><code>compilers/imcc</code>, the current <i>standard</i> PIR implementation.</li>

<li><code>docs/imcc/syntax.pod</code> for a description of PIR syntax.</li>

<li><code>docs/imcc/</code> for more documentation about the PIR language.</li>

<li><code>docs/pdds/pdd19_pir.pod</code> for the PIR design document.</li>
</ul>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../resources/parrot_small.png"
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
