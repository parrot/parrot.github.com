<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
    <HEAD>
        <TITLE>Bison specification for the PIR assembly language parser.</TITLE>
        <LINK REL="stylesheet" TYPE="text/css"
            HREF="../../../../resources/perl.css"
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY>
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Bison specification for the PIR assembly language parser.</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../../html/index.html">Contents</a> | <a href="../../../../html/compilers.html">Compilers</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>pir.y &#45; Bison specification for the PIR assembly language parser.</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>This file implements the parser for the PIR assembly language.
During the parsing phase,
data structures are created that represent the input.
These data structures are defined in <code>pircompunit.h</code>.</p>

<p>The parser implements strength reduction and constant folding.
Strength reduction refers to the selection of instructions that have the same effect as the instruction written by the PIR programmer,
but are more efficient.
For instance:</p>

<pre> add $P0, $P0, $P1</pre>

<p>can be reduced to:</p>

<pre> add $P0, $P1</pre>

<p>as <code>$P0</code> was an IN/OUT operand.</p>

<p>Constant folding refers to the compile&#45;time evaluation of expressions, if possible. For instance:</p>

<pre> add $I0, 10, 20</pre>

<p>can be written as:</p>

<pre> set $I0, 30</pre>

<p>as we can evaluate this result during compile time. Likewise, conditional branch instructions may become unconditional branch instructions (if the condition evaluates to <i>true</i> during compile time) or it may become a <code>noop</code> (no op) instruction (if the condition evaluates to <i>false</i> during compile time).</p>

<h1><a name="FUNCTIONS"
>FUNCTIONS <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<dl>
<dt><a name="static_constant_*_fold_i_i(yyscan_t_yyscanner,_int_a,_pir_math_operator_op,_int_b)"
><b><code>static constant *fold_i_i(yyscan_t yyscanner, int a, pir_math_operator op, int b)</b></code></a></dt>
Evaluates the expression <code>a op b</code> and returns a constant node containing the result value. Both <code>a</code> and <code>b</code> are integer values.
<dt><a name="static_constant_*_fold_n_i(yyscan_t_yyscanner,_double_a,_pir_math_operator_op,_int_b)"
><b><code>static constant *fold_n_i(yyscan_t yyscanner, double a, pir_math_operator op, int b)</b></code></a></dt>
Same as <code>fold_i_i</code>, except <code>a</code> is of type double.
<dt><a name="static_constant_*_fold_i_n(yyscan_t_yyscanner,_int_a,_pir_math_operator_op,_double_b)"
><b><code>static constant *fold_i_n(yyscan_t yyscanner, int a, pir_math_operator op, double b)</b></code></a></dt>
Same as <code>fold_i_i</code>, except <code>b</code> is of type double.
<dt><a name="static_constant_*_fold_n_n(yyscan_t_yyscanner,_double_a,_pir_math_operator_op,_double_b)"
><b><code>static constant *fold_n_n(yyscan_t yyscanner, double a, pir_math_operator op, double b)</b></code></a></dt>
Same as <code>fold_i_i</code>, except that both <code>a</code> and <code>b</code> are of type double.
<dt><a name="static_constant_*_fold_s_s(yyscan_t_yyscanner,_char_*a,_pir_math_operator_op,_char_*b)"
><b><code>static constant *fold_s_s(yyscan_t yyscanner, char *a, pir_math_operator op, char *b)</b></code></a></dt>
Evaluate the expression <code>a op b</code>, where both <code>a</code> and <code>b</code> are strings. Only the concatenation and comparison operators are implemented; other operators will result in an error.
<dt><a name="static_int_evaluate_i_i(int_a,_pir_rel_operator_op,_double_b)"
><b><code>static int evaluate_i_i(int a, pir_rel_operator op, double b)</b></code></a></dt>
Compare <code>a</code> with <code>b</code> according to the relational operator <code>op</code>. Wrapper for <code>evaluate_n_n</code>, which takes arguments of type double.
<dt><a name="static_int_evaluate_n_i(int_a,_pir_rel_operator_op,_double_b)"
><b><code>static int evaluate_n_i(int a, pir_rel_operator op, double b)</b></code></a></dt>
Compare <code>a</code> with <code>b</code> according to the relational operator <code>op</code>. Wrapper for <code>evaluate_n_n</code>, which takes arguments of type double.
<dt><a name="static_int_evaluate_i_n(int_a,_pir_rel_operator_op,_double_b)"
><b><code>static int evaluate_i_n(int a, pir_rel_operator op, double b)</b></code></a></dt>
Compare <code>a</code> with <code>b</code> according to the relational operator <code>op</code>. Wrapper for <code>evaluate_n_n</code>, which takes arguments of type double.
<dt><a name="static_int_evaluate_n_n(double_a,_pir_rel_operator_op,_double_b)"
><b><code>static int evaluate_n_n(double a, pir_rel_operator op, double b)</b></code></a></dt>
Compare <code>a</code> with <code>b</code> according to the relational operator <code>op</code>. <code>op</code> can be <code>&#60;!=</code>&#62;, <code>&#60;==</code>&#62;, <code>&#60;</code>, <code>&#60;=</code>, <code>&#62;</code> or <code>&#62;=</code>.
<dt><a name="static_int_evaluate_s_s(char_*a,_pir_rel_operator_op,_char_*b)"
><b><code>static int evaluate_s_s(char *a, pir_rel_operator op, char *b)</b></code></a></dt>
Compare string <code>a</code> with string <code>b</code> using the operator <code>op</code>. The function uses C&#39;s <code>strcmp</code> function. Based on that result, which can be &#45;1 (smaller), 0 (equal) or 1 (larger), a boolean result is returned. Note that <code>strcmp()</code> should not be replaced by the <code>STREQ</code> macro used throughout Parrot source code; this function uses the result of <code>strcmp()</code>.
<dt><a name="static_int_evaluate_s(char_const_*_const_s)"
><b><code>static int evaluate_s(char const *const s)</b></code></a></dt>
Evaluate a string in boolean context; if the string&#39;s length is 0, it&#39;s false. If the string equals &#34;0&#34;, &#34;.0&#34;, &#34;0.&#34; or &#34;0.0&#34;, it&#39;s false. Otherwise, it&#39;s true.
<dt><a name="static_int_evaluate_c(lexer_state_*_const_lexer,_constant_*_const_c)"
><b><code>static int evaluate_c(lexer_state *const lexer, constant *const c)</b></code></a></dt>
Evaluate a constant node in boolean context; if the constant is numeric, it must be non&#45;zero to be true; if it&#39;s a string, <code>evaluate_s</code> is invoked to evaluate the string.
<dt><a name="static_char_*_concat_strings(lexer_state_*_const_lexer,_char_const_*a,_char_const_*b)"
><b><code>static char *concat_strings(lexer_state *const lexer, char const *a, char const *b)</b></code></a></dt>
Concatenates two strings into a new buffer. The new string is returned.
<dt><a name="static_void_create_if_instr(lexer_state_*lexer,_int_invert,_int_hasnull,_char_*_const_name,_char_*_const_label)"
><b><code>static void create_if_instr(lexer_state *lexer, int invert, int hasnull, char *const name, char *const label)</b></code></a></dt>
Create an <code>if</code> or <code>unless</code> instruction; if <code>invert</code> is non&#45;zero (true), the <code>if</code> instruction is inverted, effectively becoming <code>unless</code>.If <code>hasnull</code> is non&#45;zero (true), the <code>if</code> instruction becomes <code>if_null</code>; again, if <code>invert</code> is non&#45;zero, the instruction becomes <code>unless_null</code>.<code>name</code> is the name of the variable that is checked during this instruction
<dt><a name="static_int_check_value(constant_*_const_c,_int_val)"
><b><code>static int check_value(constant *const c, int val)</b></code></a></dt>
Check whether the current value of the constant <code>c</code> equals <code>val</code>. For our purposes, it is sufficient to check for integer values (including a check against 1.0 or 0.0). If the values are indeed equal, true is returned, false otherwise. If the constant is not numeric, it returns always false.
<dt><a name="static_void_reduce_strength(yyscan_t_yyscanner,_int_newop,_int_op2_index)"
><b><code>static void reduce_strength(yyscan_t yyscanner, int newop, int op2_index)</b></code></a></dt>
Do the actual strength reduction; the current op will be replaced by <code>newop</code>. The operands at position 1 and <code>op2_index</code> will be retrieved. <code>op2_index</code> indicates the position of the second operand that must be retrieved.When the current instruction is:
<pre> add_i_i_ic</pre>
then <code>op2_index</code> will be 1, indicating the second operand must be retrieved. When the current instruction is:
<pre> add_i_ic_i</pre>
then <code>op2_index</code> will be 2, so that the two operands represented by target nodes are retrieved (the operands indicated as <code>i</code>, as opposed by <code>ic</code>.)Then, if the two operands (which are target nodes) are equal, then one of them can be removed, so that the direction of the first operand will change from OUT to INOUT.
<dt><a name="static_int_convert_3_to_2_args(int_opcode,_int_*second_op_index)"
><b><code>static int convert_3_to_2_args(int opcode, int *second_op_index)</b></code></a></dt>
Given the 3&#45;operand version of a Parrot math op (in the parameter <code>opcode</code>), get the strength&#45;reduced version with 2 operands. This is a low&#45;level, &#34;dirty&#45;job&#45;but&#45;someone&#45;has&#45;to&#45;do&#45;it&#34; function, so other higher level functions don&#39;t get cluttered. If a 2&#45;operand version is specified, then that version is returned.The second parameter <code>second_op_index</code> will be assigned the index of the second target parameter, if any (note this is an <i>out</i> parameter, as it is passed by address). So, in case of <code>PARROT_OP_add_i_ic_i</code>, this will be 2, as that&#39;s the second target (start counting from 0). In case of <code>PARROT_OP_add_i_i_ic</code>, it&#39;s 1.
<dt><a name="static_void_do_strength_reduction(lexer_state_*_const_lexer)"
><b><code>static void do_strength_reduction(lexer_state *const lexer)</b></code></a></dt>
Implement strength reduction for the math operators <code>add</code>, <code>sub</code>, <code>mul</code>, <code>div</code> and <code>fdiv</code>. If the current instruction is any of these, then the first two operands are checked; if both are targets and are equal, the second operand is removed; this means that the first operand will be an IN/OUT operand. For instance:
<pre> add $I0, $I0, $I1</pre>
becomes:
<pre> add $I0, $I1</pre>
and
<pre> add $I0, 1</pre>
becomes:
<pre> inc $I0</pre>

<dt><a name="static_void_check_first_arg_direction(lexer_state_*_const_lexer,_char_*_const_opname)"
><b><code>static void check_first_arg_direction(lexer_state *const lexer, char *const opname)</b></code></a></dt>
This function checks the first argument&#39;s direction of the op <code>opname</code>. If the direction is not <code>OUT</code>, a syntax error is emitted. This function assumes that <code>opname</code> is a valid parrot op. This check is done to complain about valid PIR syntax that is undesirable, such as:
<pre> $S0 = print</pre>
which is another way of writing:
<pre> print $S0</pre>
As the first argument <code>$S0</code> is an <code>IN</code> argument, the sugared version should not be allowed.
<dt><a name="static_void_check_op_args_for_symbols(lexer_state_*_const_lexer)"
><b><code>static void check_op_args_for_symbols(lexer_state *const lexer)</b></code></a></dt>
Check the arguments of the current instruction. First, the number of expected arguments is checked against the specified number of arguments. Then, for each argument, if the particular argument should not be a label (instructions can take LABEL operands), and if the argument is a target node, then the argument must be a declared symbol. If it is not, an error message is given.If there are errors, FALSE is returned; if successful, TRUE is returned.
<dt><a name="static_void_undeclared_symbol(lexer_state_*_const_lexer,_char_*_const_symbol)"
><b><code>static void undeclared_symbol(lexer_state *const lexer, char *const symbol)</b></code></a></dt>
Report an error message saying that <code>symbol</code> was not declared. Then test whether the symbol is perhaps a PASM register identifier. The user may have mistakenly tried to use a PASM register in PIR mode.</dl>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../../resources/parrot_small.png"
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
