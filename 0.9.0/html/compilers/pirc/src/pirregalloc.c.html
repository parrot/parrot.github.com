<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
    <HEAD>
        <TITLE>Untitled</TITLE>
        <LINK REL="stylesheet" TYPE="text/css"
            HREF="../../../../resources/perl.css"
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY>
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Untitled</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../../html/index.html">Contents</a> | <a href="../../../../html/compilers.html">Compilers</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>This file contains functions implementing a somewhat modified version of the linear scan register allocation algorithm.
This algorithm assumes there&#39;s a fixed number of registers,
which is not the case for Parrot.
Therefore,
the algorithm is modified in some places.</p>

<h1><a name="SYNOPSIS"
>SYNOPSIS <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<pre>  // create a new lsr allocator
  lsr_allocator *lsr = new_linear_scan_register_allocator(lexer);

  for ( ... ) {
      pir_type type = ... ;

      // create a new live interval, specifying location/ID of first statement
      live_interval *interval = new_live_interval(lsr, firstlocation, type);
  }

  // update live interval with more usage information about a variable
  interval&#45;&#62;endpoint = ... ;

  // perform a linear scan
  linear_scan_register_allocation(lsr);

  // clean up
  destroy_linear_scan_register_allocator(lsr);</pre>

<h1><a name="FUNCTIONS"
>FUNCTIONS <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<dl>
<dt><a name="static_void_reset_register_count(lsr_allocator_*_const_lsr)"
><b><code>static void reset_register_count(lsr_allocator *const lsr)</b></code></a></dt>
Reset the register counters; there&#39;s one counter for each register type (string, num, int, pmc).
<dt><a name="lsr_allocator_*_new_linear_scan_register_allocator(struct_lexer_state_*_lexer)"
><b><code>lsr_allocator *new_linear_scan_register_allocator(struct lexer_state *lexer)</b></code></a></dt>
Constructor for a linear scan register allocator. Initializates the allocator, and returns it.
<dt><a name="void_destroy_linear_scan_register_allocator(lsr_allocator_*lsr)"
><b><code>void destroy_linear_scan_register_allocator(lsr_allocator *lsr)</b></code></a></dt>
Destructor for linear scan register allocator. All live_interval objects are destroyed as well.
<dt><a name="static_void_add_live_interval(lsr_allocator_*_const_lsr,_live_interval_*_const_i,_pir_type_type)"
><b><code>static void add_live_interval(lsr_allocator *const lsr, live_interval *const i, pir_type type)</b></code></a></dt>
Add live_interval <code>i</code> to the list; this list is sorted on increasing start point.
<dt><a name="live_interval_*_new_live_interval(lsr_allocator_*_const_lsr,_unsigned_firstuse_location,_pir_type_type)"
><b><code>live_interval *new_live_interval(lsr_allocator *const lsr, unsigned firstuse_location, pir_type type)</b></code></a></dt>
Constructor for a live_interval struct object. After creating the new interval object, its startpoint and endpoint are initialized to the value in <code>firstuse_location</code>. Note that an interval has a type; the register allocator keeps a list of interval for each type, because obviously you can&#39;t mix different types of registers.The newly created interval is added to the list of intervals.
<dt><a name="static_void_add_interval_to_active(lsr_allocator_*lsr,_live_interval_*_i,_pir_type_type)"
><b><code>static void add_interval_to_active(lsr_allocator *lsr, live_interval *i, pir_type type)</b></code></a></dt>
Add interval <code>i</code> to the list of active intervals; the list is sorted on increasing endpoint.
<dt><a name="static_unsigned_get_free_reg(lsr_allocator_*_const_lsr,_pir_type_type)"
><b><code>static unsigned get_free_reg(lsr_allocator *const lsr, pir_type type)</b></code></a></dt>
Allocate a new register; if there&#39;s any old registers to be reused, return such a second&#45;hand register; otherwise, allocate a brand new one.
<dt><a name="static_void_add_free_reg(lsr_allocator_*_const_lsr,_unsigned_regno,_pir_type_type)"
><b><code>static void add_free_reg(lsr_allocator *const lsr, unsigned regno, pir_type type)</b></code></a></dt>
Add register <code>regno</code> to the list of free regs that can be reuse.
<dt><a name="static_void_remove_from_active(live_interval_*i)"
><b><code>static void remove_from_active(live_interval *i)</b></code></a></dt>
Remove interval <code>i</code> from the list of active intervals.
<dt><a name="static_void_expire_old_intervals(lsr_allocator_*_const_lsr,_live_interval_*_i,_pir_type_type)"
><b><code>static void expire_old_intervals(lsr_allocator *const lsr, live_interval *i, pir_type type)</b></code></a></dt>
Go over all active intervals; if the endpoint of one of them is &#62;= than <code>i</code>&#39;s start point, the action is aborted. This is why the <code>active</code> list must be sorted on increasing endpoint. Otherwise <code>j</code> is &#39;removed&#39; from active, as it has expired. (the variable is no longer needed).
<dt><a name="static_void_cache_interval_objects(lsr_allocator_*_const_lsr,_live_interval_*_interval)"
><b><code>static void cache_interval_objects(lsr_allocator *const lsr, live_interval *interval)</b></code></a></dt>
Store the interval <code>interval</code> on a caching list; whenever a new <code>live_interval</code> object is requested, these interval objects can be re&#45;used, instead of malloc()ing a new one.
<dt><a name="void_linear_scan_register_allocation(lsr_allocator_*_const_lsr)"
><b><code>void linear_scan_register_allocation(lsr_allocator *const lsr)</b></code></a></dt>
Go over all live intervals; before handling any interval, expire all old ones; they might have expired (see expire_old_intervals()). Then, allocate a new register; this can be one that was just expired.</dl>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../../resources/parrot_small.png"
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
