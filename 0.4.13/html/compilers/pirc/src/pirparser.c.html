<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>parser for Parrot Intermediate Representation</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">parser for Parrot Intermediate Representation</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../../html/index.html">Contents</a> | <a href="../../../../html/compilers.html">Compilers</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>pirparser.c &#45; parser for Parrot Intermediate Representation</p>

<h1><a name="THOUGHTS_FOR_LATER"
>THOUGHTS FOR LATER <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<ul>
<li>Add error correcting stuff,
so parsing can continue after simple errors.</li><p class="pad"></p>

<li>Maybe use #define&#39;s to implement small functions.
Effectively,
these routines will be inlined in compilation_unit() or instruction(),
but when using #define&#39;s it&#39;s still code that looks good.</li><p class="pad"></p>

<li>Skip first token of statements if it&#39;s sure that the token has already been checked by the caller.
For instance,
no need to match &#39;goto&#39; again,
if it was already checked in compilation_unit().</li><p class="pad"></p>

<li>Maybe use compilers/bcg for back&#45;end,
if that would fit well.</li><p class="pad"></p>

<li>Clean up grammar after discussion.</li><p class="pad"></p>

<dl>
<dt><a
>+ For instance,
why have :postcomp and :immediate,
having same meaning?,
and why &#34;.sub&#34; and &#34;.pcc_sub&#34;?</a></dt><p class="pad"></p>

<dt><a
>+ why &#34;object&#34; as type?
Why custom names as type,
such as &#39;.local Array x&#39; &#45;&#45; this is not needed,
and makes the code look more like a HLL.
Just stick to &#39;pmc&#39;,
which works fine.</a></dt><p class="pad"></p>

<dt><a
>+ why allow an optional comma between sub pragmas?
param pragmas don&#39;t have that so remove this opt.
comma as well for consistency.</a></dt><p class="pad"></p>

<dt><a
>+ unify &#39;.sym&#39; and &#39;.local&#39;.
Just allow one,
and think of something else for local labels in macros.</a></dt><p class="pad"></p>
</dl>
</ul>

<h1><a name="PARSER_INTERNALS"
>PARSER INTERNALS <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>The parser_state structure has the following fields:</p>

<pre lang='und' xml:lang='und'> typedef struct parser_state {
    struct     lexer_state *lexer;     &#45;&#45; the lexer
    token      curtoken;               &#45;&#45; the current token as returned by the lexer
    char     **heredoc_ids;            &#45;&#45; array for holding heredoc arguments
    unsigned   heredoc_index;          &#45;&#45; index to keep track of heredoc ids in the array
    unsigned   parse_errors;           &#45;&#45; counter for parse_errors
    pirvtable *vtable;                 &#45;&#45; vtable holding pointers for output routines
 }</pre>

<h1><a name="PARSER_API"
>PARSER API <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<ul>
<li>void exit_parser()</li><p class="pad"></p>

<p>Clean up and exit the program normally.</p>

<li>get_parse_errors()</li><p class="pad"></p>

<p>return the number of parse errors.</p>

<li>new_parser()</li><p class="pad"></p>

<p>constructor for a parser_state object. The specified filename is parsed. The semantic actions in vtable are called at certain points in the code. The vtable is constructed in the parser&#39;s client code.</p>

<li>struct lexer_state const *get_lexer()</li><p class="pad"></p>

<p>returns the specified parser&#39;s lexer</p>

<li>token get_token()</li><p class="pad"></p>

<p>returns the specified parser&#39;s current token</p>
</ul>

<h1><a name="HELPER_FUNCTIONS"
>HELPER FUNCTIONS <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<ul>
<li>static void resize_heredoc_args()</li><p class="pad"></p>

<p>Reallocate memory for the array holding heredoc arguments. If needed, the array is resized to twice its previous size. So, initially it&#39;s MAX_HEREDOC_ARGS, after the first resize(), it&#39;s 2 times MAX_HEREDOC_ARGS, after the second time it&#39;s 2 * 2 * MAX_HEREDOC_ARGS, etc.</p>

<li>static void syntax_error()</li><p class="pad"></p>

<p>Handle all syntax error through this function. numargs is the number of variable arguments. All arguments should be of type &#34;char *&#34; !!!</p>

<li>static void match()</li><p class="pad"></p>

<p>checks whether the current token is the same as the expected token. If so, all is ok, and the next token is fetched. If not, an appropiate syntax error is reported.</p>
</ul>

<h1><a name="GRAMMAR"
>GRAMMAR <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<h2><a name="Conventions"
>Conventions <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>The following conventions are used:</p>

<pre lang='und' xml:lang='und'> [ foo ]       indicate an optional foo element
 { foo }       indicate zero or more foo elements
 ( foo | bar ) either foo or bar
 IDENTIFIER    match a token of type IDENTIFIER
 &#39;string&#39;      match the literal &#39;string&#39;</pre>

<h2><a name="Grammar_rules"
>Grammar rules <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<h3><a name="Expressions"
>Expressions</a></h3>

<ul>
<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  expression &#45;&#62; ( IDENTIFIER | INTC | NUMC | STRINGC | register )</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  string_value &#45;&#62; SREG | PASM_SREG | STRINGC</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  method &#45;&#62; IDENTIFIER | STRINGC</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  target   &#45;&#62; register | IDENTIFIER</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  type &#45;&#62; &#39;int&#39; | &#39;num&#39; | &#39;pmc&#39; | &#39;string&#39;</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  key &#45;&#62; &#39;&#45;&#39; expression | &#39;..&#39; expression | expression [ &#39;..&#39; [ expression ] ]</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  keylist &#45;&#62; &#39;[&#39; key { (&#39;;&#39;|&#39;,&#39;) key } &#39;]&#39;</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  arg_flags &#45;&#62; { arg_flag }

  arg_flag &#45;&#62; &#39;:flat&#39; | &#39;:named&#39; [ &#39;(&#39; STRINGC &#39;)&#39; ]</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  argument &#45;&#62; HEREDOCID | expression arg_flags | STRINGC (&#39;=&#62;&#39; expression | arg_flags)</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  argument_list &#45;&#62; argument { &#39;,&#39; argument }</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  arguments &#45;&#62; &#39;(&#39; [argument_list] &#39;)&#39; heredoc_arguments

  heredoc_arugments &#45;&#62; { HEREDOC_STRING }</pre>
</ul>

<h3><a name="Statements"
>Statements</a></h3>

<ul>
<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  methodcall &#45;&#62; INVOCANT_IDENT method arguments</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  arith_expr &#45;&#62; [ binop expression ]

  binop      &#45;&#62; &#39;+&#39;  | &#39;&#45;&#39; | &#39;*&#39;  | &#39;/&#39; | &#39;//&#39; | &#39;%&#39;  | &#39;~~&#39;  | &#39;~&#39;
              | &#39;&#38;&#38;&#39; | &#39;&#38;&#39; | &#39;||&#39; | &#39;|&#39; | &#39;&#60;&#60;&#39; | &#39;&#62;&#62;&#39; | &#39;&#62;&#62;&#62;&#39; | &#39;.&#39;</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  parrot_instruction &#45;&#62; PARROT_OP [ expression {&#39;,&#39; expression } ]</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  assignment &#45;&#62; &#39;=&#39; ( unop expression
                    | expression arith_expr
                    | target ( keylist | [ &#39;&#45;&#62;&#39; method ] arguments )
                    | STRINGC arguments
                    | &#39;global&#39; STRINGC
                    | heredocstring
                    | methodcall
                    | &#39;null&#39;
                    | parrot_instruction
                    )

  unop       &#45;&#62; &#39;&#45;&#39; | &#39;!&#39; | &#39;~&#39;</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  return_statement &#45;&#62; &#39;.return&#39; ( arguments
                                | target [&#39;&#45;&#62;&#39; method] arguments
                                | methodcall
                                )
                                &#39;\n&#39;</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  yield_statement &#45;&#62; &#39;.yield&#39; arguments &#39;\n&#39;</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  close_ns &#45;&#62; &#39;.endnamespace&#39; IDENTIFIER &#39;\n&#39;</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  open_ns &#45;&#62; &#39;.namespace&#39; IDENTIFIER &#39;\n&#39;</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  local_id_list &#45;&#62; local_id { &#39;,&#39; local_id }

  local_id  &#45;&#62; IDENTIFIER [&#39;:unique_reg&#39;]</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  declaration_list &#45;&#62; type local_id_list &#39;\n&#39;</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  sym_declaration &#45;&#62; &#39;.sym&#39; declaration_list</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  local_declaration &#45;&#62; &#39;.local&#39; declaration_list</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  lex_declaration &#45;&#62; &#39;.lex&#39; STRINGC &#39;,&#39; target &#39;\n&#39;</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  conditional_expression &#45;&#62; expression [cond_op expression]

  cond_op &#45;&#62; &#39;&#62;&#39; | &#39;&#62;=&#39; | &#39;&#60;&#39; | &#39;&#60;=&#39; | &#39;==&#39; | &#39;!=&#39;</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  jump_statement &#45;&#62; &#39;goto&#39; IDENTIFIER &#39;\n&#39;</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  goto_statement &#45;&#62; jump_statement</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  unless_statement &#45;&#62; &#39;unless&#39; ([&#39;null&#39;] expression | conditional_expression) jump_statement</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  if_statement &#45;&#62; &#39;if&#39; ([&#39;null&#39;] expression | conditional_expression) jump_statement</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  const_definition &#45;&#62; &#39;int&#39; IDENTIFIER &#39;=&#39; INTC
                    | &#39;num&#39; IDENTIFIER &#39;=&#39; NUMC
                    | &#39;pmc&#39; IDENTIFIER &#39;=&#39; STRINGC
                    | &#39;string&#39; IDENTIFIER &#39;=&#39; STRINGC</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  param_flags &#45;&#62; { param_flag }

  param_flag &#45;&#62; &#39;:slurpy&#39;
              | &#39;:named&#39;[&#39;(&#39; STRINGC &#39;)&#39;]
              | &#39;:unique_reg&#39;
              | &#39;:optional&#39;
              | &#39;:opt_flag&#39;</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  invokable &#45;&#62; IDENTIFIER | PREG</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  long&#45;invocation &#45;&#62; &#39;.pcc_begin&#39; &#39;\n&#39;
                     { &#39;.arg&#39; expression arg_flags }
                     ( &#39;.pcc_call&#39;|&#39;.nci_call&#39;) invokable &#39;\n&#39;
                     | &#39;.invocant&#39; invokable &#39;\n&#39;
                       &#39;.meth_call&#39; method &#39;\n&#39;
                     )
                     { (local_declaration | &#39;.result&#39; target param_flags &#39;\n&#39;) }
                     &#39;.pcc_end&#39; &#39;\n&#39;</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  long_return_statement &#45;&#62; &#39;.pcc_begin_return&#39; &#39;\n&#39;
                           { &#39;.return&#39; expression arg_flags &#39;\n&#39; }
                           &#39;.pcc_end_return&#39; &#39;\n&#39;</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  long_yield_statement &#45;&#62; &#39;.pcc_begin_yield&#39; &#39;\n&#39;
                          { &#39;.return&#39; expression arg_flags &#39;\n&#39; }
                          &#39;.pcc_end_yield&#39; &#39;\n&#39;</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  target_statement &#45;&#62; target ( &#39;=&#39; assignment
                             | augmented_op expression
                             | keylist &#39;=&#39; expression
                             | &#39;&#45;&#62;&#39; method arguments
                             | arguments
                             )
                             &#39;\n&#39;

  augmented_op     &#45;&#62; &#39;+=&#39; | &#39;&#45;=&#39; | &#39;%=&#39; | &#39;/=&#39;  | &#39;//=&#39; | &#39;*=&#39;  | &#39;.=&#39;
                    | &#39;~=&#39; | &#39;&#38;=&#39; | &#39;|=&#39; | &#39;**=&#39; | &#39;&#60;&#60;=&#39; | &#39;&#62;&#62;=&#39; | &#39;&#62;&#62;&#62;=&#39;</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  target_list &#45;&#62; &#39;(&#39; target param_flags {&#39;,&#39; target param_flags } &#39;)&#39;</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  multi&#45;result&#45;invocation &#45;&#62; target_list &#39;=&#39; (invokable arguments | methodcall) &#39;\n&#39;

  invokable &#45;&#62; IDENTIFIER | PREG | STRINGC</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  macro_expansion &#45;&#62; MACRO_IDENT [ &#39;(&#39; [ expression { &#39;,&#39; expression } &#39;)&#39; ] &#39;\n&#39;</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  get_results_instr &#45;&#62; &#39;.get_results&#39; target_list &#39;\n&#39;</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  global_assignment &#45;&#62; &#39;global&#39; string_value &#39;=&#39; (IDENTIFIER|PREG) &#39;\n&#39;</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  instructions &#45;&#62; {instruction}

  instruction  &#45;&#62; {LABEL [&#39;\n&#39;]} instr

  instr &#45;&#62; if_statement
         | unless_statement
         | local_declaration
         | sym_declaration
         | lex_declaration
         | &#39;.globalconst&#39; const_definition
         | &#39;.const&#39; const_definition
         | open_ns
         | close_ns
         | return_statement
         | yield_statement
         | macro_expansion
         | target_statement
         | STRINGC arguments
         | methodcall
         | long_invocation
         | long_return_statement
         | long_yield_statement
         | &#39;null&#39; var
         | get_results_instruction
         | global_assignment
         | &#39;\n&#39;</pre>
</ul>

<h3><a name="Compilation_Units"
>Compilation Units</a></h3>

<ul>
<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  global_definition &#45;&#62; &#39;.global&#39; IDENTIFIER</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  multi&#45;type&#45;list &#45;&#62; &#39;(&#39; [multi&#45;type {&#39;,&#39; multi&#45;type } ] &#39;)&#39;

  multi&#45;type &#45;&#62; IDENTIFIER | STRINGC | keylist | type</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  sub_flags &#45;&#62; [sub_flag { [&#39;,&#39;] sub_flag } ]

  sub_flag  &#45;&#62; &#39;:anon&#39;
             | &#39;:init&#39;
             | &#39;:load&#39;
             | &#39;:main&#39;
             | &#39;:method&#39;
             | &#39;:lex&#39;
             | &#39;:outer&#39; &#39;(&#39; ( STRINGC | IDENTIFIER )  &#39;)&#39;
             | &#39;:vtable&#39; &#39;(&#39; STRINGC &#39;)&#39;
             | &#39;:multi&#39; multi&#45;type&#45;list
             | &#39;:postcomp&#39;
             | &#39;:immediate&#39;</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  parameters &#45;&#62; { &#39;.param&#39; (register | type IDENTIFIER) [param_flag] &#39;\n&#39; }</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  sub_definition &#45;&#62; &#39;.sub&#39; (IDENTIFIER | STRINGC) subflags &#39;\n&#39; parameters instructions &#39;.end&#39;</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  emit_block &#45;&#62; &#39;.emit&#39; &#39;\n&#39; { parrot_instruction &#39;\n&#39; } &#39;.eom&#39;</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  macro_parameters &#45;&#62; [ &#39;(&#39; [ id {&#39;,&#39; id} ] &#39;)&#39; ]</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'> macro&#45;definition &#45;&#62; &#39;.macro&#39; IDENTIFIER macro_parameters &#39;\n&#39; macro_body &#39;.endm&#39;</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  include &#45;&#62; &#39;.include&#39; STRINGC</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  pragma &#45;&#62; &#39;.pragma&#39; &#39;n_operators&#39; INTC</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  hll_specifier &#45;&#62; &#39;.HLL&#39; STRINGC &#39;,&#39; STRINGC</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  hll_mapping &#45;&#62; &#39;.HLL_map&#39; INTC &#39;,&#39; INTC</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  namespace_declaration &#45;&#62; &#39;.namespace&#39; [ &#39;[&#39; STRINGC { (&#39;,&#39;|&#39;;&#39;) STRINGC &#39;]&#39; ]</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  loadlib &#45;&#62; &#39;.loadlib&#39; STRINGC</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  compilation_unit &#45;&#62; global_definition
                    | sub_definition
                    | &#39;.const&#39; const_definition
                    | emit_block
                    | include
                    | macro_definition
                    | pragma
                    | loadlib
                    | namespace_declaration
                    | hll_specifier
                    | hll_mapping</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  program &#45;&#62; {&#39;\n&#39;} compilation_unit { &#39;\n&#39; compilation_unit } EOF</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  TOP &#45;&#62; program</pre>
</ul>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
