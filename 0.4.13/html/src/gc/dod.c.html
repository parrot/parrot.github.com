<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Dead object destruction of the various headers</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Dead object destruction of the various headers</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../html/index.html">Contents</a> | <a href="../../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>src/dod.c &#45; Dead object destruction of the various headers</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>This file implements <i>dead object destruction</i>.
This is documented in PDD 9 with supplementary notes in <em lang='und' xml:lang='und'>docs/dev/dod.dev</em>.</p>

<p>It&#39;s possible to turn on/off the checking of the system stack and processor registers.
The actual checking is implemented in <em lang='und' xml:lang='und'><a href="../cpu_dep.c.html">src/cpu_dep.c</a></em>.</p>

<p>There&#39;s also a verbose mode for garbage collection.</p>

<h1><a name="FUNCTIONS"
>FUNCTIONS <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>*/</p>

<p>#define DOD_C_SOURCE #include &#34;parrot/parrot.h&#34; #include &#34;parrot/dod.h&#34; #include &#60;assert.h&#62;</p>

<p>/* HEADER: include/parrot/dod.h */</p>

<p>/* Set this to 1 to see if unanchored objects are found in system areas.
* Please note: these objects might be bogus */ #define GC_VERBOSE 0</p>

<p>#if !
DISABLE_GC_DEBUG /* Set when walking the system stack */ int CONSERVATIVE_POINTER_CHASING = 0; #endif</p>

<p>static size_t find_common_mask(size_t val1,
size_t val2) __attribute__const__ __attribute__warn_unused_result__;</p>

<p>/*</p>

<p>FUNCDOC: mark_special</p>

<p>Mark a special PMC.
If it has a <code lang='und' xml:lang='und'>PMC_EXT</code> structure,
append or prepend the <code lang='und' xml:lang='und'>next_for_GC</code> pointer; otherwise,
do the custom mark directly.</p>

<p>This should really be inline,
so if inline isn&#39;t available,
it would be better if it were a macro.</p>

<p>*/</p>

<p>static void mark_special(Interp *interp /*NN*/,
PMC *obj /*NN*/) { int hi_prio; Arenas *arena_base;</p>

<pre lang='und' xml:lang='und'>    /*
     * If the object is shared, we have to use the arena and dod
     * pointers of the originating interpreter.
     *
     * We are possibly changing another interpreter&#39;s data here, so
     * the mark phase of DOD must run only on one interpreter of a pool
     * at a time. However, freeing unused objects can occur in parallel.
     * And: to be sure that a shared object is dead, we have to finish
     * the mark phase of all interpreters in a pool that might reference
     * the object.
     */
    if (PObj_is_PMC_shared_TEST(obj)) {
        interp = PMC_sync(obj)&#45;&#62;owner;
        assert(interp);
        /* XXX FIXME hack */
        if (!interp&#45;&#62;arena_base&#45;&#62;dod_mark_ptr)
            interp&#45;&#62;arena_base&#45;&#62;dod_mark_ptr = obj;
    }
    arena_base = interp&#45;&#62;arena_base;

    if (PObj_needs_early_DOD_TEST(obj))
        ++arena_base&#45;&#62;num_early_PMCs_seen;

    if (PObj_high_priority_DOD_TEST(obj) &#38;&#38; arena_base&#45;&#62;dod_trace_ptr) {
        /* set obj&#39;s parent to high priority */
        PObj_high_priority_DOD_SET(arena_base&#45;&#62;dod_trace_ptr);
        hi_prio = 1;
    }
    else
        hi_prio = 0;

    if (obj&#45;&#62;pmc_ext) {
        PMC* const tptr = arena_base&#45;&#62;dod_trace_ptr;

        ++arena_base&#45;&#62;num_extended_PMCs;
        /*
         * XXX this basically invalidates the high&#45;priority marking
         *     of PMCs by putting all PMCs onto the front of the list.
         *     The reason for this is the by far better cache locality
         *     when aggregates and their contents are marked &#34;together&#34;.
         *
         *     To enable high priority marking again we should probably
         *     use a second pointer chain, which is, when not empty,
         *     processed first.
         */
        if (tptr || hi_prio) {
            if (PMC_next_for_GC(tptr) == tptr) {
                PMC_next_for_GC(obj) = obj;
            }
            else {
                /* put it at the head of the list */
                PMC_next_for_GC(obj) = PMC_next_for_GC(tptr);
            }

            PMC_next_for_GC(tptr)    = (PMC*)obj;
        }
        else {
            /* put it on the end of the list */
            PMC_next_for_GC(arena_base&#45;&#62;dod_mark_ptr) = obj;

            /* Explicitly make the tail of the linked list be
             * self&#45;referential */
            arena_base&#45;&#62;dod_mark_ptr = PMC_next_for_GC(obj) = obj;
        }
    }
    else if (PObj_custom_mark_TEST(obj)) {
        PObj_get_FLAGS(obj) |= PObj_custom_GC_FLAG;
        VTABLE_mark(interp, obj);
    }
}</pre>

<p>PARROT_API void pobject_lives(Interp *interp /*NN*/, PObj *obj /*NN*/) { #if PARROT_GC_GMS do { if (!PObj_live_TEST(obj) &#38;&#38; \ PObj_to_GMSH(obj)&#45;&#62;gen&#45;&#62;gen_no &#62;= interp&#45;&#62;gc_generation) \ parrot_gc_gms_pobject_lives(interp, obj); \ } while (0); #else /* not PARROT_GC_GMS */ /* if object is live or on free list return */ if (PObj_is_live_or_free_TESTALL(obj)) { return; } # if ! DISABLE_GC_DEBUG # if GC_VERBOSE if (CONSERVATIVE_POINTER_CHASING) { fprintf(stderr, &#34;GC Warning! Unanchored %s %p &#34; &#34; found in system areas \n&#34;, PObj_is_PMC_TEST(obj) ? &#34;PMC&#34; : &#34;Buffer&#34;, obj); } # endif # endif /* mark it live */ PObj_live_SET(obj);</p>

<pre lang='und' xml:lang='und'>    /* if object is a PMC and contains buffers or PMCs, then attach
     * the PMC to the chained mark list.
     */
    if (PObj_is_special_PMC_TEST(obj)) {
        mark_special(interp, (PMC*) obj);
    }
#  ifndef NDEBUG
    else {
        if (PObj_is_PMC_TEST(obj)) {
            PMC * const p = (PMC*)obj;

            if (p&#45;&#62;pmc_ext &#38;&#38; PMC_metadata(p)) {
                fprintf(stderr, &#34;GC: error obj %p (%s) has properties\n&#34;,
                        (void *)p, (char*)p&#45;&#62;vtable&#45;&#62;whoami&#45;&#62;strstart);
            }
        }
    }
#  endif
#  if GC_VERBOSE
    /* buffer GC_DEBUG stuff */
    if (! GC_DEBUG(interp))
        return;

    if (PObj_report_TEST(obj)) {
        fprintf(stderr, &#34;GC: buffer %p pointing to %p marked live\n&#34;,
                obj, PObj_bufstart((Buffer*) obj));
    }
#  endif
#endif  /* PARROT_GC_GMS */
}</pre>

<p>/*</p>

<p>FUNCDOC: Parrot_dod_trace_root</p>

<p>Trace the root set. Returns 0 if it&#39;s a lazy DOD run and all objects that need timely destruction were found.</p>

<p><code lang='und' xml:lang='und'>trace_stack</code> can have these values:</p>

<pre lang='und' xml:lang='und'> 0 ... trace normal roots, no system areas
 1 ... trace whole root set
 2 ... trace system areas only</pre>

<p>*/</p>

<p>PARROT_API int Parrot_dod_trace_root(Interp *interp /*NN*/, int trace_stack) { Arenas * const arena_base = interp&#45;&#62;arena_base; parrot_context_t *ctx;</p>

<pre lang='und' xml:lang='und'>    /*
     * note: adding locals here did cause increased DOD runs
     */
    unsigned int i = 0;

    if (trace_stack == 2) {
        trace_system_areas(interp);
        return 0;
    }

    if (interp&#45;&#62;profile)
        Parrot_dod_profile_start(interp);

    /* We have to start somewhere; the interpreter globals is a good place */
    if (!arena_base&#45;&#62;dod_mark_start) {
        arena_base&#45;&#62;dod_mark_start
            = arena_base&#45;&#62;dod_mark_ptr
            = interp&#45;&#62;iglobals;
    }

    /* mark it as used  */
    pobject_lives(interp, (PObj *)interp&#45;&#62;iglobals);

    /* mark the current context. */
    ctx = CONTEXT(interp&#45;&#62;ctx);
    mark_context(interp, ctx);

    /* mark the dynamic environment. */
    mark_stack(interp, interp&#45;&#62;dynamic_env);

    /*
     * mark vtable&#45;&#62;data
     *
     * XXX these PMCs are constant and shouldn&#39;t get collected
     * but t/library/dumper* fails w/o this marking.
     *
     * It seems that the Class PMC gets DODed &#45; these should
     * get created as constant PMCs.
     */
    for (i = 1; i &#60; (unsigned int)interp&#45;&#62;n_vtable_max; i++) {
        const VTABLE * const vtable = interp&#45;&#62;vtables[i];
        /*
         * XXX dynpmc groups have empty slots for abstract objects
         */
        if (vtable) {
            if (vtable&#45;&#62;mro)
                pobject_lives(interp, (PObj *)vtable&#45;&#62;mro);

            pobject_lives(interp, (PObj *)vtable&#45;&#62;_namespace);
        }
    }

    /* mark exception list */
    for (i = 0; i &#60;= E_LAST_PYTHON_E; ++i)
        pobject_lives(interp, (PObj*)interp&#45;&#62;exception_list[i]);

    /* mark the root_namespace */
    pobject_lives(interp, (PObj *)interp&#45;&#62;root_namespace);

    /* s. packfile.c */
    mark_const_subs(interp);

    /* mark caches and freelists */
    mark_object_cache(interp);

    /* Now mark the class hash */
    pobject_lives(interp, (PObj *)interp&#45;&#62;class_hash);

    /* Mark the PMC Proxy PMC array. */
    pobject_lives(interp, (PObj *)interp&#45;&#62;pmc_proxies);

    /* Mark the registry if any */
    if (interp&#45;&#62;DOD_registry)
        pobject_lives(interp, (PObj *)interp&#45;&#62;DOD_registry);

    /* Mark the transaction log */
    /* XXX do this more generically? */
    if (interp&#45;&#62;thread_data &#38;&#38; interp&#45;&#62;thread_data&#45;&#62;stm_log)
        Parrot_STM_mark_transaction(interp);

    /* Walk the iodata */
    Parrot_IOData_mark(interp, interp&#45;&#62;piodata);

    /* quick check if we can already bail out */
    if (arena_base&#45;&#62;lazy_dod &#38;&#38; arena_base&#45;&#62;num_early_PMCs_seen &#62;=
            arena_base&#45;&#62;num_early_DOD_PMCs)
        return 0;

    /* Find important stuff on the system stack */
    if (trace_stack)
        trace_system_areas(interp);

    if (interp&#45;&#62;profile)
        Parrot_dod_profile_end(interp, PARROT_PROF_DOD_p1);

    return 1;
}</pre>

<p>/*</p>

<p>FUNCDOC: trace_active_PMCs</p>

<p>Do a full trace run and mark all the PMCs as active if they are. Returns whether the run completed, that is, whether it&#39;s safe to proceed with GC.</p>

<p>*/</p>

<p>static int trace_active_PMCs(Interp *interp /*NN*/, int trace_stack) { if (!Parrot_dod_trace_root(interp, trace_stack)) return 0;</p>

<pre lang='und' xml:lang='und'>    /* Okay, we&#39;ve marked the whole root set, and should have a good&#45;sized
     * list of things to look at. Run through it */
    return Parrot_dod_trace_children(interp, (size_t) &#45;1);
}</pre>

<p>/*</p>

<p>FUNCDOC: Parrot_dod_trace_children</p>

<p>Returns whether the tracing process completed.</p>

<p>*/</p>

<p>PARROT_API int Parrot_dod_trace_children(Interp *interp /*NN*/, size_t how_many) { Arenas * const arena_base = interp&#45;&#62;arena_base; const int lazy_dod = arena_base&#45;&#62;lazy_dod; PMC *current = arena_base&#45;&#62;dod_mark_start; PMC *next;</p>

<pre lang='und' xml:lang='und'>    const UINTVAL mask = PObj_data_is_PMC_array_FLAG | PObj_custom_mark_FLAG;

    /*
     * First phase of mark is finished. Now if we are the owner
     * of a shared pool, we must run the mark phase of other
     * interpreters in our pool, so that live shared PMCs in that
     * interpreter are appended to our mark_ptrs chain.
     *
     * If there is a count of shared PMCs and we have already seen
     * all these, we could skip that.
     */
    if (interp&#45;&#62;profile)
        Parrot_dod_profile_start(interp);

    pt_DOD_mark_root_finished(interp);

    for (; ; current = next) {
        const UINTVAL bits = PObj_get_FLAGS(current) &#38; mask;

        if (lazy_dod &#38;&#38; arena_base&#45;&#62;num_early_PMCs_seen &#62;=
                arena_base&#45;&#62;num_early_DOD_PMCs) {
            return 0;
        }

        arena_base&#45;&#62;dod_trace_ptr = current;

        /*
         * short&#45;term hack to color objects black
         */
        PObj_get_FLAGS(current) |= PObj_custom_GC_FLAG;

        /*
         * clearing the flag is much more expensive then testing
         */
        if (!PObj_needs_early_DOD_TEST(current))
            PObj_high_priority_DOD_CLEAR(current);

        /* mark properties */
        if (PMC_metadata(current))
            pobject_lives(interp, (PObj *)PMC_metadata(current));

        /* Start by checking if there&#39;s anything at all. This assumes that the
         * largest percentage of PMCs won&#39;t have anything in their data
         * pointer that we need to trace. */
        if (bits) {
            if (bits == PObj_data_is_PMC_array_FLAG) {
                /* malloced array of PMCs */
                PMC ** const data = PMC_data_typed(current, PMC **);

                if (data) {
                    int i;
                    for (i = 0; i &#60; PMC_int_val(current); i++) {
                        if (data[i])
                            pobject_lives(interp, (PObj *)data[i]);
                    }
                }
            }
            else {
                /* All that&#39;s left is the custom */
                assert(!PObj_on_free_list_TEST(current));
                VTABLE_mark(interp, current);
            }
        }

        /* this value may be null */
        next = PMC_next_for_GC(current);

        if (next &#38;&#38; next == current)
            break;

        if (&#45;&#45;how_many == 0) {
            current = next;
            break;
        }
    }

    arena_base&#45;&#62;dod_mark_start = current;
    arena_base&#45;&#62;dod_trace_ptr  = NULL;

    if (interp&#45;&#62;profile)
        Parrot_dod_profile_end(interp, PARROT_PROF_DOD_p2);

    return 1;
}</pre>

<p>#ifdef GC_IS_MALLOC</p>

<p>/*</p>

<p>FUNCDOC: clear_cow</p>

<p>Clear the COW ref count.</p>

<p>*/</p>

<p>void clear_cow(Interp *interp, Small_Object_Pool *pool /*NN*/, int cleanup) { const UINTVAL object_size = pool&#45;&#62;object_size; Small_Object_Arena *cur_arena;</p>

<pre lang='und' xml:lang='und'>    /* clear refcount for COWable objects. */
    for (cur_arena = pool&#45;&#62;last_Arena;
            NULL != cur_arena; cur_arena = cur_arena&#45;&#62;prev) {
        UINTVAL i;
        Buffer *b = cur_arena&#45;&#62;start_objects;

        for (i = 0; i &#60; cur_arena&#45;&#62;used; i++) {
            if (!PObj_on_free_list_TEST(b)) {
                if (cleanup) {
                    /* clear COWed external FLAG */
                    PObj_external_CLEAR(b);

                    /* if cleanup (Parrot_destroy) constants are dead too */
                    PObj_constant_CLEAR(b);
                    PObj_live_CLEAR(b);
                }

                if (PObj_COW_TEST(b) &#38;&#38; PObj_bufstart(b) &#38;&#38;
                        !PObj_external_TEST(b)) {
                    INTVAL * const refcount = PObj_bufrefcountptr(b);
                    *refcount               = 0;
                }
            }

            b = (Buffer *)((char *)b + object_size);
        }
    }
}</pre>

<p>/*</p>

<p>FUNCDOC: used_cow</p>

<p>Find other users of COW&#39;s <code lang='und' xml:lang='und'>bufstart</code>.</p>

<p>*/</p>

<p>void used_cow(Interp *interp, Small_Object_Pool *pool /*NN*/, int cleanup) { UINTVAL object_size = pool&#45;&#62;object_size; Small_Object_Arena *cur_arena;</p>

<pre lang='und' xml:lang='und'>    for (cur_arena = pool&#45;&#62;last_Arena;
            NULL != cur_arena; cur_arena = cur_arena&#45;&#62;prev) {
        const Buffer *b = cur_arena&#45;&#62;start_objects;
        UINTVAL i;

        for (i = 0; i &#60; cur_arena&#45;&#62;used; i++) {
            if (!PObj_on_free_list_TEST(b) &#38;&#38;
                    PObj_COW_TEST(b) &#38;&#38;
                    PObj_bufstart(b) &#38;&#38;
                   !PObj_external_TEST(b)) {

                INTVAL * const refcount = PObj_bufrefcountptr(b);

                /* mark users of this bufstart by incrementing refcount */
                if (PObj_live_TEST(b))
                    *refcount = 1 &#60;&#60; 29;        /* ~infinite usage */
                else
                    (*refcount)++;      /* dead usage */
            }

            b = (Buffer *)((char *)b + object_size);
        }
    }
}
#endif /* GC_IS_MALLOC */</pre>

<p>/*</p>

<p>FUNCDOC: Parrot_dod_sweep</p>

<p>Put any buffers/PMCs that are now unused onto the pool&#39;s free list. If <code lang='und' xml:lang='und'>GC_IS_MALLOC</code>, bufstart gets freed too, if possible. Avoid buffers that are immune from collection (i.e. constant).</p>

<p>*/</p>

<p>PARROT_API void Parrot_dod_sweep(Interp *interp /*NN*/, Small_Object_Pool *pool /*NN*/) { Arenas * const arena_base = interp&#45;&#62;arena_base; UINTVAL i, total_used = 0; UINTVAL object_size = pool&#45;&#62;object_size;</p>

<pre lang='und' xml:lang='und'>    Small_Object_Arena *cur_arena;
    size_t              nm;
#if REDUCE_ARENAS
    UINTVAL free_arenas = 0, old_total_used = 0;
#endif</pre>

<p>#if GC_VERBOSE if (Interp_trace_TEST(interp, 1)) { Interp *tracer = interp&#45;&#62;debugger; PMC *pio = PIO_STDERR(interp);</p>

<pre lang='und' xml:lang='und'>        PIO_flush(interp, pio);

        if (tracer) {
            pio = PIO_STDERR(tracer);
            PIO_flush(tracer, pio);
        }
    }
#endif

    /* Run through all the buffer header pools and mark */
    for (cur_arena = pool&#45;&#62;last_Arena;
            NULL != cur_arena; cur_arena = cur_arena&#45;&#62;prev) {
        Buffer *b = (Buffer *)cur_arena&#45;&#62;start_objects;

        for (i = nm = 0; i &#60; cur_arena&#45;&#62;used; i++) {
            if (PObj_on_free_list_TEST(b))
                ; /* if it&#39;s on free list, do nothing */
            else if (PObj_live_TEST(b)) {
                total_used++;
                PObj_live_CLEAR(b);
                PObj_get_FLAGS(b) &#38;= ~PObj_custom_GC_FLAG;
            }
            else {
                /* it must be dead */</pre>

<p>#if GC_VERBOSE if (Interp_trace_TEST(interp, 1)) { fprintf(stderr, &#34;Freeing pobject %p\n&#34;, b); if (PObj_is_PMC_TEST(b)) { fprintf(stderr, &#34;\t = PMC type %s\n&#34;, (char*) ((PMC*)b)&#45;&#62;vtable&#45;&#62;whoami&#45;&#62;strstart); } } #endif</p>

<pre lang='und' xml:lang='und'>                if (PObj_is_shared_TEST(b)) {
                    /* only mess with shared objects if we
                     * (and thus everyone) is suspended for
                     * a GC run.
                     * XXX wrong thing to do with &#34;other&#34; GCs
                     */
                    if (!(interp&#45;&#62;thread_data &#38;&#38;
                            (interp&#45;&#62;thread_data&#45;&#62;state &#38;
                            THREAD_STATE_SUSPENDED_GC))) {
                        ++total_used;
                        goto next;
                    }
                }

                /* if object is a PMC and needs destroying */
                if (PObj_is_PMC_TEST(b)) {
                    PMC * const p = (PMC*)b;

                    /* then destroy it here
                     *
                     * TODO collect objects with finalizers
                    */
                    if (PObj_needs_early_DOD_TEST(p))
                        &#45;&#45;arena_base&#45;&#62;num_early_DOD_PMCs;

                    if (PObj_active_destroy_TEST(p))
                        VTABLE_destroy(interp, p);

                    if (PObj_is_PMC_EXT_TEST(p) &#38;&#38; p&#45;&#62;pmc_ext != NULL) {
                        /* if the PMC has a PMC_EXT structure,
                         * return it to the pool/arena
                         */
                        Small_Object_Pool * const ext_pool = arena_base&#45;&#62;pmc_ext_pool;

                        if (PObj_is_PMC_shared_TEST(p) &#38;&#38; PMC_sync(p)) {
                            MUTEX_DESTROY(PMC_sync(p)&#45;&#62;pmc_lock);
                            mem_internal_free(PMC_sync(p));
                            PMC_sync(p) = NULL;
                        }

                        ext_pool&#45;&#62;add_free_object(interp, ext_pool, p&#45;&#62;pmc_ext);
                    }
#ifndef NDEBUG
                    /*
                     * invalidate the PMC
                     */
                    p&#45;&#62;pmc_ext     = (PMC_EXT *)0xdeadbeef;
                    p&#45;&#62;vtable      = (VTABLE  *)0xdeadbeef;
                    PMC_pmc_val(p) = (PMC     *)0xdeadbeef;
#endif
                }
                /* else object is a buffer(like) */
                else if (PObj_sysmem_TEST(b) &#38;&#38; PObj_bufstart(b)) {
                    /* has sysmem allocated, e.g. string_pin */
                    mem_sys_free(PObj_bufstart(b));
                    PObj_bufstart(b) = NULL;
                    PObj_buflen(b)   = 0;
                }
                else {
#ifdef GC_IS_MALLOC
                    /* free allocated space at (int*)bufstart &#45; 1,
                     * but not if it used COW or is external
                     */
                    if (PObj_bufstart(b) &#38;&#38;
                            !PObj_is_external_or_free_TESTALL(b)) {
                        if (PObj_COW_TEST(b)) {
                            INTVAL *refcount = ((INTVAL *)PObj_bufstart(b) &#45; 1);

                            if (!&#45;&#45;(*refcount))
                                free(refcount); /* the actual bufstart */
                        }
                        else
                            free((INTVAL*)PObj_bufstart(b) &#45; 1);
                    }
#else
                    /*
                     * XXX Jarkko did report that on irix pool&#45;&#62;mem_pool
                     *     was NULL, which really shouldn&#39;t happen
                     */
                    if (pool&#45;&#62;mem_pool) {
                        if (!PObj_COW_TEST(b)) {
                            ((Memory_Pool *)
                             pool&#45;&#62;mem_pool)&#45;&#62;guaranteed_reclaimable +=
                                PObj_buflen(b);
                        }
                        ((Memory_Pool *)
                         pool&#45;&#62;mem_pool)&#45;&#62;possibly_reclaimable +=
                            PObj_buflen(b);
                    }
#endif
                    PObj_buflen(b) = 0;
                }
                PObj_flags_SETTO((PObj *)b, PObj_on_free_list_FLAG);
                pool&#45;&#62;add_free_object(interp, pool, b);
            }
next:
            b = (Buffer *)((char *)b + object_size);
        }
    }
    pool&#45;&#62;num_free_objects = pool&#45;&#62;total_objects &#45; total_used;
}</pre>

<p>#ifndef PLATFORM_STACK_WALK</p>

<p>/*</p>

<p>FUNCDOC: find_common_mask</p>

<p>Find a mask covering the longest common bit&#45;prefix of <code lang='und' xml:lang='und'>val1</code> and <code lang='und' xml:lang='und'>val2</code>.</p>

<p>*/</p>

<p>static size_t find_common_mask(size_t val1, size_t val2) { int i; const int bound = sizeof (size_t) * 8;</p>

<pre lang='und' xml:lang='und'>    /* Shifting a value by its size (in bits) or larger is undefined behaviour.
       So need an explicit check to return 0 if there is no prefix, rather than
       attempting to rely on (say) 0xFFFFFFFF &#60;&#60; 32 being 0.  */
    for (i = 0; i &#60; bound; i++) {
        if (val1 == val2)
            return ~(size_t)0 &#60;&#60; i;

        val1 &#62;&#62;= 1;
        val2 &#62;&#62;= 1;
    }

    if (val1 == val2) {
        assert(i == bound);
        return 0;
    }

    internal_exception(INTERP_ERROR,
            &#34;Unexpected condition in find_common_mask()!\n&#34;);

    return 0;
}</pre>

<p>/*</p>

<p>FUNCDOC: trace_mem_block</p>

<p>Traces the memory block between <code lang='und' xml:lang='und'>lo_var_ptr</code> and <code lang='und' xml:lang='und'>hi_var_ptr</code>.</p>

<p>*/</p>

<p>void trace_mem_block(Interp *interp /*NN*/, size_t lo_var_ptr, size_t hi_var_ptr) { size_t prefix; ptrdiff_t cur_var_ptr;</p>

<pre lang='und' xml:lang='und'>    const size_t buffer_min = get_min_buffer_address(interp);
    const size_t buffer_max = get_max_buffer_address(interp);
    const size_t pmc_min    = get_min_pmc_address(interp);
    const size_t pmc_max    = get_max_pmc_address(interp);

    const size_t mask       =
        find_common_mask(buffer_min &#60; pmc_min ? buffer_min : pmc_min,
                         buffer_max &#62; pmc_max ? buffer_max : pmc_max);

    if (!lo_var_ptr || !hi_var_ptr)
        return;

    if (lo_var_ptr &#60; hi_var_ptr) {
        const size_t tmp_ptr = hi_var_ptr;
        hi_var_ptr           = lo_var_ptr;
        lo_var_ptr           = tmp_ptr;
    }

    /* Get the expected prefix */
    prefix = mask &#38; buffer_min;

    for (cur_var_ptr = hi_var_ptr;
            (ptrdiff_t)cur_var_ptr &#60; (ptrdiff_t)lo_var_ptr;
            cur_var_ptr = (size_t)((ptrdiff_t)cur_var_ptr + sizeof (void *))) {
        const size_t ptr = *(size_t *)cur_var_ptr;

        /* Do a quick approximate range check by bit&#45;masking */
        if ((ptr &#38; mask) == prefix || !prefix) {
            /* Note that what we find via the stack or registers are not
             * guaranteed to be live pmcs/buffers, and could very well have
             * had their bufstart/vtable destroyed due to the linked list of
             * free headers... */
            if (pmc_min &#60;= ptr &#38;&#38; ptr &#60; pmc_max &#38;&#38;
                    is_pmc_ptr(interp, (void *)ptr)) {
                /* ...so ensure that pobject_lives checks PObj_on_free_list_FLAG
                 * before adding it to the next_for_GC list, to have
                 * vtable&#45;&#62;mark() called. */
                pobject_lives(interp, (PObj *)ptr);
            }
            else if (buffer_min &#60;= ptr &#38;&#38; ptr &#60; buffer_max &#38;&#38;
                    is_buffer_ptr(interp, (void *)ptr)) {
                /* ...and since pobject_lives doesn&#39;t care about bufstart, it
                 * doesn&#39;t really matter if it sets a flag */
                pobject_lives(interp, (PObj *)ptr);
            }
        }
    }
    return;
}
#endif</pre>

<p>/*</p>

<p>FUNCDOC: Run through all PMC arenas and clear live bits.</p>

<p>*/</p>

<p>/* interp is unused and can be removed */ static void clear_live_bits(Interp *interp /*NULLOK*/, Small_Object_Pool *pool /*NN*/) { Small_Object_Arena *arena; const UINTVAL object_size = pool&#45;&#62;object_size;</p>

<pre lang='und' xml:lang='und'>    for (arena = pool&#45;&#62;last_Arena; arena; arena = arena&#45;&#62;prev) {
        Buffer *b = (Buffer *)arena&#45;&#62;start_objects;
        UINTVAL i;

        for (i = 0; i &#60; arena&#45;&#62;used; i++) {
            PObj_live_CLEAR(b);
            b = (Buffer *)((char *)b + object_size);
        }
    }</pre>

<p>}</p>

<p>PARROT_API void Parrot_dod_clear_live_bits(Interp *interp /*NN*/) { Small_Object_Pool * const pool = interp&#45;&#62;arena_base&#45;&#62;pmc_pool; clear_live_bits(interp, pool); }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_dod_profile_start</p>

<p>Records the start time of a DOD run when profiling is enabled.</p>

<p>*/</p>

<p>PARROT_API void Parrot_dod_profile_start(Interp *interp /*NN*/) { if (Interp_flags_TEST(interp, PARROT_PROFILE_FLAG)) interp&#45;&#62;profile&#45;&#62;dod_time = Parrot_floatval_time(); }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_dod_profile_end</p>

<p>Records the end time of the DOD part <code lang='und' xml:lang='und'>what</code> run when profiling is enabled. Also record start time of next part.</p>

<p>*/</p>

<p>PARROT_API void Parrot_dod_profile_end(Interp *interp /*NN*/, int what) { if (Interp_flags_TEST(interp, PARROT_PROFILE_FLAG)) { RunProfile * const profile = interp&#45;&#62;profile; const FLOATVAL now = Parrot_floatval_time();</p>

<pre lang='und' xml:lang='und'>        profile&#45;&#62;data[what].numcalls++;
        profile&#45;&#62;data[what].time += now &#45; profile&#45;&#62;dod_time;

        /*
         * we&#39;ve recorded the time of a DOD/GC piece from
         * dod_time until now, so add this to the start of the
         * currently executing opcode, which hasn&#39;t run this
         * interval.
         */
        profile&#45;&#62;starttime += now &#45; profile&#45;&#62;dod_time;

        /* prepare start for next step */
        profile&#45;&#62;dod_time   = now;
    }
}</pre>

<p>/*</p>

<p>FUNCDOC: Parrot_dod_ms_run_init</p>

<p>Prepare for a mark &#38; sweep DOD run.</p>

<p>*/</p>

<p>PARROT_API void Parrot_dod_ms_run_init(Interp *interp /*NN*/) { Arenas * const arena_base = interp&#45;&#62;arena_base;</p>

<pre lang='und' xml:lang='und'>    arena_base&#45;&#62;dod_trace_ptr       = NULL;
    arena_base&#45;&#62;dod_mark_start      = NULL;
    arena_base&#45;&#62;num_early_PMCs_seen = 0;
    arena_base&#45;&#62;num_extended_PMCs   = 0;
}</pre>

<p>static int sweep_cb(Interp *interp /*NN*/, Small_Object_Pool *pool /*NN*/, int flag, void *arg) { int * const total_free = (int *) arg;</p>

<p>#ifdef GC_IS_MALLOC if (flag &#38; POOL_BUFFER) used_cow(interp, pool, 0); #endif</p>

<pre lang='und' xml:lang='und'>    Parrot_dod_sweep(interp, pool);</pre>

<p>#ifdef GC_IS_MALLOC if (flag &#38; POOL_BUFFER) clear_cow(interp, pool, 0); #endif</p>

<pre lang='und' xml:lang='und'>    if (interp&#45;&#62;profile &#38;&#38; (flag &#38; POOL_PMC))
        Parrot_dod_profile_end(interp, PARROT_PROF_DOD_cp);

    *total_free += pool&#45;&#62;num_free_objects;

    return 0;
}</pre>

<p>/*</p>

<p>FUNCDOC: Parrot_dod_ms_run</p>

<p>Run the stop&#45;the&#45;world mark &#38; sweep collector.</p>

<p>*/</p>

<p>PARROT_API void Parrot_dod_ms_run(Interp *interp /*NN*/, int flags) { Arenas * const arena_base = interp&#45;&#62;arena_base;</p>

<pre lang='und' xml:lang='und'>    /* XXX these should go into the interpreter */
    int total_free     = 0;

    if (arena_base&#45;&#62;DOD_block_level)
        return;

    if (interp&#45;&#62;debugger) {
        /*
         * if the other interpreter did a DOD run, it can set
         * live bits of shared objects, but these aren&#39;t reset, because
         * they are in a different arena. When now such a PMC points to
         * other non&#45;shared object, these wouldn&#39;t be marked and hence
         * collected.
         */
        Parrot_dod_clear_live_bits(interp);
    }

    /*
     * the sync sweep is always at the end, so that
     * the live bits are cleared
     */
    if (flags &#38; DOD_finish_FLAG) {
        /* XXX */
        Parrot_dod_clear_live_bits(interp);
        clear_live_bits(interp,
            interp&#45;&#62;arena_base&#45;&#62;constant_pmc_pool);

        Parrot_dod_sweep(interp, interp&#45;&#62;arena_base&#45;&#62;pmc_pool);
        Parrot_dod_sweep(interp, interp&#45;&#62;arena_base&#45;&#62;constant_pmc_pool);

        return;
    }

    ++arena_base&#45;&#62;DOD_block_level;
    arena_base&#45;&#62;lazy_dod = flags &#38; DOD_lazy_FLAG;

    /* tell the threading system that we&#39;re doing DOD mark */
    pt_DOD_start_mark(interp);
    Parrot_dod_ms_run_init(interp);

    /* Now go trace the PMCs */
    if (trace_active_PMCs(interp, flags &#38; DOD_trace_stack_FLAG)) {
        arena_base&#45;&#62;dod_trace_ptr = NULL;
        arena_base&#45;&#62;dod_mark_ptr  = NULL;

        /* mark is now finished */
        pt_DOD_stop_mark(interp);

        /* Now put unused PMCs and Buffers on the free list */
        Parrot_forall_header_pools(interp, POOL_BUFFER | POOL_PMC,
            (void*)&#38;total_free, sweep_cb);

        if (interp&#45;&#62;profile)
            Parrot_dod_profile_end(interp, PARROT_PROF_DOD_cb);
    }
    else {
        pt_DOD_stop_mark(interp); /* XXX */

        /* successful lazy DOD count */
        ++arena_base&#45;&#62;lazy_dod_runs;

        /* it was an aborted lazy dod run &#45; we should clear the live bits, but
         * e.g. t/pmc/timer_7 succeeds w/o this */</pre>

<p>#if 1 Parrot_dod_clear_live_bits(interp); #endif if (interp&#45;&#62;profile) Parrot_dod_profile_end(interp, PARROT_PROF_DOD_p2); }</p>

<pre lang='und' xml:lang='und'>    /* Note it */
    arena_base&#45;&#62;dod_runs++;
    &#45;&#45;arena_base&#45;&#62;DOD_block_level;

    return;
}</pre>

<p>/*</p>

<p>FUNCDOC: Parrot_do_dod_run</p>

<p>Call the configured garbage collector to reclaim unused headers.</p>

<p>*/</p>

<p>PARROT_API void Parrot_do_dod_run(Interp *interp /*NN*/, UINTVAL flags) { interp&#45;&#62;arena_base&#45;&#62;do_dod_run(interp, flags); parrot_gc_context(interp); }</p>

<p>/*</p>

<h1><a name="SEE_ALSO"
>SEE ALSO <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p><em lang='und' xml:lang='und'>include/parrot/dod.h</em>, <em lang='und' xml:lang='und'><a href="../cpu_dep.c.html">src/cpu_dep.c</a></em>, <em lang='und' xml:lang='und'>docs/dev/dod.dev</em> and <em lang='und' xml:lang='und'>docs/pdds/pdd09_gc.pod</em>.</p>

<h1><a name="HISTORY"
>HISTORY <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Initial version by Mike Lambert on 2002.05.27.</p>

<p>*/</p>

<p>/* * Local variables: * c&#45;file&#45;style: &#34;parrot&#34; * End: * vim: expandtab shiftwidth=4: */</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
