<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Base vtable calling functions</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Base vtable calling functions</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../html/index.html">Contents</a> | <a href="../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>src/key.c &#45; Base vtable calling functions</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>The base vtable calling functions.</p>

<h2><a name="Functions"
>Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>*/</p>

<p>#include &#34;parrot/parrot.h&#34; #include &#34;parrot/key.h&#34;</p>

<p>/* HEADER: include/parrot/key.h */</p>

<p>/*</p>

<p>FUNCDOC: key_new Returns a new <code lang='und' xml:lang='und'>Key</code> PMC.</p>

<p>*/</p>

<p>PARROT_API PMC * key_new(Interp *interp /*NN*/) { PMC * const key = pmc_new(interp,
enum_class_Key);</p>

<pre lang='und' xml:lang='und'>    return key;
}</pre>

<p>/*</p>

<p>FUNCDOC: key_new_integer Returns a new integer <code lang='und' xml:lang='und'>Key</code> PMC with value <code lang='und' xml:lang='und'>value</code>.</p>

<p>*/</p>

<p>PARROT_API PMC * key_new_integer(Interp *interp /*NN*/, INTVAL value) { PMC * const key = pmc_new(interp, enum_class_Key);</p>

<pre lang='und' xml:lang='und'>    PObj_get_FLAGS(key) |= KEY_integer_FLAG;
    PMC_int_val(key) = value;

    return key;
}</pre>

<p>/*</p>

<p>FUNCDOC: key_new_number Returns a new number <code lang='und' xml:lang='und'>Key</code> PMC with value <code lang='und' xml:lang='und'>value</code>.</p>

<p>*/</p>

<p>PARROT_API PMC * key_new_number(Interp *interp /*NN*/, FLOATVAL value) { PMC * const key = pmc_new(interp, enum_class_Key);</p>

<pre lang='und' xml:lang='und'>    PObj_get_FLAGS(key) |= KEY_number_FLAG;
    PMC_num_val(key) = value;

    return key;
}</pre>

<p>/*</p>

<p>FUNCDOC: Returns a new string <code lang='und' xml:lang='und'>Key</code> PMC with value <code lang='und' xml:lang='und'>value</code>.</p>

<p>*/</p>

<p>PARROT_API PMC * key_new_string(Interp *interp /*NN*/, STRING *value) { PMC * const key = pmc_new(interp, enum_class_Key);</p>

<pre lang='und' xml:lang='und'>    PObj_get_FLAGS(key) |= KEY_string_FLAG;
    PMC_str_val(key) = value;

    return key;
}</pre>

<p>/*</p>

<p>FUNCDOC: Returns a new string <code lang='und' xml:lang='und'>Key</code> PMC with value <code lang='und' xml:lang='und'>value</code> converted to a <code lang='und' xml:lang='und'>STRING</code>.</p>

<p>*/</p>

<p>PARROT_API PMC * key_new_cstring(Interp *interp /*NN*/, const char *value /*NULLOK*/) { return key_new_string(interp, string_from_cstring(interp, value, 0)); }</p>

<p>/*</p>

<p>FUNCDOC: Returns a new PMC <code lang='und' xml:lang='und'>Key</code> PMC with value <code lang='und' xml:lang='und'>value</code>.</p>

<p>*/</p>

<p>PARROT_API PMC * key_new_pmc(Interp *interp /*NN*/, PMC *value) { PMC * const key = pmc_new(interp, enum_class_Key);</p>

<pre lang='und' xml:lang='und'>    PObj_get_FLAGS(key) |= KEY_pmc_FLAG;
    internal_exception(1, &#34;this is broken &#45; see slice.pmc&#34;);
    PMC_pmc_val(key) = value;

    return key;
}</pre>

<p>/*</p>

<p>FUNCDOC: Set the integer <code lang='und' xml:lang='und'>value</code> in <code lang='und' xml:lang='und'>key</code>.</p>

<p>*/</p>

<p>PARROT_API void key_set_integer(Interp *interp, PMC *key /*NN*/, INTVAL value) { PObj_get_FLAGS(key) &#38;= ~KEY_type_FLAGS; PObj_get_FLAGS(key) |= KEY_integer_FLAG; PMC_int_val(key) = value;</p>

<pre lang='und' xml:lang='und'>    return;
}</pre>

<p>/*</p>

<p>FUNCDOC: Set the register <code lang='und' xml:lang='und'>value</code> in <code lang='und' xml:lang='und'>key</code>.</p>

<p>*/</p>

<p>PARROT_API void key_set_register(Interp *interp, PMC *key /*NN*/, INTVAL value, INTVAL flag) { PObj_get_FLAGS(key) &#38;= ~KEY_type_FLAGS; PObj_get_FLAGS(key) |= KEY_register_FLAG | flag; PMC_int_val(key) = value;</p>

<pre lang='und' xml:lang='und'>    return;
}</pre>

<p>/*</p>

<p>FUNCDOC: Set the number <code lang='und' xml:lang='und'>value</code> in <code lang='und' xml:lang='und'>key</code>.</p>

<p>*/</p>

<p>PARROT_API void key_set_number(Interp *interp, PMC *key /*NN*/, FLOATVAL value) { PObj_get_FLAGS(key) &#38;= ~KEY_type_FLAGS; PObj_get_FLAGS(key) |= KEY_number_FLAG; PMC_num_val(key) = value;</p>

<pre lang='und' xml:lang='und'>    return;
}</pre>

<p>/*</p>

<p>FUNCDOC: Set the string <code lang='und' xml:lang='und'>value</code> in <code lang='und' xml:lang='und'>key</code>.</p>

<p>*/</p>

<p>PARROT_API void key_set_string(Interp *interp, PMC *key /*NN*/, STRING *value) { PObj_get_FLAGS(key) &#38;= ~KEY_type_FLAGS; PObj_get_FLAGS(key) |= KEY_string_FLAG; PMC_str_val(key) = value;</p>

<pre lang='und' xml:lang='und'>    return;
}</pre>

<p>/*</p>

<p>FUNCDOC: key_set_pmc Set the PMC <code lang='und' xml:lang='und'>value</code> in <code lang='und' xml:lang='und'>key</code>.</p>

<p>*/</p>

<p>PARROT_API void key_set_pmc(Interp *interp, PMC *key /*NN*/, PMC *value) { PObj_get_FLAGS(key) &#38;= ~KEY_type_FLAGS; PObj_get_FLAGS(key) |= KEY_pmc_FLAG; /* * XXX leo * what for is this indirection? */ internal_exception(1, &#34;this is broken &#45; see slice.pmc&#34;); PMC_pmc_val(key) = value;</p>

<pre lang='und' xml:lang='und'>    return;
}</pre>

<p>/*</p>

<p>FUNCDOC: key_type Returns the type of <code lang='und' xml:lang='und'>key</code>.</p>

<p>*/</p>

<p>PARROT_API INTVAL key_type(Interp *interp, const PMC *key /*NN*/) { return (PObj_get_FLAGS(key) &#38; KEY_type_FLAGS) &#38; ~KEY_register_FLAG; }</p>

<p>PARROT_API INTVAL key_integer(Interp *interp, PMC *key /*NN*/) { switch (PObj_get_FLAGS(key) &#38; KEY_type_FLAGS) { case KEY_hash_iterator_FLAGS: case KEY_integer_FLAG: return PMC_int_val(key); case KEY_integer_FLAG | KEY_register_FLAG: return REG_INT(PMC_int_val(key)); case KEY_pmc_FLAG | KEY_register_FLAG: { PMC * const reg = REG_PMC(PMC_int_val(key)); return VTABLE_get_integer(interp, reg); } case KEY_string_FLAG: return string_to_int(interp, PMC_str_val(key)); case KEY_string_FLAG | KEY_register_FLAG: { STRING * const s_reg = REG_STR(PMC_int_val(key)); return string_to_int(interp, s_reg); } default: /* TODO check for slice_FLAGs */ return VTABLE_get_integer(interp, key); } }</p>

<p>PARROT_API FLOATVAL key_number(Interp *interp, PMC *key /*NN*/) { switch (PObj_get_FLAGS(key) &#38; KEY_type_FLAGS) { case KEY_number_FLAG: return PMC_num_val(key); case KEY_number_FLAG | KEY_register_FLAG: return REG_NUM(PMC_int_val(key)); case KEY_pmc_FLAG: return VTABLE_get_number(interp, key); /* PMC_pmc_val(key)); */ case KEY_pmc_FLAG | KEY_register_FLAG: { PMC * const reg = REG_PMC(PMC_int_val(key)); return VTABLE_get_number(interp, reg); } default: internal_exception(INVALID_OPERATION, &#34;Key not a number!\n&#34;); return 0; } }</p>

<p>PARROT_API STRING * key_string(Interp *interp /*NN*/, PMC *key /*NN*/) { switch (PObj_get_FLAGS(key) &#38; KEY_type_FLAGS) { case KEY_string_FLAG: return PMC_str_val(key); case KEY_string_FLAG | KEY_register_FLAG: return REG_STR(PMC_int_val(key)); /* PMC_pmc_val(key)); */ case KEY_pmc_FLAG | KEY_register_FLAG: { PMC * const reg = REG_PMC(PMC_int_val(key)); return VTABLE_get_string(interp, reg); } case KEY_integer_FLAG: return string_from_int(interp, PMC_int_val(key)); case KEY_integer_FLAG | KEY_register_FLAG: return string_from_int(interp, REG_INT(PMC_int_val(key))); default: case KEY_pmc_FLAG: return VTABLE_get_string(interp, key); } }</p>

<p>/*</p>

<p>FUNCDOC: key_pmc These functions return the integer/number/string/PMC values of <code lang='und' xml:lang='und'>key</code> if possible. Otherwise they throws an exceptions.</p>

<p>*/</p>

<p>PARROT_API PMC * key_pmc(Interp *interp, PMC *key /*NN*/) { switch (PObj_get_FLAGS(key) &#38; KEY_type_FLAGS) { case KEY_pmc_FLAG | KEY_register_FLAG: return REG_PMC(PMC_int_val(key)); default: return key; /* PMC_pmc_val(key); */ } }</p>

<p>/*</p>

<p>FUNCDOC: key_next Returns the next key if <code lang='und' xml:lang='und'>key</code> is in a sequence of linked keys.</p>

<p>*/</p>

<p>PARROT_API PMC * key_next(Interp *interp, PMC *key /*NN*/) { if (!key&#45;&#62;pmc_ext) return NULL; return (PMC *)PMC_data(key); }</p>

<p>/*</p>

<p>FUNCDOC: key_append Appends <code lang='und' xml:lang='und'>key2</code> to <code lang='und' xml:lang='und'>key1</code>.</p>

<p>Note that if <code lang='und' xml:lang='und'>key1</code> is not the last key in a sequence linked keys then the last key will be found and <code lang='und' xml:lang='und'>key2</code> appended to that.</p>

<p>Returns <code lang='und' xml:lang='und'>key1</code>.</p>

<p>*/</p>

<p>PARROT_API PMC * key_append(Interp *interp, PMC *key1 /*NN*/, PMC *key2 /*NN*/) { PMC *tail = key1;</p>

<pre lang='und' xml:lang='und'>    while (PMC_data(tail)) {
        tail = (PMC *)PMC_data(tail);
    }

    PMC_data(tail) = key2;

    return key1;
}</pre>

<p>/*</p>

<p>FUNCDOC: key_mark Marks <code lang='und' xml:lang='und'>key</code> as live.</p>

<p>*/</p>

<p>PARROT_API void key_mark(Interp *interp /*NN*/, PMC *key /*NN*/) { const UINTVAL flags = PObj_get_FLAGS(key) &#38; KEY_type_FLAGS;</p>

<pre lang='und' xml:lang='und'>    if (flags == KEY_string_FLAG)
        pobject_lives(interp, (PObj *)PMC_str_val(key));
    /*
     * KEY_hash_iterator_FLAGS denote a hash key iteration, PMC_data() is
     * the bucket_index and not the next key component
     */
    if (flags == KEY_hash_iterator_FLAGS)
        return;

    /* if iteration hasn&#39;t started, above flag isn&#39;t set yet */
    if (PMC_data(key) &#38;&#38; PMC_data(key) != (void *)INITBucketIndex)
        pobject_lives(interp, (PObj *)PMC_data(key));</pre>

<p>}</p>

<p>PARROT_API STRING * key_set_to_string(Interp *interp /*NN*/, PMC *key /*NULLOK*/) { STRING * const semicolon = string_from_cstring(interp, &#34; ; &#34;, 3); STRING * const quote = string_from_cstring(interp, &#34;&#39;&#34;, 1); STRING * const value = string_from_cstring(interp, &#34;[ &#34;, 2);</p>

<pre lang='und' xml:lang='und'>    for (; key; key = (PMC *)PMC_data(key)) {
        switch (PObj_get_FLAGS(key) &#38; KEY_type_FLAGS) {
            case KEY_integer_FLAG:
                string_append(interp, value, string_from_int(interp, PMC_int_val(key)));
                break;
            case KEY_string_FLAG:
                string_append(interp, value, quote);
                string_append(interp, value, PMC_str_val(key));
                string_append(interp, value, quote);
                break;
            case KEY_pmc_FLAG:
                string_append(interp, value, VTABLE_get_string(interp, key));
                break;
            case KEY_integer_FLAG | KEY_register_FLAG:
                string_append(interp, value, string_from_int(interp, REG_INT(PMC_int_val(key))));
                break;
            case KEY_string_FLAG | KEY_register_FLAG:
                string_append(interp, value, quote);
                string_append(interp, value, REG_STR(PMC_int_val(key)));
                string_append(interp, value, quote);
                break;
            case KEY_pmc_FLAG | KEY_register_FLAG:
                {
                PMC * const reg = REG_PMC(PMC_int_val(key));
                string_append(interp, value, VTABLE_get_string(interp, reg));
                }
                break;
            default:
                string_append(interp, value, string_from_cstring(interp, &#34;Key type unknown&#34;, 0));
                break;
        }

        if (PMC_data(key))
            string_append(interp, value, semicolon);
    }
    string_append(interp, value, string_from_cstring(interp, &#34; ]&#34;, 2));
    return value;
}</pre>

<p>/*</p>

<h1><a name="SEE_ALSO"
>SEE ALSO <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p><em lang='und' xml:lang='und'>include/parrot/key.h</em>.</p>

<h1><a name="HISTORY"
>HISTORY <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>Initial version by Jeff G. on 2001.12.05.</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
