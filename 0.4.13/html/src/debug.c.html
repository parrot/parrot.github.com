<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Parrot debugging</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Parrot debugging</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../html/index.html">Contents</a> | <a href="../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>src/debug.c &#45; Parrot debugging</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>This file implements Parrot debugging and is used by <code lang='und' xml:lang='und'>pdb</code>,
the Parrot debugger,
and the <code lang='und' xml:lang='und'>debug</code> ops.</p>

<h2><a name="Functions"
>Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="static_const_char*_parse_int(const_char_*str,_int_*intP)"
><b><code lang='und' xml:lang='und'>static const char *parse_int(const char *str, int *intP)</b></code></a></dt><p class="pad"></p>

<dd>Parse an <code lang='und' xml:lang='und'>int</code> out of a string and return a pointer to just after the <code lang='und' xml:lang='und'>int</code>.
The output parameter <code lang='und' xml:lang='und'>intP</code> contains the parsed value.</dd><p class="pad"></p>

<dt><a name="static_const_char*_parse_string(Interp_*interp,_const_char_*str,_STRING_**strP)"
><b><code lang='und' xml:lang='und'>static const char *parse_string(Interp *interp, const char *str, STRING **strP)</b></code></a></dt><p class="pad"></p>

<dd>Parse a double&#45;quoted string out of a C string and return a pointer to just after the string.
The parsed string is converted to a Parrot <code lang='und' xml:lang='und'>STRING</code> and placed in the output parameter <code lang='und' xml:lang='und'>strP</code>.</dd><p class="pad"></p>

<dt><a name="static_const_char*_parse_key(Interp_*interp,_const_char_*str,_PMC_**keyP)"
><b><code lang='und' xml:lang='und'>static const char *parse_key(Interp *interp, const char *str, PMC **keyP)</b></code></a></dt><p class="pad"></p>

<dd>Parse an aggregate key out of a string and return a pointer to just after the key.
Currently only string and integer keys are allowed.</dd><p class="pad"></p>

<dt><a name="static_const_char_*_parse_command(const_char_*command,_unsigned_long_*cmdP)"
><b><code lang='und' xml:lang='und'>static const char *parse_command(const char *command, unsigned long *cmdP)</b></code></a></dt><p class="pad"></p>

<dd>Convert the command at the beginning of a string into a numeric value that can be used as a switch key for fast lookup.</dd><p class="pad"></p>

<dt><a name="void_PDB_next(Interp_*interp,_const_char_*command)"
><b><code lang='und' xml:lang='und'>void PDB_next(Interp *interp, const char *command)</b></code></a></dt><p class="pad"></p>

<dd>Execute the next N operation(s).</dd><p class="pad"></p>

<dd>Inits the program if needed,
runs the next N &#62;= 1 operations and stops.</dd><p class="pad"></p>

<dt><a name="void_PDB_trace(Interp_*interp,_const_char_*command)"
><b><code lang='und' xml:lang='und'>void PDB_trace(Interp *interp, const char *command)</b></code></a></dt><p class="pad"></p>

<dd>Execute the next N operations; if no number is specified,
it defaults to 1.</dd><p class="pad"></p>

<dt><a name="PDB_condition_t_*_PDB_cond(Interp_*interp,_const_char_*command)"
><b><code lang='und' xml:lang='und'>PDB_condition_t *PDB_cond(Interp *interp, const char *command)</b></code></a></dt><p class="pad"></p>

<dd>Analyzes a condition from the user input.</dd><p class="pad"></p>

<dt><a name="void_PDB_watchpoint(Interp_*interp,_const_char_*command)"
><b><code lang='und' xml:lang='und'>void PDB_watchpoint(Interp *interp, const char *command)</b></code></a></dt><p class="pad"></p>

<dd>Set a watchpoint.</dd><p class="pad"></p>

<dt><a name="void_PDB_set_break(Interp_*interp,_const_char_*command)"
><b><code lang='und' xml:lang='und'>void PDB_set_break(Interp *interp, const char *command)</b></code></a></dt><p class="pad"></p>

<dd>Set a break point,
the source code file must be loaded.</dd><p class="pad"></p>

<dt><a name="void_PDB_init(Interp_*interp,_const_char_*command)"
><b><code lang='und' xml:lang='und'>void PDB_init(Interp *interp, const char *command)</b></code></a></dt><p class="pad"></p>

<dd>Init the program.</dd><p class="pad"></p>

<dt><a name="void_PDB_continue(Interp_*interp,_const_char_*command)"
><b><code lang='und' xml:lang='und'>void PDB_continue(Interp *interp, const char *command)</b></code></a></dt><p class="pad"></p>

<dd>Continue running the program.
If a number is specified,
skip that many breakpoints.</dd><p class="pad"></p>

<dt><a name="PDB_breakpoint_t_*_PDB_find_breakpoint(Interp_*interp,_const_char_*command)"
><b><code lang='und' xml:lang='und'>PDB_breakpoint_t *PDB_find_breakpoint(Interp *interp, const char *command)</b></code></a></dt><p class="pad"></p>

<dd>Find breakpoint number N; returns <code lang='und' xml:lang='und'>NULL</code> if the breakpoint doesn&#39;t exist or if no breakpoint was specified.</dd><p class="pad"></p>

<dt><a name="void_PDB_disable_breakpoint(Interp_*interp,_const_char_*command)"
><b><code lang='und' xml:lang='und'>void PDB_disable_breakpoint(Interp *interp, const char *command)</b></code></a></dt><p class="pad"></p>

<dd>Disable a breakpoint; it can be reenabled with the enable command.</dd><p class="pad"></p>

<dt><a name="void_PDB_enable_breakpoint(Interp_*interp,_const_char_*command)"
><b><code lang='und' xml:lang='und'>void PDB_enable_breakpoint(Interp *interp, const char *command)</b></code></a></dt><p class="pad"></p>

<dd>Reenable a disabled breakpoint; if the breakpoint was not disabled,
has no effect.</dd><p class="pad"></p>

<dt><a name="void_PDB_delete_breakpoint(Interp_*interp,_const_char_*command)"
><b><code lang='und' xml:lang='und'>void PDB_delete_breakpoint(Interp *interp, const char *command)</b></code></a></dt><p class="pad"></p>

<dd>Delete a breakpoint.</dd><p class="pad"></p>

<dt><a name="void_PDB_delete_condition(Interp_*interp,_PDB_breakpoint_t_*breakpoint)"
><b><code lang='und' xml:lang='und'>void PDB_delete_condition(Interp *interp, PDB_breakpoint_t *breakpoint)</b></code></a></dt><p class="pad"></p>

<dd>Delete a condition associated with a breakpoint.</dd><p class="pad"></p>

<dt><a name="void_PDB_skip_breakpoint(Interp_*interp,_long_i)"
><b><code lang='und' xml:lang='und'>void PDB_skip_breakpoint(Interp *interp, long i)</b></code></a></dt><p class="pad"></p>

<dd>Skip <code lang='und' xml:lang='und'>i</code> times all breakpoints.</dd><p class="pad"></p>

<dt><a name="char_PDB_program_end(Interp_*interp)"
><b><code lang='und' xml:lang='und'>char PDB_program_end(Interp *interp)</b></code></a></dt><p class="pad"></p>

<dd>End the program.</dd><p class="pad"></p>

<dt><a name="char_PDB_check_condition(Interp_*interp,_PDB_condition_t_*condition)"
><b><code lang='und' xml:lang='und'>char PDB_check_condition(Interp *interp, PDB_condition_t *condition)</b></code></a></dt><p class="pad"></p>

<dd>Returns true if the condition was met.</dd><p class="pad"></p>

<dt><a name="char_PDB_break(Interp_*interp)"
><b><code lang='und' xml:lang='und'>char PDB_break(Interp *interp)</b></code></a></dt><p class="pad"></p>

<dd>Returns true if we have to stop running.</dd><p class="pad"></p>

<dt><a name="char_*_PDB_escape(const_char_*string,_INTVAL_length)"
><b><code lang='und' xml:lang='und'>char *PDB_escape(const char *string, INTVAL length)</b></code></a></dt><p class="pad"></p>

<dd>Escapes <code lang='und' xml:lang='und'>&#34;</code>,
<code lang='und' xml:lang='und'>\r</code>,
<code lang='und' xml:lang='und'>\n</code>,
<code lang='und' xml:lang='und'>\t</code>,
<code lang='und' xml:lang='und'>\a</code> and <code lang='und' xml:lang='und'>\\</code>.</dd><p class="pad"></p>

<dt><a name="int_PDB_unescape(char_*string)"
><b><code lang='und' xml:lang='und'>int PDB_unescape(char *string)</b></code></a></dt><p class="pad"></p>

<dd>Do inplace unescape of <code lang='und' xml:lang='und'>\r</code>,
<code lang='und' xml:lang='und'>\n</code>,
<code lang='und' xml:lang='und'>\t</code>,
<code lang='und' xml:lang='und'>\a</code> and <code lang='und' xml:lang='und'>\\</code>.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>size_t PDB_disassemble_op(Interp *interp, char *dest, int space, op_info_t *info, opcode_t *op, PDB_file_t *file, opcode_t *code_start, int full_name)</b></code></a></dt><p class="pad"></p>

<dd>Disassembles <code lang='und' xml:lang='und'>op</code>.</dd><p class="pad"></p>

<dt><a name="void_PDB_disassemble(Interp_*interp,_const_char_*command)"
><b><code lang='und' xml:lang='und'>void PDB_disassemble(Interp *interp, const char *command)</b></code></a></dt><p class="pad"></p>

<dd>Disassemble the bytecode.</dd><p class="pad"></p>

<dt><a name="long_PDB_add_label(PDB_file_t_*file,_opcode_t_*cur_opcode,_opcode_t_offset)"
><b><code lang='und' xml:lang='und'>long PDB_add_label(PDB_file_t *file, opcode_t *cur_opcode, opcode_t offset)</b></code></a></dt><p class="pad"></p>

<dd>Add a label to the label list.</dd><p class="pad"></p>

<dt><a name="void_PDB_free_file(Interp_*interp)"
><b><code lang='und' xml:lang='und'>void PDB_free_file(Interp *interp)</b></code></a></dt><p class="pad"></p>

<dd>Frees any allocated source files.</dd><p class="pad"></p>

<dt><a name="void_PDB_load_source(Interp_*interp,_const_char_*command)"
><b><code lang='und' xml:lang='und'>void PDB_load_source(Interp *interp, const char *command)</b></code></a></dt><p class="pad"></p>

<dd>Load a source code file.</dd><p class="pad"></p>

<dt><a name="char_PDB_hasinstruction(char_*c)"
><b><code lang='und' xml:lang='und'>char PDB_hasinstruction(char *c)</b></code></a></dt><p class="pad"></p>

<dd>Return true if the line has an instruction.</dd><p class="pad"></p>

<dd>XXX TODO:</dd><p class="pad"></p>

<ul>
<li>This should take the line,
get an instruction,
get the opcode for that instruction and check that is the correct one.</li><p class="pad"></p>

<li>Decide what to do with macros if anything.</li><p class="pad"></p>
</ul>

<dt><a name="void_PDB_list(Interp_*interp,_const_char_*command)"
><b><code lang='und' xml:lang='und'>void PDB_list(Interp *interp, const char *command)</b></code></a></dt><p class="pad"></p>

<dd>Show lines from the source code file.</dd><p class="pad"></p>

<dt><a name="void_PDB_eval(Interp_*interp,_const_char_*command)"
><b><code lang='und' xml:lang='und'>void PDB_eval(Interp *interp, const char *command)</b></code></a></dt><p class="pad"></p>

<dd><code lang='und' xml:lang='und'>eval</code>s an instruction.</dd><p class="pad"></p>

<dt><a name="opcode_t_*_PDB_compile(Interp_*interp,_const_char_*command)"
><b><code lang='und' xml:lang='und'>opcode_t *PDB_compile(Interp *interp, const char *command)</b></code></a></dt><p class="pad"></p>

<dd>Compiles instructions with the PASM compiler.</dd><p class="pad"></p>

<dd>Appends an <code lang='und' xml:lang='und'>end</code> op.</dd><p class="pad"></p>

<dd>This may be called from <code lang='und' xml:lang='und'>PDB_eval</code> above or from the compile opcode which generates a malloced string.</dd><p class="pad"></p>

<dt><a name="int_PDB_extend_const_table(Interp_*interp)"
><b><code lang='und' xml:lang='und'>int PDB_extend_const_table(Interp *interp)</b></code></a></dt><p class="pad"></p>

<dd>Extend the constant table.</dd><p class="pad"></p>

<dt><a name="void_PDB_print_user_stack(Interp_*interp,_const_char_*command)"
><b><code lang='und' xml:lang='und'>void PDB_print_user_stack(Interp *interp, const char *command)</b></code></a></dt><p class="pad"></p>

<dd>Print an entry from the user stack.</dd><p class="pad"></p>

<dt><a name="void_PDB_info(Interp_*interp)"
><b><code lang='und' xml:lang='und'>void PDB_info(Interp *interp)</b></code></a></dt><p class="pad"></p>

<dd>Print the interpreter info.</dd><p class="pad"></p>

<dt><a name="void_PDB_help(Interp_*interp,_const_char_*command)"
><b><code lang='und' xml:lang='und'>void PDB_help(Interp *interp, const char *command)</b></code></a></dt><p class="pad"></p>

<dd>Print the help text.
&#34;Help&#34; with no arguments prints a list of commands.
&#34;Help xxx&#34; prints information on command xxx.</dd><p class="pad"></p>

<dt><a name="void_PDB_backtrace(Interp_*interp)"
><b><code lang='und' xml:lang='und'>void PDB_backtrace(Interp *interp)</b></code></a></dt><p class="pad"></p>

<dd>Prints a backtrace of the interp&#39;s call chain.</dd><p class="pad"></p>
</dl>

<h1><a name="SEE_ALSO"
>SEE ALSO <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p><em lang='und' xml:lang='und'>include/parrot/debug.h</em>,
<em lang='und' xml:lang='und'><a href="pdb.c.html">src/pdb.c</a></em> and <em lang='und' xml:lang='und'>ops/debug.ops</em>.</p>

<h1><a name="HISTORY"
>HISTORY <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<dl>
<dt><a name="Initial_version_by_Daniel_Grunblatt_on_2002.5.19."
>Initial version by Daniel Grunblatt on 2002.5.19.</a></dt><p class="pad"></p>

<dt><a name="Start_of_rewrite_&#45;_leo_2005.02.16"
>Start of rewrite &#45; leo 2005.02.16</a></dt><p class="pad"></p>

<dd>The debugger now uses its own interpreter.
User code is run in Interp *debugee.
We have:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  debug_interp&#45;&#62;pdb&#45;&#62;debugee&#45;&#62;debugger
    ^                            |
    |                            v
    +&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; := &#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;+</pre>

<dd>Debug commands are mostly run inside the <code lang='und' xml:lang='und'>debugger</code>. User code runs of course in the <code lang='und' xml:lang='und'>debugee</code>.</dd><p class="pad"></p>
</dl>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
