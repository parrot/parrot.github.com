<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>List aka array routines</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">List aka array routines</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../html/index.html">Contents</a> | <a href="../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>src/list.c &#45; List aka array routines</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>List is roughly based on concepts of IntList (thanks to Steve),
so I don&#39;t repeat them here.</p>

<p>Especially the same invariants hold,
except an empty list is really empty,
meaning,
push does first check for space.</p>

<p>The main differences are:</p>

<p>&#45; List can hold items of different size,
it&#39;s suitable for ints and PMCs ...,
calculations are still done in terms of items.
The item_size is specified at list creation time with the &#34;type&#34; argument.</p>

<p>If you later store different item types in the list,
as stated initially,
you&#39;ll get probably not what you want &#45; so don&#39;t do this.</p>

<p>&#45; List does auto grow.
The caller may implement a different behaviour if she likes.</p>

<p>&#45; Error checking for out of bounds access is minimal,
caller knows better,
what should be done.</p>

<p>&#45; List structure itself is different from List_chunk,
implying:</p>

<ul>
<li>end of list is not <code lang='und' xml:lang='und'>list&#45;&#62;prev</code> but <code lang='und' xml:lang='und'>list&#45;&#62;end</code></li><p class="pad"></p>

<li>start of list is list&#45;&#62;first</li><p class="pad"></p>

<li>the list of chunks is not closed,
detecting the end is more simple</li><p class="pad"></p>

<li>no spare is keeped,
didn&#39;t improve due to size constraints</li><p class="pad"></p>

<li>the List object itself doesn&#39;t move around for shift/unshift</li><p class="pad"></p>
</ul>

<p>&#45; list chunks don&#39;t have <code lang='und' xml:lang='und'>&#45;&#62;start</code> and <code lang='und' xml:lang='und'>&#45;&#62;end</code> fields.
Instead the list has <code lang='und' xml:lang='und'>&#45;&#62;start</code>,
which is start of first chunk,
and <code lang='und' xml:lang='und'>&#45;&#62;cap</code>,
the total usable capacity in the list.</p>

<p>&#45; number of items in chunks are not fixed,
but there is a mode using same sized chunks</p>

<h2><a name="Grow_policy"
>Grow policy <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="enum_grow_fixed"
><b><code lang='und' xml:lang='und'>enum_grow_fixed</b></code></a></dt><p class="pad"></p>

<dd>All chunks are of <code lang='und' xml:lang='und'>MAX_ITEMS</code> size,
chosen,
when the first access to the array is indexed and beyond <code lang='und' xml:lang='und'>MIN_ITEMS</code> and below 10 * <code lang='und' xml:lang='und'>MAX_ITEMS</code></dd><p class="pad"></p>

<dd>If the first access is beyond 10 * <code lang='und' xml:lang='und'>MAX_ITEMS</code> a sparse chunk will be created.</dd><p class="pad"></p>

<dd>To avoid this &#45; and the performance penalty &#45; set the array size before setting elements.</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    new P0, .Array
    set P0, 100000  # sets fixed sized, no sparse</pre>

<dd>This is only meaningful, if a lot of the entries are used too.</dd><p class="pad"></p>

<dt><a name="enum_grow_growing"
><b><code lang='und' xml:lang='und'>enum_grow_growing</b></code></a></dt><p class="pad"></p>

<dd>Chunk sizes grow from <code lang='und' xml:lang='und'>MIN_ITEMS</code> to <code lang='und' xml:lang='und'>MAX_ITEMS</code>, this will be selected for pushing data on an empty array.</dd><p class="pad"></p>

<dt><a name="enum_grow_mixed"
><b><code lang='und' xml:lang='und'>enum_grow_mixed</b></code></a></dt><p class="pad"></p>

<dd>Mixture of above chunk types and when sparse chunks are present, or after insert and delete.</dd><p class="pad"></p>

<dd>The chunks hold the information, how many chunks are of the same type, beginning from the current, and how many items are included in this range. See <code lang='und' xml:lang='und'>get_chunk</code> below for details.</dd><p class="pad"></p>
</dl>

<h2><a name="Sparse_lists"
>Sparse lists <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>To save memory, List can handle sparse arrays. This code snippet:</p>

<p>new P0, .IntList set P0[1000000], 42</p>

<p>generates 3 List_chunks, one at the beginning of the array, a big sparse chunk and a chunk for the actual data.</p>

<p>Setting values inside sparse chunks changes them to real chunks. For poping/shifting inside sparse chunks, s. return value below.</p>

<h2><a name="Chunk_types"
>Chunk types <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="fixed_items"
><b><code lang='und' xml:lang='und'>fixed_items</b></code></a></dt><p class="pad"></p>

<dd>Have allocated space, size is a power of 2, consecutive chunks are same sized.</dd><p class="pad"></p>

<dt><a name="grow_items"
><b><code lang='und' xml:lang='und'>grow_items</b></code></a></dt><p class="pad"></p>

<dd>Same, but consecutive chunks are growing.</dd><p class="pad"></p>

<dt><a name="no_power_2"
><b><code lang='und' xml:lang='und'>no_power_2</b></code></a></dt><p class="pad"></p>

<dd>Have allocated space but any size.</dd><p class="pad"></p>

<dt><a name="sparse"
><b><code lang='und' xml:lang='und'>sparse</b></code></a></dt><p class="pad"></p>

<dd>Only dummy allocation, <code lang='und' xml:lang='und'>chunk&#45;&#62;items</code> holds the items of this sparse hole.</dd><p class="pad"></p>
</dl>

<h2><a name="Data_types"
>Data types <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>A List can hold various datatypes. See <em lang='und' xml:lang='und'>src/datatypes.h</em> for the enumeration of types.</p>

<p>Not all are yet implemented in <code lang='und' xml:lang='und'>list_set</code>/<code lang='und' xml:lang='und'>list_item</code>, see the <code lang='und' xml:lang='und'>switch()</code>.</p>

<p>Arbitrary length data:</p>

<p>Construct initializer with:</p>

<dl>
<dt><a name="enum_type_sized"
><b><code lang='und' xml:lang='und'>enum_type_sized</b></code></a></dt><p class="pad"></p>

<dt><a name="item_size_(in_bytes)"
><b><code lang='und' xml:lang='und'>item_size</b></code> (in bytes)</a></dt><p class="pad"></p>

<dt><a name="items_per_chunk_(rounded_up_to_power_of_2,_default_MAX_ITEMS)"
><b><code lang='und' xml:lang='und'>items_per_chunk</b></code> (rounded up to power of 2, default <b><code lang='und' xml:lang='und'>MAX_ITEMS</b></code>)</a></dt><p class="pad"></p>
</dl>

<p>In <code lang='und' xml:lang='und'>list_assign</code> the values are copied into the array, <code lang='und' xml:lang='und'>list_get</code> returns a pointer as for all other data types.</p>

<p>See <em lang='und' xml:lang='und'>src/list_2.t</em> and <code lang='und' xml:lang='und'>list_new_init()</code>.</p>

<h2><a name="Return_value"
>Return value <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>List get functions return a <code lang='und' xml:lang='und'>(void*)</code> pointer to the location of the stored data. The caller has to extract the value from this pointer.</p>

<p>For non existent data beyond the dimensions of the array a <code lang='und' xml:lang='und'>NULL</code> pointer is returned.</p>

<p>For non existing data inside sparse holes, a pointer <code lang='und' xml:lang='und'>(void*)&#45;1</code> is returned.</p>

<p>The caller can decide to assume these data as undef or 0 or whatever is appropriate.</p>

<h2><a name="Testing"
>Testing <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>See <em lang='und' xml:lang='und'>t/src/{int,}list.c</em> and <em lang='und' xml:lang='und'>t/pmc/{int,}list.t</em>.</p>

<p>Also all array usage depends on list.</p>

<h2><a name="Functions"
>Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>*/</p>

<p>#include &#34;parrot/parrot.h&#34; #include &#60;assert.h&#62;</p>

<p>/* HEADER: include/parrot/list.h */</p>

<p>/* internals */ static List_chunk *allocate_chunk(Interp *interp, List *list, UINTVAL items, UINTVAL size); static UINTVAL rebuild_chunk_list(Interp *interp, List *list); static List_chunk *alloc_next_size(Interp *interp, List *list, int where, UINTVAL idx); static List_chunk *add_chunk(Interp *interp, List *list, int where, UINTVAL idx); static List_chunk *get_chunk(Interp *interp, List *list, UINTVAL *idx); static void split_chunk(Interp *interp, List *list, List_chunk *chunk, UINTVAL idx); static void list_set(Interp *interp, List *list, void *item, INTVAL type, INTVAL idx); static void *list_item(Interp *interp, List *list, int type, INTVAL idx); static void list_append(Interp *interp, List *list, void *item, int type, UINTVAL idx); #ifdef LIST_DEBUG static void list_dump(FILE *fp, List *list, INTVAL type); #endif</p>

<p>#define chunk_list_size(list) \ (PObj_buflen(&#38;list&#45;&#62;chunk_list) / sizeof (List_chunk *))</p>

<p>/* hide the ugly cast somehow: */ #define chunk_list_ptr(list, idx) \ ((List_chunk**) PObj_bufstart(&#38;list&#45;&#62;chunk_list))[idx]</p>

<p>/*</p>

<p>FUNCDOC: allocate_chunk</p>

<p>Make a new chunk, size bytes big, holding items items.</p>

<p>*/</p>

<p>static List_chunk * allocate_chunk(Interp *interp, List *list /*NN*/, UINTVAL items, UINTVAL size) { List_chunk *chunk;</p>

<pre lang='und' xml:lang='und'>    Parrot_block_DOD(interp);
    /*Parrot_block_GC(interp); &#45; why */
    chunk = (List_chunk *)new_bufferlike_header(interp, sizeof (*chunk));
    chunk&#45;&#62;items = items;
    chunk&#45;&#62;n_chunks = 0;
    chunk&#45;&#62;n_items  = 0;
    chunk&#45;&#62;next     = NULL;
    chunk&#45;&#62;prev     = NULL;
    Parrot_allocate_aligned(interp, (Buffer *)chunk, size);
    memset(PObj_bufstart((Buffer*)chunk), 0, size);
    /* see also src/hash.c */
    if (list&#45;&#62;container) {
        DOD_WRITE_BARRIER(interp, list&#45;&#62;container, 0, chunk);
    }
    Parrot_unblock_DOD(interp);
    /*Parrot_unblock_GC(interp); */
    return chunk;
}</pre>

<p>#ifdef LIST_DEBUG</p>

<p>/*</p>

<p>FUNCDOC: list_dump Only char and int are supported currently.</p>

<p>*/</p>

<p>static void list_dump(FILE *fp, List *list /*NN*/, INTVAL type) { List_chunk *chunk = list&#45;&#62;first; UINTVAL idx = 0;</p>

<pre lang='und' xml:lang='und'>    for (; chunk; chunk = chunk&#45;&#62;next) {
        printf(chunk&#45;&#62;flags &#38; no_power_2 ? &#34;(&#34; : &#34;[&#34;);
        if (chunk&#45;&#62;flags &#38; sparse)
            printf(INTVAL_FMT &#34; x &#39;&#39;&#34;, chunk&#45;&#62;items);
        else
            UINTVAL i;
            for (i = 0; i &#60; chunk&#45;&#62;items; i++) {
                if (idx++ &#62;= list&#45;&#62;start &#38;&#38; idx &#60;= list&#45;&#62;length + list&#45;&#62;start) {
                    switch (list&#45;&#62;item_type) {
                    case enum_type_int:
                    case enum_type_short:
                        printf(&#34;%d&#34;, (int)((int *)
                                           PObj_bufstart(&#38;chunk&#45;&#62;data))[i]);
                        break;
                    case enum_type_char:
                        printf(&#34;%c&#34;, (char)((char *)
                                            PObj_bufstart(&#38;chunk&#45;&#62;data))[i]);
                        break;
                    }
                }
                if (i &#60; chunk&#45;&#62;items &#45; 1)
                    printf(&#34;,&#34;);
            }
        printf(chunk&#45;&#62;flags &#38; no_power_2 ? &#34;)&#34; : &#34;]&#34;);
        if (chunk&#45;&#62;next)
            printf(&#34; &#45;&#62; &#34;);
    }
    printf(&#34;\n&#34;);
}
#endif</pre>

<p>/*</p>

<p>FUNCDOC: rebuild_chunk_ptrs</p>

<p>Rebuild chunk_list and update/optimize chunk usage, helper functions.</p>

<p>Delete empty chunks, count chunks and fix prev pointers.</p>

<p>*/</p>

<p>static void rebuild_chunk_ptrs(List *list /*NN*/, int cut) { List_chunk *chunk, *prev; UINTVAL len = 0, start = list&#45;&#62;start; UINTVAL cap;</p>

<pre lang='und' xml:lang='und'>    cap = 0;
    for (prev = 0, chunk = list&#45;&#62;first; chunk; chunk = chunk&#45;&#62;next) {
        /* skip empty chunks, first is empty, when all items get skipped due
         * to list&#45;&#62;start */
        if (chunk&#45;&#62;items == start) {
            if (prev)
                prev&#45;&#62;next = chunk&#45;&#62;next;
            else
                list&#45;&#62;first = chunk&#45;&#62;next;
            start = 0;
            continue;
        }
        len++;
        start = 0;
        chunk&#45;&#62;prev = prev;
        prev = chunk;
        list&#45;&#62;last = chunk;
        if (cut &#38;&#38; cap &#62; list&#45;&#62;start + list&#45;&#62;length &#38;&#38; chunk != list&#45;&#62;first) {
            list&#45;&#62;last = chunk&#45;&#62;prev ? chunk&#45;&#62;prev : list&#45;&#62;first;
            len&#45;&#45;;
            break;
        }
        cap += chunk&#45;&#62;items;
    }
    if (list&#45;&#62;last)
        list&#45;&#62;last&#45;&#62;next = 0;
    list&#45;&#62;cap = cap;
    if (list&#45;&#62;first)
        list&#45;&#62;first&#45;&#62;prev = 0;
    list&#45;&#62;n_chunks = len;
}</pre>

<p>/*</p>

<p>FUNCDOC: rebuild_sparse</p>

<p>Coalesce adjacent sparse chunks.</p>

<p>*/</p>

<p>static void rebuild_sparse(List *list /*NN*/) { List_chunk *chunk = list&#45;&#62;first; List_chunk *prev = NULL; int changes = 0;</p>

<pre lang='und' xml:lang='und'>    for (; chunk; chunk = chunk&#45;&#62;next) {
        if (prev &#38;&#38; (prev&#45;&#62;flags &#38; sparse) &#38;&#38;
                (chunk&#45;&#62;flags &#38; sparse)) {
            prev&#45;&#62;items += chunk&#45;&#62;items;
            chunk&#45;&#62;items = 0;
            changes++;
            continue;
        }
        prev = chunk;
    }
    if (changes)
        rebuild_chunk_ptrs(list, 0);
}</pre>

<p>/*</p>

<p>FUNCDOC: rebuild_other</p>

<p>Coalesce adjacent irregular chunks.</p>

<p>*/</p>

<p>static void rebuild_other(Interp *interp, List *list /*NN*/) { List_chunk *chunk = list&#45;&#62;first; List_chunk *prev = NULL; int changes = 0;</p>

<pre lang='und' xml:lang='und'>    for (; chunk; chunk = chunk&#45;&#62;next) {
        /* two adjacent irregular chunks */
        if (prev &#38;&#38; (prev&#45;&#62;flags &#38; no_power_2) &#38;&#38;
                (chunk&#45;&#62;flags &#38; no_power_2)) {
            /* DONE don&#39;t make chunks bigger then MAX_ITEMS, no &#45; make then
             * but: if bigger, split them in a next pass
             * TODO test the logic that solves the above problem */
            if (prev&#45;&#62;items + chunk&#45;&#62;items &#62; MAX_ITEMS) {
                Parrot_reallocate(interp, (Buffer *)prev,
                        MAX_ITEMS * list&#45;&#62;item_size);
                if (list&#45;&#62;container) {
                    DOD_WRITE_BARRIER(interp, list&#45;&#62;container, 0, prev);
                }
                mem_sys_memmove(
                        (char *) PObj_bufstart(&#38;prev&#45;&#62;data) +
                        prev&#45;&#62;items * list&#45;&#62;item_size,
                        (char *) PObj_bufstart(&#38;chunk&#45;&#62;data),
                        (MAX_ITEMS &#45; prev&#45;&#62;items) * list&#45;&#62;item_size);
                mem_sys_memmove(
                        (char *) PObj_bufstart(&#38;chunk&#45;&#62;data),
                        (char *) PObj_bufstart(&#38;chunk&#45;&#62;data) +
                        (MAX_ITEMS &#45; prev&#45;&#62;items) * list&#45;&#62;item_size,
                        (chunk&#45;&#62;items &#45; (MAX_ITEMS &#45; prev&#45;&#62;items))
                                                        * list&#45;&#62;item_size);
                chunk&#45;&#62;items = chunk&#45;&#62;items &#45; (MAX_ITEMS &#45; prev&#45;&#62;items);
                prev&#45;&#62;items = MAX_ITEMS;
            }
            else {
                Parrot_reallocate(interp, (Buffer *)prev,
                        (prev&#45;&#62;items + chunk&#45;&#62;items) * list&#45;&#62;item_size);
                if (list&#45;&#62;container) {
                    DOD_WRITE_BARRIER(interp, list&#45;&#62;container, 0, prev);
                }
                mem_sys_memmove(
                        (char *) PObj_bufstart(&#38;prev&#45;&#62;data) +
                        prev&#45;&#62;items * list&#45;&#62;item_size,
                        (char *) PObj_bufstart(&#38;chunk&#45;&#62;data),
                        chunk&#45;&#62;items * list&#45;&#62;item_size);
                prev&#45;&#62;items += chunk&#45;&#62;items;
                chunk&#45;&#62;items = 0;
            }
            changes++;
            continue;
        }
        prev = chunk;
    }
    if (changes)
        rebuild_chunk_ptrs(list, 0);
}</pre>

<p>/*</p>

<p>FUNCDOC: rebuild_fix_ends</p>

<p>Called by <code lang='und' xml:lang='und'>rebuild_chunk_list()</code>.</p>

<p>*/</p>

<p>static void rebuild_fix_ends(Interp *interp, List *list /*NN*/) { List_chunk * const chunk = list&#45;&#62;first; /* first is irregular, next is empty */ if (list&#45;&#62;n_chunks &#60;= 2 &#38;&#38; (chunk&#45;&#62;flags &#38; no_power_2) &#38;&#38; (!chunk&#45;&#62;next || chunk&#45;&#62;next&#45;&#62;items == 0 || list&#45;&#62;start + list&#45;&#62;length &#60;= chunk&#45;&#62;items)) { chunk&#45;&#62;flags = 0; list&#45;&#62;grow_policy = enum_grow_unknown; list&#45;&#62;cap += PObj_buflen(&#38;chunk&#45;&#62;data) / list&#45;&#62;item_size &#45; chunk&#45;&#62;items; chunk&#45;&#62;items = PObj_buflen(&#38;chunk&#45;&#62;data) / list&#45;&#62;item_size; } /* XXX &#45; still needed? &#45; if last is empty and last&#45;&#62;prev not full then * delete last &#45; combine small chunks if list is big */ }</p>

<p>/*</p>

<p>FUNCDOC: rebuild_chunk_list</p>

<p>Called to optimise the list when modifying it in some way.</p>

<p>*/</p>

<p>static UINTVAL rebuild_chunk_list(Interp *interp /*NN*/, List *list /*NN*/) { List_chunk *chunk, *prev, *first; UINTVAL len;</p>

<pre lang='und' xml:lang='und'>    Parrot_block_DOD(interp);
    Parrot_block_GC(interp);
    /* count chunks and fix prev pointers */
    rebuild_chunk_ptrs(list, 0);
    /* if not regular, check &#38; optimize */
    if (list&#45;&#62;grow_policy == enum_grow_mixed) {
        rebuild_sparse(list);
        rebuild_other(interp, list);
        rebuild_fix_ends(interp, list);
    }

    /* allocate a new chunk_list buffer, if old one has moved or is too small */
    len = list&#45;&#62;n_chunks;
    if (list&#45;&#62;collect_runs != interp&#45;&#62;arena_base&#45;&#62;collect_runs ||
            len &#62; chunk_list_size(list)) {
        /* round up to reasonable size */
        len = 1 &#60;&#60; (ld(len) + 1);
        if (len &#60; 4)
            len = 4;
        Parrot_reallocate(interp, (Buffer *)list,
                len * sizeof (List_chunk *));
        if (list&#45;&#62;container) {
            DOD_WRITE_BARRIER(interp, list&#45;&#62;container, 0, list);
        }
        list&#45;&#62;collect_runs = interp&#45;&#62;arena_base&#45;&#62;collect_runs;
    }

    /* reset type, actual state of chunks will show, what we really have */
    list&#45;&#62;grow_policy = enum_grow_unknown;

    /* fill chunk_list and update statistics */
    first = chunk = list&#45;&#62;first;
    for (prev = NULL, len = 0; chunk; chunk = chunk&#45;&#62;next) {
        chunk_list_ptr(list, len) = chunk;
        len++;

        /* look, what type of chunks we have this is always correct: */
        chunk&#45;&#62;n_chunks = 1;
        chunk&#45;&#62;n_items = chunk&#45;&#62;items;

        /* sparse hole or irregular chunk */
        if (chunk&#45;&#62;flags &#38; (sparse | no_power_2)) {
            List_chunk *next;

            /* add next sparse or no_power_2 chunks up so that get_chunk will
             * skip this range of chunks, when the idx is beyond this block. */
            for (next = chunk&#45;&#62;next; next; next = next&#45;&#62;next)
                if (next&#45;&#62;flags &#38; (sparse | no_power_2)) {
                    chunk&#45;&#62;n_chunks++;
                    chunk&#45;&#62;n_items += next&#45;&#62;items;
                }
                else
                    break;
            first = chunk&#45;&#62;next;
            list&#45;&#62;grow_policy = enum_grow_mixed;
            continue;
        }
        /* clear flag, next chunks will tell what comes */
        chunk&#45;&#62;flags = enum_grow_unknown;
        if (first &#38;&#38; first != chunk) {
            /* constant chunk block */
            if (first&#45;&#62;items == chunk&#45;&#62;items) {
                first&#45;&#62;n_chunks++;
                first&#45;&#62;n_items += chunk&#45;&#62;items;
                first&#45;&#62;flags = fixed_items;
                /* TODO optimize for fixed but non MAX_ITEMS lists */
                if (first&#45;&#62;items == MAX_ITEMS)
                    list&#45;&#62;grow_policy |= enum_grow_fixed;
                else
                    list&#45;&#62;grow_policy |= enum_grow_mixed;
            }
            /* growing chunk block could optimize small growing blocks, they
             * are probably not worth the effort. */
            else if (prev &#38;&#38; (prev&#45;&#62;items == chunk&#45;&#62;items &#62;&#62; 1)) {
                first&#45;&#62;n_chunks++;
                first&#45;&#62;n_items += chunk&#45;&#62;items;
                first&#45;&#62;flags = grow_items;
                list&#45;&#62;grow_policy |= enum_grow_growing;
            }
            /* different growing scheme starts here */
            else {
                first = chunk;
            }
        }
        prev = chunk;
    }
    /* if we have some mixture of grow_policies, then set it to _mixed */
    if (list&#45;&#62;grow_policy &#38;&#38; list&#45;&#62;grow_policy != enum_grow_growing &#38;&#38;
            list&#45;&#62;grow_policy != enum_grow_fixed)
        list&#45;&#62;grow_policy = enum_grow_mixed;
    Parrot_unblock_DOD(interp);
    Parrot_unblock_GC(interp);
    return len;
}</pre>

<p>/*</p>

<p>FUNCDOC: alloc_next_size</p>

<p>Calculate size and items for next chunk and allocate it.</p>

<p>*/</p>

<p>static List_chunk * alloc_next_size(Interp *interp, List *list /*NN*/, int where, UINTVAL idx) { UINTVAL items, size; List_chunk *new_chunk; const int much = idx &#45; list&#45;&#62;cap &#62;= MIN_ITEMS; int do_sparse = (INTVAL)idx &#45; (INTVAL)list&#45;&#62;cap &#62;= 10 * MAX_ITEMS;</p>

<pre lang='und' xml:lang='und'>    if (list&#45;&#62;item_type == enum_type_sized) {
        items = list&#45;&#62;items_per_chunk;
        size = items * list&#45;&#62;item_size;
        list&#45;&#62;grow_policy = items == MAX_ITEMS ?
            enum_grow_fixed : enum_grow_mixed;
        do_sparse = 0;
    }
    else if (do_sparse) {
        assert(where);
        /* don&#39;t add sparse chunk at start of list */
        if (!list&#45;&#62;n_chunks) {
            list&#45;&#62;grow_policy = enum_grow_fixed;
            /* if wee need more, the next allocation will allocate the rest */
            items = MAX_ITEMS;
            size = items * list&#45;&#62;item_size;
            do_sparse = 0;
        }
        else {
            items = idx &#45; list&#45;&#62;cap &#45; 1;
            /* round down this function will then be called again, to add the
             * final real chunk, with the rest of the needed size */
            items &#38;= ~(MAX_ITEMS &#45; 1);
            list&#45;&#62;grow_policy = enum_grow_mixed;
            /* allocate a dummy chunk holding many items virtually */
            size = list&#45;&#62;item_size;
        }
    }
    /* initial size for empty lists grow_policy is not yet known or was
     * different */
    else if (!list&#45;&#62;cap) {
#ifdef ONLY_FIXED_ALLOCATIONS
        list&#45;&#62;grow_policy = enum_grow_fixed;
#else
        list&#45;&#62;grow_policy = enum_grow_unknown;
#endif
        /* more then MIN_ITEMS, i.e. indexed access beyond length */
        if (much) {
            list&#45;&#62;grow_policy = enum_grow_fixed;
            items = MAX_ITEMS;
        }
        else {
            /* TODO make bigger for small items like char */
            items = MIN_ITEMS;
        }
        size = items * list&#45;&#62;item_size;
    }
    else {
        if (list&#45;&#62;grow_policy &#38; (enum_grow_fixed | enum_grow_mixed))
            items = MAX_ITEMS;
        else {
            items = where ? list&#45;&#62;last&#45;&#62;items : list&#45;&#62;first&#45;&#62;items;
            /* push: allocate at end, more if possbile */
            if (where) {
                if (items &#60; MAX_ITEMS) {
                    items &#60;&#60;= 1;
                    list&#45;&#62;grow_policy = enum_grow_growing;
                }
            }
            /* unshift: if possible, make less items */
            else {
                list&#45;&#62;grow_policy = enum_grow_growing;
                if (items &#62; MIN_ITEMS)
                    items &#62;&#62;= 1;        /* allocate less */
                /* if not: second allocation from unshift */
                else {
                    list&#45;&#62;grow_policy = enum_grow_mixed;
                    items = MAX_ITEMS;
                }
            }
        }
        size = items * list&#45;&#62;item_size;
    }
    new_chunk = allocate_chunk(interp, list, items, size);
    list&#45;&#62;cap += items;
    if (do_sparse)
        new_chunk&#45;&#62;flags |= sparse;
    return new_chunk;
}</pre>

<p>/*</p>

<p>FUNCDOC: add_chunk</p>

<p>Add chunk at start or end.</p>

<p>*/</p>

<p>static List_chunk * add_chunk(Interp *interp /*NN*/, List *list /*NN*/, int where, UINTVAL idx) { List_chunk * const chunk = where ? list&#45;&#62;last : list&#45;&#62;first; List_chunk * const new_chunk = alloc_next_size(interp, list, where, idx);</p>

<pre lang='und' xml:lang='und'>    if (where) {                /* at end */
        if (chunk)
            chunk&#45;&#62;next = new_chunk;
        list&#45;&#62;last = new_chunk;
        if (!list&#45;&#62;first)
            list&#45;&#62;first = new_chunk;
    }
    else {
        new_chunk&#45;&#62;next = chunk;
        list&#45;&#62;first = new_chunk;
        if (!list&#45;&#62;last)
            list&#45;&#62;last = new_chunk;
    }
    rebuild_chunk_list(interp, list);
    return new_chunk;
}</pre>

<p>/*</p>

<p>FUNCDOC: ld Calculates log2(x).</p>

<p>Stolen from <em lang='und' xml:lang='und'>src/malloc.c</em>.</p>

<p>*/</p>

<p>PARROT_API UINTVAL ld(UINTVAL x) /* CONST, WARN_UNUSED */ { UINTVAL m; /* bit position of highest set bit of m */</p>

<pre lang='und' xml:lang='und'>    /* On intel, use BSRL instruction to find highest bit */
#if defined(__GNUC__) &#38;&#38; defined(i386)

  __asm__(&#34;bsrl %1,%0\n\t&#34;:&#34;=r&#34;(m)
  :        &#34;g&#34;(x));</pre>

<p>#else { /* * Based on branch&#45;free nlz algorithm in chapter 5 of Henry S. Warren * Jr&#39;s book &#34;Hacker&#39;s Delight&#34;. */</p>

<pre lang='und' xml:lang='und'>        unsigned int n = ((x &#45; 0x100) &#62;&#62; 16) &#38; 8;

        x &#60;&#60;= n;
        m = ((x &#45; 0x1000) &#62;&#62; 16) &#38; 4;
        n += m;
        x &#60;&#60;= m;
        m = ((x &#45; 0x4000) &#62;&#62; 16) &#38; 2;
        n += m;
        x = (x &#60;&#60; m) &#62;&#62; 14;
        m = 13 &#45; n + (x &#38; ~(x &#62;&#62; 1));
    }
#endif
    return m;
}</pre>

<p>/*</p>

<p>FUNCDOC: get_chunk</p>

<p>Get the chunk for <code lang='und' xml:lang='und'>idx</code>, also update the <code lang='und' xml:lang='und'>idx</code> to point into the chunk.</p>

<p>This routine will be called for every operation on list, so its optimized to be fast and needs an up to date chunk statistic, that <code lang='und' xml:lang='und'>rebuild_chunk_list</code> does provide.</p>

<p>The scheme of operations is:</p>

<pre lang='und' xml:lang='und'>    if all_chunks_are_MAX_ITEMS
         chunk = chunk_list[ idx / MAX_ITEMS ]
         idx =   idx % MAX_ITEMS
         done.

    chunk = first
    repeat
         if (index &#60; chunk&#45;&#62;items)
             done.

     if (index &#62;= items_in_chunk_block)
         index &#45;= items_in_chunk_block
         chunk += chunks_in_chunk_block
         continue

     calc chunk and index in this block
     done.</pre>

<p>One chunk_block consists of chunks of the same type: fixed, growing or other. So the time to look up a chunk doesn&#39;t depend on the array length, but on the complexity of the array. <code lang='und' xml:lang='und'>rebuild_chunk_list</code> tries to reduce the complexity, but may fail, if you e.g. do a prime sieve by actually <code lang='und' xml:lang='und'>list_delet</code>ing the none prime numbers.</p>

<p>The complexity of the array is how many different <code lang='und' xml:lang='und'>chunk_blocks</code> are there. They come from:</p>

<p>&#45; initially fixed: 1</p>

<p>&#45; initially growing: 2</p>

<p>&#45; first unshift: 1 except for initially fixed arrays</p>

<p>&#45; insert: 1 &#45; 3</p>

<p>&#45; delete: 1 &#45; 2</p>

<p>&#45; sparse hole: 3 (could be 2, code assumes access at either end now)</p>

<p>There could be some optimizer, that, after detecting almost only indexed access after some time, does reorganize the array to be all <code lang='und' xml:lang='und'>MAX_ITEMS</code> sized, when this would improve performance.</p>

<p>*/</p>

<p>static List_chunk * get_chunk(Interp *interp, List *list /*NN*/, UINTVAL *idx /*NN*/) { List_chunk *chunk; UINTVAL i;</p>

<p>#ifndef GC_IS_MALLOC if (list&#45;&#62;collect_runs != interp&#45;&#62;arena_base&#45;&#62;collect_runs) rebuild_chunk_list(interp, list); #endif #ifdef SLOW_AND_BORING for (chunk = list&#45;&#62;first; chunk; chunk = chunk&#45;&#62;next) { if (*idx &#60; chunk&#45;&#62;items) return chunk; *idx &#45;= chunk&#45;&#62;items; } internal_exception(INTERNAL_PANIC, &#34;list structure chaos!\n&#34;); #endif</p>

<pre lang='und' xml:lang='und'>    /* fixed sized chunks &#45; easy: all MAX_ITEMS sized */
    if (list&#45;&#62;grow_policy == enum_grow_fixed) {
        chunk = chunk_list_ptr(list, *idx &#62;&#62; LD_MAX);
        *idx &#38;= MAX_MASK;
        return chunk;
    }

    /* else look at chunks flags, what grow type follows and adjust chunks and
     * idx */
    for (i = 0, chunk = list&#45;&#62;first; chunk;) {
        /* if we have no more items, we have found the chunk */
        if (*idx &#60; chunk&#45;&#62;items)
            return chunk;

        /* now look, if we can use the range of items in chunk_block: if idx
         * is beyond n_items, skip n_chunks */
        if (*idx &#62;= chunk&#45;&#62;n_items) {
            i += chunk&#45;&#62;n_chunks;
            *idx &#45;= chunk&#45;&#62;n_items;
            chunk = chunk_list_ptr(list, i);
            continue;
        }
        /* we are inside this range of items */
        if (chunk&#45;&#62;flags &#38; fixed_items) {
            /* all chunks are chunk&#45;&#62;items big, a power of 2 */
            chunk = chunk_list_ptr(list, i + (*idx &#62;&#62; ld(chunk&#45;&#62;items)));
            *idx &#38;= chunk&#45;&#62;items &#45; 1;
            return chunk;
        }</pre>

<p>/* * Here is a small table, providing the basics of growing sized * addressing, for people like me, who&#39;s math lessons are +30 years * in the past ;&#45;) * assuming MIN_ITEMS=4 * * ch# size idx +4 bit ld2(idx) &#45;ld2(4) * * 0 4 0..3 4..7 0000 01xx 2 0 * 1 8 4..11 8..15 0000 1xxx 3 1 * 2 16 12..27 16..31 0001 xxxx 4 2 * ... * 8 1024 1020.. ...2047 10 8 */</p>

<pre lang='und' xml:lang='und'>        if (chunk&#45;&#62;flags &#38; grow_items) {
            /* the next chunks are growing from chunk&#45;&#62;items ... last&#45;&#62;items */
            const UINTVAL ld_first = ld(chunk&#45;&#62;items);
            const UINTVAL slot = ld(*idx + chunk&#45;&#62;items) &#45; ld_first;

            /* we are in this growing area, so we are done */
            assert(slot &#60; chunk&#45;&#62;n_chunks);
            *idx &#45;= (1 &#60;&#60; (ld_first + slot)) &#45; chunk&#45;&#62;items;
            return chunk_list_ptr(list, i + slot);
        }

        if (chunk&#45;&#62;flags &#38; (sparse | no_power_2)) {
            /* these chunks hold exactly chunk&#45;&#62;items */
            *idx &#45;= chunk&#45;&#62;items;
            i++;
            chunk = chunk&#45;&#62;next;
            continue;
        }
        internal_exception(INTERNAL_PANIC, &#34;list structure chaos #1!\n&#34;);
    }
    internal_exception(INTERNAL_PANIC, &#34;list structure chaos #2!\n&#34;);
    return 0;
}</pre>

<p>/*</p>

<p>FUNCDOC: split_chunk</p>

<p>Split a sparse chunk, so that we have</p>

<p>&#45; allocated space at <code lang='und' xml:lang='und'>idx</code></p>

<p>if sparse is big:</p>

<p>&#45; <code lang='und' xml:lang='und'>MAX_ITEMS</code> near <code lang='und' xml:lang='und'>idx</code> and if there is still sparse space after the real chunk, this also <code lang='und' xml:lang='und'>n*MAX_ITEMS</code> sized, so that consecutive writing would make <code lang='und' xml:lang='und'>MAX_ITEMS</code> sized real chunks.</p>

<p>*/</p>

<p>static void split_chunk(Interp *interp, List *list /*NN*/, List_chunk *chunk /*NN*/, UINTVAL ix) {</p>

<pre lang='und' xml:lang='und'>    /* allocate space at idx */
    if (chunk&#45;&#62;items &#60;= MAX_ITEMS) {
        /* it fits, just allocate */
        Parrot_reallocate(interp, (Buffer *)chunk,
                chunk&#45;&#62;items * list&#45;&#62;item_size);
        if (list&#45;&#62;container) {
            DOD_WRITE_BARRIER(interp, list&#45;&#62;container, 0, chunk);
        }
        chunk&#45;&#62;flags |= no_power_2;
        chunk&#45;&#62;flags &#38;= ~sparse;
    }
    else {
        /* split chunk&#45;&#62;items: n3 = n*MAX_ITEMS after chunk n2 = MAX_ITEMS
         * chunk n1 = rest before */
        const INTVAL idx = ix;
        const INTVAL n2 = MAX_ITEMS;
        const INTVAL n3 = ((chunk&#45;&#62;items &#45; idx) / MAX_ITEMS) * MAX_ITEMS;
        const INTVAL n1 = chunk&#45;&#62;items &#45; n2 &#45; n3;

        chunk&#45;&#62;items = n2;
        Parrot_reallocate(interp, (Buffer *)chunk,
                chunk&#45;&#62;items * list&#45;&#62;item_size);
        if (list&#45;&#62;container) {
            DOD_WRITE_BARRIER(interp, list&#45;&#62;container, 0, chunk);
        }
        chunk&#45;&#62;flags &#38;= ~sparse;
        if (n3) {
            List_chunk * const new_chunk = allocate_chunk(interp, list, n3, list&#45;&#62;item_size);
            new_chunk&#45;&#62;flags |= sparse;
            new_chunk&#45;&#62;next = chunk&#45;&#62;next;
            if (chunk&#45;&#62;next)
                chunk&#45;&#62;next = new_chunk;
            else
                list&#45;&#62;last = new_chunk;
        }
        /* size before idx */
        if (n1 &#62; 0) {
            /* insert a new sparse chunk before this one */
            List_chunk * const new_chunk = allocate_chunk(interp, list, n1, list&#45;&#62;item_size);
            new_chunk&#45;&#62;flags |= sparse;
            new_chunk&#45;&#62;next = chunk;
            if (chunk&#45;&#62;prev)
                chunk&#45;&#62;prev&#45;&#62;next = new_chunk;
            else
                list&#45;&#62;first = new_chunk;
        }
    }

    rebuild_chunk_list(interp, list);
}</pre>

<p>/*</p>

<p>FUNCDOC: list_set</p>

<p>Set <code lang='und' xml:lang='und'>item</code> of type <code lang='und' xml:lang='und'>type</code> in chunk at <code lang='und' xml:lang='und'>idx</code>.</p>

<p>*/</p>

<p>static void list_set(Interp *interp, List *list /*NN*/, void *item, INTVAL type, INTVAL idx) { const INTVAL oidx = idx; List_chunk *chunk = get_chunk(interp, list, (UINTVAL *)&#38;idx);</p>

<pre lang='und' xml:lang='und'>    assert(chunk);
    /* if this is a sparse chunk: split in possibly 2 sparse parts before and
     * after then make a real chunk, rebuild chunk list and set item */
    if (chunk&#45;&#62;flags &#38; sparse) {
        split_chunk(interp, list, chunk, idx);
        /* reget chunk and idx */
        idx = oidx;
        chunk = get_chunk(interp, list, (UINTVAL *)&#38;idx);
        assert(chunk);
        assert(!(chunk&#45;&#62;flags &#38; sparse));
    }

    switch (type) {
    case enum_type_sized:
        /* copy data into list */
        memcpy(&#38;((char *) PObj_bufstart(&#38;chunk&#45;&#62;data))[idx * list&#45;&#62;item_size],
                item, list&#45;&#62;item_size);
        break;
    case enum_type_char:
        ((char *) PObj_bufstart(&#38;chunk&#45;&#62;data))[idx] = (char)PTR2INTVAL(item);
        break;
    case enum_type_short:
        ((short *) PObj_bufstart(&#38;chunk&#45;&#62;data))[idx] = (short)PTR2INTVAL(item);
        break;
    case enum_type_int:
        ((int *) PObj_bufstart(&#38;chunk&#45;&#62;data))[idx] = (int)PTR2INTVAL(item);
        break;
    case enum_type_INTVAL:
        ((INTVAL *) PObj_bufstart(&#38;chunk&#45;&#62;data))[idx] = PTR2INTVAL(item);
        break;
    case enum_type_FLOATVAL:
        ((FLOATVAL *) PObj_bufstart(&#38;chunk&#45;&#62;data))[idx] = *(FLOATVAL *)item;
        break;
    case enum_type_PMC:
        if (list&#45;&#62;container) {
            DOD_WRITE_BARRIER(interp, list&#45;&#62;container,
                    ((PMC **) PObj_bufstart(&#38;chunk&#45;&#62;data))[idx],
                    (PMC*)item);
        }
        ((PMC **) PObj_bufstart(&#38;chunk&#45;&#62;data))[idx] = (PMC *)item;
        break;
    case enum_type_STRING:
        ((STRING **) PObj_bufstart(&#38;chunk&#45;&#62;data))[idx] = (STRING *)item;
        break;
    default:
        internal_exception(1, &#34;Unknown list entry type\n&#34;);
        break;
    }
}</pre>

<p>/*</p>

<p>FUNCDOC: list_item</p>

<p>Get the pointer to the item of type <code lang='und' xml:lang='und'>type</code> in the chunk at <code lang='und' xml:lang='und'>idx</code>.</p>

<p>*/</p>

<p>static void * list_item(Interp *interp, List *list /*NN*/, int type, INTVAL idx) { List_chunk * const chunk = get_chunk(interp, list, (UINTVAL *)&#38;idx); /* if this is a sparse chunk return &#45;1, the caller may decide to return 0 * or undef or whatever */ if (chunk&#45;&#62;flags &#38; sparse) { #ifdef INTLIST_EMUL static int null = 0;</p>

<pre lang='und' xml:lang='und'>        return (void *)&#38;null;
#else
        return (void *)&#45;1;
#endif
    }

    switch (type) {
    case enum_type_sized:
        return (void *)&#38;((char *)
                         PObj_bufstart(&#38;chunk&#45;&#62;data))[idx * list&#45;&#62;item_size];
        break;
    case enum_type_char:
        return (void *)&#38;((char *) PObj_bufstart(&#38;chunk&#45;&#62;data))[idx];
        break;
    case enum_type_short:
        return (void *)&#38;((short *) PObj_bufstart(&#38;chunk&#45;&#62;data))[idx];
        break;
    case enum_type_int:
        return (void *)&#38;((int *) PObj_bufstart(&#38;chunk&#45;&#62;data))[idx];
        break;
    case enum_type_INTVAL:
        return (void *)&#38;((INTVAL *) PObj_bufstart(&#38;chunk&#45;&#62;data))[idx];
        break;
    case enum_type_FLOATVAL:
        return (void *)&#38;((FLOATVAL *) PObj_bufstart(&#38;chunk&#45;&#62;data))[idx];
        break;
    case enum_type_PMC:
        return (void *)&#38;((PMC **) PObj_bufstart(&#38;chunk&#45;&#62;data))[idx];
        break;
    case enum_type_STRING:
        return (void *)&#38;((STRING **) PObj_bufstart(&#38;chunk&#45;&#62;data))[idx];
        break;
    default:
        internal_exception(1, &#34;Unknown list entry type\n&#34;);
        break;
    }
    return 0;</pre>

<p>}</p>

<p>/*</p>

<p>FUNCDOC: list_append</p>

<p>Add one or more chunks to end of list.</p>

<p>*/</p>

<p>static void list_append(Interp *interp /*NN*/, List *list /*NN*/, void *item, int type, UINTVAL idx) { /* initially, list may be empty, also used by assign */ while (idx &#62;= list&#45;&#62;cap) add_chunk(interp, list, enum_add_at_end, idx); list_set(interp, list, item, type, idx); /* invariant: prepare for next push */ if (idx &#62;= list&#45;&#62;cap &#45; 1) add_chunk(interp, list, enum_add_at_end, 0); }</p>

<p>/*</p>

<h2><a name="Public_Interface_Functions"
>Public Interface Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>FUNCDOC: list_new Returns a new list of type <code lang='und' xml:lang='und'>type</code>.</p>

<p>*/</p>

<p>PARROT_API List * list_new(Interp *interp, INTVAL type) /*WARN_UNUSED*/ { List * const list = (List *)new_bufferlike_header(interp, sizeof (*list));</p>

<pre lang='und' xml:lang='und'>    list&#45;&#62;item_type = type;
    switch (type) {
    case enum_type_sized:       /* gets overridden below */
    case enum_type_char:
        list&#45;&#62;item_size = sizeof (char);
        break;
    case enum_type_short:
        list&#45;&#62;item_size = sizeof (short);
        break;
    case enum_type_int:
        list&#45;&#62;item_size = sizeof (int);
        break;
    case enum_type_INTVAL:
        list&#45;&#62;item_size = sizeof (INTVAL);
        break;
    case enum_type_FLOATVAL:
        list&#45;&#62;item_size = sizeof (FLOATVAL);
        break;
    case enum_type_PMC:
        list&#45;&#62;item_size = sizeof (PMC *);
        break;
    case enum_type_STRING:
        list&#45;&#62;item_size = sizeof (STRING *);
        break;
    default:
        internal_exception(1, &#34;Unknown list type\n&#34;);
        break;
    }
    return list;
}</pre>

<p>/*</p>

<p>FUNCDOC: list_pmc_new</p>

<p>Create a new list containing PMC* values in PMC_data(container).</p>

<p>*/</p>

<p>PARROT_API void list_pmc_new(Interp *interp, PMC *container /*NN*/) { List * const l = list_new(interp, enum_type_PMC); l&#45;&#62;container = container; PMC_data(container) = l; }</p>

<p>/*</p>

<p>FUNCDOC: list_new_init</p>

<p><code lang='und' xml:lang='und'>list_new_init()</code> uses these initializers:</p>

<pre lang='und' xml:lang='und'>    0 ... size (set initial size of list)
    1 ... array dimensions (multiarray)
    2 ... type (overriding type parameter)
    3 ... item_size for enum_type_sized
    4 ... items_per_chunk</pre>

<p>After getting these values out of the key/value pairs, a new array with these values is stored in user_data, where the keys are explicit.</p>

<p>*/</p>

<p>PARROT_API List * list_new_init(Interp *interp, INTVAL type, PMC *init /*NN*/) /* WARN_UNUSED */ { List *list; PMC * user_array, *multi_key; INTVAL i, len, size, item_size, items_per_chunk;</p>

<pre lang='und' xml:lang='und'>    if (!init&#45;&#62;vtable)
        internal_exception(1, &#34;Illegal initializer for init\n&#34;);
    len = VTABLE_elements(interp, init);
    if (len &#38; 1)
        internal_exception(1, &#34;Illegal initializer for init: odd elements\n&#34;);

    size = item_size = items_per_chunk = 0;
    multi_key = NULL;
    for (i = 0; i &#60; len; i += 2) {
        const INTVAL key = VTABLE_get_integer_keyed_int(interp, init, i);
        const INTVAL val = i + 1;
        switch (key) {
            case 0:
                size = VTABLE_get_integer_keyed_int(interp, init, val);
                break;
            case 1:
                multi_key = VTABLE_get_pmc_keyed_int(interp, init, val);
                break;
            case 2:
                type = VTABLE_get_integer_keyed_int(interp, init, val);
                break;
            case 3:
                item_size = VTABLE_get_integer_keyed_int(interp, init, val);
                break;
            case 4:
                items_per_chunk = VTABLE_get_integer_keyed_int(
                        interp, init, val);
                break;
        }
    }
    list = list_new(interp, type);
    if (list&#45;&#62;item_type == enum_type_sized) { /* override item_size */
        if (!item_size)
            internal_exception(1, &#34;No item_size for type_sized list\n&#34;);
        list&#45;&#62;item_size = item_size;
        list&#45;&#62;items_per_chunk =
            items_per_chunk
                ? (1 &#60;&#60; (ld(items_per_chunk) + 1)) /* make power of 2 */
                : MAX_ITEMS;
    }
    if (size)
        list_set_length(interp, list, size);
    /* make a private copy of init data */
    list&#45;&#62;user_data = user_array = pmc_new(interp, enum_class_SArray);
    /* set length */
    VTABLE_set_integer_native(interp, user_array, 2);
    /* store values */
    VTABLE_set_integer_keyed_int(interp, user_array, 0,  size);
    VTABLE_set_pmc_keyed_int(interp, user_array, 1, multi_key);
    return list;
}</pre>

<p>/*</p>

<p>FUNCDOC: list_pmc_new_init</p>

<p>Create a new list containing PMC* values in PMC_data(container).</p>

<p>*/</p>

<p>PARROT_API void list_pmc_new_init(Interp *interp, PMC *container /*NN*/, PMC *init /*NN*/) { List * const l = list_new_init(interp, enum_type_PMC, init); l&#45;&#62;container = container; PMC_data(container) = l; /* * this is a new PMC, so no old value */ DOD_WRITE_BARRIER(interp, container, NULL, l&#45;&#62;user_data); }</p>

<p>/*</p>

<p>FUNCDOC: list_clone</p>

<p>Return a clone of the list.</p>

<p>TODO &#45; Barely tested. Optimize new array structure, fixed if big.</p>

<p>*/</p>

<p>PARROT_API List * list_clone(Interp *interp /*NN*/, const List *other /*NN*/) /* WARN_UNUSED */ { List *l; List_chunk *chunk, *prev; UINTVAL i; PMC *op; STRING *s;</p>

<pre lang='und' xml:lang='und'>    Parrot_block_DOD(interp);
    Parrot_block_GC(interp);

    l = list_new(interp, other&#45;&#62;item_type);
    mem_sys_memcopy(l, other, sizeof (List));
    PObj_buflen(&#38;l&#45;&#62;chunk_list) = 0;
    PObj_bufstart(&#38;l&#45;&#62;chunk_list) = 0;

    for (chunk = other&#45;&#62;first, prev = 0; chunk; chunk = chunk&#45;&#62;next) {
        List_chunk * const new_chunk = allocate_chunk(interp, l,
                chunk&#45;&#62;items, PObj_buflen(&#38;chunk&#45;&#62;data));
        new_chunk&#45;&#62;flags = chunk&#45;&#62;flags;
        if (!prev)
            l&#45;&#62;first = new_chunk;
        else
            prev&#45;&#62;next = new_chunk;
        prev = new_chunk;

        if (!(new_chunk&#45;&#62;flags &#38; sparse)) {
            switch (l&#45;&#62;item_type) {
            case enum_type_PMC:
                for (i = 0; i &#60; chunk&#45;&#62;items; i++) {
                    op = ((PMC **) PObj_bufstart(&#38;chunk&#45;&#62;data))[i];
                    if (op) {
                        ((PMC **) PObj_bufstart(&#38;new_chunk&#45;&#62;data))[i] =
                            VTABLE_clone(interp, op);
                    }
                }
                break;
            case enum_type_STRING:
                for (i = 0; i &#60; chunk&#45;&#62;items; i++) {
                    s = ((STRING **) PObj_bufstart(&#38;chunk&#45;&#62;data))[i];
                    if (s) {
                        ((STRING **) PObj_bufstart(&#38;new_chunk&#45;&#62;data))[i] =
                                string_copy(interp, s);
                    }
                }
                break;
            default:
                mem_sys_memcopy(PObj_bufstart(&#38;new_chunk&#45;&#62;data),
                        PObj_bufstart(&#38;chunk&#45;&#62;data), PObj_buflen(&#38;chunk&#45;&#62;data));
                break;
            }
        }
    }
    if (other&#45;&#62;user_data) {
        l&#45;&#62;user_data = VTABLE_clone(interp, other&#45;&#62;user_data);
    }
    rebuild_chunk_list(interp, l);
    Parrot_unblock_DOD(interp);
    Parrot_unblock_GC(interp);
    return l;
}</pre>

<p>/*</p>

<p>FUNCDOC: list_mark</p>

<p>Mark the list and its contents as live.</p>

<p>*/</p>

<p>PARROT_API void list_mark(Interp *interp /*NN*/, List *list /*NN*/) { List_chunk *chunk;</p>

<pre lang='und' xml:lang='und'>    for (chunk = list&#45;&#62;first; chunk; chunk = chunk&#45;&#62;next) {
        pobject_lives(interp, (PObj *)chunk);
        if (list&#45;&#62;item_type == enum_type_PMC ||
                list&#45;&#62;item_type == enum_type_STRING) {
            if (!(chunk&#45;&#62;flags &#38; sparse)) {
                PObj **p = ((PObj **) PObj_bufstart(&#38;chunk&#45;&#62;data));
                UINTVAL i;

                for (i = 0; i &#60; chunk&#45;&#62;items; i++, ++p) {
                    if (*p)
                        pobject_lives(interp, *p);
                }
            }

        }
    }
    pobject_lives(interp, (PObj *)list);
    if (list&#45;&#62;user_data)
        pobject_lives(interp, (PObj *) list&#45;&#62;user_data);
}</pre>

<p>/*</p>

<p>FUNCDOC: list_visit</p>

<p>This is used by freeze/thaw to visit the contents of the list.</p>

<p><code lang='und' xml:lang='und'>pinfo</code> is the visit info, (see include/parrot/pmc_freeze.h&#62;).</p>

<p>*/</p>

<p>PARROT_API void list_visit(Interp *interp, List *list /*NN*/, void *pinfo) { List_chunk *chunk; visit_info * const info = (visit_info*) pinfo; UINTVAL idx;</p>

<pre lang='und' xml:lang='und'>    const UINTVAL n = list_length(interp, list);
    assert(list&#45;&#62;item_type == enum_type_PMC);
    /* TODO intlist ... */
    for (idx = 0, chunk = list&#45;&#62;first; chunk; chunk = chunk&#45;&#62;next) {
        /* TODO deleted elements */
        if (!(chunk&#45;&#62;flags &#38; sparse)) {
            UINTVAL i;
            for (i = 0; i &#60; chunk&#45;&#62;items &#38;&#38; idx &#60; n; i++, idx++) {
                PMC ** const pos = ((PMC **) PObj_bufstart(&#38;chunk&#45;&#62;data)) + i;
                info&#45;&#62;thaw_ptr = pos;
                (info&#45;&#62;visit_pmc_now)(interp, *pos, info);
            }
        }
        /*
         * TODO handle sparse
         */
    }
}</pre>

<p>/*</p>

<p>FUNCDOC: list_length Returns the length of the list.</p>

<p>*/</p>

<p>PARROT_API INTVAL list_length(Interp *interp, const List *list /*NN*/) /* PURE, WARN_UNUSED */ { UNUSED(interp); return list&#45;&#62;length; }</p>

<p>/*</p>

<p>FUNCDOC: list_set_length</p>

<p>Sets the length of the list to <code lang='und' xml:lang='und'>len</code>.</p>

<p>*/</p>

<p>PARROT_API void list_set_length(Interp *interp, List *list /*NN*/, INTVAL len) { if (len &#60; 0) len += list&#45;&#62;length; if (len &#62;= 0) { const UINTVAL idx = list&#45;&#62;start + (UINTVAL)len; list&#45;&#62;length = len; if (idx &#62;= list&#45;&#62;cap) { /* assume user will fill it, so don&#39;t generate sparse * chunks */ if (!list&#45;&#62;cap &#38;&#38; idx &#62; MAX_ITEMS) { while (idx &#45; MAX_ITEMS &#62;= list&#45;&#62;cap) { add_chunk(interp, list, enum_add_at_end, list&#45;&#62;cap + MAX_ITEMS); } }</p>

<pre lang='und' xml:lang='und'>            list_append(interp, list, 0, list&#45;&#62;item_type, idx);
        }
        else {
            rebuild_chunk_ptrs(list, 1);
        }
        rebuild_chunk_list(interp, list);
    }
}</pre>

<p>/*</p>

<p>FUNCDOC: list_insert Make room for <code lang='und' xml:lang='und'>n_items</code> at <code lang='und' xml:lang='und'>idx</code>.</p>

<p>*/</p>

<p>PARROT_API void list_insert(Interp *interp, List *list /*NN*/, INTVAL idx, INTVAL n_items) { List_chunk *chunk;</p>

<pre lang='und' xml:lang='und'>    assert(idx &#62;= 0);
    idx += list&#45;&#62;start;
    assert(n_items &#62;= 0);
    if (n_items == 0)
        return;
    /* empty list */
    if (idx &#62;= (INTVAL)list&#45;&#62;cap) {
        idx += n_items;
        list&#45;&#62;length = idx;
        while (idx &#62;= (INTVAL)list&#45;&#62;cap)
            add_chunk(interp, list, enum_add_at_end, idx);
        return;
    }
    list&#45;&#62;length += n_items;
    list&#45;&#62;cap += n_items;
    chunk = get_chunk(interp, list, (UINTVAL *)&#38;idx);
    /* the easy case: */
    if (chunk&#45;&#62;flags &#38; sparse)
        chunk&#45;&#62;items += n_items;
    else {
        List_chunk *new_chunk;
        INTVAL items;

        /* 1. cut this chunk at idx */
        list&#45;&#62;grow_policy = enum_grow_mixed;
        /* allocate a sparse chunk, n_items big */
        new_chunk = allocate_chunk(interp, list, n_items,
                list&#45;&#62;item_size);
        new_chunk&#45;&#62;flags |= sparse;
        items = chunk&#45;&#62;items &#45; idx;
        if (items) {
            List_chunk *rest;

            /* allocate a small chunk, holding the rest of chunk beyond idx */
            chunk&#45;&#62;flags = no_power_2;
            rest = allocate_chunk(interp, list, items,
                    items * list&#45;&#62;item_size);
            rest&#45;&#62;flags |= no_power_2;
            /* hang them together */
            rest&#45;&#62;next = chunk&#45;&#62;next;
            chunk&#45;&#62;next = new_chunk;
            new_chunk&#45;&#62;next = rest;
            /* copy data over */
            mem_sys_memmove(
                    (char *)PObj_bufstart(&#38;rest&#45;&#62;data),
                    (char *)PObj_bufstart(&#38;chunk&#45;&#62;data) + idx * list&#45;&#62;item_size,
                    items * list&#45;&#62;item_size);
        }
        else {
            new_chunk&#45;&#62;next = chunk&#45;&#62;next;
            chunk&#45;&#62;next = new_chunk;
        }
        chunk&#45;&#62;items = idx;
    }
    rebuild_chunk_list(interp, list);
}</pre>

<p>/*</p>

<p>FUNCDOC: list_delete</p>

<p>Delete <code lang='und' xml:lang='und'>n_items</code> at <code lang='und' xml:lang='und'>idx</code>.</p>

<p>*/</p>

<p>PARROT_API void list_delete(Interp *interp, List *list /*NN*/, INTVAL idx, INTVAL n_items) { List_chunk *chunk;</p>

<pre lang='und' xml:lang='und'>    assert(idx &#62;= 0);
    assert(n_items &#62;= 0);
    if (n_items == 0)
        return;
    idx += list&#45;&#62;start;
    chunk = get_chunk(interp, list, (UINTVAL *)&#38;idx);
    /* deleting beyond end? */
    if (idx + n_items &#62; (INTVAL)list&#45;&#62;length)
        n_items = list&#45;&#62;length &#45; idx;
    list&#45;&#62;length &#45;= n_items;
    list&#45;&#62;cap &#45;= n_items;
    list&#45;&#62;grow_policy = enum_grow_mixed;
    while (n_items &#62; 0) {
        if (idx + n_items &#60;= (INTVAL)chunk&#45;&#62;items) {
            /* chunk is bigger then we want to delete */
            if (!(chunk&#45;&#62;flags &#38; sparse)) {
                chunk&#45;&#62;flags = no_power_2;
                if (idx + n_items &#60;= (INTVAL)chunk&#45;&#62;items) {
#ifdef __LCC__
                    /* LCC has a bug where it can&#39;t handle all the temporary
                     * variables created in this one line.  adding an explicit
                     * one fixes things.  No need to force this workaround on
                     * less brain&#45;damaged compilers though */
                    size_t tmp_size = (chunk&#45;&#62;items &#45; idx &#45; n_items) *
                            list&#45;&#62;item_size;

                    mem_sys_memmove(
                            (char *) PObj_bufstart(&#38;chunk&#45;&#62;data) +
                            idx * list&#45;&#62;item_size,
                            (char *) PObj_bufstart(&#38;chunk&#45;&#62;data) +
                            (idx + n_items) * list&#45;&#62;item_size, tmp_size);
#else
                    mem_sys_memmove(
                            (char *) PObj_bufstart(&#38;chunk&#45;&#62;data) +
                            idx * list&#45;&#62;item_size,
                            (char *) PObj_bufstart(&#38;chunk&#45;&#62;data) +
                            (idx + n_items) * list&#45;&#62;item_size,
                            (chunk&#45;&#62;items &#45; idx &#45; n_items) * list&#45;&#62;item_size);
#endif
                }
            }
            chunk&#45;&#62;items &#45;= n_items;
            break;
        }
        if (idx == 0 &#38;&#38; n_items &#62;= (INTVAL)chunk&#45;&#62;items) {
            /* delete this chunk */
            n_items &#45;= chunk&#45;&#62;items;
            /* rebuild_chunk_list will kill it because: */
            chunk&#45;&#62;items = 0;
            if (!chunk&#45;&#62;prev)
                list&#45;&#62;first = chunk&#45;&#62;next;
        }
        else if (idx) {
            /* else shrink chunk, it starts at idx then */
            if (!(chunk&#45;&#62;flags &#38; sparse))
                chunk&#45;&#62;flags = no_power_2;
            n_items &#45;= chunk&#45;&#62;items &#45; idx;
            chunk&#45;&#62;items = idx;
        }
        idx = 0;
        chunk = chunk&#45;&#62;next;
    }
    rebuild_chunk_ptrs(list, 1);
    rebuild_chunk_list(interp, list);
}</pre>

<p>/*</p>

<p>FUNCDOC: list_push</p>

<p>Pushes <code lang='und' xml:lang='und'>item</code> of type <code lang='und' xml:lang='und'>type</code> on to the end of the list.</p>

<p>*/</p>

<p>PARROT_API void list_push(Interp *interp, List *list /*NN*/, void *item, int type) { const INTVAL idx = list&#45;&#62;start + list&#45;&#62;length++;</p>

<pre lang='und' xml:lang='und'>    list_append(interp, list, item, type, idx);
}</pre>

<p>/*</p>

<p>FUNCDOC: list_unshift</p>

<p>Pushes <code lang='und' xml:lang='und'>item</code> of type <code lang='und' xml:lang='und'>type</code> on to the start of the list.</p>

<p>*/</p>

<p>PARROT_API void list_unshift(Interp *interp, List *list /*NN*/, void *item, int type) { List_chunk *chunk;</p>

<pre lang='und' xml:lang='und'>    if (list&#45;&#62;start == 0) {
        chunk = add_chunk(interp, list, enum_add_at_start, 0);
        list&#45;&#62;start = chunk&#45;&#62;items;
    }
    else
        chunk = list&#45;&#62;first;
    list_set(interp, list, item, type, &#45;&#45;list&#45;&#62;start);
    list&#45;&#62;length++;
}</pre>

<p>/*</p>

<p>FUNCDOC: list_pop</p>

<p>Removes and returns the last item of type <code lang='und' xml:lang='und'>type</code> from the end of the list.</p>

<p>*/</p>

<p>PARROT_API void * list_pop(Interp *interp, List *list /*NN*/, int type) { UINTVAL idx; void *ret; List_chunk *chunk = list&#45;&#62;last;</p>

<pre lang='und' xml:lang='und'>    if (list&#45;&#62;length == 0) {
        return 0;
    }
    idx = list&#45;&#62;start + &#45;&#45;list&#45;&#62;length;
    if (list&#45;&#62;length == 0)
        list&#45;&#62;start = 0;

    /* shrink array if necessary */
    if (idx &#60; list&#45;&#62;cap &#45; chunk&#45;&#62;items) {
        list&#45;&#62;cap &#45;= chunk&#45;&#62;items;
        chunk = list&#45;&#62;last = chunk&#45;&#62;prev;
        chunk&#45;&#62;next = 0;
        if (list&#45;&#62;n_chunks &#60;= 2)
            list&#45;&#62;first = list&#45;&#62;last;
        rebuild_chunk_list(interp, list);
    }
    ret = list_item(interp, list, type, idx);
    return ret;
}</pre>

<p>/*</p>

<p>FUNCDOC: list_shift</p>

<p>Removes and returns the first item of type <code lang='und' xml:lang='und'>type</code> from the start of the list.</p>

<p>*/</p>

<p>PARROT_API void * list_shift(Interp *interp, List *list /*NN*/, int type) { void *ret; UINTVAL idx = list&#45;&#62;start++; List_chunk *chunk = list&#45;&#62;first;</p>

<pre lang='und' xml:lang='und'>    if (list&#45;&#62;length == 0) {
        return 0;
    }
    list&#45;&#62;length&#45;&#45;;
    /* optimize push + shift on empty lists */
    if (list&#45;&#62;length == 0)
        list&#45;&#62;start = 0;
    ret = list_item(interp, list, type, idx);
    if (list&#45;&#62;start &#62;= chunk&#45;&#62;items) {
        list&#45;&#62;cap &#45;= chunk&#45;&#62;items;
        chunk = list&#45;&#62;first = chunk&#45;&#62;next ? chunk&#45;&#62;next : list&#45;&#62;last;
        list&#45;&#62;start = 0;
        rebuild_chunk_list(interp, list);
        if (list&#45;&#62;n_chunks == 1)
            list&#45;&#62;last = list&#45;&#62;first;
    }
    return ret;
}</pre>

<p>/*</p>

<p>FUNCDOC: list_assign</p>

<p>Assigns <code lang='und' xml:lang='und'>item</code> of type <code lang='und' xml:lang='und'>type</code> to index <code lang='und' xml:lang='und'>idx</code>.</p>

<p>*/</p>

<p>PARROT_API void list_assign(Interp *interp, List *list /*NN*/, INTVAL idx, void *item, int type) { const INTVAL length = list&#45;&#62;length;</p>

<pre lang='und' xml:lang='und'>    if (idx &#60; &#45;length)
        idx = &#45;idx &#45; length &#45; 1;
    else if (idx &#60; 0)
        idx += length;
    if (idx &#62;= length) {
        list_append(interp, list, item, type, list&#45;&#62;start + idx);
        list&#45;&#62;length = idx + 1;
    }
    else {
        list_set(interp, list, item, type, list&#45;&#62;start + idx);
    }
}</pre>

<p>/*</p>

<p>FUNCDOC: list_get</p>

<p>Returns the item of type <code lang='und' xml:lang='und'>type</code> at index <code lang='und' xml:lang='und'>idx</code>.</p>

<p>*/</p>

<p>PARROT_API void * list_get(Interp *interp, List *list /*NN*/, INTVAL idx, int type) /* WARN_UNUSED, PURE */ { const INTVAL length = list&#45;&#62;length;</p>

<pre lang='und' xml:lang='und'>    if (idx &#62;= length || &#45;idx &#62; length) {
        return 0;
    }

    if (idx &#60; 0)
        idx += length;
    idx += list&#45;&#62;start;
    return list_item(interp, list, type, idx);
}</pre>

<p>/*</p>

<p>FUNCDOC: list_splice</p>

<p>Replaces <code lang='und' xml:lang='und'>count</code> items starting at <code lang='und' xml:lang='und'>offset</code> with the items in <code lang='und' xml:lang='und'>value</code>.</p>

<p>If <code lang='und' xml:lang='und'>count</code> is 0 then the items in <code lang='und' xml:lang='und'>value</code> will be inserted after <code lang='und' xml:lang='und'>offset</code>.</p>

<p>*/</p>

<p>PARROT_API void list_splice(Interp *interp, List *list /*NN*/, List *value_list /*NULLOK*/, INTVAL offset, INTVAL count) { const INTVAL value_length = value_list ? value_list&#45;&#62;length : 0; const INTVAL length = list&#45;&#62;length; const int type = list&#45;&#62;item_type; INTVAL i, j;</p>

<pre lang='und' xml:lang='und'>    if (value_list &#38;&#38; type != value_list&#45;&#62;item_type)
        internal_exception(1, &#34;Item type mismatch in splice\n&#34;);

    /* start from end */
    if (offset &#60; 0)
        offset += length;
    if (offset &#60; 0)
        internal_exception(OUT_OF_BOUNDS, &#34;illegal splice offset\n&#34;);
    /* &#34;leave that many elements off the end of the array&#34; */
    if (count &#60; 0)
        count += length &#45; offset + 1;
    if (count &#60; 0)
        count = 0;

    /* replace count items at offset with values */
    for (i = j = 0; i &#60; count &#38;&#38; j &#60; value_length; i++, j++) {
        void *val = list_get(interp, value_list, j, type);

        /* no clone here, if the HL want&#39;s to reuse the values, the HL has to
         * clone the values */
        if (type == enum_type_PMC)
            val = *(PMC **)val;
        else if (type == enum_type_STRING)
            val = *(STRING **)val;
        list_assign(interp, list, offset + i, val, type);
    }
    /* if we still have values in value_list, insert them */
    if (j &#60; value_length) {
        /* make room for the remaining values */
        list_insert(interp, list, offset + i, value_length &#45; j);
        for (; j &#60; value_length; i++, j++) {
            void *val = list_get(interp, value_list, j, type);

            if (type == enum_type_PMC)
                val = *(PMC **)val;
            else if (type == enum_type_STRING)
                val = *(STRING **)val;
            list_assign(interp, list, offset + i, val, type);
        }
    }
    else {
        /* else delete the rest */
        list_delete(interp, list, offset + i, count &#45; i);
    }
}</pre>

<p>/*</p>

<h1><a name="HISTORY"
>HISTORY <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<ul>
<li>1.1</li><p class="pad"></p>

<p>10.10.2002 Initial version.</p>

<li>1.2</li><p class="pad"></p>

<p>11.10.2002 More documentation, optimized irregular chunk blocks, fixed indexed access WRT <code lang='und' xml:lang='und'>list&#45;&#62;start</code>, cosmetics.</p>

<li>1.3</li><p class="pad"></p>

<p>13.10.2002 Put <code lang='und' xml:lang='und'>intlist_length</code> into <em lang='und' xml:lang='und'><a href="intlist.c.html">src/intlist.c</a></em>.</p>

<li>1.4</li><p class="pad"></p>

<p>16.10.2002 Integrated list in parrot/arrays.</p>

<li>1.5</li><p class="pad"></p>

<p>17.10.2002 Clone integral data (intlist).</p>

<li>1.6</li><p class="pad"></p>

<p>18.10.2002 Moved tests to <code lang='und' xml:lang='und'>t/src/list.t</code>.</p>

<li>1.7</li><p class="pad"></p>

<p>19.10.2002 Set intial length (<code lang='und' xml:lang='und'>new_init</code>).</p>

<li>1.8</li><p class="pad"></p>

<p>21.10.2002 <code lang='und' xml:lang='und'>gc_debug</code> stuff.</p>

<li>1.9</li><p class="pad"></p>

<p>21.10.2002 splice.</p>

<li>1.10</li><p class="pad"></p>

<p>22.10.2002 Update comment WRT clone in splice.</p>

<li>1.11</li><p class="pad"></p>

<p>26.10.2002 <code lang='und' xml:lang='und'>user_data</code></p>

<li>1.18</li><p class="pad"></p>

<p>Fixes.</p>

<li>1.19</li><p class="pad"></p>

<p>08.11.2002 arbitrary sized items (<code lang='und' xml:lang='und'>enum_type_sized</code>).</p>

<li>1.26</li><p class="pad"></p>

<p>08.01.2003 move <code lang='und' xml:lang='und'>Chunk_list</code> flags out of buffer header.</p>

<li>1.29</li><p class="pad"></p>

<p>Join chunks &#62; <code lang='und' xml:lang='und'>MAX_ITEMS</code> (Matt Fowles)</p>

<li>1.30</li><p class="pad"></p>

<p>Greater threshold before <code lang='und' xml:lang='und'>do_sparse()</code>. Setting initial size to avoid sparse</p>

<li>1.33</li><p class="pad"></p>

<p>04.07.2003 Use a SArray for user_data</p>
</ul>

<p>*/</p>

<p>/* * Local variables: * c&#45;file&#45;style: &#34;parrot&#34; * End: * vim: expandtab shiftwidth=4: */</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
