<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>IO layer handling</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">IO layer handling</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../html/index.html">Contents</a> | <a href="../../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>src/io/io_passdown.c &#45; IO layer handling</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>This is a set of helper functions which search for the first implementation of a function in the layer&#45;stack,
call it with the appropriate arguments and return the value returned.</p>

<h2><a name="Functions"
>Functions <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>*/</p>

<p>#include &#60;parrot/parrot.h&#62; #include &#34;io_private.h&#34;</p>

<p>/* HEADER: src/io/io_private.h */</p>

<p>/*</p>

<p>FUNCDOC: PIO_open_down</p>

<p>Looks for the implementation of <code lang='und' xml:lang='und'>Open</code> and calls it if found,
returning its return value.</p>

<p>Returns <code lang='und' xml:lang='und'>NULL</code> if no implementation is found.</p>

<p>*/</p>

<p>ParrotIO * PIO_open_down(Interp *interp,
ParrotIOLayer *layer /*NULLOK*/,
const char *name /*NN*/,
INTVAL flags) /* WARN_UNUSED */ { while (layer) { if (layer&#45;&#62;api&#45;&#62;Open) { return layer&#45;&#62;api&#45;&#62;Open(interp,
layer,
name,
flags); } layer = PIO_DOWNLAYER(layer); } /* No layer found */ return NULL; }</p>

<p>/*</p>

<p>FUNCDOC: PIO_open_async_down</p>

<p>Looks for the implementation of <code lang='und' xml:lang='und'>Open_ASync</code> and calls it if found,
returning its return value.</p>

<p>Returns <code lang='und' xml:lang='und'>NULL</code> if no implementation is found.</p>

<p>*/</p>

<p>ParrotIO * PIO_open_async_down(Interp *interp,
ParrotIOLayer *layer /*NULLOK*/,
const char *name /*NN*/,
const char *mode /*NN*/,
DummyCodeRef * dummy) /* WARN_UNUSED */ { while (layer) { if (layer&#45;&#62;api&#45;&#62;Open_ASync) { return layer&#45;&#62;api&#45;&#62;Open_ASync(interp,
layer,
name,
mode,
dummy); } layer = PIO_DOWNLAYER(layer); } /* No layer found */ return NULL; }</p>

<p>/*</p>

<p>PIO_fdopen_down</p>

<p>Looks for the implementation of <code lang='und' xml:lang='und'>FDOpen</code> and calls it if found,
returning its return value.</p>

<p>Returns <code lang='und' xml:lang='und'>NULL</code> if no implementation is found.</p>

<p>*/</p>

<p>ParrotIO * PIO_fdopen_down(Interp *interp,
ParrotIOLayer *layer /*NULLOK*/,
PIOHANDLE fd,
INTVAL flags) /* WARN_UNUSED */ { while (layer) { if (layer&#45;&#62;api&#45;&#62;FDOpen) { return layer&#45;&#62;api&#45;&#62;FDOpen(interp,
layer,
fd,
flags); } layer = PIO_DOWNLAYER(layer); } /* No layer found */ return NULL; }</p>

<p>size_t PIO_peek_down(Interp *interp,
ParrotIOLayer *layer /*NULLOK*/,
ParrotIO * io,
STRING ** buf) /* WARN_UNUSED */ { while (layer) { if (layer&#45;&#62;api&#45;&#62;Peek) { return layer&#45;&#62;api&#45;&#62;Peek(interp,
layer,
io,
buf); } layer = PIO_DOWNLAYER(layer); }</p>

<pre lang='und' xml:lang='und'>    /* No layer found */
    return 0;
}</pre>

<p>/*</p>

<p>FUNCDOC: PIO_close_down</p>

<p>Looks for the implementation of <code lang='und' xml:lang='und'>Close</code> and calls it if found, returning its return value.</p>

<p>Returns <code lang='und' xml:lang='und'>&#45;1</code> if no implementation is found.</p>

<p>*/</p>

<p>INTVAL PIO_close_down(Interp *interp, ParrotIOLayer *layer /*NULLOK*/, ParrotIO * io) /* WARN_UNUSED */ { while (layer) { if (layer&#45;&#62;api&#45;&#62;Close) { return layer&#45;&#62;api&#45;&#62;Close(interp, layer, io); } layer = PIO_DOWNLAYER(layer); } /* No layer found */ return &#45;1; }</p>

<p>/*</p>

<p>PIO_write_down</p>

<p>Looks for the implementation of <code lang='und' xml:lang='und'>Write</code> and calls it if found, returning its return value.</p>

<p>Returns <code lang='und' xml:lang='und'>0</code> if no implementation is found.</p>

<p>*/</p>

<p>size_t PIO_write_down(Interp *interp, ParrotIOLayer *layer /*NULLOK*/, ParrotIO * io, STRING *s) /* WARN_UNUSED */ { while (layer) { if (layer&#45;&#62;api&#45;&#62;Write) { return layer&#45;&#62;api&#45;&#62;Write(interp, layer, io, s); } layer = PIO_DOWNLAYER(layer); } /* No layer found */ return 0; }</p>

<p>/*</p>

<p>FUNCDOC: PIO_write_async_down</p>

<p>Looks for the implementation of <code lang='und' xml:lang='und'>WriteASync</code> and calls it if found, returning its return value.</p>

<p>Returns <code lang='und' xml:lang='und'>0</code> if no implementation is found.</p>

<p>*/</p>

<p>size_t PIO_write_async_down(Interp *interp, ParrotIOLayer *layer /*NULLOK*/, ParrotIO * io, STRING *s, DummyCodeRef *dummy) /* WARN_UNUSED */ { while (layer) { if (layer&#45;&#62;api&#45;&#62;Write_ASync) { return layer&#45;&#62;api&#45;&#62;Write_ASync(interp, layer, io, s, dummy); } layer = PIO_DOWNLAYER(layer); } /* No layer found */ return 0; }</p>

<p>/*</p>

<p>FUNCDOC: PIO_read_down</p>

<p>Looks for the implementation of <code lang='und' xml:lang='und'>Read</code> and calls it if found, returning its return value.</p>

<p>Returns <code lang='und' xml:lang='und'>0</code> if no implementation is found.</p>

<p>*/</p>

<p>size_t PIO_read_down(Interp *interp, ParrotIOLayer *layer /*NULLOK*/, ParrotIO * io, STRING ** buf) /* WARN_UNUSED */ { while (layer) { if (layer&#45;&#62;api&#45;&#62;Read) { return layer&#45;&#62;api&#45;&#62;Read(interp, layer, io, buf); } layer = PIO_DOWNLAYER(layer); } /* No layer found */ return 0; }</p>

<p>/*</p>

<p>FUNCDOC: PIO_read_async_down</p>

<p>Looks for the implementation of <code lang='und' xml:lang='und'>Read_ASync</code> and calls it if found, returning its return value.</p>

<p>Returns <code lang='und' xml:lang='und'>0</code> if no implementation is found.</p>

<p>*/</p>

<p>size_t PIO_read_async_down(Interp *interp, ParrotIOLayer *layer /*NULLOK*/, ParrotIO * io, STRING ** buf, DummyCodeRef *dummy) /* WARN_UNUSED */ { while (layer) { if (layer&#45;&#62;api&#45;&#62;Read_ASync) { return layer&#45;&#62;api&#45;&#62;Read_ASync(interp, layer, io, buf, dummy); } layer = PIO_DOWNLAYER(layer); } /* No layer found */ return 0; }</p>

<p>/*</p>

<p>FUNCDOC: PIO_flush_down</p>

<p>Looks for the implementation of <code lang='und' xml:lang='und'>Flush</code> and calls it if found, returning its return value.</p>

<p>Returns <code lang='und' xml:lang='und'>0</code> if no implementation is found.</p>

<p>*/</p>

<p>INTVAL PIO_flush_down(Interp *interp, ParrotIOLayer *layer /*NULLOK*/, ParrotIO * io) /* WARN_UNUSED */ { while (layer) { if (layer&#45;&#62;api&#45;&#62;Flush) { layer&#45;&#62;api&#45;&#62;Flush(interp, layer, io); } layer = PIO_DOWNLAYER(layer); } /* No layer found */ return 0; }</p>

<p>/*</p>

<p>FUNCDOC: PIO_seek_down</p>

<p>Looks for the implementation of <code lang='und' xml:lang='und'>Seek</code> and calls it if found, returning its return value.</p>

<p>Returns <code lang='und' xml:lang='und'>&#45;1</code> if no implementation is found.</p>

<p>*/</p>

<p>PIOOFF_T PIO_seek_down(Interp *interp, ParrotIOLayer *layer /*NULLOK*/, ParrotIO * io, PIOOFF_T offset, INTVAL whence) /* WARN_UNUSED */ { while (layer) { if (layer&#45;&#62;api&#45;&#62;Seek) { return layer&#45;&#62;api&#45;&#62;Seek(interp, layer, io, offset, whence); } layer = PIO_DOWNLAYER(layer); } /* No layer found */ return &#45;1; }</p>

<p>/*</p>

<p>FUNCDOC: PIO_tell_down</p>

<p>Looks for the implementation of <code lang='und' xml:lang='und'>Tell</code> and calls it if found, returning its return value.</p>

<p>Returns <code lang='und' xml:lang='und'>0</code> if no implementation is found.</p>

<p>*/</p>

<p>PIOOFF_T PIO_tell_down(Interp *interp, ParrotIOLayer *layer /*NULLOK*/, ParrotIO * io) /* WARN_UNUSED */ { while (layer) { if (layer&#45;&#62;api&#45;&#62;Tell) { return layer&#45;&#62;api&#45;&#62;Tell(interp, layer, io); } layer = PIO_DOWNLAYER(layer); } /* No layer found */ return 0; }</p>

<p>/*</p>

<p>FUNCDOC: PIO_setbuf_down</p>

<p>Looks for the implementation of <code lang='und' xml:lang='und'>SetBuf</code> and calls it if found, returning its return value.</p>

<p>Returns <code lang='und' xml:lang='und'>&#45;1</code> if no implementation is found.</p>

<p>*/</p>

<p>INTVAL PIO_setbuf_down(Interp *interp, ParrotIOLayer *layer /*NULLOK*/, ParrotIO * io, size_t bufsize) /* WARN_UNUSED */ { while (layer) { if (layer&#45;&#62;api&#45;&#62;SetBuf) { return layer&#45;&#62;api&#45;&#62;SetBuf(interp, layer, io, bufsize); } layer = PIO_DOWNLAYER(layer); } /* No layer found */ return &#45;1; }</p>

<p>/*</p>

<p>FUNCDOC: PIO_setlinebuf_down</p>

<p>Looks for the implementation of <code lang='und' xml:lang='und'>SetLineBuf</code> and calls it if found, returning its return value.</p>

<p>Returns <code lang='und' xml:lang='und'>&#45;1</code> if no implementation is found.</p>

<p>*/</p>

<p>INTVAL PIO_setlinebuf_down(Interp *interp, ParrotIOLayer *layer /*NULLOK*/, ParrotIO * io) /* WARN_UNUSED */ { while (layer) { if (layer&#45;&#62;api&#45;&#62;SetLineBuf) { return layer&#45;&#62;api&#45;&#62;SetLineBuf(interp, layer, io); } layer = PIO_DOWNLAYER(layer); } /* No layer found */ return &#45;1; }</p>

<p>/*</p>

<p>FUNCDOC: PIO_eof_down</p>

<p>Looks for the implementation of <code lang='und' xml:lang='und'>Eof</code> and calls it if found, returning its return value.</p>

<p>Returns <code lang='und' xml:lang='und'>&#45;1</code> if no implementation is found.</p>

<p>*/</p>

<p>INTVAL PIO_eof_down(Interp *interp, ParrotIOLayer *layer /*NULLOK*/, ParrotIO * io) /* WARN_UNUSED */ { while (layer) { if (layer&#45;&#62;api&#45;&#62;Eof) { return layer&#45;&#62;api&#45;&#62;Eof(interp, layer, io); } layer = PIO_DOWNLAYER(layer); } /* No layer found */ return &#45;1; }</p>

<p>/*</p>

<p>FUNCDOC: PIO_poll_down</p>

<p>Looks for the implementation of <code lang='und' xml:lang='und'>Poll</code> and calls it if found, returning its return value.</p>

<p>Returns <code lang='und' xml:lang='und'>&#45;1</code> if no implementation is found.</p>

<p>*/</p>

<p>INTVAL PIO_poll_down(Interp *interp, ParrotIOLayer *layer, ParrotIO *io, INTVAL which, INTVAL sec, INTVAL usec) /* WARN_UNUSED */ { while (layer) { if (layer&#45;&#62;api&#45;&#62;Poll) { return layer&#45;&#62;api&#45;&#62;Poll(interp, layer, io, which, sec, usec); } layer = PIO_DOWNLAYER(layer); } return &#45;1; }</p>

<p>/*</p>

<p>FUNCDOC: PIO_socket_down</p>

<p>Looks for the implementation of <code lang='und' xml:lang='und'>Socket</code> and calls it if found, returning its return value.</p>

<p>Returns <code lang='und' xml:lang='und'>NULL</code> if no implementation is found.</p>

<p>*/</p>

<p>ParrotIO * PIO_socket_down(Interp *interp, ParrotIOLayer *layer, INTVAL fam, INTVAL type, INTVAL proto) /* WARN_UNUSED */ { while (layer) { if (layer&#45;&#62;api&#45;&#62;Socket) { return layer&#45;&#62;api&#45;&#62;Socket(interp, layer, fam, type, proto); } layer = PIO_DOWNLAYER(layer); } return NULL; }</p>

<p>/*</p>

<p>FUNCDOC: PIO_recv_down</p>

<p>Looks for the implementation of <code lang='und' xml:lang='und'>Recv</code> and calls it if found, returning its return value.</p>

<p>Returns <code lang='und' xml:lang='und'>&#45;1</code> if no implementation is found.</p>

<p>*/</p>

<p>INTVAL PIO_recv_down(Interp *interp, ParrotIOLayer *layer, ParrotIO *io, STRING **buf) /* WARN_UNUSED */ { while (layer) { if (layer&#45;&#62;api&#45;&#62;Recv) { return layer&#45;&#62;api&#45;&#62;Recv(interp, layer, io, buf); } layer = PIO_DOWNLAYER(layer); } return &#45;1; }</p>

<p>/*</p>

<p>FUNCDOC: PIO_send_down</p>

<p>Looks for the implementation of <code lang='und' xml:lang='und'>Send</code> and calls it if found, returning its return value.</p>

<p>Returns <code lang='und' xml:lang='und'>&#45;1</code> if no implementation is found.</p>

<p>*/</p>

<p>INTVAL PIO_send_down(Interp *interp, ParrotIOLayer *layer, ParrotIO *io, STRING *buf) /* WARN_UNUSED */ { while (layer) { if (layer&#45;&#62;api&#45;&#62;Send) { return layer&#45;&#62;api&#45;&#62;Send(interp, layer, io, buf); } layer = PIO_DOWNLAYER(layer); } return &#45;1; }</p>

<p>/*</p>

<p>FUNCDOC: PIO_connect_down</p>

<p>Looks for the implementation of <code lang='und' xml:lang='und'>Connect</code> and calls it if found, returning its return value.</p>

<p>Returns <code lang='und' xml:lang='und'>&#45;1</code> if no implementation is found.</p>

<p>*/</p>

<p>INTVAL PIO_connect_down(Interp *interp, ParrotIOLayer *layer, ParrotIO *io, STRING *address) /* WARN_UNUSED */ { while (layer) { if (layer&#45;&#62;api&#45;&#62;Connect) { return layer&#45;&#62;api&#45;&#62;Connect(interp, layer, io, address); } layer = PIO_DOWNLAYER(layer); } return &#45;1; }</p>

<p>/*</p>

<p>FUNCDOC: PIO_bind_down</p>

<p>Looks for the implementation of <code lang='und' xml:lang='und'>Bind</code> and calls it if found, returning its return value.</p>

<p>Returns <code lang='und' xml:lang='und'>&#45;1</code> if no implementation is found.</p>

<p>*/</p>

<p>INTVAL PIO_bind_down(Interp *interp, ParrotIOLayer *layer, ParrotIO *io, STRING *address) /* WARN_UNUSED */ { while (layer) { if (layer&#45;&#62;api&#45;&#62;Bind) { return layer&#45;&#62;api&#45;&#62;Bind(interp, layer, io, address); } layer = PIO_DOWNLAYER(layer); } return &#45;1; }</p>

<p>/*</p>

<p>FUNCDOC: PIO_listen_down</p>

<p>Looks for the implementation of <code lang='und' xml:lang='und'>listen</code> and calls it if found, returning its return value.</p>

<p>Returns <code lang='und' xml:lang='und'>&#45;1</code> if no implementation is found.</p>

<p>*/</p>

<p>INTVAL PIO_listen_down(Interp *interp, ParrotIOLayer *layer, ParrotIO *io, INTVAL backlog) /* WARN_UNUSED */ { while (layer) { if (layer&#45;&#62;api&#45;&#62;Listen) { return layer&#45;&#62;api&#45;&#62;Listen(interp, layer, io, backlog); } layer = PIO_DOWNLAYER(layer); } return &#45;1; }</p>

<p>/*</p>

<p>FUNCDOC: PIO_accept_down</p>

<p>Looks for the implementation of <code lang='und' xml:lang='und'>Accept</code> and calls it if found, returning its return value.</p>

<p>Returns <code lang='und' xml:lang='und'>&#45;1</code> if no implementation is found.</p>

<p>*/</p>

<p>ParrotIO * PIO_accept_down(Interp *interp, ParrotIOLayer *layer, ParrotIO *io) /* WARN_UNUSED */ { while (layer) { if (layer&#45;&#62;api&#45;&#62;Accept) { return layer&#45;&#62;api&#45;&#62;Accept(interp, layer, io); } layer = PIO_DOWNLAYER(layer); } return NULL; }</p>

<p>/*</p>

<h1><a name="SEE_ALSO"
>SEE ALSO <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p><em lang='und' xml:lang='und'><a href="io_buf.c.html">src/io/io_buf.c</a></em>, <em lang='und' xml:lang='und'><a href="io_passdown.c.html">src/io/io_passdown.c</a></em>, <em lang='und' xml:lang='und'><a href="io_stdio.c.html">src/io/io_stdio.c</a></em>, <em lang='und' xml:lang='und'><a href="io_unix.c.html">src/io/io_unix.c</a></em>, <em lang='und' xml:lang='und'><a href="io_win32.c.html">src/io/io_win32.c</a></em>, <em lang='und' xml:lang='und'><a href="io.c.html">src/io/io.c</a></em>, <em lang='und' xml:lang='und'><a href="io_private.h.html">src/io/io_private.h</a></em>.</p>

<h1><a name="HISTORY"
>HISTORY <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Initially written by Juergen Boemmels</p>

<p>Some ideas and goals from Perl5.7 and Nick Ing&#45;Simmons&#39; work.</p>

<p>*/</p>

<p>/* * Local variables: * c&#45;file&#45;style: &#34;parrot&#34; * End: * vim: expandtab shiftwidth=4: */</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
