<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>IO Layer Handling</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">IO Layer Handling</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../html/index.html">Contents</a> | <a href="../../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>src/io/io_layers.c &#45; IO Layer Handling</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>The Parrot IO subsystem uses a per&#45;interpreter stack to provide a layer&#45;based approach to IO.
Each layer implements a subset of the <code lang='und' xml:lang='und'>ParrotIOLayerAPI</code> vtable.
To find an IO function the layer stack is searched downwards until a non&#45;<code lang='und' xml:lang='und'>NULL</code> function pointer is found for that particular slot.</p>

<h2><a name="Layer_and_Stack_Functions"
>Layer and Stack Functions <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>FUNCDOC: PIO_base_new_layer</p>

<p>The default IO layer constructor.
Creates and returns a new <code lang='und' xml:lang='und'>ParrotIOLayer</code>.
If a prototype <code lang='und' xml:lang='und'>*proto</code> is supplied then its values will be copied to the new instance.</p>

<p>*/</p>

<p>#include &#34;parrot/parrot.h&#34; #include &#34;parrot/io.h&#34; #include &#34;io_private.h&#34;</p>

<p>/* HEADER: include/parrot/io.h */</p>

<p>PARROT_API ParrotIOLayer * PIO_base_new_layer(ParrotIOLayer *proto) { ParrotIOLayer * const new_layer = mem_allocate_typed(ParrotIOLayer);</p>

<pre lang='und' xml:lang='und'>    /*
     * XXX use managed memory here ?
     */
    if (proto) {
        /* FIXME: Flag here to indicate whether to free strings */
        new_layer&#45;&#62;name  = proto&#45;&#62;name;
        new_layer&#45;&#62;flags = proto&#45;&#62;flags;
        new_layer&#45;&#62;api   = proto&#45;&#62;api;
    }
    else {
        new_layer&#45;&#62;name = NULL;
        new_layer&#45;&#62;flags = 0;
        new_layer&#45;&#62;api = NULL;
    }
    new_layer&#45;&#62;self = 0;
    new_layer&#45;&#62;up = NULL;
    new_layer&#45;&#62;down = NULL;
    return new_layer;
}</pre>

<p>/*</p>

<p>PIO_base_delete_layer</p>

<p>The default IO layer destructor. Frees the memory associated with <code lang='und' xml:lang='und'>*layer</code>.</p>

<p>*/</p>

<p>PARROT_API void PIO_base_delete_layer(ParrotIOLayer *layer /*NULLOK*/) { if (layer != NULL) mem_sys_free(layer); }</p>

<p>/*</p>

<p>FUNCDOC: PIO_push_layer</p>

<p>Push a layer onto an IO object (<code lang='und' xml:lang='und'>*pmc</code>) or the default stack.</p>

<p>FUNCDOC: PIO_push_layer_str</p>

<p>Push a layer onto an IO object (<code lang='und' xml:lang='und'>*pmc</code>).</p>

<p>*/</p>

<p>PARROT_API INTVAL PIO_push_layer(Interp *interp, PMC *pmc /*NULLOK*/, ParrotIOLayer *layer /*NULLOK*/) { if (layer == NULL) return &#45;1;</p>

<pre lang='und' xml:lang='und'>    if (!PMC_IS_NULL(pmc)) {
        ParrotIOLayer    *t;
        ParrotIO * const io = PMC_data_typed(pmc, ParrotIO *);

        if (!io)
            return &#45;1;

        /* Error( 1st layer must be terminal) */
        if (io&#45;&#62;stack == NULL &#38;&#38; (layer&#45;&#62;flags &#38; PIO_L_TERMINAL) == 0)
            return &#45;1;

        /* Check and see if this layer already is on stack
         * This is a internals sanity check not a user level
         * check, at least until I fix copy&#45;on&#45;write stacks.
         * &#45;Melvin
         */
        for (t = io&#45;&#62;stack; t; t = t&#45;&#62;down) {
            if (t == layer)
                return &#45;1;
        }

        /* if this is a global layer create a copy first */
        if (!(io&#45;&#62;stack&#45;&#62;flags &#38; PIO_L_LAYER_COPIED))
            io&#45;&#62;stack = PIO_copy_stack(io&#45;&#62;stack);

        layer&#45;&#62;down = io&#45;&#62;stack;

        if (io&#45;&#62;stack)
            io&#45;&#62;stack&#45;&#62;up = layer;

        io&#45;&#62;stack = layer;

        PMC_struct_val(pmc) = layer;

        if (layer&#45;&#62;api&#45;&#62;Pushed)
            (*layer&#45;&#62;api&#45;&#62;Pushed) (layer, io);
    }
    else {
        ParrotIOLayer *t;
        ParrotIOData * const d = interp&#45;&#62;piodata;
        if (d&#45;&#62;default_stack == NULL &#38;&#38; (layer&#45;&#62;flags &#38; PIO_L_TERMINAL) == 0) {
            /* Error( 1st layer must be terminal) */
            return &#45;1;
        }
        /* Sanity check */
        for (t = d&#45;&#62;default_stack; t; t = t&#45;&#62;down) {
            if (t == layer)
                return &#45;1;
        }

        layer&#45;&#62;down = d&#45;&#62;default_stack;
        if (d&#45;&#62;default_stack)
            d&#45;&#62;default_stack&#45;&#62;up = layer;
        d&#45;&#62;default_stack = layer;
        return 0;
    }
    return &#45;1;
}</pre>

<p>PARROT_API ParrotIOLayer * PIO_get_layer(Interp *interp, const char *name /*NN*/) /* WARN_UNUSED */ { ParrotIOLayer **t;</p>

<pre lang='und' xml:lang='und'>    UNUSED(interp);
    for (t = pio_registered_layers; *t; ++t)
        if (strcmp(name, (*t)&#45;&#62;name) == 0)
            return *t;
    return NULL;
}</pre>

<p>void PIO_push_layer_str(Interp *interp, PMC *pmc, STRING *ls) { char * const cls = string_to_cstring(interp, ls); ParrotIOLayer * const l = PIO_get_layer(interp, cls); ParrotIOLayer * newlayer;</p>

<pre lang='und' xml:lang='und'>    string_cstring_free(cls);
    if (!l)
        internal_exception(1, &#34;Layer not found&#34;);

    /* make private copy */
    newlayer = PIO_base_new_layer(l);
    newlayer&#45;&#62;flags |= PIO_L_LAYER_COPIED;
    PIO_push_layer(interp, pmc, newlayer);
}</pre>

<p>/*</p>

<p>FUNCDOC: PIO_pop_layer</p>

<p>Pop a layer from an IO object (<code lang='und' xml:lang='und'>*pmc</code>) or the default stack.</p>

<p>FUNCDOC: PIO_pop_layer_str</p>

<p>Pop a layer from an IO object (<code lang='und' xml:lang='und'>*pmc</code>) and return the name of the popped layer. The layer gets freed.</p>

<p>*/</p>

<p>PARROT_API ParrotIOLayer * PIO_pop_layer(Interp *interp, PMC *pmc /*NULLOK*/) { ParrotIO * const io = PMC_data_typed(pmc, ParrotIO *);</p>

<pre lang='und' xml:lang='und'>    if (!PMC_IS_NULL(pmc)) {
        ParrotIOLayer *layer;

        if (!io)
            return 0;

        /* if this is a global layer create a copy first */
        if (!(io&#45;&#62;stack&#45;&#62;flags &#38; PIO_L_LAYER_COPIED))
            io&#45;&#62;stack = PIO_copy_stack(io&#45;&#62;stack);

        layer = io&#45;&#62;stack;

        if (layer) {
            io&#45;&#62;stack           = layer&#45;&#62;down;
            PMC_struct_val(pmc) = io&#45;&#62;stack;
            io&#45;&#62;stack&#45;&#62;up       = 0;
            layer&#45;&#62;up           = 0;
            layer&#45;&#62;down         = 0;

            if (layer&#45;&#62;api&#45;&#62;Popped)
                (*layer&#45;&#62;api&#45;&#62;Popped) (layer, io);

            return layer;
        }

        return layer;
    }
    /* Null io object &#45; use default stack */
    else {
        ParrotIOData  * const d     = interp&#45;&#62;piodata;
        ParrotIOLayer * const layer = d&#45;&#62;default_stack;

        if (layer) {
            d&#45;&#62;default_stack     = layer&#45;&#62;down;
            d&#45;&#62;default_stack&#45;&#62;up = NULL;
            layer&#45;&#62;up            = 0;
            layer&#45;&#62;down          = 0;

            return layer;
        }
    }

    return NULL;
}</pre>

<p>STRING * PIO_pop_layer_str(Interp *interp, PMC *pmc) { ParrotIOLayer * const layer = PIO_pop_layer(interp, pmc); STRING * const ls = string_make(interp, layer&#45;&#62;name, strlen(layer&#45;&#62;name), &#34;iso&#45;8859&#45;1&#34;, 0); mem_sys_free(layer); return ls; }</p>

<p>/*</p>

<p>FUNCDOC: PIO_copy_stack</p>

<p>Primarily used to copy the default IO stack for a new IO object. Later we will do some funky copy&#45;on&#45;write stuff.</p>

<p>*/</p>

<p>PARROT_API ParrotIOLayer * PIO_copy_stack(ParrotIOLayer *stack /*NULLOK*/) { ParrotIOLayer *ptr_new = NULL; ParrotIOLayer *ptr_last = NULL; ParrotIOLayer **ptr_ptr_new = &#38;ptr_new;</p>

<pre lang='und' xml:lang='und'>    while (stack) {
        *ptr_ptr_new = PIO_base_new_layer(stack);
        (*ptr_ptr_new)&#45;&#62;flags |= PIO_L_LAYER_COPIED;
        (*ptr_ptr_new)&#45;&#62;up = ptr_last;
        stack = stack&#45;&#62;down;
        ptr_last = *ptr_ptr_new;
        ptr_ptr_new = &#38;((*ptr_ptr_new)&#45;&#62;down);
    }

    return ptr_new;
}</pre>

<p>/* * Local variables: * c&#45;file&#45;style: &#34;parrot&#34; * End: * vim: expandtab shiftwidth=4: */</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
