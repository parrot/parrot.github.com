<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Hash table</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Hash table</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../html/index.html">Contents</a> | <a href="../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>src/hash.c &#45; Hash table</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>A hashtable contains an array of bucket indexes.
Buckets are nodes in a linked list,
each containing a <code lang='und' xml:lang='und'>void *</code> key and value.
During hash creation,
the types of key and value as well as appropriate compare and hashing functions can be set.</p>

<p>This hash implementation uses just one piece of malloced memory.
The <code lang='und' xml:lang='und'>hash&#45;&#62;bs</code> bucket store points to this region.</p>

<p>This hash doesn&#39;t move during GC,
therefore a lot of the old caveats don&#39;t apply.</p>

<h2><a name="Functions"
>Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>*/</p>

<p>#include &#34;parrot/parrot.h&#34; #include &#60;assert.h&#62;</p>

<p>#define INITIAL_BUCKETS 16</p>

<p>#define N_BUCKETS(n) ((n) &#45; (n)/4) #define HASH_ALLOC_SIZE(n) (N_BUCKETS(n) * sizeof (HashBucket) + \ (n) * sizeof (HashBucket *))</p>

<p>/* HEADER: include/parrot/hash.h */</p>

<p>/*</p>

<p>FUNCDOC: Return the hashed value of the key <code lang='und' xml:lang='und'>value</code>.</p>

<p>see also string.c</p>

<p>*/</p>

<p>static size_t key_hash_STRING(Interp *interp,
STRING *value,
size_t seed) { STRING * const s = value;</p>

<pre lang='und' xml:lang='und'>    if (s&#45;&#62;hashval) {
        return s&#45;&#62;hashval;
    }

    return string_hash(interp, s, seed);
}</pre>

<p>/*</p>

<p>FUNCDOC: Compares the two strings, returning 0 if they are identical.</p>

<p>*/</p>

<p>static int STRING_compare(Parrot_Interp interp, const void *search_key, const void *bucket_key) { return string_equal(interp, (const STRING *)search_key, (const STRING *)bucket_key); }</p>

<p>/*</p>

<p>FUNCDOC: Compares the two pointers, returning 0 if they are identical</p>

<p>*/</p>

<p>static int pointer_compare(Parrot_Interp interp, const void * const a, const void * const b) { return a != b; }</p>

<p>/*</p>

<p>FUNCDOC: Returns a hashvalue for a pointer.</p>

<p>*/</p>

<p>static size_t key_hash_pointer(Interp *interp, void *value, size_t seed) { return ((size_t) value) ^ seed; }</p>

<p>static size_t key_hash_cstring(Interp *interp, const void *value /*NN*/, size_t seed) { register size_t h = seed; const unsigned char * p = (const unsigned char *) value; while (*p) { h += h &#60;&#60; 5; h += *p++; } return h; }</p>

<p>/*</p>

<p>FUNCDOC: C string versions of the <code lang='und' xml:lang='und'>key_hash</code> and <code lang='und' xml:lang='und'>compare</code> functions.</p>

<p>*/</p>

<p>static int cstring_compare(Parrot_Interp interp, const char *a /*NN*/, const char *b /*NN*/) { UNUSED(interp); return strcmp(a, b); }</p>

<p>/*</p>

<p>FUNCDOC: Custom <code lang='und' xml:lang='und'>key_hash</code> function.</p>

<p>*/</p>

<p>static size_t key_hash_int(Interp *interp, void *value, size_t seed) { UNUSED(interp); return (size_t)value ^ seed; }</p>

<p>/*</p>

<p>FUNCDOC: Custom <code lang='und' xml:lang='und'>compare</code> function.</p>

<p>*/</p>

<p>/*</p>

<p>FUNCDOC: Custom <code lang='und' xml:lang='und'>compare</code> function.</p>

<p>*/</p>

<p>static int int_compare(Parrot_Interp interp, const void *a, const void *b) { UNUSED(interp); return a != b; }</p>

<p>/*</p>

<p>FUNCDOC: Print out the hash in human&#45;readable form. Except it&#39;s empty.</p>

<h1><a name="SEE_ALSO"
>SEE ALSO <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p><em lang='und' xml:lang='und'>docs/pdds/pdd08_keys.pod</em>.</p>

<h1><a name="HISTORY"
>HISTORY <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<ul>
<li>Initial version by Jeff G. on 2001.12.05</li><p class="pad"></p>

<li>Substantially rewritten by Steve F.</li><p class="pad"></p>

<li>2003.10.25</li><p class="pad"></p>

<p>leo add function pointer for compare, hash, mark</p>

<p>hash keys are now <code lang='und' xml:lang='und'>(void *)</code></p>

<p>add <code lang='und' xml:lang='und'>parrot_new_cstring_hash()</code> function</p>

<li>2003.11.04</li><p class="pad"></p>

<p><code lang='und' xml:lang='und'>bucket&#45;&#62;value</code> is now a plain pointer, no more an <code lang='und' xml:lang='und'>HASH_ENTRY</code></p>

<p>With little changes, we can again store arbitrary items if needed, see TODO in code.</p>

<li>2003.11.06</li><p class="pad"></p>

<p>boemmels renamed <code lang='und' xml:lang='und'>HASH</code> and <code lang='und' xml:lang='und'>HASHBUCKET</code> to <code lang='und' xml:lang='und'>Hash</code> and <code lang='und' xml:lang='und'>HashBucket</code></p>

<li>2003.11.11</li><p class="pad"></p>

<p>leo randomize <code lang='und' xml:lang='und'>key_hash</code> seed</p>

<p>extend <code lang='und' xml:lang='und'>parrot_new_hash_x()</code> init call by <code lang='und' xml:lang='und'>value_type</code> and <code lang='und' xml:lang='und'>_size</code>.</p>

<li>2003.11.14</li><p class="pad"></p>

<p>leo <code lang='und' xml:lang='und'>USE_STRING_EQUAL</code> define, see comment above</p>

<li>2005.05.23</li><p class="pad"></p>

<p>leo heavy rewrite: use just one piece of malloced memory</p>
</ul>

<h1><a name="TODO"
>TODO <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>Future optimizations:</p>

<ul>
<li>Stop reallocating the bucket pool, and instead add chunks on. (Saves pointer fixups and copying during <code lang='und' xml:lang='und'>realloc</code>.)</li><p class="pad"></p>

<li>Hash contraction (don&#39;t if it&#39;s worth it)</li><p class="pad"></p>
</ul>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
