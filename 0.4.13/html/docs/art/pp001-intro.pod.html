<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Untitled</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Untitled</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../html/index.html">Contents</a> | <a href="../../../html/docs.html">Documentation</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="Writing_PIR"
>Writing PIR <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>PIR (Parrot Intermediate Representation) is a way to program the parrot virtual machine that is easier to use than PASM (Parrot Assembler).
PASM notation is like any other assembler&#45;like format and can be used directly,
but it is more verbose and gives too much power to the user.
PIR abstracts common operations and conventions into a syntax that more closely resembles a high&#45;level language.
PIR allows the programmer to write code that more naturally expresses their intent without worrying about setting up the exact details that PASM requires to function properly.</p>

<p>This article will show the basics on programming in PIR.
More advanced topics will appear in later articles.</p>

<h2><a name="Getting_Parrot"
>Getting Parrot <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>In order to test the PIR and PASM code in this article,
a parrot virtual machine is needed (henceforth just &#34;parrot&#34;).
Parrot is available from <a href='http://parrotcode.org'><a href="http://parrotcode.org">http://parrotcode.org</a></a>.
Just download the latest release,
or checkout the current development version from the SVN tree.
The programs in this article were tested with Parrot 0.4.3.</p>

<p>Parrot is very easy to compile on unix&#45;like operating systems: just run <code lang='und' xml:lang='und'>perl Configure.pl &#38;&#38; make</code> in the root directory of the parrot source and,
if everything works correctly,
a <code lang='und' xml:lang='und'>parrot</code> executable should appear.
Normally,
I use it directly from the root directory of the parrot source,
instead of installing it into the system.</p>

<p>If you do not want to compile your own Parrot you can download a pre&#45;compiled binary from <a href="http://www.parrotcode.org/source.html">http://www.parrotcode.org/source.html</a></p>

<h2><a name="Parrot_Virtual_Machine_overview"
>Parrot Virtual Machine overview <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Before we get started with the examples,
here&#39;s a quick overview of parrot&#39;s architecture.</p>

<p>Parrot is a register&#45;based virtual machine.
It provides 4 types of registers.
The register types are:</p>

<dl>
<dt><a name="I_&#45;_integer"
>I &#45; integer</a></dt><p class="pad"></p>

<dt><a name="N_&#45;_floating_point"
>N &#45; floating point</a></dt><p class="pad"></p>

<dt><a name="S_&#45;_string"
>S &#45; string</a></dt><p class="pad"></p>

<dt><a name="P_&#45;_PMC_(Parrot_Magic_Cookie)"
>P &#45; PMC (Parrot Magic Cookie)</a></dt><p class="pad"></p>
</dl>

<p>Registers are designated by the type of register followed by a number.
For instance,
the integer registers are <code lang='und' xml:lang='und'>I0</code>,
<code lang='und' xml:lang='und'>I1</code> and so on.
The PMC registers hold arbitrary data objects and are parrot&#39;s mechanism for implementing more complex behavior than the ones that can be expressed using the other 3 register types alone.
PMCs will be covered in more detail in a future article.
Examples in this article will focus on the first 3 register types.</p>

<h2><a name="Simple_Operators"
>Simple Operators <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Let me start with a simple and typical example:</p>

<pre lang='und' xml:lang='und'>  .sub main :main
       print &#34;hello world\n&#34;
  .end</pre>

<p>To run it, save the code in a <code lang='und' xml:lang='und'>hello.pir</code> file and pass it to the parrot virtual machine:</p>

<pre lang='und' xml:lang='und'>   ./parrot hello.pir</pre>

<p>Note that I am using a relative path to parrot given that I didn&#39;t install it into the system.</p>

<p>The keywords starting with a dot (<code lang='und' xml:lang='und'>.sub</code> and <code lang='und' xml:lang='und'>.end</code>) are PIR macros. They are used together to define subroutines. After the <code lang='und' xml:lang='und'>.sub</code> keyword I use the name of the subroutine. The keyword that starts with a colon (<code lang='und' xml:lang='und'>:main</code>) is a attribute (more on those later) that tells parrot that this is the main body of the program and that it should start by executing this subroutine. By the way, I could use <code lang='und' xml:lang='und'>.sub foo :main</code> and Parrot will use the <code lang='und' xml:lang='und'>foo</code> subroutine as the main body of the program. The actual name of the subroutine does not matter as long as it has the attribute <code lang='und' xml:lang='und'>:main</code>.</p>

<p>Before going into more details about subroutines and calling conventions, let&#39;s compare some PIR syntax to the equivalent PASM.</p>

<p>If I want to add two integer registers using PASM I would use the Parrot <code lang='und' xml:lang='und'>set</code> opcode to put values into registers, and the <code lang='und' xml:lang='und'>add</code> opcode to add them, like this:</p>

<pre lang='und' xml:lang='und'>   set I1, 5
   set I2, 3
   add I0, I1, I2   # I0 yields 5+3</pre>

<p>PIR includes infix operators for these common opcodes. I could write this same code as</p>

<pre lang='und' xml:lang='und'>   I1 = 5
   I2 = 3
   I0 = I1 + I2</pre>

<p>There are the four arithmetic operators as you should be expecting, as well as the six different comparison operators, which return a boolean value:</p>

<pre lang='und' xml:lang='und'>   I1 = 5
   I2 = 3
   I0 = I1 &#60;= I2   # I0 yields 0 (false)</pre>

<p>I can also use the short accumulation&#45;like operators, like <code lang='und' xml:lang='und'>+=</code>.</p>

<p>Also, PIR allows an extended syntax for registers. If the register name is prefixed with a dollar sign, like <code lang='und' xml:lang='und'>$I1</code>, the parrot PIR compiler will automatically assign these &#34;virtual registers&#34; to actual registers as needed and handle whatever manipulations are needed for optimization.</p>

<p>Another PIR perk is that local variable names may be declared and used instead of register names. For that I just need to declare the variable using the <code lang='und' xml:lang='und'>.local</code> keyword:</p>

<pre lang='und' xml:lang='und'>   .local int size
   size = 5</pre>

<p>The parrot compiler will choose one register and associate it with my variable name. I can declare local variables for any of the four data types available on PIR: <code lang='und' xml:lang='und'>int</code>, <code lang='und' xml:lang='und'>string</code>, <code lang='und' xml:lang='und'>num</code> and <code lang='und' xml:lang='und'>pmc</code>.</p>

<h2><a name="Branching"
>Branching <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Another simplification of PASM are branches. Basically, when I want to test a condition and jump to another place in the code, I would write the following PASM code:</p>

<pre lang='und' xml:lang='und'>   le I1, I2, LESS_EQ</pre>

<p>Meaning, if <code lang='und' xml:lang='und'>I1</code> is less or equal than <code lang='und' xml:lang='und'>I2</code>, jump to label <code lang='und' xml:lang='und'>LESS_EQ</code>. In PIR I would write it in a more legible way:</p>

<pre lang='und' xml:lang='und'>   if $I1 &#60;= $I2 goto LESS_EQ</pre>

<p>PIR includes the <code lang='und' xml:lang='und'>unless</code> keyword as well.</p>

<h2><a name="Calling_Functions"
>Calling Functions <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Subroutines can easily be created using the <code lang='und' xml:lang='und'>.sub</code> keyword shown before. If you do not need parameters, it just as simple as I show in the following code:</p>

<pre lang='und' xml:lang='und'>  .sub main :main
     hello()
  .end

  .sub hello
    print &#34;Hello World\n&#34;
  .end</pre>

<p>Now, I want to make my <code lang='und' xml:lang='und'>hello</code> subroutine a little more useful, such that I can greet other people. For that I will use the <code lang='und' xml:lang='und'>.param</code> keyword to define the parameters <code lang='und' xml:lang='und'>hello</code> can handle:</p>

<pre lang='und' xml:lang='und'>  .sub main :main
     hello(&#34;leo&#34;)
     hello(&#34;chip&#34;)
  .end

  .sub hello
     .param string person
     print &#34;Hello &#34;
     print person
     print &#34;\n&#34;
  .end</pre>

<p>If I need more parameters I just need to add more <code lang='und' xml:lang='und'>.param</code> lines.</p>

<p>To return values from PIR subroutines I use the <code lang='und' xml:lang='und'>.return</code> keyword, followed by one or more arguments, just like this:</p>

<pre lang='und' xml:lang='und'>  .return (10, 20, 30)</pre>

<h2><a name="Factorial_Example"
>Factorial Example <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Now, for a little more complicated example, let me show how I would code Factorial subroutine:</p>

<pre lang='und' xml:lang='und'>  .sub main :main
     $I1 = factorial(5)
     print $I1
     print &#34;\n&#34;
  .end

  .sub factorial
     .param int i
     if i &#62; 1 goto recurse
     .return (1)
  recurse:
     $I1 = i &#45; 1
     $I2 = factorial($I1)
     $I2 *= i
     .return ($I2)
  .end</pre>

<p>This example also shows that PIR subroutines may be recursive just as in a high&#45;level language.</p>

<h2><a name="Named_Arguments"
>Named Arguments <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>As some other languages as Python and Perl support named arguments, PIR supports them as well.</p>

<p>As before, I need to use <code lang='und' xml:lang='und'>.param</code> for each named argument, but with one of the two following syntaxes:</p>

<pre lang='und' xml:lang='und'>  .sub func
    .param int a :named(&#34;foo&#34;)    # or
    .param int &#34;bar&#34; =&#62; b</pre>

<p>Both of these lines say the exact same thing: the subroutine will receive an integer named &#34;foo&#34;, and inside of the subroutine that integer will be known as &#34;a&#34;.</p>

<p>When calling the function, I need to pass the names of the arguments. For that there are two syntaxes as well:</p>

<pre lang='und' xml:lang='und'>  func( 10 :named(&#34;foo&#34;) )        # or
  func( &#34;foo&#34; =&#62; 10 )</pre>

<p>Note that with named arguments, you may rearrange the order of your parameters at will.</p>

<pre lang='und' xml:lang='und'>  .sub foo
    .param string &#34;name&#34;    =&#62; a
    .param int    &#34;age&#34;     =&#62; b
    .param string &#34;gender&#34;  =&#62; c
    # ...
  .end</pre>

<p>This subroutine may be called in any of the following ways:</p>

<pre lang='und' xml:lang='und'>  foo( &#34;Fred&#34;, 35, &#34;m&#34; )
  foo( &#34;gender&#34; =&#62; &#34;m&#34;, &#34;name&#34; =&#62; &#34;Fred&#34;, &#34;age&#34; =&#62; 35 )
  foo( &#34;age&#34; =&#62; 35, &#34;gender&#34; =&#62; &#34;m&#34;, &#34;name&#34; =&#62; &#34;Fred&#34; )
  foo( &#34;m&#34; :named(&#34;gender&#34;), 35 :named(&#34;age&#34;), &#34;name&#34; =&#62; &#34;Fred&#34; )</pre>

<p>and any other permutation you can think of as long as you use the named argument syntax.</p>

<p>It&#39;s also possible to use named syntax when returning values from subroutines. Into the <code lang='und' xml:lang='und'>.return</code> command I&#39;ll use:</p>

<pre lang='und' xml:lang='und'>  .return ( &#34;bar&#34; =&#62; 20, &#34;foo&#34; =&#62; 10)</pre>

<p>and when calling the function, I will do:</p>

<pre lang='und' xml:lang='und'>  (&#34;foo&#34; =&#62; $I0, &#34;bar&#34; =&#62; $I1) = func()</pre>

<p>And <code lang='und' xml:lang='und'>$I0</code> will yield 10, and <code lang='und' xml:lang='und'>$I1</code> will yield 20, as expected.</p>

<h2><a name="Concluding"
>Concluding <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>To conclude this first article on PIR and to let you test what you learned, let me show you how to do input on PASM (hence, also in PIR). There is a <code lang='und' xml:lang='und'>read</code> opcode to read from standard input. Just pass it a string register or variable where you wish the characters read to be placed and the number of characters you wish to read:</p>

<pre lang='und' xml:lang='und'>  read $S1, 100</pre>

<p>This line will read 100 characters (or until the end of the line) and put the read string into <code lang='und' xml:lang='und'>$S1</code>. In case you need a number, just assign the string to the correct register type:</p>

<pre lang='und' xml:lang='und'>  read $S1, 100
  $I1 = $S1</pre>

<p>With the PIR syntax shown in this article you should be able to start writing simple programs. Next article we will look into available PMCs, and how they can be used.</p>

<h2><a name="Author"
>Author <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Alberto Sim&#195;&#181;es</p>

<h2><a name="Thanks"
>Thanks <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<blockquote>
<p>* Jonathan Scott Duff</p>
</blockquote>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
