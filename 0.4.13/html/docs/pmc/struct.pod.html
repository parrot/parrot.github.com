<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Accessing C Structs from Parrot</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Accessing C Structs from Parrot</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../html/index.html">Contents</a> | <a href="../../../html/docs.html">Documentation</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Structures &#45; Accessing C Structs from Parrot</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Parrot provides two PMC classes to deal with C structures.
These are UnManagedStruct and ManagedStruct.
The former has no allocated memory and is typically used to access structures returned by NCI calls,
while the latter can be used to define a structure and pass it over to a C function &#45; pointers to structures in both cases of course.</p>

<h1><a name="Structure_definition"
>Structure definition <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>The Struct PMCs take an array of triples per structure element,
either as initializer or with the <b>assign</b> opcode to define the struct elements.</p>

<dl>
<dt><a name="Datatype"
>Datatype</a></dt><p class="pad"></p>

<dd>The datatype is defined by constants declared in <em lang='und' xml:lang='und'>datatypes.pasm</em>.</dd><p class="pad"></p>

<dt><a name="Array_Size"
>Array Size</a></dt><p class="pad"></p>

<dd>The second initializer item,
if set to a value greater then 1,
defines the struct element to consist of an array of the given data type.</dd><p class="pad"></p>

<dt><a name="Byte_Offset"
>Byte Offset</a></dt><p class="pad"></p>

<dd>The third initializer is the byte offset of the data item in the structure.
This entry can be 0 if packing of the structure is aligned to the item&#39;s sizes or the alignment is the item&#39;s size.
Otherwise these offsets must be set correctly as Parrot doesn&#39;t know how your C compiler packs arbitrary data.
Parrot only knows the size of each item.</dd><p class="pad"></p>
</dl>

<h2><a name="Alignment"
>Alignment <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Parrot tries to do The Right Thing that is currently align items at their size.</p>

<pre lang='und' xml:lang='und'>  struct {
    char c;
    int  i;
  }</pre>

<p>The <code lang='und' xml:lang='und'>i</code> above is aligned at 4 (for i386 or such).</p>

<h2><a name="Example"
>Example <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>The C structure</p>

<pre lang='und' xml:lang='und'>  struct {
    double d;
    float  f;
    int    i[4];
    char  *s;
  };</pre>

<p>can be declared with this initializer:</p>

<pre lang='und' xml:lang='und'>  new P2, .PerlArray
  .include &#34;datatypes.pasm&#34;
  push P2, .DATATYPE_DOUBLE
  push P2, 0    # no array i.e. 1 element
  push P2, 0    # calculate offset by just adding item size
  push P2, .DATATYPE_FLOAT
  push P2, 0
  push P2, 0
  push P2, .DATATYPE_INT
  push P2, 4    # 4 elem array
  push P2, 0
  push P2, .DATATYPE_CSTR
  push P2, 0
  push P2, 0</pre>

<h2><a name="Named_Structure_Elements"
>Named Structure Elements <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>The initializer can be an OrderedHash PMC too. When all elements are defined in the correct order this can be used to define and access struct elements by name and by index:</p>

<pre lang='und' xml:lang='und'>  new P2, .OrderedHash
  .include &#34;datatypes.pasm&#34;
  set P2[&#34;d&#34;], .DATATYPE_DOUBLE
  push P2, 0    # no array i.e. 1 element
  push P2, 0    # calculate offset by just adding item size
  set P2[&#34;f&#34;], .DATATYPE_FLOAT
  ...</pre>

<h1><a name="Size_of_a_Structure"
>Size of a Structure <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>For ManagedStruct (a new structure passed over to a C function) the storage for data items has to be allocated. This is done automatically, when the initializer is attached to the Struct PMC.</p>

<p>The size can be obtained by:</p>

<pre lang='und' xml:lang='und'>  new P5, .ManagedStruct, P2   # P2 be some initializer

  set I0, P5    # allocated size</pre>

<h1><a name="Accessing_Structure_Items"
>Accessing Structure Items <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Setting or getting items is done by keyed access to the Struct PMC. The first key is the structure item, an optional second key can access the n&#45;th array element.</p>

<h2><a name="Example"
>Example <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<pre lang='und' xml:lang='und'>  set P5[0], N0         # set d
  set N0, P5[0]         # get d

  set N0, P5[&#34;d&#34;]       # get d if initializer is an OrderedHash

  set P5[1], N1         # set f
  set N1, P5[1]         # get f
  set N1, P5[&#34;f&#34;]       # get f if initializer is an OrderedHash

  set P5[2;0], I2       # set i[0]
  set I3, P5[2;3]       # get i[3]

  set P5[&#34;i&#34;; 2]        # set i[2] if initializer is an OrderedHash

  set S0, P5[3]         # get string at *s
  set S0, P5[&#34;s&#34;]       # same</pre>

<h2><a name="Strings"
>Strings <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>When passing a STRING to a structure that needs a 0&#45;terminated C&#45;string (char *s), then you have to provide the terminating NUL char in the string.</p>

<pre lang='und' xml:lang='und'>  struct {
    ...
    char *s;
  };

  set P5[&#34;s&#34;], &#34;a string\x0&#34;</pre>

<p>Please also note, that the C function currently gets a pointer to string memory, so any code that might trigger GC should be avoided (or GC turned off). Passing constant strings like above is safe though.</p>

<pre lang='und' xml:lang='und'>  set P5[&#34;s&#34;], S0  # S0 shouldn&#39;t move until function call</pre>

<h2><a name="Callback_Functions_in_the_C_Library"
>Callback Functions in the C Library <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Given a C function that returns a structure containing a callback function like in this example:</p>

<pre lang='und' xml:lang='und'>  static struct {
      int (*f)(char *);
  } t = {
       call_back
  };
  return &#38;t;</pre>

<p>The PASM would look like:</p>

<pre lang='und' xml:lang='und'>  push P2, .DATATYPE_FUNC_PTR
  # attach function signature property to this type
  set P1, P2[&#45;1]
  new P3, .PerlString
  set P3, &#34;it&#34;
  setprop P1, &#34;_signature&#34;, P3
  push P2, 0
  push P2, 0
  # P5 is the return UnManagedStruct PMC
  assign P5, P2
  # now we get a callable NCI PMC
  set P0, P5[0]
  set S5, &#34;hello call_back&#34;
  # call the call_back function
  invoke</pre>

<h2><a name="Nested_Structures_or_Pointers_to_Nested_Structures"
>Nested Structures or Pointers to Nested Structures <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Each contained structure needs its own UnManagedStruct initializer. The UnManagedStruct of the contained structures has to be attached to the structure type PMC as the property <b>&#34;_struct&#34;</b>.</p>

<p>If a C function returns a pointer to this structure:</p>

<pre lang='und' xml:lang='und'>  static struct xt {
      char x;
      struct yt {
          char i;
          int  j;
      } _y;
      char z;
  } _x;</pre>

<p>... access to elements could look like:</p>

<pre lang='und' xml:lang='und'>  # the nested structure
  new P3, .OrderedHash
  set P3[&#34;i&#34;], .DATATYPE_CHAR
  push P3, 0
  push P3, 0
  set P3[&#34;j&#34;], .DATATYPE_INT
  push P3, 0
  push P3, 0
  new P4, .UnManagedStruct, P3

  # outer structure
  new P2, .OrderedHash
  set P2[&#34;x&#34;], .DATATYPE_CHAR
  push P2, 0
  push P2, 0
  set P2[&#34;_y&#34;], .DATATYPE_STRUCT

  # attach the unmanaged struct as property to the type PMC
  set P1, P2[&#45;1]                # last element
  setprop P1, &#34;_struct&#34;, P4
  push P2, 0
  push P2, 0
  set P2[&#34;z&#34;], .DATATYPE_CHAR
  push P2, 0
  push P2, 0

  # attach struct initializer to return value in P5
  assign P5, P2

  # now access values
  set I0, P5[0]         # x
  set I0, P5[1;0]       # _y.i
  set I0, P5[1;1]       # _y.j
  set I0, P5[2]         # z

  # or by name
  set I0, P5[&#34;x&#34;]
  set I0, P5[&#34;_y&#34;; &#34;i&#34;]
  set I0, P5[&#34;_y&#34;; &#34;j&#34;]
  set I0, P5[&#34;z&#34;]</pre>

<p>If the structure has a pointer to another structure the datatype is:</p>

<pre lang='und' xml:lang='und'>  push P2, .DATATYPE_STRUCT_PTR</pre>

<h1><a name="Passing_A_Structure_to_a_C_function"
>Passing A Structure to a C function <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>For a shared library <b>libnci_test.so</b> (or whatever) and a C function</p>

<pre lang='und' xml:lang='und'>  typedef struct _dfi_t {
    double d;
    float  f;
    int    i[4];
  } dfi_t;

  int nci_ip(dfi_t *p) {}</pre>

<p>a pointer to the structure is passed with the <b>p</b> signature char:</p>

<pre lang='und' xml:lang='und'>  loadlib P1, &#34;libnci_test&#34;
  dlfunc P0, P1, &#34;nci_ip&#34;, &#34;ip&#34;
  # P5 is ManagedStruct from above
  invoke
  # I5 is result</pre>

<h1><a name="BUGS"
>BUGS <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Not all datatypes are implemented. Alignment is barely tested on different machines. Arrays of structures aren&#39;t handled yet. Passing nested structures to C isn&#39;t finished.</p>

<h1><a name="FILES"
>FILES <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p><em lang='und' xml:lang='und'><a href="../../src/pmc/unmanagedstruct.pmc.html">src/pmc/unmanagedstruct.pmc</a></em>, <em lang='und' xml:lang='und'><a href="../../src/pmc/managedstruct.pmc.html">src/pmc/managedstruct.pmc</a></em></p>

<h1><a name="SEE_ALSO"
>SEE ALSO <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p><em lang='und' xml:lang='und'><a href="../pdds/pdd03_calling_conventions.pod.html">docs/pdds/pdd03_calling_conventions.pod</a></em> <em lang='und' xml:lang='und'><a href="../../t/pmc/nci.t.html">t/pmc/nci.t</a></em>, <em lang='und' xml:lang='und'><a href="../../src/nci_test.c.html">src/nci_test.c</a></em></p>

<h1><a name="AUTHOR"
>AUTHOR <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Leopold Toetsch &#60;lt@toetsch.at&#62;</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
