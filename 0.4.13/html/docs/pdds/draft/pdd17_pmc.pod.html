<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Parrot Magic Cookies</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Parrot Magic Cookies</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../../html/index.html">Contents</a> | <a href="../../../../html/docs.html">Documentation</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>docs/pdds/pdd17_pmc.pod &#45; Parrot Magic Cookies</p>

<h1><a name="VERSION"
>VERSION <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>$Revision$</p>

<h1><a name="ABSTRACT"
>ABSTRACT <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>This PDD describes the internal structure and behavior of the Parrot Magic Cookie (PMC) data type.</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>PMCs implement all internal data types more complex than a simple integer,
float,
or string,
and also the data types of high&#45;level languages.
Nothing outside the core of Parrot (in fact,
nothing outside the data type&#39;s vtable routines) should infer anything about a PMC (hence the Magic part).</p>

<p>This does mean,
though,
that you need to either know what functions are available and what they do,
or have some method of finding out.</p>

<p>It&#39;s faster if you know which vtable entry does what,
so that&#39;s the method parrot uses.</p>

<h1><a name="QUESTIONS"
>QUESTIONS <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<ul>
<li>Where should c&#45;level role implementations live?
In src/pmc?
What naming convention should we use for the files?
Singleton role goes to rsingleton.pmc?</li><p class="pad"></p>

<li>Should we create a pmrole keyword like pmclass?
And pmr2c to translate them to C?
How different are classes and roles at the PMC level?</li><p class="pad"></p>

<li>&#60;particle&#62; pmclass needs a keyword to specify what roles a class is composed from.
We&#39;re already using &#39;does&#39;,
but in an ad hoc way,
from what I can see in the little docs there are about &#39;does&#39;.</li><p class="pad"></p>

<li>&#60;particle&#62; Do c&#45;level roles have custom flags like PMCs?
Class PMC has a custom flag for &#39;instantiated&#39;,
right now it uses a full int,
which I think is a waste of space.
&#60;allison&#62; 8 bits is pretty limited,
and IIRC we&#39;ve already run into the limitation.
This runs back to Leo&#39;s proposal to make PMCs a little more flexible,
so we wouldn&#39;t have to hold all PMCs to the same 8 bits</li><p class="pad"></p>
</ul>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<dl>
<dt><a name="&#45;_High&#45;level_objects_can_subclass_low&#45;level_PMCs"
>&#45; High&#45;level objects can subclass low&#45;level PMCs</a></dt><p class="pad"></p>
</dl>

<h1><a name="IMPLEMENTATION"
>IMPLEMENTATION <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<h2><a name="Internal_structure"
>Internal structure <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>All PMCs have the form:</p>

<pre lang='und' xml:lang='und'>    struct PMC {
        pobj_t obj;
        VTABLE *vtable;
 #if ! PMC_DATA_IN_EXT
        DPOINTER *data;
 #endif
        struct PMC_EXT *pmc_ext;
    };</pre>

<p>where <code lang='und' xml:lang='und'>obj</code> is a pointer to a <code lang='und' xml:lang='und'>pobj_t</code> structure:</p>

<pre lang='und' xml:lang='und'>    typedef struct pobj_t {
        UnionVal u;
        Parrot_UInt flags;
    } pobj_t;</pre>

<p>and where:</p>

<pre lang='und' xml:lang='und'>    typedef union UnionVal {
        struct {
            void * _bufstart;
            size_t _buflen;
        } _b;
        struct {
            DPOINTER* _struct_val;
            PMC* _pmc_val;
        } _ptrs;
        INTVAL _int_val;
        FLOATVAL _num_val;
        struct parrot_string_t * _string_val;
    } UnionVal;</pre>

<p><code lang='und' xml:lang='und'>u</code> holds data associated with the PMC. This can be in the form of an integer value, a floating&#45;point value, a string value, or a pointer to other data. <code lang='und' xml:lang='und'>u</code> may be empty, since the PMC structure also provides a more general data pointer, but is useful for PMCs which hold only a single piece of data (e.g. <code lang='und' xml:lang='und'>PerlInts</code>).</p>

<p><code lang='und' xml:lang='und'>flags</code> holds a set of flags associated with the PMC; these are documented in <em lang='und' xml:lang='und'>include/parrot/pobj.h</em>, and are generally only used within the Parrot internals.</p>

<p><code lang='und' xml:lang='und'>vtable</code> holds a pointer to the <b>vtable</b> associated with the PMC. This points to a set of functions, with interfaces described in <a href='#Vtable_Functions'>&#34;Vtable Functions&#34;</a> that implement the basic behaviour of the PMC (i.e. how it behaves under addition, subtraction, cloning etc.)</p>

<p><code lang='und' xml:lang='und'>data</code> (if present) holds a pointer to any additional data associated with the PMC. This may be NULL.</p>

<p><code lang='und' xml:lang='und'>pmc_ext</code> points to an extended PMC structure. This has the form:</p>

<pre lang='und' xml:lang='und'>    struct PMC_EXT {
 #if PMC_DATA_IN_EXT
        DPOINTER *data;
 #endif
        PMC *_metadata;             # [Note: replaced by roles]
        struct _Sync *_synchronize; # [Note: may be deprecated, see STM]
        PMC *_next_for_GC;
    };</pre>

<p><code lang='und' xml:lang='und'>data</code> is a generic data pointer, as described above.</p>

<p><code lang='und' xml:lang='und'>_metadata</code> holds internal PMC metadata. The specification for this has not yet been finalized.</p>

<p><code lang='und' xml:lang='und'>_synchronize</code> is for access synchronization between shared PMCs.</p>

<p><code lang='und' xml:lang='und'>_next_for_GC</code> determines the next PMC in the &#39;used&#39; list during dead object detection in the GC.</p>

<p>PMCs are not required to have a <code lang='und' xml:lang='und'>PMC_EXT</code> structure (i.e. <code lang='und' xml:lang='und'>pmc_ext</code> can be null).</p>

<p>PMCs are used to implement the basic data types of the high level languages running on top of Parrot. For instance, a Perl 5 <code lang='und' xml:lang='und'>SV</code> will map onto one (or more) types of PMC, while particular Python datatypes will map onto different types of PMC.</p>

<h2><a name="Vtable_Functions"
>Vtable Functions <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Vtables decouple the interface and implementation of various object functions. The actual vtable structure contains pointers to functions that implement the methods for that particular PMC. All pointers must point to valid functions with appropriate prototypes.</p>

<p>In C code, the first parameter to any vtable routine is the current interpreter. The second parameter is the PMC itself.</p>

<p>The following list details each of the vtable methods, their prototypes, and their behavior.</p>

<h3><a name="Core_Vtable_Functions"
>Core Vtable Functions</a></h3>

<dl>
<dt><a name="void_init(INTERP,_PMC*_self)"
>void init(INTERP, PMC* self)</a></dt><p class="pad"></p>

<dd>Called when a PMC is first instantiated. It takes an unused PMC parameter and turns it into a PMC of the appropriate class.</dd><p class="pad"></p>

<dt><a name="void_init_pmc(INTERP,_PMC*_self,_PMC*_initializer)"
>void init_pmc(INTERP, PMC* self, PMC* initializer)</a></dt><p class="pad"></p>

<dd>Alternative entry point called when a PMC is first instantiated. Accepts a PMC parameter used to initialize the given object. Interpretation of the PMC initializer is left open, each PMC is free to choose its own implemention. A NULL value passed as the initializer parameter is allowed.</dd><p class="pad"></p>

<dd>NOTE: It is strongly suggested that init_pmc(PMCNULL) be equivalent to init(), though there will of necessity be exceptions.</dd><p class="pad"></p>

<dt><a name="void_morph(INTERP,_PMC*_self,_INTVAL_type)"
>void morph(INTERP, PMC* self, INTVAL type)</a></dt><p class="pad"></p>

<dd>Turn the PMC into a PMC of type <i>type</i>. If the morphing can&#39;t be done in any reasonable way &#45;&#45; for instance if an integer is asked to turn into an Array &#45;&#45; then the PMC is first destroyed, then recreated as an empty PMC of the new type.</dd><p class="pad"></p>

<dd>This method is primarily used when the interpreter has need of coercing a PMC to a particular type, and isn&#39;t meant as a general purpose casting tool. Compilers should only emit valid morphing operations.</dd><p class="pad"></p>

<dt><a name="void_mark(INTERP,_PMC*_self)"
>void mark(INTERP, PMC* self)</a></dt><p class="pad"></p>

<dd>Called when the DOD is tracing live PMCs. If this method is called then the code must mark all strings and PMCs that it contains as live, otherwise they may be collected.</dd><p class="pad"></p>

<dd>This method is only called if the DOD has detected that this PMC is both alive and has a custom mark routine as indicated by the custom mark PMC flag. (Most normal PMCs don&#39;t need a custom mark routine.)</dd><p class="pad"></p>

<dd>If a PMC has this flag set, then it is responsible for marking all buffers and PMCs under its control as alive. If it does not, those PMCs or buffers may be collected later. This method does <i>not</i> have to call the <code lang='und' xml:lang='und'>mark</code> method on any PMCs it marks&#45;&#45;the DOD system takes care of that. (So no need to recurse into aggregate PMCs or anything of the sort).</dd><p class="pad"></p>

<dd>This method may allocate no memory from Parrot, nor may it alter Parrot&#39;s internal structures. It should have no side&#45;effects from the C level either. This routine may not throw an exception.</dd><p class="pad"></p>

<dt><a name="void_destroy(INTERP,_PMC*_self)"
>void destroy(INTERP, PMC* self)</a></dt><p class="pad"></p>

<dd>Called when the PMC is destroyed. This method is called by the DOD when it determines that a PMC is dead and that the PMC has marked itself as having a destroy method (an active finalizer).</dd><p class="pad"></p>

<dd>When this method finishes, the PMC will be marked as dead. As such you should make sure that you don&#39;t leave any references to it in any Parrot structure by the end of the method.</dd><p class="pad"></p>

<dd>This method may not throw an exception. It will be ignored if it does.</dd><p class="pad"></p>

<dt><a name="PMC*_clone(INTERP,_PMC*_self)"
>PMC* clone(INTERP, PMC* self)</a></dt><p class="pad"></p>

<dd>Return a clone of a PMC.</dd><p class="pad"></p>

<dt><a name="defined"
>defined</a></dt><p class="pad"></p>
</dl>

<h3><a name="Accessors"
>Accessors</a></h3>

<dl>
<dt><a name="PMC*_getprop(INTERP,_PMC*_self,_STRING*_key)"
>PMC* getprop(INTERP, PMC* self, STRING* key)</a></dt><p class="pad"></p>

<dd>Return the value from the property hash of <i>self</i> keyed by <i>key</i>. The key should not be NULL.</dd><p class="pad"></p>

<dt><a name="void_setprop(INTERP,_PMC*_self,_STRING*_key,_PMC*_value)"
>void setprop(INTERP, PMC* self, STRING* key, PMC* value)</a></dt><p class="pad"></p>

<dd>Set the value in the property hash of <i>self</i> that is keyed by <i>key</i> to the value of <i>value</i>. The key should not be NULL.</dd><p class="pad"></p>

<dt><a name="void_delprop(INTERP,_PMC*_self,_STRING*_key)"
>void delprop(INTERP, PMC* self, STRING* key)</a></dt><p class="pad"></p>

<dd>Delete the value from the property hash of <i>self</i> keyed by <i>key</i>. The key should not be NULL.</dd><p class="pad"></p>

<dt><a name="PMC*_getprops(INTERP,_PMC*_self)"
>PMC* getprops(INTERP, PMC* self)</a></dt><p class="pad"></p>

<dd>Return the entire property hash for <i>self</i>.</dd><p class="pad"></p>

<dt><a name="INTVAL_type(INTERP,_PMC*_self)"
>INTVAL type(INTERP, PMC* self)</a></dt><p class="pad"></p>

<dd>Return the type of the PMC. Type is a unique number associated with the PMC when the PMC&#39;s class is loaded. Negative numbers are considered interpreter&#45;specific, non&#45;public types.</dd><p class="pad"></p>

<dt><a name="UINTVAL_subtype(INTERP,_PMC*_self,_INTVAL_type)_[deprecated]"
>UINTVAL subtype(INTERP, PMC* self, INTVAL type) [deprecated]</a></dt><p class="pad"></p>

<dd>Return the subtype of a PMC. (Note that this may be unimplemented, and may go away). This is intended to return information about the PMC&#45;&#45;what type of number or string it is, whether it&#39;s a scalar, hash, array, or list, and suchlike things.</dd><p class="pad"></p>

<dd>[This can be adequately handled by <code lang='und' xml:lang='und'>does</code> and <code lang='und' xml:lang='und'>inspect</code>.]</dd><p class="pad"></p>

<dt><a name="STRING*_name(INTERP,_PMC*_self)"
>STRING* name(INTERP, PMC* self)</a></dt><p class="pad"></p>

<dd>Return the name of the class for the PMC.</dd><p class="pad"></p>

<dt><a name="get_integer"
>get_integer</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  INTVAL get_integer(INTERP, PMC* self)</pre>

<dd>Return the native integer value of the PMC.</dd><p class="pad"></p>

<dt><a name="get_number"
>get_number</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  FLOATVAL get_number(INTERP, PMC* self)</pre>

<dd>Return the native floating&#45;point value of the PMC.</dd><p class="pad"></p>

<dt><a name="get_bignum"
>get_bignum</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  PMC* get_bignum(INTERP, PMC* self)</pre>

<dd>Return the extended precision numeric value of the PMC as a new bignum PMC.</dd><p class="pad"></p>

<dt><a name="get_string"
>get_string</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  STRING* get_string(INTERP, PMC* self)</pre>

<dd>Return the native string value of the PMC. This may be in any encoding, chosen by the PMC.</dd><p class="pad"></p>

<dt><a name="get_bool"
>get_bool</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  INTVAL get_bool(INTERP, PMC* self)</pre>

<dd>Return the true/false value of the PMC (the constant TRUE or the constant FALSE). The definition of truth for a given PMC will depend on the type of the PMC. For a scalar, it may be as simple as returning false when the PMC has a value 0 or &#34;&#34;, and returning true when the PMC has any other value.</dd><p class="pad"></p>

<dt><a name="get_pmc"
>get_pmc</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  PMC* get_pmc(INTERP, PMC* self)</pre>

<dd>Return the PMC value for this PMC. This is useful in circumstances where the thing being accessed may return something other than its own value. For example, an array might return a reference to itself. Any PMC may return a value different from the PMC that <code lang='und' xml:lang='und'>get_pmc</code> is being called on.</dd><p class="pad"></p>

<dt><a name="set_integer_native"
>set_integer_native</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  void set_integer_native(INTERP, PMC* self, INTVAL value)</pre>

<dd>Set the integer value of this PMC from a native integer value (integer register/constant).</dd><p class="pad"></p>

<dt><a name="set_integer_same"
>set_integer_same</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  void set_integer_same(INTERP, PMC* self, PMC* value)</pre>

<dd>Set the value of this PMC from the integer value of another PMC. The value PMC is guaranteed to be of the same type as the <i>self</i> PMC, so optimizations may be made.</dd><p class="pad"></p>

<dt><a name="set_number_native"
>set_number_native</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  void set_number_native(INTERP, PMC* self, FLOATVAL value)</pre>

<dd>Set the value of this PMC from a native floating&#45;point value (float register/constant).</dd><p class="pad"></p>

<dt><a name="set_number_same"
>set_number_same</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  void set_number_same(INTERP, PMC* self, PMC* value)</pre>

<dd>Set the value of this PMC from the floating&#45;point value another PMC. The value PMC is guaranteed to be of the same type as the <i>self</i> PMC, so optimizations may be made.</dd><p class="pad"></p>

<dt><a name="get_pointer"
>get_pointer</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  void* get_pointer(INTERP, PMC* self)</pre>

<dd>Returns a pointer value for the PMC. Useful for PMCs that hold pointers to arbitrary data. The details of the data (type, location etc.) depend on the PMC.</dd><p class="pad"></p>

<dt><a name="set_bignum_int"
>set_bignum_int</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  void set_bignum_int(INTERP, PMC* self, INTVAL value)</pre>

<dd>Morph the PMC to a BIGNUM PMC, and set the extended&#45;precision value from a native integer.</dd><p class="pad"></p>

<dt><a name="set_string_native"
>set_string_native</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  void set_string_native(INTERP, PMC* self, STRING* value)</pre>

<dd>Set the value of this PMC from a native string value (string register/constant).</dd><p class="pad"></p>

<dt><a name="assign_string_native"
>assign_string_native</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  void assign_string_native(INTERP, PMC* self, STRING* value)</pre>

<dd>Set the value of this PMC to a copied native string value (string register/constant).</dd><p class="pad"></p>

<dt><a name="set_string_same"
>set_string_same</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  void set_string_same(INTERP, PMC* self, PMC* value)</pre>

<dd>Set the value of this PMC from the string value of another PMC. The value PMC is guaranteed to be of the same type as the <i>self</i> PMC, so optimizations may be made.</dd><p class="pad"></p>

<dt><a name="set_bool"
>set_bool</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  void set_bool(INTERP, PMC* self, INTVAL value)</pre>

<dd>Set the boolean state of the PMC to TRUE if the native integer value passed in is TRUE, or FALSE if the value is FALSE. The definition of truth is left open to the particular PMC. For a scalar, it may be as simple as setting false when a 0 value is passed in, and seting true when any other value is passed in.</dd><p class="pad"></p>

<dt><a name="assign_pmc"
>assign_pmc</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  void assign_pmc(INTERP, PMC* self, PMC* value)</pre>

<dd>Set the value of the PMC in <i>self</i> to the value of the PMC in <i>value</i> by copying the value.</dd><p class="pad"></p>

<dt><a name="set_pmc"
>set_pmc</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  void set_pmc(INTERP, PMC* self, PMC* value)</pre>

<dd>Make the PMC in <i>self</i> refer to the PMC passed as <i>value</i>.</dd><p class="pad"></p>

<dt><a name="set_pointer"
>set_pointer</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  void set_pointer(INTERP, PMC* self, void* value)</pre>

<dd>Set the pointer value of the PMC Useful for PMCs that hold pointers to arbitrary data. The details of the data (type, location etc.) depend on the PMC.</dd><p class="pad"></p>
</dl>

<h3><a name="Aggregate_Vtable_Functions"
>Aggregate Vtable Functions</a></h3>

<p>Many of the following functions have a *_keyed form, a *_keyed_int form, and a *_keyed_str form. The keyed forms take a PMC*, INTVAL, or STRING* key as a parameter. The PMC* parameter is NULL if there is no key for that PMC; this means that that argument is unkeyed.</p>

<p>In some cases, the caller must provide a non&#45;NULL key. Those cases are explicitly stated below. In the other cases, you may have to implement the keyed vtable functions and check for a NULL <i>self</i> key even if you are implementing a non&#45;aggregate type. If the <i>self</i> key is non&#45;NULL and the PMC class is a non&#45;aggregate type, the _keyed_* methods should throw an exception.</p>

<p>If you do not implement the *_keyed_int and *_keyed_str functions, the default will convert the INTVAL or STRING* into a key PMC* and call the corresponding *_keyed functions.</p>

<dl>
<dt><a name="elements"
>elements</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  INTVAL elements(INTERP, PMC* self)</pre>

<dd>Return the number of elements in the PMC.</dd><p class="pad"></p>

<dt><a name="get_integer_keyed"
>get_integer_keyed</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  INTVAL get_integer_keyed(INTERP, PMC* self, PMC* key)</pre>

<dd>Return the integer value for the element indexed by a PMC key. The key is guaranteed not to be NULL for this function.</dd><p class="pad"></p>

<dt><a name="get_integer_keyed_int"
>get_integer_keyed_int</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  INTVAL get_integer_keyed_int(INTERP, PMC* self, INTVAL key)</pre>

<dd>Return the integer value for the element indexed by an integer key. The key is guaranteed not to be NULL for this function.</dd><p class="pad"></p>

<dt><a name="get_integer_keyed_str"
>get_integer_keyed_str</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  INTVAL get_integer_keyed_str(INTERP, PMC* self, STRING* key)</pre>

<dd>Return the integer value for the element indexed by a string key. The key is guaranteed not to be NULL for this function.</dd><p class="pad"></p>

<dt><a name="get_number_keyed"
>get_number_keyed</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  FLOATVAL get_number_keyed(INTERP, PMC* self, PMC* key)</pre>

<dd>Return the native floating&#45;point value for the element indexed by a PMC key. The key is guaranteed not to be NULL for this function.</dd><p class="pad"></p>

<dt><a name="get_number_keyed_int"
>get_number_keyed_int</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  FLOATVAL get_number_keyed_int(INTERP, PMC* self, INTVAL key)</pre>

<dd>Return the native floating&#45;point value for the element indexed by an integer key. The key is guaranteed not to be NULL for this function.</dd><p class="pad"></p>

<dt><a name="get_number_keyed_str"
>get_number_keyed_str</a></dt><p class="pad"></p>

<dd>Return the native floating&#45;point value for the element indexed by a string key. The key is guaranteed not to be NULL for this function.</dd><p class="pad"></p>

<dt><a name="get_string_keyed"
>get_string_keyed</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  STRING* get_string_keyed(INTERP, PMC* self, PMC* key)</pre>

<dd>Return the string value for the element indexed by a PMC key. The key is guaranteed not to be NULL for this function.</dd><p class="pad"></p>

<dt><a name="get_string_keyed_int"
>get_string_keyed_int</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  STRING* get_string_keyed_int(INTERP, PMC* self, INTVAL key)</pre>

<dd>Return the string value for the element indexed by an integer key. The key is guaranteed not to be NULL for this function.</dd><p class="pad"></p>

<dt><a name="get_string_keyed_str"
>get_string_keyed_str</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  STRING* get_string_keyed_str(INTERP, PMC* self, STRING* key)</pre>

<dd>Return the string value for the element indexed by a string key. The key is guaranteed not to be NULL for this function.</dd><p class="pad"></p>

<dt><a name="get_bool_keyed"
>get_bool_keyed</a></dt><p class="pad"></p>

<dd>Return the boolean value for the element indexed by a PMC key.</dd><p class="pad"></p>

<dt><a name="get_bool_keyed_int"
>get_bool_keyed_int</a></dt><p class="pad"></p>

<dd>Return the boolean value for the element indexed by an integer key.</dd><p class="pad"></p>

<dt><a name="get_bool_keyed_str"
>get_bool_keyed_str</a></dt><p class="pad"></p>

<dd>Return the boolean value for the element indexed by a string key.</dd><p class="pad"></p>

<dt><a name="get_pmc_keyed"
>get_pmc_keyed</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  PMC* get_pmc_keyed(INTERP, PMC* self, PMC* key)</pre>

<dd>Return the PMC value for the element indexed by a PMC key. The key is guaranteed not to be NULL for this function.</dd><p class="pad"></p>

<dt><a name="get_pmc_keyed_int"
>get_pmc_keyed_int</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  PMC* get_pmc_keyed_int(INTERP, PMC* self, INTVAL key)</pre>

<dd>Return the PMC value for the element indexed by an integer key. The key is guaranteed not to be NULL for this function.</dd><p class="pad"></p>

<dt><a name="get_pmc_keyed_str"
>get_pmc_keyed_str</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  PMC* get_pmc_keyed_str(INTERP, PMC* self, STRING* key)</pre>

<dd>Return the PMC value for the element indexed by a string key. The key is guaranteed not to be NULL for this function.</dd><p class="pad"></p>

<dt><a name="get_pointer_keyed"
>get_pointer_keyed</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  void* get_pointer_keyed(INTERP, PMC* self, PMC* key)</pre>

<dd>Return the pointer value for the element indexed by a PMC key. The details of the data (type, location etc.) depend on the PMC.</dd><p class="pad"></p>

<dt><a name="get_pointer_keyed_int"
>get_pointer_keyed_int</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  void* get_pointer_keyed_int(INTERP, PMC* self, INTVAL key)</pre>

<dd>Return the pointer value for the element indexed by an integer key. The details of the data (type, location etc.) depend on the PMC.</dd><p class="pad"></p>

<dt><a name="get_pointer_keyed_str"
>get_pointer_keyed_str</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  void* get_pointer_keyed_str(INTERP, PMC* self, STRING* key)</pre>

<dd>Return the pointer value for the element indexed by a string key. The details of the data (type, location etc.) depend on the PMC.</dd><p class="pad"></p>

<dt><a name="set_integer_keyed"
>set_integer_keyed</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  void set_integer_keyed(INTERP, PMC* self, PMC* key, INTVAL value)</pre>

<dd>Set the integer value of the element indexed by a PMC key. The key is guaranteed not to be NULL for this function.</dd><p class="pad"></p>

<dt><a name="set_integer_keyed_int"
>set_integer_keyed_int</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  void set_integer_keyed_int(INTERP, PMC* self, INTVAL key, INTVAL value)</pre>

<dd>Set the integer value of the element indexed by an integer key. The key is guaranteed not to be NULL for this function.</dd><p class="pad"></p>

<dt><a name="set_integer_keyed_str"
>set_integer_keyed_str</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  void set_integer_keyed_str(INTERP, PMC* self, STRING* key, INTVAL value)</pre>

<dd>Set the integer value of the element indexed by a string key. The key is guaranteed not to be NULL for this function.</dd><p class="pad"></p>

<dt><a name="set_number_keyed"
>set_number_keyed</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  void set_number_keyed(INTERP, PMC* self, PMC* key, FLOATVAL value)</pre>

<dd>Set the floating&#45;point value of the element indexed by a PMC key. The key is guaranteed not to be NULL for this function.</dd><p class="pad"></p>

<dt><a name="set_number_keyed_int"
>set_number_keyed_int</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  void set_number_keyed_int(INTERP, PMC* self, INTVAL key, FLOATVAL value)</pre>

<dd>Set the floating&#45;point value of the element indexed by an integer key. The key is guaranteed not to be NULL for this function.</dd><p class="pad"></p>

<dt><a name="set_number_keyed_str"
>set_number_keyed_str</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  void set_number_keyed_str(INTERP, PMC* self, STRING* key, FLOATVAL value)</pre>

<dd>Set the floating&#45;point value of the element indexed by a string key. The key is guaranteed not to be NULL for this function.</dd><p class="pad"></p>

<dt><a name="set_string_keyed"
>set_string_keyed</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  void set_string_keyed(INTERP, PMC* self, PMC* key, STRING* value)</pre>

<dd>Set the string value of the element indexed by a PMC key. The key is guaranteed not to be NULL for this function.</dd><p class="pad"></p>

<dt><a name="set_string_keyed_int"
>set_string_keyed_int</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  void set_string_keyed_int(INTERP, PMC* self, INTVAL key, STRING* value)</pre>

<dd>Set the string value of the element indexed by an integer key. The key is guaranteed not to be NULL for this function.</dd><p class="pad"></p>

<dt><a name="set_string_keyed_str"
>set_string_keyed_str</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  void set_string_keyed_str(INTERP, PMC* self, STRING* key, STRING* value)</pre>

<dd>Set the string value of the element indexed by a string key. The key is guaranteed not to be NULL for this function.</dd><p class="pad"></p>

<dt><a name="set_pmc_keyed"
>set_pmc_keyed</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  void set_pmc_keyed(INTERP, PMC* self, PMC* key, PMC* value)</pre>

<dd>Set the value of the element indexed by a PMC key, by copying the value of another PMC.</dd><p class="pad"></p>

<dt><a name="set_pmc_keyed_int"
>set_pmc_keyed_int</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  void set_pmc_keyed_int(INTERP, PMC* self, INTVAL key, PMC* value)</pre>

<dd>Set the PMC value of the element indexed by an integer key, by copying the value of another PMC.</dd><p class="pad"></p>

<dt><a name="set_pmc_keyed_str"
>set_pmc_keyed_str</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  void set_pmc_keyed_str(INTERP, PMC* self, STRING* key, PMC* value)</pre>

<dd>Set the PMC value of the element indexed by a string key, by copying the value of another PMC.</dd><p class="pad"></p>

<dt><a name="set_pointer_keyed"
>set_pointer_keyed</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  void set_pointer_keyed(INTERP, PMC* self, PMC* key, void* value)</pre>

<dd>Set the pointer value of the element indexed by a PMC key.</dd><p class="pad"></p>

<dt><a name="set_pointer_keyed_int"
>set_pointer_keyed_int</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  void set_pointer_keyed_int(INTERP, PMC* self, INTVAL key, void* value)</pre>

<dd>Set the pointer value of the element indexed by an integer key.</dd><p class="pad"></p>

<dt><a name="set_pointer_keyed_str"
>set_pointer_keyed_str</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  void set_pointer_keyed_str(INTERP, PMC* self, STRING* key, void* value)</pre>

<dd>Set the pointer value of the element indexed by a string key.</dd><p class="pad"></p>

<dt><a name="INTVAL_type_keyed(INTERP,_PMC*_self,_PMC*_key)"
>INTVAL type_keyed(INTERP, PMC* self, PMC* key)</a></dt><p class="pad"></p>

<dd>Return the type number of the PMC indexed by a PMC key. The <i>key</i> parameter is guaranteed not to be NULL for this method.</dd><p class="pad"></p>

<dt><a name="INTVAL_type_keyed_int(INTERP,_PMC*_self,_INTVAL_key)"
>INTVAL type_keyed_int(INTERP, PMC* self, INTVAL key)</a></dt><p class="pad"></p>

<dd>Return the type number of the PMC indexed by an integer key. The <i>key</i> parameter is guaranteed not to be NULL for this method.</dd><p class="pad"></p>

<dt><a name="INTVAL_type_keyed_str(INTERP,_PMC*_self,_STRING*_key)"
>INTVAL type_keyed_str(INTERP, PMC* self, STRING* key)</a></dt><p class="pad"></p>

<dd>Return the type number of the PMC indexed by a string key. The <i>key</i> parameter is guaranteed not to be NULL for this method.</dd><p class="pad"></p>

<dt><a name="pop_integer"
>pop_integer</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  INTVAL pop_integer(INTERP, PMC* self)</pre>

<dd>Return the integer value of the last item on the list, removing that item.</dd><p class="pad"></p>

<dt><a name="pop_float"
>pop_float</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  FLOATVAL pop_float(INTERP, PMC* self)</pre>

<dd>Return the floating&#45;point value of the last item on the list, removing that item.</dd><p class="pad"></p>

<dt><a name="pop_string"
>pop_string</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  STRING* pop_string(INTERP, PMC* self)</pre>

<dd>Return the string value of the last item on the list, removing that item.</dd><p class="pad"></p>

<dt><a name="pop_pmc"
>pop_pmc</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  PMC* pop_pmc(INTERP, PMC* self)</pre>

<dd>Return the PMC value of the last item on the list, removing that item.</dd><p class="pad"></p>

<dt><a name="push_integer"
>push_integer</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  void push_integer(INTERP, PMC* self, INTVAL value)</pre>

<dd>Add the passed in integer value to the end of the list.</dd><p class="pad"></p>

<dt><a name="push_float"
>push_float</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  void push_float(INTERP, PMC* self, FLOATVAL value)</pre>

<dd>Add the passed in floating&#45;point number to the end of the list.</dd><p class="pad"></p>

<dt><a name="push_string"
>push_string</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  void push_string(INTERP, PMC* self, STRING* value)</pre>

<dd>Add the passed in string to the end of the list.</dd><p class="pad"></p>

<dt><a name="push_pmc"
>push_pmc</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  void push_pmc(INTERP, PMC* self, PMC* value)</pre>

<dd>Add the passed in PMC to the end of the list.</dd><p class="pad"></p>

<dt><a name="shift_integer"
>shift_integer</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  INTVAL shift_integer(INTERP, PMC* self)</pre>

<dd>Return the integer value of the first item on the list, removing that item.</dd><p class="pad"></p>

<dt><a name="shift_float"
>shift_float</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  FLOATVAL shift_float(INTERP, PMC* self)</pre>

<dd>Return the floating&#45;point value of the first item on the list, removing that item.</dd><p class="pad"></p>

<dt><a name="shift_string"
>shift_string</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  STRING* shift_string(INTERP, PMC* self)</pre>

<dd>Return the string value of the first item on the list, removing that item.</dd><p class="pad"></p>

<dt><a name="shift_pmc"
>shift_pmc</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  PMC* shift_pmc(INTERP, PMC* self)</pre>

<dd>Return the PMC value of the first item on the list, removing that item.</dd><p class="pad"></p>

<dt><a name="unshift_integer"
>unshift_integer</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  void unshift_integer(INTERP, PMC* self, INTVAL value)</pre>

<dd>Add the passed in integer value to the beginning of the list.</dd><p class="pad"></p>

<dt><a name="unshift_float"
>unshift_float</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  void unshift_float(INTERP, PMC* self, FLOATVAL value)</pre>

<dd>Add the passed in floating&#45;point number to the beginning of the list.</dd><p class="pad"></p>

<dt><a name="unshift_string"
>unshift_string</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  void unshift_string(INTERP, PMC* self, STRING* value)</pre>

<dd>Add the passed in string to the beginning of the list.</dd><p class="pad"></p>

<dt><a name="unshift_pmc"
>unshift_pmc</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  void unshift_pmc(INTERP, PMC* self, PMC* value)</pre>

<dd>Add the passed in PMC to the beginning of the list.</dd><p class="pad"></p>

<dt><a name="splice"
>splice</a></dt><p class="pad"></p>

<dt><a name="void_splice(INTERP,_PMC*_self,_PMC*_value,_INTVAL_offset,_INTVAL_count)"
>void splice(INTERP, PMC* self, PMC* value, INTVAL offset, INTVAL count)</a></dt><p class="pad"></p>

<dd>Replace the <i>count</i> PMCs at offset <i>offset</i> from the beginning of <i>self</i> with the PMCs in the aggregate <i>value</i>.</dd><p class="pad"></p>

<dt><a name="exists_keyed"
>exists_keyed</a></dt><p class="pad"></p>

<dt><a name="exists_keyed_int"
>exists_keyed_int</a></dt><p class="pad"></p>

<dt><a name="exists_keyed_str"
>exists_keyed_str</a></dt><p class="pad"></p>

<dt><a name="defined_keyed"
>defined_keyed</a></dt><p class="pad"></p>

<dt><a name="defined_keyed_int"
>defined_keyed_int</a></dt><p class="pad"></p>

<dt><a name="defined_keyed_str"
>defined_keyed_str</a></dt><p class="pad"></p>

<dt><a name="dtem_delete_keyed_str"
>dtem delete_keyed_str</a></dt><p class="pad"></p>

<dt><a name="nextkey_keyed"
>nextkey_keyed</a></dt><p class="pad"></p>

<dt><a name="nextkey_keyed_itr_str"
>nextkey_keyed_itr_str</a></dt><p class="pad"></p>
</dl>

<h3><a name="Math_Vtable_Functions"
>Math Vtable Functions</a></h3>

<dl>
<dt><a name="add"
>add</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  void add(INTERP, PMC* self, PMC* value, PMC* dest)
  void add_int(INTERP, PMC* self, INTVAL value, PMC* dest)
  void add_float(INTERP, PMC* self, FLOATVAL value, PMC* dest)</pre>

<dd>Add the value of <i>self</i> to the value of a PMC, native integer, or native floating&#45;point number and store the result in a PMC <i>dest</i>. Note that <i>dest</i> may be the same PMC as <i>self</i>; in that case optimizations may be made.</dd><p class="pad"></p>

<dt><a name="subtract"
>subtract</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  PMC* subtract(INTERP, PMC* self, PMC* value, PMC* dest)
  PMC* subtract_int(INTERP, PMC* self, INTVAL value, PMC* dest)
  PMC* subtract_float(INTERP, PMC* self, FLOATVAL value, PMC* dest)</pre>

<dd>Subtract the value of a PMC, native integer, or native floating&#45;point number from a PMC and store the result in <i>dest</i>. If <i>dest</i> is NULL create a result PMC of an appropriate type. Note that <i>dest</i> may be the same PMC as <i>self</i>; in that case optimizations may be made.</dd><p class="pad"></p>

<dt><a name="i_subtract"
>i_subtract</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  void i_subtract(INTERP, PMC* self, PMC* value)
  void i_subtract_int(INTERP, PMC* self, INTVAL value)
  void i_subtract_float(INTERP, PMC* self, FLOATVAL value)</pre>

<dd>Inplace operation: subtract a PMC, native integer, or native floating&#45;point number from the value of a PMC and store the result back in the same PMC.</dd><p class="pad"></p>

<dt><a name="increment"
>increment</a></dt><p class="pad"></p>

<dt><a name="decrement"
>decrement</a></dt><p class="pad"></p>

<dt><a name="multiply"
>multiply</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  void multiply(INTERP, PMC* self, PMC* value, PMC* dest)
  void multiply_int(INTERP, PMC* self, INTVAL value, PMC* dest)
  void multiply_float(INTERP, PMC* self, FLOATVAL value, PMC* dest)</pre>

<dd>Multiply a PMC, native integer, or floating&#45;point value by the value of the PMC <i>self</i> and store the result in the <i>dest</i> PMC. Note that <i>dest</i> may be the same PMC as <i>self</i>; in that case optimizations may be made.</dd><p class="pad"></p>

<dt><a name="divide"
>divide</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  void divide(INTERP, PMC* self, PMC* value, PMC* dest)
  void divide_int(INTERP, PMC* self, INTVAL value, PMC* dest)
  void divide_float(INTERP, PMC* self, FLOATVAL value, PMC* dest)</pre>

<dd>Divide the value of the <i>self</i> PMC by a PMC, native integer, or native floating&#45;point number and store the result in <i>dest</i>. Note that <i>dest</i> may be the same PMC as <i>self</i>; in that case optimizations may be made.</dd><p class="pad"></p>

<dt><a name="modulus"
>modulus</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  void modulus(INTERP, PMC* self, PMC* value, PMC* dest)
  void modulus_int(INTERP, PMC* self, INTVAL value, PMC* dest)
  void modulus_float(INTERP, PMC* self, FLOATVAL value, PMC* dest)</pre>

<dd>Divide the value of the <i>self</i> PMC by the value of a PMC, native integer, or native floating&#45;point number and store the remainder in <i>dest</i>. Note that <i>dest</i> may be the same PMC as <i>self</i>; in that case optimizations may be made.</dd><p class="pad"></p>

<dt><a name="cmodulus"
>cmodulus</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  void cmodulus(INTERP, PMC* self, PMC* value, PMC* dest)
  void cmodulus_int(INTERP, PMC* self, INTVAL value, PMC* dest)
  void cmodulus_float(INTERP, PMC* self, FLOATVAL value, PMC* dest)</pre>

<dd>Divide the value of the <i>self</i> PMC by the value of a PMC, native integer, or native floating&#45;point number and store the remainder in <i>dest</i>. Note that <i>dest</i> may be the same PMC as <i>self</i>; in that case optimizations may be made.</dd><p class="pad"></p>

<dd>Note that <code lang='und' xml:lang='und'>modulus</code> uses Knuth&#39;s &#34;corrected mod&#34; algorithm, as implemented in <em lang='und' xml:lang='und'><a href="../../../src/utils.c.html">src/utils.c</a></em>, while <code lang='und' xml:lang='und'>cmodulus</code> uses the C&#45;style fmod function.</dd><p class="pad"></p>

<dt><a name="neg"
>neg</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  void neg(INTERP, PMC* self, PMC* dest)</pre>

<dd>Negate the sign of <i>self</i> and store the result in <i>dest</i>. Note that <i>self</i> and <i>dest</i> may refer to the same PMC, in which case optimizations may be made.</dd><p class="pad"></p>
</dl>

<h3><a name="Logical_Vtable_Functions"
>Logical Vtable Functions</a></h3>

<dl>
<dt><a name="bitwise_or"
>bitwise_or</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  void bitwise_or(INTERP, PMC* self, PMC* value, PMC* dest)
  void bitwise_or_int(INTERP, PMC* self, INTVAL value, PMC* dest)</pre>

<dd>Calculate the bitwise&#45;OR of the value of the <i>self</i> PMC and the value of a PMC or native integer and store the result in <i>dest</i>. Note that <i>dest</i> may be the same PMC as <i>self</i>; in that case optimizations may be made. [Question: what happens when the <i>self</i> and <i>value</i> PMCs aren&#39;t integers?]</dd><p class="pad"></p>

<dt><a name="bitwise_and"
>bitwise_and</a></dt><p class="pad"></p>

<dt><a name="bitwise_and_int"
>bitwise_and_int</a></dt><p class="pad"></p>

<dt><a name="bitwise_xor"
>bitwise_xor</a></dt><p class="pad"></p>

<dt><a name="bitwise_xor_int"
>bitwise_xor_int</a></dt><p class="pad"></p>

<dt><a name="bitwise_ors"
>bitwise_ors</a></dt><p class="pad"></p>

<dt><a name="bitwise_ors_str"
>bitwise_ors_str</a></dt><p class="pad"></p>

<dt><a name="bitwise_ands"
>bitwise_ands</a></dt><p class="pad"></p>

<dt><a name="bitwise_ands_str"
>bitwise_ands_str</a></dt><p class="pad"></p>

<dt><a name="bitwise_xors"
>bitwise_xors</a></dt><p class="pad"></p>

<dt><a name="bitwise_xors_str"
>bitwise_xors_str</a></dt><p class="pad"></p>

<dt><a name="bitwise_not"
>bitwise_not</a></dt><p class="pad"></p>

<dt><a name="bitwise_shl"
>bitwise_shl</a></dt><p class="pad"></p>

<dt><a name="bitwise_shl_int"
>bitwise_shl_int</a></dt><p class="pad"></p>

<dt><a name="bitwise_shr"
>bitwise_shr</a></dt><p class="pad"></p>

<dt><a name="bitwise_shr_int"
>bitwise_shr_int</a></dt><p class="pad"></p>

<dt><a name="is_equal"
>is_equal</a></dt><p class="pad"></p>

<dt><a name="is_same"
>is_same</a></dt><p class="pad"></p>

<dt><a name="cmp"
>cmp</a></dt><p class="pad"></p>

<dt><a name="cmp_num"
>cmp_num</a></dt><p class="pad"></p>

<dt><a name="cmp_string"
>cmp_string</a></dt><p class="pad"></p>

<dt><a name="logical_or"
>logical_or</a></dt><p class="pad"></p>

<dt><a name="logical_and"
>logical_and</a></dt><p class="pad"></p>

<dt><a name="logical_xor"
>logical_xor</a></dt><p class="pad"></p>

<dt><a name="logical_not"
>logical_not</a></dt><p class="pad"></p>
</dl>

<h3><a name="String_Vtable_Functions"
>String Vtable Functions</a></h3>

<dl>
<dt><a name="concatenate"
>concatenate</a></dt><p class="pad"></p>

<dt><a name="concatenate_native"
>concatenate_native</a></dt><p class="pad"></p>

<dt><a name="repeat"
>repeat</a></dt><p class="pad"></p>

<dt><a name="repeat_int"
>repeat_int</a></dt><p class="pad"></p>
</dl>

<h3><a name="Code_Vtable_Functions"
>Code Vtable Functions</a></h3>

<dl>
<dt><a name="invoke"
>invoke</a></dt><p class="pad"></p>

<dt><a name="fsh"
>fsh</a></dt><p class="pad"></p>

<dt><a name="visit"
>visit</a></dt><p class="pad"></p>

<dt><a name="share"
>share</a></dt><p class="pad"></p>
</dl>

<h3><a name="Class/Object_Vtable_Functions"
>Class/Object Vtable Functions</a></h3>

<dl>
<dt><a name="can"
>can</a></dt><p class="pad"></p>

<dt><a name="does"
>does</a></dt><p class="pad"></p>

<dt><a name="isa"
>isa</a></dt><p class="pad"></p>

<dt><a name="add_method"
>add_method</a></dt><p class="pad"></p>

<dt><a name="add_attribute"
>add_attribute</a></dt><p class="pad"></p>

<dt><a name="get_attr"
>get_attr</a></dt><p class="pad"></p>

<dt><a name="set_attr"
>set_attr</a></dt><p class="pad"></p>

<dt><a name="add_parent"
>add_parent</a></dt><p class="pad"></p>

<dt><a name="add_role"
>add_role</a></dt><p class="pad"></p>

<dt><a name="PMC*_find_method(INTERP,_PMC*_self,_STRING*_method_name)"
>PMC* find_method(INTERP, PMC* self, STRING* method_name)</a></dt><p class="pad"></p>

<dd>Return a subroutine PMC for the passed method name. This subroutine PMC may be cached, so the method <i>must</i> return an equivalent sub PMC each time, or be capable of dealing with the returned sub PMCs being reused. [Why should it be cached? Can you turn off caching? What if you want to override find_method to generate methods on the fly?]</dd><p class="pad"></p>
</dl>

<h2><a name="Interaction_between_PMCs_and_high&#45;level_objects"
>Interaction between PMCs and high&#45;level objects <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>{{ Address the problem of high&#45;level objects inheriting from low&#45;level PMCs, and any structural changes to low&#45;level PMCs that might require. }}</p>

<p>If a low&#45;level PMC expects to be overridden by high&#45;level classes (which means all the core low&#45;level PMC types), it must respect a standard interface. It must implement the <code lang='und' xml:lang='und'>get_attr</code> and <code lang='und' xml:lang='und'>set_attr</code> vtable entries for any core attributes it expects to be accessible to subclasses.</p>

<p>Subclassing a low&#45;level class from a high&#45;level class makes an entry in the high&#45;level class&#39;s list of parents. This entry is a proxy class object for the low&#45;level PMC class that provides access to the low&#45;level PMC&#39;s vtable (including the implementations of get_attr and set_attr), and defines the storage that the low&#45;level object will need within the high&#45;level object (this could be as simple as a single PMC attribute that is an instance of the low&#45;level class).</p>

<h2><a name="Core_PMCs"
>Core PMCs <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Parrot has a number of core PMC types that all programs can guarantee will be available to them. (With the possible exception of Parrot programs executing on an embedded device or other restricted environment)</p>

<h3><a name="Scalar_types"
>Scalar types</a></h3>

<dl>
<dt><a name="Undef"
>Undef</a></dt><p class="pad"></p>

<dd>This is the generic no&#45;value type. It has a numeric value of zero, a string value of empty string, and a boolean value of false. It will, on assignment, turn itself into a PMC of the source type, or if assigned a basic type will turn itself into one of the wrapper PMC types (detailed below) for the basic types.</dd><p class="pad"></p>

<dt><a name="Integer"
>Integer</a></dt><p class="pad"></p>

<dd>The PMC wrapper for Parrot&#39;s low&#45;level integer type. Always an integer, with other types auto&#45;converted to an integer when stored into this PMC. The range and behaviour of the Integer PMC is identical to the platform low&#45;level integer.</dd><p class="pad"></p>

<dd>The boolean value for an Integer is false if zero, otherwise true.</dd><p class="pad"></p>

<dd>Floating point, string, and bignum values assigned to an Integer PMC round to the nearest integer. Floats, or strings which resolve to numbers, cap at the platform maximum or minimum integer value.</dd><p class="pad"></p>

<dd>Integer PMCs take on a value of 1 if a boolean true is assigned, and a value of 0 if a boolean false is assigned.</dd><p class="pad"></p>

<dd>If an out&#45;of&#45;range value is assigned to an Integer PMC, the PMC will throw an exception if exact math is enabled.</dd><p class="pad"></p>

<dt><a name="Float"
>Float</a></dt><p class="pad"></p>

<dd>The PMC wrapper for Parrot&#39;s low&#45;level floating&#45;point type. Always a float, with other types autoconverted to a float when stored into this PMC.</dd><p class="pad"></p>

<dd>The boolean value for a Float is false if exactly zero, otherwise true.</dd><p class="pad"></p>

<dd>When converted to an integer, floats round to the closest integer, capping at the platform maximum or minimum integer value.</dd><p class="pad"></p>

<dd>When converting to a string, floats use the platform default snprintf format.</dd><p class="pad"></p>

<dt><a name="String"
>String</a></dt><p class="pad"></p>

<dd>The PMC wrapper for Parrot&#39;s low&#45;level string type. Always a simple string, with other types autoconverted to a string when stored into this PMC.</dd><p class="pad"></p>

<dd>The boolean value for a String is false if empty or the string &#39;0&#39; (a one character string holding a zero) otherwise true. This PMC autoconverts to an integer or float when its integer or float value is fetched.</dd><p class="pad"></p>

<dt><a name="Boolean"
>Boolean</a></dt><p class="pad"></p>

<dd>A true/false value. Returns 0 for false, 1 for true when fetched as an integer or float, empty string for false and &#39;1&#39; for true when fetched as a string.</dd><p class="pad"></p>

<dd>{{ IMPLEMENTATION NOTE: move the definitions of the Python constants &#34;True&#34; and &#34;False&#34; out of src/pmc/boolean.pmc. They belong in HLL&#45;specific code, not in the core boolean type. }}</dd><p class="pad"></p>

<dt><a name="BigInt"
>BigInt</a></dt><p class="pad"></p>

<dd>An arbitrary precision integer.</dd><p class="pad"></p>

<dt><a name="BigNum"
>BigNum</a></dt><p class="pad"></p>

<dd>The PMC wrapper for Parrot&#39;s low&#45;level BigNum type. {{ NOTE: this type doesn&#39;t seem to exist. }}</dd><p class="pad"></p>

<dt><a name="Complex"
>Complex</a></dt><p class="pad"></p>

<dd>A complex number, consisting of a real part and an imaginary part. {{ NOTE: is this a complete and useful implementation of complex numbers? }}</dd><p class="pad"></p>

<dt><a name="ParrotClass"
>ParrotClass</a></dt><p class="pad"></p>

<dd>The PMC for Parrot&#39;s class. (Note that this may go away if we ultimately make all classes just objects)</dd><p class="pad"></p>

<dt><a name="ParrotObject"
>ParrotObject</a></dt><p class="pad"></p>

<dd>The PMC for Parrot&#39;s base object type.</dd><p class="pad"></p>

<dt><a name="Ref"
>Ref</a></dt><p class="pad"></p>

<dd>The PMC that represents a reference to another PMC. Delegates all functions to the referred&#45;to PMC.</dd><p class="pad"></p>

<dt><a name="AggregateElementRef"
>AggregateElementRef</a></dt><p class="pad"></p>

<dd>This PMC represents a reference to an element contained in an aggregate PMC type, such as an array or hash. It is initialized with the key being referenced and the aggregate PMC containing that key.</dd><p class="pad"></p>

<dd>Note that assigning to the reference PMC will be equivalent to a keyed set on the referenced aggregate PMC &#45; that is, it modifies the element rather than doing a v&#45;table call on the element itself. It is important to be aware of this when assigning a PMC through this reference; it is not the same behaviour as the Ref PMC.</dd><p class="pad"></p>

<dt><a name="WeakRegisterRef"
>WeakRegisterRef</a></dt><p class="pad"></p>

<dd>This PMC represents a weak reference to a register. Should the reference live beyond the context containing the register that it references, any attempt to use the reference will throw an exception.</dd><p class="pad"></p>

<dd>A weak register reference can only be created by the <code lang='und' xml:lang='und'>register_ref</code> opcode. Any assignment to the register will behave like a set instruction. That is, when assigning a PMC using a WeakRegisterRef PMC, the register will be updated to reference that PMC rather than calling the assign v&#45;table call on the PMC in that register. This is not the same behaviour as the Ref PMC.</dd><p class="pad"></p>

<dt><a name="Random"
>Random</a></dt><p class="pad"></p>

<dd>A singleton PMC that generates a random number. {{ NOTE: Why do we have this? }}</dd><p class="pad"></p>
</dl>

<h3><a name="Array_types"
>Array types</a></h3>

<p>Note that for the following types you can set the size of the array by using the VTABLE_set_integer_native() method. Assigning an integer to the array as a whole sets the array to that size.</p>

<p>Size&#45;changing operations (such as push, pop, shift, unshift, and splice) on statically&#45;sized arrays will throw an exception.</p>

<dl>
<dt><a name="Array"
>Array</a></dt><p class="pad"></p>

<dd>The base class for all array types (a statically sized array for any arbitrary type). New array types can be derived from the base Array. In user code it is recommended to use one of the specific array types below, rather than the base type.</dd><p class="pad"></p>

<dt><a name="FixedBooleanArray"
>FixedBooleanArray</a></dt><p class="pad"></p>

<dd>A statically sized array which holds only Boolean values.</dd><p class="pad"></p>

<dt><a name="ResizableBooleanArray"
>ResizableBooleanArray</a></dt><p class="pad"></p>

<dd>A dynamically sized array which holds only Boolean values.</dd><p class="pad"></p>

<dt><a name="FixedIntegerArray"
>FixedIntegerArray</a></dt><p class="pad"></p>

<dd>A statically sized array which holds only Integer values.</dd><p class="pad"></p>

<dt><a name="ResizableIntegerArray"
>ResizableIntegerArray</a></dt><p class="pad"></p>

<dd>A dynamically sized array which holds only Integer values.</dd><p class="pad"></p>

<dt><a name="FixedFloatArray"
>FixedFloatArray</a></dt><p class="pad"></p>

<dd>A statically sized array which holds only Float values.</dd><p class="pad"></p>

<dt><a name="ResizableFloatArray"
>ResizableFloatArray</a></dt><p class="pad"></p>

<dd>A dynamically sized array which holds only Float values.</dd><p class="pad"></p>

<dt><a name="FixedPMCArray"
>FixedPMCArray</a></dt><p class="pad"></p>

<dd>A statically sized array which holds only PMC values.</dd><p class="pad"></p>

<dt><a name="ResizablePMCArray"
>ResizablePMCArray</a></dt><p class="pad"></p>

<dd>A dynamically sized array which holds only PMC values.</dd><p class="pad"></p>

<dt><a name="FixedStringArray"
>FixedStringArray</a></dt><p class="pad"></p>

<dd>A statically sized array which holds only String values.</dd><p class="pad"></p>

<dt><a name="ResizableStringArray"
>ResizableStringArray</a></dt><p class="pad"></p>

<dd>A dynamically sized array which holds only String values.</dd><p class="pad"></p>

<dt><a name="Exception"
>Exception</a></dt><p class="pad"></p>
</dl>

<h3><a name="Hash_types"
>Hash types</a></h3>

<dl>
<dt><a name="Hash"
>Hash</a></dt><p class="pad"></p>

<dd>A container with key&#45;value semantics. The values are PMCs.</dd><p class="pad"></p>

<dt><a name="Env"
>Env</a></dt><p class="pad"></p>

<dd>Env is a singleton PMC class, that is there is only one Env PMC in any interpreter. This PMC gives access to the process&#39; environment variables&#45;&#45;reading from it returns the value of the named process environment variable, while writing to it sets the value of a process environment variable. For example, to retrieve the current value of TERM (the terminal type on most Unix systems):</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>   new P1, .Env
   set S1, P1[&#39;TERM&#39;]</pre>

<dd>Note that an embedding system may override this behavior.</dd><p class="pad"></p>

<dt><a name="Namespace"
>Namespace</a></dt><p class="pad"></p>

<dt><a name="OrderedHash"
>OrderedHash</a></dt><p class="pad"></p>

<dt><a name="AddrRegistry"
>AddrRegistry</a></dt><p class="pad"></p>

<dd>Simulates reference counting for dead&#45;object detection and garbage collection.</dd><p class="pad"></p>
</dl>

<h3><a name="Subroutine_types"
>Subroutine types</a></h3>

<dl>
<dt><a name="Sub"
>Sub</a></dt><p class="pad"></p>

<dt><a name="Closure"
>Closure</a></dt><p class="pad"></p>

<dd>A closure: subroutine object plus captured lexical scope.</dd><p class="pad"></p>

<dt><a name="Coroutine"
>Coroutine</a></dt><p class="pad"></p>

<dt><a name="Continuation"
>Continuation</a></dt><p class="pad"></p>

<dt><a name="CSub"
>CSub</a></dt><p class="pad"></p>

<dt><a name="Eval"
>Eval</a></dt><p class="pad"></p>

<dt><a name="Exception_Handler"
>Exception_Handler</a></dt><p class="pad"></p>

<dt><a name="MultiSub"
>MultiSub</a></dt><p class="pad"></p>

<dt><a name="NCI"
>NCI</a></dt><p class="pad"></p>

<dd>A native call interface wrapper around a C function.</dd><p class="pad"></p>

<dt><a name="Bound_NCI"
>Bound_NCI</a></dt><p class="pad"></p>

<dd>An internal NCI method call bound to a particular call instance. {{ NOTE: where are these used? }}</dd><p class="pad"></p>

<dt><a name="Compiler"
>Compiler</a></dt><p class="pad"></p>

<dd>A subroutine implementing a language compiler. (Derived from NCI.)</dd><p class="pad"></p>
</dl>

<h1><a name="ATTACHMENTS"
>ATTACHMENTS <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>None.</p>

<h1><a name="FOOTNOTES"
>FOOTNOTES <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>None.</p>

<h1><a name="REFERENCES"
>REFERENCES <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>None.</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
