<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Conventions and Guidelines for Parrot Source Code</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Conventions and Guidelines for Parrot Source Code</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../html/index.html">Contents</a> | <a href="../../../html/docs.html">Documentation</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>docs/pdds/pdd07_codingstd.pod &#45; Conventions and Guidelines for Parrot Source Code</p>

<h1><a name="ABSTRACT"
>ABSTRACT <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>This document describes the various rules,
guidelines and advice for those wishing to contribute to the source code of Parrot,
in such areas as code structure,
naming conventions,
comments etc.</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>One of the criticisms of Perl 5 is that its source code is impenetrable to newcomers,
due to such things as inconsistent or obscure variable naming conventions,
lack of comments in the source code,
and so on.
We don&#39;t intend to make the same mistake when writing Parrot.
Hence this document.</p>

<p>We define three classes of conventions.
Those that say <i>must</i> are mandatory,
and code will not be accepted (apart from in exceptional circumstances) unless it follows these rules.
Those that say <i>should</i> are strong guidelines that should normally be followed unless there is a sensible reason to do otherwise.
Finally,
those that say <i>may</i>,
are tentative suggestions to be used at your discretion.</p>

<p>Note this particular PDD makes some recommendations that are specific to the C programming language.
This does not preclude Parrot (or Perl 6) being implemented in other languages,
but in this case,
additional PDDs may need to be authored for the extra language&#45;specific features.</p>

<h1><a name="IMPLEMENTATION"
>IMPLEMENTATION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<h2><a name="Coding_style"
>Coding style <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>The following <i>must</i> apply:</p>

<ul>
<li>4 column indents for code and 2 column indents for nested CPP #directives.
All indentation must consist of spaces,
no tabs (for ease of patching).</li><p class="pad"></p>

<p>There are two exceptions to the CPP indenting&#45; neither PARROT_IN_CORE nor the outermost _GUARD #ifdefs cause the level of indenting to increase.</p>

<p>To ensure that tabs aren&#39;t inadvertently used for indentation,
the following boilerplate code must appear at the bottom of each source file.
(This rule may be rescinded if I&#39;m ever threatened with a lynching....)</p>

<pre lang='und' xml:lang='und'>   /*
    * Local variables:
    * c&#45;indentation&#45;style: bsd
    * c&#45;basic&#45;offset: 4
    * indent&#45;tabs&#45;mode: nil
    * End:
    *
    * vim: expandtab shiftwidth=4:
    */</pre>

<li>Any other tabs are assumed to be on an 8&#45;character boundary.</li><p class="pad"></p>

<li>ANSI C function prototypes</li><p class="pad"></p>

<li>&#34;K&#38;R&#34; style for indenting control constructs: ie the closing <code lang='und' xml:lang='und'>}</code> should line up with the opening <code lang='und' xml:lang='und'>if</code> etc.</li><p class="pad"></p>

<li>When a conditional spans multiple lines, the opening <code lang='und' xml:lang='und'>{</code> must line up with the <code lang='und' xml:lang='und'>if</code> or <code lang='und' xml:lang='und'>while</code>, or be at the end&#45;of&#45;line otherwise.</li><p class="pad"></p>

<li>Uncuddled <code lang='und' xml:lang='und'>else</code>s: ie avoid <code lang='und' xml:lang='und'>} else {</code></li><p class="pad"></p>

<li>No C++ style comments (<code lang='und' xml:lang='und'>//</code>): some C compilers may choke on them</li><p class="pad"></p>

<li>Mark places that need to be revisited with XXX (and preferably your initials too), and revisit often!</li><p class="pad"></p>

<li>In function definitions, the name starts in column 0, with the return type on the previous line.</li><p class="pad"></p>

<li>However, in function declarations (in header files) the return type is kept on the same line.</li><p class="pad"></p>

<li>Variable names should be included for all function parameters in the function declarations. These names should match the parameters in the function definition.</li><p class="pad"></p>

<li>Single space after keywords that are followed by <code lang='und' xml:lang='und'>()</code>, eg <code lang='und' xml:lang='und'>return (x+y)*2</code>, but no space between function name and following <code lang='und' xml:lang='und'>()</code>, eg <code lang='und' xml:lang='und'>z = foo(x+y)*2</code></li><p class="pad"></p>
</ul>

<p>The following <i>should</i> apply</p>

<ul>
<li>Do not exceed 79 columns</li><p class="pad"></p>

<li><code lang='und' xml:lang='und'>return foo;</code> rather than <code lang='und' xml:lang='und'>return (foo);</code></li><p class="pad"></p>

<li><code lang='und' xml:lang='und'>if (!foo) ...</code> rather than <code lang='und' xml:lang='und'>if (foo == FALSE) ...</code> etc.</li><p class="pad"></p>

<li>Avoid assignments in conditionals, but if they&#39;re unavoidable, use Extra paren, e.g. <code lang='und' xml:lang='und'>if (a &#38;&#38; (b = c)) ...</code></li><p class="pad"></p>

<li>Avoid double negatives, eg <code lang='und' xml:lang='und'>#ifndef NO_FEATURE_FOO</code></li><p class="pad"></p>

<li>Binary operators should have a space on either side; parentheses should not have space immediately after the opening paren nor immediately before the closing paren, commas should have space after but not before, eg</li><p class="pad"></p>

<pre lang='und' xml:lang='und'>        x = (a + b) * f(c, d / e)</pre>

<li>Long lines should be split before an operator so that it is immediately obvious when scanning the LHS of the code that this has happened, and two extra levels of indent should be used.</li><p class="pad"></p>

<li>and/or split on matching parens, with the content on separate line(s) and with one extra indent:</li><p class="pad"></p>

<pre lang='und' xml:lang='und'>    do_arbitrary_function(
        list_of_parameters_with_long_names, or_complex_subexpression(
            of_more_params, or_expressions + 1
        )
    );</pre>
</ul>

<p>To enforce the spacing, indenting, and bracing guidelines mentioned above, the following arguments to GNU Indent should be used:</p>

<pre lang='und' xml:lang='und'>   &#45;kr &#45;nce &#45;sc &#45;cp0 &#45;l79 &#45;lc79 &#45;psl &#45;nut &#45;cdw &#45;ncs &#45;lps</pre>

<p>This expands out to:</p>

<dl>
<dt><a name="&#45;nbad"
>&#45;nbad</a></dt><p class="pad"></p>

<dd>Do not force blank lines after declarations.</dd><p class="pad"></p>

<dt><a name="&#45;bap"
>&#45;bap</a></dt><p class="pad"></p>

<dd>Force blank lines after procedure bodies.</dd><p class="pad"></p>

<dt><a name="&#45;bbo"
>&#45;bbo</a></dt><p class="pad"></p>

<dd>Prefer to break long lines before boolean operators.</dd><p class="pad"></p>

<dt><a name="&#45;nbc"
>&#45;nbc</a></dt><p class="pad"></p>

<dd>Do not force newlines after commas in declarations</dd><p class="pad"></p>

<dt><a name="&#45;br"
>&#45;br</a></dt><p class="pad"></p>

<dd>Put braces on line with if, etc.</dd><p class="pad"></p>

<dt><a name="&#45;brs"
>&#45;brs</a></dt><p class="pad"></p>

<dd>Put braces on struct declaration line.</dd><p class="pad"></p>

<dt><a name="&#45;c33"
>&#45;c33</a></dt><p class="pad"></p>

<dd>Put comments to the right of code in column 33 (not recommended)</dd><p class="pad"></p>

<dt><a name="&#45;cd33"
>&#45;cd33</a></dt><p class="pad"></p>

<dd>Put declaration comments to the right of code in column 33</dd><p class="pad"></p>

<dt><a name="&#45;ncdb"
>&#45;ncdb</a></dt><p class="pad"></p>

<dd>Do not put comment delimiters on blank lines.</dd><p class="pad"></p>

<dt><a name="&#45;nce"
>&#45;nce</a></dt><p class="pad"></p>

<dd>Do not cuddle } and else.</dd><p class="pad"></p>

<dt><a name="&#45;cdw"
>&#45;cdw</a></dt><p class="pad"></p>

<dd>Do cuddle do { } while.</dd><p class="pad"></p>

<dt><a name="&#45;ci4"
>&#45;ci4</a></dt><p class="pad"></p>

<dd>Continuation indent of 4 spaces</dd><p class="pad"></p>

<dt><a name="&#45;cli0"
>&#45;cli0</a></dt><p class="pad"></p>

<dd>Case label indent of 0 spaces</dd><p class="pad"></p>

<dt><a name="&#45;ncs"
>&#45;ncs</a></dt><p class="pad"></p>

<dd>Do not put a space after a cast operator.</dd><p class="pad"></p>

<dt><a name="&#45;d0"
>&#45;d0</a></dt><p class="pad"></p>

<dd>Set indentation of comments not to the right of code to 0 spaces.</dd><p class="pad"></p>

<dt><a name="&#45;di1"
>&#45;di1</a></dt><p class="pad"></p>

<dd>Put declaration variables 1 space after their types</dd><p class="pad"></p>

<dt><a name="&#45;nfc1"
>&#45;nfc1</a></dt><p class="pad"></p>

<dd>Do not format comments in the first column as normal.</dd><p class="pad"></p>

<dt><a name="&#45;nfca"
>&#45;nfca</a></dt><p class="pad"></p>

<dd>Do not format any comments</dd><p class="pad"></p>

<dt><a name="&#45;hnl"
>&#45;hnl</a></dt><p class="pad"></p>

<dd>Prefer to break long lines at the position of newlines in the input.</dd><p class="pad"></p>

<dt><a name="&#45;i4"
>&#45;i4</a></dt><p class="pad"></p>

<dd>4&#45;space indents</dd><p class="pad"></p>

<dt><a name="&#45;ip0"
>&#45;ip0</a></dt><p class="pad"></p>

<dd>Indent parameter types in old&#45;style function definitions by 0 spaces.</dd><p class="pad"></p>

<dt><a name="&#45;l79"
>&#45;l79</a></dt><p class="pad"></p>

<dd>maximum line length for non&#45;comment lines is 79 spaces.</dd><p class="pad"></p>

<dt><a name="&#45;lc79"
>&#45;lc79</a></dt><p class="pad"></p>

<dd>maximum line length for comment lines is 79 spaces.</dd><p class="pad"></p>

<dt><a name="&#45;lp"
>&#45;lp</a></dt><p class="pad"></p>

<dd>maximum line length for non&#45;comment lines is 79 spaces.</dd><p class="pad"></p>

<dt><a name="&#45;npcs"
>&#45;npcs</a></dt><p class="pad"></p>

<dd>Do not put a space after the function in function calls.</dd><p class="pad"></p>

<dt><a name="&#45;nprs"
>&#45;nprs</a></dt><p class="pad"></p>

<dd>Do not put a space after every &#180;(&#180; and before every &#180;)&#180;.</dd><p class="pad"></p>

<dt><a name="&#45;saf"
>&#45;saf</a></dt><p class="pad"></p>

<dd>Put a space after each for.</dd><p class="pad"></p>

<dt><a name="&#45;sai"
>&#45;sai</a></dt><p class="pad"></p>

<dd>Put a space after each if.</dd><p class="pad"></p>

<dt><a name="&#45;saw"
>&#45;saw</a></dt><p class="pad"></p>

<dd>Put a space after each while.</dd><p class="pad"></p>

<dt><a name="&#45;sc"
>&#45;sc</a></dt><p class="pad"></p>

<dd>Put the `*&#180; character at the left of comments.</dd><p class="pad"></p>

<dt><a name="&#45;nsob"
>&#45;nsob</a></dt><p class="pad"></p>

<dd>Do not swallow optional blank lines.</dd><p class="pad"></p>

<dt><a name="&#45;nss"
>&#45;nss</a></dt><p class="pad"></p>

<dd>Do not force a space before the semicolon after certain statements</dd><p class="pad"></p>

<dt><a name="&#45;nut"
>&#45;nut</a></dt><p class="pad"></p>

<dd>Use spaces instead of tabs.</dd><p class="pad"></p>

<dt><a name="&#45;lps"
>&#45;lps</a></dt><p class="pad"></p>

<dd>Leave space between `#&#180; and preprocessor directive.</dd><p class="pad"></p>

<dt><a name="&#45;psl"
>&#45;psl</a></dt><p class="pad"></p>

<dd>Put the type of a procedure on the line before its name. (.c files), or</dd><p class="pad"></p>

<dt><a name="&#45;npsl"
>&#45;npsl</a></dt><p class="pad"></p>

<dd>Leave a procedure declaration&#39;s return type alone (.h files)</dd><p class="pad"></p>
</dl>

<p>Please note that it is also necessary to include all typedef types with the &#34;&#45;T&#34; option to ensure that everything is formatted properly.</p>

<p>A script (<em lang='und' xml:lang='und'>tools/dev/run_indent.pl</em>) is provided which runs <em lang='und' xml:lang='und'>indent</em> properly automatically.</p>

<h2><a name="Naming_conventions"
>Naming conventions <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="Subsystems_and_APIs"
>Subsystems and APIs</a></dt><p class="pad"></p>

<dd>The Parrot core will be split into a number of subsystems, each with an associated API. For the purposes of naming files, data structures, etc, each subsystem will be assigned a short nickname, eg <i>pmc</i>, <i>gc</i>, <i>io</i>. All code within the core will belong to a subsystem; miscellaneous code with no obvious home will be placed in the special subsystem called <i>misc</i>.</dd><p class="pad"></p>

<dt><a name="Filenames"
>Filenames</a></dt><p class="pad"></p>

<dd>Filenames must be assumed to be case&#45;insensitive, in the sense that that you may not have two different files called <em lang='und' xml:lang='und'>Foo</em> and <em lang='und' xml:lang='und'>foo</em>. Normal source&#45;code filenames should be all lower&#45;case; filenames with upper&#45;case letters in them are reserved for notice&#45;me&#45;first files such as <em lang='und' xml:lang='und'>README</em>, and for files which need some sort of pre&#45;processing applied to them or which do the preprocessing &#45; eg a script <em lang='und' xml:lang='und'>foo.SH</em> might read <em lang='und' xml:lang='und'>foo.TEMPLATE</em> and output <em lang='und' xml:lang='und'>foo.c</em>.</dd><p class="pad"></p>

<dd>The characters making up filenames must be chosen from the ASCII set A&#45;Z,a&#45;z,0&#45;9 plus .&#45;_</dd><p class="pad"></p>

<dd>An underscore should be used to separate words rather than a hyphen (&#45;). A file should not normally have more than a single &#39;.&#39; in it, and this should be used to denote a suffix of some description. The filename must still be unique if the main part is truncated to 8 characters and any suffix truncated to 3 characters. Ideally, filenames should restricted to 8.3 in the first place, but this is not essential.</dd><p class="pad"></p>

<dd>Each subsystem <i>foo</i> should supply the following files. This arrangement is based on the assumption that each subsystem will &#45; as far as is practical &#45; present an opaque interface to all other subsystems within the core, as well as to extensions and embeddings.</dd><p class="pad"></p>

<dl>
<dt><a name="foo.h"
>foo.h</a></dt><p class="pad"></p>

<dd>This contains all the declarations needed for external users of that API (and nothing more), ie it defines the API. It is permissible for the API to include different or extra functionality when used by other parts of the core, compared with its use in extensions and embeddings. In this case, the extra stuff within the file is enabled by testing for the macro <code lang='und' xml:lang='und'>PERL_IN_CORE</code>.</dd><p class="pad"></p>

<dt><a name="foo_private.h"
>foo_private.h</a></dt><p class="pad"></p>

<dd>This contains declarations used internally by that subsystem, and which must only be included within source files associated the subsystem. This file defines the macro <code lang='und' xml:lang='und'>PERL_IN_FOO</code> so that code knows when it is being used within that subsystem. The file will also contain all the &#39;convenience&#39; macros used to define shorter working names for functions without the perl prefix (see below).</dd><p class="pad"></p>

<dt><a name="foo_globals.h"
>foo_globals.h</a></dt><p class="pad"></p>

<dd>This file contains the declaration of a single structure containing the private global variables used by the subsystem (see the section on globals below for more details).</dd><p class="pad"></p>

<dt><a name="foo.sym"
>foo.sym</a></dt><p class="pad"></p>

<dd>This file (format and contents TBD) contains information about global symbols associated with the subsystem, and may be used by scripts to auto&#45;generate such stuff as the include files mentioned above, linker map tables, documentation etc, based upon portability and extensibility requirements.</dd><p class="pad"></p>

<dt><a name="foo_bar.[ch]_etc"
>foo_bar.[ch] etc</a></dt><p class="pad"></p>

<dd>All other source files associated with the subsystem will have the prefix foo_</dd><p class="pad"></p>
</dl>

<dt><a name="Header_Files"
>Header Files</a></dt><p class="pad"></p>

<dd>All .h files should include the following &#34;guards&#34; to prevent multiple&#45;inclusion:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    /* file header comments */

    #if !defined(PARROT_&#60;FILENAME&#62;_H_GUARD)
    #define PARROT_&#60;FILENAME&#62;_H_GUARD

    /* body of file */

    #endif /* PARROT_&#60;FILENAME&#62;_H_GUARD */</pre>

<dt><a name="Names_of_code_entities"
>Names of code entities</a></dt><p class="pad"></p>

<dd>Code entities such as variables, functions, macros etc (apart from strictly local ones) should all follow these general guidelines.</dd><p class="pad"></p>

<ul>
<li>Multiple words or components should be separated with underscores rather than using tricks such as capitalization, eg <code lang='und' xml:lang='und'>new_foo_bar</code> rather than <code lang='und' xml:lang='und'>NewFooBar</code> or (gasp) <code lang='und' xml:lang='und'>newfoobar</code>.</li><p class="pad"></p>

<li>The names of entities should err on the side of verbosity, eg <code lang='und' xml:lang='und'>create_foo_from_bar()</code> in preference to <code lang='und' xml:lang='und'>ct_foo_bar()</code>. Avoid cryptic abbreviations wherever possible.</li><p class="pad"></p>

<li>All entities should be prefixed with the name of the subsystem they appear in, eg <code lang='und' xml:lang='und'>pmc_foo()</code>, <code lang='und' xml:lang='und'>struct io_bar</code>. They should be further prefixed with the word &#39;perl&#39; if they have external visibility or linkage, namely, non&#45;static functions, plus macros and typedefs etc which appear in public header files. (Global variables are handled specially; see below.) For example:</li><p class="pad"></p>

<pre lang='und' xml:lang='und'>    perlpmc_foo()
    struct perlio_bar
    typedef struct perlio_bar Perlio_bar
    #define PERLPMC_readonly_TEST ...</pre>

<p>In the specific case of the use of global variables and functions within a subsystem, convenience macros will be defined (in foo_private.h) that allow use of the shortened name in the case of functions (ie <code lang='und' xml:lang='und'>pmc_foo()</code> instead of <code lang='und' xml:lang='und'>perlpmc_foo()</code>), and hide the real representation in the case of global variables.</p>

<li>Variables and structure names should be all lower&#45;case, eg <code lang='und' xml:lang='und'>pmc_foo</code>.</li><p class="pad"></p>

<li>Structure elements should be all lower&#45;case, and the first component of the name should incorporate the structure&#39;s name or an abbreviation of it.</li><p class="pad"></p>

<li>Typedef names should be lower&#45;case except for the first letter, eg <code lang='und' xml:lang='und'>Foo_bar</code>. The exception to this is when the first component is a short abbreviation, in which case the whole first component may be made uppercase for readability purposes, eg <code lang='und' xml:lang='und'>IO_foo</code> rather than <code lang='und' xml:lang='und'>Io_foo</code>. Structures should generally be typedefed.</li><p class="pad"></p>

<li>Macros should have their first component uppercase, and the majority of the remaining components should be likewise. Where there is a family of macros, the variable part can be indicated in lowercase, eg <code lang='und' xml:lang='und'>PMC_foo_FLAG</code>, <code lang='und' xml:lang='und'>PMC_bar_FLAG</code>, ....</li><p class="pad"></p>

<li>A macro which defines a flag bit should be suffixed with <code lang='und' xml:lang='und'>_FLAG</code>, eg <code lang='und' xml:lang='und'>PMC_readonly_FLAG</code> (although you probably want to use an <code lang='und' xml:lang='und'>enum</code> instead.)</li><p class="pad"></p>

<li>A macro which tests a flag bit should be suffixed with <code lang='und' xml:lang='und'>_TEST</code>, eg <code lang='und' xml:lang='und'>if (PMC_readonly_TEST(foo)) ...</code></li><p class="pad"></p>

<li>A macro which sets a flag bit should be suffixed with <code lang='und' xml:lang='und'>_SET</code>, eg <code lang='und' xml:lang='und'>PMC_readonly_SET(foo);</code></li><p class="pad"></p>

<li>A macro which clears a flag bit should be suffixed with <code lang='und' xml:lang='und'>_CLEAR</code>, eg <code lang='und' xml:lang='und'>PMC_readonly_CLEAR(foo);</code></li><p class="pad"></p>

<li>A macro defining a mask of flag bits should be suffixed with <code lang='und' xml:lang='und'>_MASK</code>, eg <code lang='und' xml:lang='und'>foo &#38;= ~PMC_STATUS_MASK</code> (but see notes on extensibility below).</li><p class="pad"></p>

<li>Macros can be defined to cover common flag combinations, in which case they should have <code lang='und' xml:lang='und'>_SETALL</code>, <code lang='und' xml:lang='und'>CLEARALL</code>, <code lang='und' xml:lang='und'>_TESTALL</code> or &#60;_TESTANY&#62; suffixes as appropriate, to indicate aggregate bits, eg <code lang='und' xml:lang='und'>PMC_valid_CLEARALL(foo)</code></li><p class="pad"></p>

<li>A macro defining an auto&#45;configuration value should be prefixed with <code lang='und' xml:lang='und'>HAS_</code>, eg <code lang='und' xml:lang='und'>HAS_BROKEN_FLOCK</code>, <code lang='und' xml:lang='und'>HAS_EBCDIC</code>.</li><p class="pad"></p>

<li>A macro indicating the compilation &#39;location&#39; should be prefixed with <code lang='und' xml:lang='und'>IN_</code>, eg <code lang='und' xml:lang='und'>PERL_IN_CORE</code>, <code lang='und' xml:lang='und'>PERL_IN_PMC</code>, <code lang='und' xml:lang='und'>PERL_IN_X2P</code>. Individual include file visitations should be marked with <code lang='und' xml:lang='und'>PERL_IN_FOO_H</code> for file foo.h</li><p class="pad"></p>

<li>A macro indicating major compilation switches should be prefixed with <code lang='und' xml:lang='und'>USE_</code>, eg <code lang='und' xml:lang='und'>PERL_USE_STDIO</code>, <code lang='und' xml:lang='und'>USE_MULTIPLICITY</code>.</li><p class="pad"></p>

<li>A macro that may declare stuff and thus needs to be at the start of a block should be prefixed with <code lang='und' xml:lang='und'>DECL_</code>, eg <code lang='und' xml:lang='und'>DECL_SAVE_STACK</code>. Note that macros which implicitly declare and then use variables are strongly discouraged, unless it is essential for portability or extensibility. The following are in decreasing preference style&#45;wise, but increasing preference extensibility&#45;wise.</li><p class="pad"></p>

<pre lang='und' xml:lang='und'>    { Stack sp = GETSTACK;  x = POPSTACK(sp) ... /* sp is an auto variable */
    { DECL_STACK(sp);  x = POPSTACK(sp); ... /* sp may or may not be auto */
    { DECL_STACK; x = POPSTACK; ... /* anybody&#39;s guess */</pre>
</ul>

<dt><a name="Global_Variables"
>Global Variables</a></dt><p class="pad"></p>

<dd>Global variables must never be accessed directly outside the subsystem in which they are used. Some other method, such as accessor functions, must be provided by that subsystem&#39;s API. (For efficiency the &#39;accessor functions&#39; may occasionally actually be macros, but then the rule still applies in spirit at least).</dd><p class="pad"></p>

<dd>All global variables needed for the internal use of a particular subsystem should all be declared within a single struct called foo_globals for subsystem foo. This structure&#39;s declaration is placed in the file foo_globals.h. Then somewhere a single compound structure will be declared which has as members the individual structures from each subsystem. Instances of this structure are then defined as a one&#45;off global variable, or as per&#45;thread instances, or whatever is required.</dd><p class="pad"></p>

<dd>[Actually, three separate structures may be required, for global, per&#45;interpreter and per&#45;thread variables.]</dd><p class="pad"></p>

<dd>Within an individual subsystem, macros are defined for each global variable of the form <code lang='und' xml:lang='und'>GLOBAL_foo</code> (the name being deliberately clunky). So we might for example have the following macros:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>        /* perl_core.h or similar */

        #ifdef HAS_THREADS
        #  define GLOBALS_BASE (aTHX_&#45;&#62;globals)
        #else
        #  define GLOBALS_BASE (Perl_globals)
        #endif

        /* pmc_private.h */

        #define GLOBAL_foo   GLOBALS_BASE.pmc.foo
        #define GLOBAL_bar   GLOBALS_BASE.pmc.bar
        ... etc ...</pre>
</dl>

<h2><a name="Code_comments"
>Code comments <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>The importance of good code documentation cannot be stressed enough. To make your code understandable by others (and indeed by yourself when you come to make changes a year later :&#45;), the following conventions apply to all source files.</p>

<dl>
<dt><a name="Developer_files"
>Developer files</a></dt><p class="pad"></p>

<dd>Each source file (eg a <em lang='und' xml:lang='und'>foo.c</em> <em lang='und' xml:lang='und'>foo.h</em> pair), should contain inline POD documentation containing information on the implementation decisions associated with the source file. (Note that this is in contrast to PDDs, which describe design decisions). In addition, more discussive documentation can be placed in <em lang='und' xml:lang='und'>*.dev</em> files in the <em lang='und' xml:lang='und'>docs/dev</em> directory. This is the place for mini&#45;essays on how to avoid overflows in unsigned arithmetic, or on the pros and cons of differing hash algorithms, and why the current one was chosen, and how it works.</dd><p class="pad"></p>

<dd>In principle, someone coming to a particular source file for the first time should be able to read the inline documentation file and gain an immediate overview of what the source file is for, the algorithms it implements, etc.</dd><p class="pad"></p>

<dd>The POD documentation should follow the standard POD layout:</dd><p class="pad"></p>

<dl>
<dt><a name="Copyright"
>Copyright</a></dt><p class="pad"></p>

<dd>The Parrot copyright statement.</dd><p class="pad"></p>

<dt><a name="SVN"
>SVN</a></dt><p class="pad"></p>

<dd>A SVN id string.</dd><p class="pad"></p>

<dt><a name="NAME"
>NAME</a></dt><p class="pad"></p>

<dd>src/foo.c &#45; Foo</dd><p class="pad"></p>

<dt><a name="SYNOPSIS"
>SYNOPSIS</a></dt><p class="pad"></p>

<dd>When appropriate, some simple examples of usage.</dd><p class="pad"></p>

<dt><a name="DESCRIPTION"
>DESCRIPTION</a></dt><p class="pad"></p>

<dd>A description of the contents of the file, how the implementation works, data structures and algorithms, and anything that may be of interest to your successors, eg benchmarks of differing hash algorithms, essays on how to do integer arithmetic.</dd><p class="pad"></p>

<dt><a name="HISTORY"
>HISTORY</a></dt><p class="pad"></p>

<dd>Record major changes to the file, eg &#34;we moved from a linked list to a hash table implementation for storing Foos, as it was found to be much faster&#34;.</dd><p class="pad"></p>

<dt><a name="SEE_ALSO"
>SEE ALSO</a></dt><p class="pad"></p>

<dd>Links to pages and books that may contain useful info relevant to the stuff going on in the code &#45; eg the book you stole the hash function from.</dd><p class="pad"></p>
</dl>

<dt><a name="Per&#45;section_comments"
>Per&#45;section comments</a></dt><p class="pad"></p>

<dd>If there is a collection of functions, structures or whatever which are grouped together and have a common theme or purpose, there should be a general comment at the start of the section briefly explaining their overall purpose. (Detailed essays should be left to the developer file). If there is really only one section, then the top&#45;of&#45;file comment already satisfies this requirement.</dd><p class="pad"></p>

<dt><a name="Per&#45;entity_comments"
>Per&#45;entity comments</a></dt><p class="pad"></p>

<dd>Every non&#45;local named entity, be it a function, variable, structure, macro or whatever, must have an accompanying comment explaining it&#39;s purpose. This comment must be in the special format described below, in order to allow automatic extraction by tools &#45; for example, to generate per API man pages, <b>perldoc &#45;f</b> style utilities and so on.</dd><p class="pad"></p>

<dd>Often the comment need only be a single line explaining its purpose, but sometimes more explanation may be needed. For example, &#34;return an Integer Foo to its allocation pool&#34; may be enough to demystify the function <code lang='und' xml:lang='und'>del_I_foo()</code></dd><p class="pad"></p>

<dd>Each comment should be of the form</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    /*

    =item C&#60;function(arguments)&#62;

    Description.

    =cut

    */</pre>

<dd>This inline POD documentation is parsed to HTML by running:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>        % perl tools/docs/write_docs.pl &#45;s</pre>

<dt><a name="Optimizations"
>Optimizations</a></dt><p class="pad"></p>

<dd>Whenever code has deliberately been written in an odd way for performance reasons, you should point this out &#45; if nothing else, to avoid some poor schmuck trying subsequently to replace it with something &#39;cleaner&#39;.</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    /* The loop is partially unrolled here as it makes it a lot faster.
     * See the .dev file for the full details
     */</pre>

<dt><a name="General_comments"
>General comments</a></dt><p class="pad"></p>

<dd>While there is no need to go mad commenting every line of code, it is immensely helpful to provide a &#34;running commentary&#34; every 10 or so lines say; if nothing else, this makes it easy to quickly locate a specific chunk of code. Such comments are particularly useful at the top of each major branch, eg</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    if (FOO_bar_BAZ(**p+*q) &#60;= (r&#45;s[FOZ &#38; FAZ_MASK]) || FLOP_2(z99)) {
        /* we&#39;re in foo mode: clean up lexicals */
        ... (20 lines of gibberish) ...
    }
    else if (...) {
        /* we&#39;re in bar mode: clean up globals */
        ... (20 more lines of gibberish) ...
    }
    else {
        /* we&#39;re in baz mode: self&#45;destruct */
        ....
    }</pre>
</dl>

<h2><a name="Extensibility"
>Extensibility <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>If Perl 5 is anything to go by, the lifetime of Perl 6 will be at least seven years. During this period, the source code will undergo many major changes never envisaged by its original authors &#45; cf threads, unicode in perl 5. To this end, your code should balance out the assumptions that make things possible, fast or small, with the assumptions that make it difficult to change things in future. This is especially important for parts of the code which are exposed through APIs &#45; the requirements of src or binary compatibility for such things as extensions can make it very hard to change things later on.</p>

<p>For example, if you define suitable macros to set/test flags in a struct, then you can later add a second word of flags to the struct without breaking source compatibility. (Although you might still break binary compatibility if you&#39;re not careful.) Of the following two methods of setting a common combination of flags, the second doesn&#39;t assume that all the flags are contained within a single field:</p>

<pre lang='und' xml:lang='und'>    foo&#45;&#62;flags |= (FOO_int_FLAG | FOO_num_FLAG | FOO_str_FLAG);
    FOO_valid_value_SETALL(foo);</pre>

<p>Similarly, avoid using a char* (or {char*,length}) if it is feasible to later use a PMC* at the same point: cf UTF&#45;8 hash keys in Perl 5.</p>

<p>Of course, private code hidden behind an API can play more fast and loose than code which gets exposed.</p>

<h2><a name="Portability"
>Portability <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Related to extensibility is portability. Perl runs on many, many platforms, and will no doubt be ported to ever more bizarre and obscure ones over time. You should never assume an operating system, processor architecture, endian&#45;ness, word size, or whatever. In particular, don&#39;t fall into any of the following common traps:</p>

<p>Internal data types and their utility functions (especially for strings) should be used over a bare char * whenever possible. Ideally there should be no char * in the source anywhere, and no use of C&#39;s standard string library.</p>

<p>Don&#39;t assume GNU C, and don&#39;t use any GNU extensions unless protected by #ifdefs for non&#45;GNU&#45;C builds.</p>

<p>TBC ... Any contributions welcome !!!</p>

<h2><a name="Performance"
>Performance <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>We want Perl to be fast. Very fast. But we also want it to be portable and extensible. Based on the 90/10 principle, (or 80/20, or 95/5, depending on who you speak to), most performance is gained or lost in a few small but critical areas of code. Concentrate your optimization efforts there.</p>

<p>Note that the most overwhelmingly important factor in performance is in choosing the correct algorithms and data structures in the first place. Any subsequent tweaking of code is secondary to this. Also, any tweaking that is done should as far as possible be platform independent, or at least likely to cause speed&#45;ups in a wide variety of environments, and do no harm elsewhere. Only in exceptional circumstances should assembly ever even be considered, and then only if generic fallback code is made available that can still be used by all other non&#45;optimized platforms.</p>

<p>Probably the dominant factor (circa 2001) that effects processor performance is the cache. Processor clock rates have increased far in excess of main memory access rates, and the only way for the processor to proceed without stalling is for most of the data items it needs to be found to hand in the cache. It is reckoned that even a 2% cache miss rate can cause a slowdown in the region of 50%. It is for this reason that algorithms and data structures must be designed to be &#39;cache&#45;friendly&#39;.</p>

<p>A typical cache may have a block size of anywhere between 4 and 256 bytes. When a program attempts to read a word from memory and the word is already in the cache, then processing continues unaffected. Otherwise, the processor is typically stalled while a whole contiguous chunk of main memory is read in and stored in a cache block. Thus, after incurring the initial time penalty, you then get all the memory adjacent to the initially read data item for free. Algorithms that make use of this fact can experience quite dramatic speedups. For example, the following pathological code ran four times faster on my machine by simply swapping <code lang='und' xml:lang='und'>i</code> and <code lang='und' xml:lang='und'>j</code>.</p>

<pre lang='und' xml:lang='und'>    int a[1000][1000];

    ... (a gets populated) ...

    int i,j,k;
    for (i=0; i&#60;1000; i++) {
        for (j=0; j&#60;1000; j++) {
            k += a[j][i];
        }
    }</pre>

<p>This all boils down to: keep things near to each other that get accessed at around the same time. (This is why the important optimizations occur in data structure and algorithm design rather than in the detail of the code.) This rule applies both to the layout of different objects relative to each other, and to the relative positioning of individual fields within a single structure.</p>

<p>If you do put an optimization in, time it on as many architectures as you can, and be suspicious of it if it slows down on any of them! Perhaps it will be slow on other architectures too (current and future). Perhaps it wasn&#39;t so clever after all? If the optimization is platform specific, you should probably put it in a platform&#45;specific function in a platform&#45;specific file, rather than cluttering the main source with zillions of #ifdefs.</p>

<p>And remember to document it.</p>

<p>Loosely speaking, Perl tends to optimism for speed rather than space, so you may want to code for speed first, then tweak to reclaim some space while not affecting performance.</p>

<h1><a name="REFERENCES"
>REFERENCES <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>The section on coding style is based on Perl5&#39;s <em lang='und' xml:lang='und'>Porting/patching.pod</em> by Daniel Grisinger. The section on naming conventions grew from some suggestions by Paolo Molaro &#60;lupus@lettere.unipd.it&#62;. Other snippets came from various P5Pers. The rest of it is probably my fault.</p>

<h1><a name="VERSION"
>VERSION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<h2><a name="CURRENT"
>CURRENT <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<pre lang='und' xml:lang='und'>   Maintainer: Dave Mitchell &#60;davem@fdgroup.com&#62;
   Class: Internals
   PDD Number: 7
   Version: 1
   Status: Developing
   Last Modified: 6 August 2001
   PDD Format: 1
   Language: English</pre>

<h2><a name="HISTORY"
>HISTORY <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Based on an earlier draft which covered only code comments.</p>

<h1><a name="CHANGES"
>CHANGES <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>None. First version</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
