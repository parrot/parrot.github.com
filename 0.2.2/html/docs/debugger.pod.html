<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>The Parrot Debugger</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">The Parrot Debugger</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../html/index.html">Contents</a> | <a href="../../html/docs.html">Documentation</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>docs/debugger.pod &#45; The Parrot Debugger</p>

<h1><a name="ABSTRACT"
>ABSTRACT <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>This document describes <em lang='und' xml:lang='und'>pdb</em>,
the Parrot Debugger.</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>Starting from version 0.0.6 Parrot has its own debugger,
which is modeled after Perl&#39;s one.
Its name is <em lang='und' xml:lang='und'>pdb</em>,
and is an interactive environment that let you step through bytecode,
set breakpoints,
evaluate assembly instructions and peek at the interpreter status.</p>

<p>A good (well,
at least some) knowledge of the Parrot internals is obviously required to read this document.
Some familiarity with debugging principles is also mandatory beyond this point.</p>

<h1><a name="BUILDING_pdb"
>BUILDING pdb <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>The debugger is not built with Parrot,
but you should make it with its specific target:</p>

<pre lang='und' xml:lang='und'>  make pdb</pre>

<p>(where <code lang='und' xml:lang='und'>make</code> is the same <code lang='und' xml:lang='und'>make</code> incarnation you used to build Parrot).</p>

<p>If everything goes well, you should come up with a <em lang='und' xml:lang='und'>pdb</em> executable in the same directory as the Parrot program.</p>

<h1><a name="THE_DEBUGGER_SHELL"
>THE DEBUGGER SHELL <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>To start the debugger type:</p>

<pre lang='und' xml:lang='und'>  pdb file.pbc</pre>

<p>That is, <em lang='und' xml:lang='und'>pdb</em> takes exactly one argument, which is the Parrot bytecode that you&#39;re going to debug. <em lang='und' xml:lang='und'>pdb</em> will automatically load and disassemble the bytecode file for you.</p>

<p>Note that you can&#39;t pass command line arguments to your program when you invoke the debugger. See the <code lang='und' xml:lang='und'>run (r)</code> command below for this.</p>

<p>After the version banner, you&#39;ll see the friendly debugger prompt:</p>

<pre lang='und' xml:lang='und'>  (pdb)</pre>

<p><em lang='und' xml:lang='und'>pdb</em> is ready to receive commands and give output. To list the available commands type &#39;h&#39;. To quit the debugger type &#39;q&#39;.</p>

<p>As with the Perl debugger, whenever it halts and shows you a line of code, it is always the line it&#39;s <i>about</i> to execute, not the one that it has just executed.</p>

<h1><a name="DEBUGGER_COMMANDS"
>DEBUGGER COMMANDS <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>Always remember that you can enter &#39;h&#39; to get a list of commands (this document may be outdated in respect to the actual debugger, so let it speak for itself).</p>

<p>Most commands can be shortened to their first letter. When available, this is signaled by the letter in parentheses after the command name Thus, <code lang='und' xml:lang='und'>help (h)</code> means that the command can be given as &#39;help&#39; or just &#39;h&#39;. On the other hand, <code lang='und' xml:lang='und'>load</code> can only be given as &#39;load&#39;, verbatim. And the debugger is case sensitive.</p>

<p>A blank line always repeats the last command entered.</p>

<p>Also note that at this point in its development, <em lang='und' xml:lang='und'>pdb</em> has very poor error checking on commands and their arguments, so type carefully or something bad will happen. Feel free to report bugs, or better yet patch the source code (see <a href='#FILES'>&#34;FILES&#34;</a> below).</p>

<dl>
<dt><a name="disassemble"
>disassemble</a></dt><p class="pad"></p>

<dd>Disassemble a loaded bytecode file. This will turn a file loaded with <code lang='und' xml:lang='und'>load</code> into proper Parrot assembler.</dd><p class="pad"></p>

<dt><a name="load"
>load</a></dt><p class="pad"></p>

<dd>Load a source code (assembler) file. The syntax is:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  load FILE</pre>

<dt><a name="list_(l)"
>list (l)</a></dt><p class="pad"></p>

<dd>List the source code. The syntax is:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  list [FROM] [NUM]</pre>

<dd>Both arguments are optional. By default <code lang='und' xml:lang='und'>FROM</code> is from where the last list command ended (or the first line if this is the first invocation) and <code lang='und' xml:lang='und'>NUM</code> is 10. That is, it lists the source code ten lines at a time.</dd><p class="pad"></p>

<dd>Note that the disassembled source code is not the same as the original source code: labels take the names <code lang='und' xml:lang='und'>L1 .. Ln</code> and opcodes are fully qualified (eg. <code lang='und' xml:lang='und'>set_i_ic</code> instead of just <code lang='und' xml:lang='und'>set</code>). See also <code lang='und' xml:lang='und'>eval (e)</code>.</dd><p class="pad"></p>

<dd>Example:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  # lists the first three source code lines
  (pdb) l 1 3
  1  set_i_ic I1,0
  2  L3:  print_sc &#34;fact of &#34;
  3  print_i I1</pre>

<dt><a name="run_(r)"
>run (r)</a></dt><p class="pad"></p>

<dd>Run (or restart) the program. The syntax is:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  run [ARGUMENTS]</pre>

<dd>Any arguments you give are passed as command line arguments to the program (ie. they populate P0).</dd><p class="pad"></p>

<dd>After the program has ended, you can run it again with this command. See also the <code lang='und' xml:lang='und'>continue (c)</code> command.</dd><p class="pad"></p>

<dd>Example:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  (pdb) r
  Restarting
  fact of 0 is: 1
  fact of 1 is: 1
  fact of 2 is: 2
  fact of 3 is: 6
  fact of 4 is: 24
  fact of 5 is: 120
  fact of 6 is: 720
  Program exited.</pre>

<dt><a name="break_(b)"
>break (b)</a></dt><p class="pad"></p>

<dd>Add a breakpoint. The syntax is:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  b LINE [if CONDITION]</pre>

<dd>If you want a conditional breakpoint you should first specify the register that is involved in the condition (at least one must be), the comparison and then the third argument can be either another register or a constant, which must be of the same type as the first register specified.</dd><p class="pad"></p>

<dd>The command returns a number which is the breakpoint identifier. You should note this number for the <code lang='und' xml:lang='und'>delete (d)</code> command (see below).</dd><p class="pad"></p>

<dd>Example:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  # sets a breakpoint on line 10 (will be breakpoint 0)
  (pdb) b 10
  Breakpoint 0 at line 10

  # another breakpoint on line 11 (will be breakpoint 1)
  (pdb) b 11
  Breakpoint 1 at line 11

  # break at line 4 if I16 is less than or equal to 123456
  (pdb) b 4 if I16 &#60;= 123456
  Breakpoint 2 at line 4

  # break at line 4 if N27 is greater than 5.23
  (pdb) b 5 if N27 &#62; 5.23
  Breakpoint 3 at line 5

  # break at line 4 if S2 is equal to S13
  (pdb) b 6 if S2 == S13
  Breakpoint 4 at line 6

  # break at line 4 if S5 is equal to &#34;stop&#34;
  (pdb) b 7 if S2 == &#34;stop&#34;
  Breakpoint 5 at line 7</pre>

<dt><a name="watch_(w)"
>watch (w)</a></dt><p class="pad"></p>

<dd>Add a watchpoint. The syntax is:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  w CONDITION</pre>

<dd>The condition has the same format as in <code lang='und' xml:lang='und'>break</code></dd><p class="pad"></p>

<dt><a name="delete_(d)"
>delete (d)</a></dt><p class="pad"></p>

<dd>Delete a breakpoint. The syntax is:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  d NUM</pre>

<dd>The <code lang='und' xml:lang='und'>NUM</code> argument is the breakpoint number (from 0 to N) as emitted by the <code lang='und' xml:lang='und'>break (b)</code> command. It is NOT the line that has the breakpoint.</dd><p class="pad"></p>

<dd>Example:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  # delete the first breakpoint (was on line 10, see example above)
  (pdb) d 0</pre>

<dt><a name="disable"
>disable</a></dt><p class="pad"></p>

<dd>Disable a breakpoint. The syntax is the same as for the <code lang='und' xml:lang='und'>delete</code> command. Disabled breakpoints can be reenabled with <code lang='und' xml:lang='und'>enable</code>.</dd><p class="pad"></p>

<dt><a name="enable"
>enable</a></dt><p class="pad"></p>

<dd>Reenable a disabled breakpoint. The syntax is:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  enable [NUM]</pre>

<dd>where <code lang='und' xml:lang='und'>NUM</code> is the number of the breakpoint.</dd><p class="pad"></p>

<dt><a name="continue_(c)"
>continue (c)</a></dt><p class="pad"></p>

<dd>Continue the program execution. The syntax of this command is:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  continue [NUM]</pre>

<dd>Without arguments, the command just runs the source code until a breakpoint is found (or until the end of the program).</dd><p class="pad"></p>

<dd>If you specify a number, it will skip the next <code lang='und' xml:lang='und'>NUM</code> breakpoints it encounters.</dd><p class="pad"></p>

<dd>When the program has ended, continue will do nothing. Use <code lang='und' xml:lang='und'>run (r)</code> to execute it again.</dd><p class="pad"></p>

<dt><a name="next_(n)"
>next (n)</a></dt><p class="pad"></p>

<dd>Run the next instruction. The syntax is:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  next [NUM]</pre>

<dd><code lang='und' xml:lang='und'>NUM</code> defaults to 1, but you can give a number of instructions to execute before stopping again.</dd><p class="pad"></p>

<dt><a name="eval_(e)"
>eval (e)</a></dt><p class="pad"></p>

<dd>Run an instruction. The syntax is:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  eval INSTRUCTION</pre>

<dd>Example:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  (pdb) e set I0, 42

  (pdb) e print I0
  42

  (pdb) p i
  I0 =           42
  I1 =            0
  ...</pre>

<dt><a name="trace_(t)"
>trace (t)</a></dt><p class="pad"></p>

<dd>Trace the next instruction. The syntax is:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  trace [NUM]</pre>

<dd>It executes the next <code lang='und' xml:lang='und'>NUM</code> instructions (default is 1) just as <code lang='und' xml:lang='und'>next (n)</code> does, but printing additional trace information. This is the same as the information you get when running Parrot with the <code lang='und' xml:lang='und'>&#45;t</code> option.</dd><p class="pad"></p>

<dd>Example:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  # executes 2 instructions and trace them
  (pdb) t 2
  PC=0; OP=67 (set_i_ic); ARGS=(I1=0, 0)
  PC=3; OP=24 (print_sc); ARGS=(&#34;fact of &#34;)
  fact of
  3  print_i I1</pre>

<dt><a name="print_(p)"
>print (p)</a></dt><p class="pad"></p>

<dd>Print the interpreter registers. The syntax is:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  print VALUE</pre>

<dd><code lang='und' xml:lang='und'>VALUE</code> may be:</dd><p class="pad"></p>

<dl>
<dt><a name="A_register_name:_I3"
>A register name: <b><code lang='und' xml:lang='und'>I3</b></code></a></dt><p class="pad"></p>

<dd>Prints out the single register specified.</dd><p class="pad"></p>

<dt><a name="A_register_type:_i,_n,_s,_or_p"
>A register type: <b><code lang='und' xml:lang='und'>i</b></code>, <b><code lang='und' xml:lang='und'>n</b></code>, <b><code lang='und' xml:lang='und'>s</b></code>, or <b><code lang='und' xml:lang='und'>p</b></code></a></dt><p class="pad"></p>

<dd>Prints out all registers of the given type</dd><p class="pad"></p>

<dt><a name="An_aggregate_key:_P0[1]"
>An aggregate key: <b><code lang='und' xml:lang='und'>P0[1]</b></code></a></dt><p class="pad"></p>

<dd>Looks up the given (integer&#45; or string&#45;valued) key in a PMC register.</dd><p class="pad"></p>
</dl>

<dd>For PMC registers, the command will print the number, the class of the PMC (in square brackets) and its string representation (when available). It prints &#60;null pmc&#62; for uninitialized PMC registers.</dd><p class="pad"></p>

<dd>Example:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  # prints the content of I2
  (pdb) p i2
  Integer Registers:
  I2 =              0

  # prints the content of P0
  (pdb) p P0
  PMC Registers:
  P0 = [PerlArray]

  # prints the content of all string registers
  (pdb) p s
  String Registers:
   0 =
          Buflen  =                  4
          Flags   =                  0
          Bufused =                  4
          Strlen  =                  4
          Offset  =                  0
          String  =       Just
   1 =
          Buflen  =                  8
          Flags   =                  0
          Bufused =                  7
          Strlen  =                  7
          String  =       another
   2 =
          Buflen  =                  8
          Flags   =                  0
          Bufused =                  6
          Strlen  =                  6
          String  =       Parrot
   3 =
          Buflen  =                  8
          Flags   =                  0
          Bufused =                  6
          Strlen  =                  6
          String  =       hacker
   4 =
   5 =
   6 =
   7 =
   8 =
   # ... and so on</pre>

<dt><a name="stack_(s)"
>stack (s)</a></dt><p class="pad"></p>

<dd>Examine the stack. The syntax is:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  stack TYPE [NUM]
  stack NUM</pre>

<dd>The first form prints entries from the register stacks (eg. results from <code lang='und' xml:lang='und'>push_i</code>, <code lang='und' xml:lang='und'>push_n</code>, <code lang='und' xml:lang='und'>push_s</code> and <code lang='und' xml:lang='und'>push_p</code>). For the meaning of <code lang='und' xml:lang='und'>TYPE</code> see the <code lang='und' xml:lang='und'>print (p)</code> command. The <code lang='und' xml:lang='und'>NUM</code> argument is the frame number (defaults to 0). The whole frame (0..31) is printed out.</dd><p class="pad"></p>

<dd>The second form prints a single entry (<code lang='und' xml:lang='und'>NUM</code>) from the generic stack (eg. results from <code lang='und' xml:lang='und'>save</code>), prepending the type of the entry on output.</dd><p class="pad"></p>

<dd>Example:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  # prints the value on top of the generic stack
  (pdb) s 0
  Integer =             42

  # prints the first integer register stack frame
  (pdb) s i
  Integer stack, frame 0, depth 0
  Integer Registers:
   0 =              0
   1 =              0
   2 =              0
   3 =              0
   4 =              0
   5 =              0
   6 =              0
   7 =              0
   8 =              0
   # ... and so on</pre>

<dt><a name="info"
>info</a></dt><p class="pad"></p>

<dd>Print interpreter information.</dd><p class="pad"></p>

<dd>Example:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  (pdb) info
  Total memory allocated = 81936
  DOD runs = 6
  Collect runs = 0
  Active PMCs = 8197
  Active buffers = 7
  Total PMCs = 21840
  Total buffers = 48
  Header allocations since last collect = 0
  Memory allocations since last collect = 2</pre>

<dt><a name="quit_(q)"
>quit (q)</a></dt><p class="pad"></p>

<dd>Exit the debugger.</dd><p class="pad"></p>

<dt><a name="help_(h)"
>help (h)</a></dt><p class="pad"></p>

<dd>Prints information about debugger commands. The syntax is:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  help [COMMAND]</pre>

<dd>If <code lang='und' xml:lang='und'>COMMAND</code> is omitted, prints a list of the available commands.</dd><p class="pad"></p>
</dl>

<h1><a name="FILES"
>FILES <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<dl>
<dt><a name="src/pdb.c"
>src/pdb.c</a></dt><p class="pad"></p>

<dd>This is the file that will produce the executable. Nothing fancy here, only the <code lang='und' xml:lang='und'>main</code> function.</dd><p class="pad"></p>

<dt><a name="src/debug.c"
>src/debug.c</a></dt><p class="pad"></p>

<dd>Most of the debugger is implemented here. You may want to start from the <code lang='und' xml:lang='und'>PDB_run_command</code> function and go down from there for the real meat.</dd><p class="pad"></p>

<dt><a name="src/embed.c"
>src/embed.c</a></dt><p class="pad"></p>

<dd><code lang='und' xml:lang='und'>Parrot_debug</code>, the function which launches the debugger, is implemented here.</dd><p class="pad"></p>

<dt><a name="include/parrot/debug.h"
>include/parrot/debug.h</a></dt><p class="pad"></p>

<dd>This defines all the PDB structures, which hold data used by the debugger.</dd><p class="pad"></p>
</dl>

<h1><a name="HISTORY"
>HISTORY <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<dl>
<dt><a name="Version_1.0"
>Version 1.0</a></dt><p class="pad"></p>

<dd>First version (SVN debug.c revision 1.24), authored by Aldo Calpini</dd><p class="pad"></p>
</dl>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
