<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Parrot FAQ</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Parrot FAQ</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../html/index.html">Contents</a> | <a href="../../html/docs.html">Documentation</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>docs/faq.pod &#45; Parrot FAQ</p>

<h1><a name="GENERAL_QUESTIONS"
>GENERAL QUESTIONS <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<h2><a name="What_is_Parrot?"
>What is Parrot? <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Parrot is the new interpreter being designed from scratch to support the upcoming Perl6 language.
It is being designed as a standalone virtual machine that can be used to execute bytecode compiled dynamic languages such as Perl6,
but also Perl5.
Ideally,
Parrot can be used to support other dynamic,
bytecode&#45;compiled languages such as Python,
Ruby and Tcl.</p>

<h2><a name="Why_&#34;Parrot&#34;?"
>Why &#34;Parrot&#34;? <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>The name &#34;Parrot&#34; relates to Simon Cozens&#39;s <a href='#LINKS'>April Fool&#39;s Joke</a> where Larry Wall and Guido van Rossum announced the merger of the Perl and Python languages.</p>

<p>As penance,
Simon spent time as Parrot&#39;s lead developer,
but he&#39;s gotten better.</p>

<h2><a name="Is_Parrot_the_same_as_Perl_6?"
>Is Parrot the same as Perl 6? <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>No.
Parrot is an implementation that is expected to be used to execute Perl6 programs.
The Perl6 language definition is currently being crafted by Larry Wall.
While the true nature of Perl6 is still unknown,
it will be substantially similar to Perl as we know it today,
and will need a runtime system.
For more information on the nascent Perl6 language definition,
check out Larry&#39;s <a href='#LINKS'>apocalypses</a>.</p>

<h2><a name="Can_I_use_Parrot_today?"
>Can I use Parrot today? <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Yes.</p>

<p>Parrot is in the early phases of its implementation.
The primary way to use Parrot is to write Parrot assembly code,
described in <a href='TODO#pdd6.pod'>PDD6</a>.</p>

<p>You can also create dynamic content within Apache using Ask Bjorn Hansen&#39;s mod_parrot module.
You are strongly advised that mod_parrot is a toy,
and should not be used with any production code.</p>

<h2><a name="Why_should_I_program_in_Parrot_Assembly_language?"
>Why should I program in Parrot Assembly language? <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Lots of reasons,
actually.
:^)</p>

<ul>
<li>All the <a href='#LINKS'>cool kids</a> are doing it.</li><p class="pad"></p>

<li>It&#39;s a neat hack.</li><p class="pad"></p>

<li>You get all the pleasure of programming in assembly language without any of the requisite system crashes.</li><p class="pad"></p>
</ul>

<p>Seriously,
though,
programming in Parrot assembly language is an interesting challenge.
It&#39;s also one of the best ways to write test cases for Parrot.</p>

<h2><a name="When_can_I_expect_to_use_Parrot_with_a_real_programming_language?"
>When can I expect to use Parrot with a <i>real</i> programming language? <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>It depends on what you mean by <i>real</i>.
:^)</p>

<ul>
<li>Leon Brocard has released a proof&#45;of&#45;concept <a href='#LINKS'>Java bytecode to Parrot bytecode</a> compiler.</li><p class="pad"></p>

<li>Gregor Purdy is working on a little language called Jako that targets Parrot bytecode directly.
(Available with the Parrot distribution.)</li><p class="pad"></p>

<li>Dan Sugalski and Jeff Goff have started work on compiling Scheme down to Parrot bytecode.
(Available with the Parrot distribution.)</li><p class="pad"></p>

<li>Clint Pierce wrote an Integer Basic implementation in parrot assembly,
which is shipped with the parrot distribution,
as are a few example programs.
(Including Hunt the Wumpus and Eliza)</li><p class="pad"></p>

<li>There&#39;s a Befunge interpreter in the languages directory</li><p class="pad"></p>

<li>There&#39;s an (ahem)BF interpreter in the languages directory.
Be aware that BF is not,
strictly speaking,
the language&#39;s name,
merely its initials.</li><p class="pad"></p>

<li>There is a prototype Perl 6 implementation in the languages directory as well,
though it&#39;s only as complete as the Perl 6 spec.
(Which,
at this writing,
isn&#39;t sufficiently complete)</li><p class="pad"></p>
</ul>

<h2><a name="What_language_is_Parrot_written_in?"
>What language is Parrot written in? <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>C.</p>

<h2><a name="For_the_love_of_God,_man,_why?!?!?!?"
>For the love of God,
man,
why?!?!?!? <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Because it&#39;s the best we&#39;ve got.</p>

<h2><a name="That&#39;s_sad."
>That&#39;s sad. <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>So true.
Regardless,
C&#39;s available pretty much everywhere.
Perl 5&#39;s in C,
so we can potentially build any place Perl 5 builds.</p>

<h2><a name="Why_not_write_it_in_insert_favorite_language_here?"
>Why not write it in <i>insert favorite language here</i>? <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Because of one of:</p>

<ul>
<li>Not available everywhere.</li><p class="pad"></p>

<li>Limited talent pool for core programmers.</li><p class="pad"></p>

<li>Not fast enough.</li><p class="pad"></p>
</ul>

<h2><a name="Why_aren&#39;t_you_using_external_tool_or_library_X?"
>Why aren&#39;t you using external tool or library <i>X</i>? <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>The most common issues are:</p>

<ul>
<li>License compatibility.</li><p class="pad"></p>

<p>Parrot has an odd license &#45;&#45; it currently uses the same license as Perl 5,
which is the disjunction of the GNU GPL and the Artistic License,
which can be written (Artistic|GPL) for short.
Thus,
Parrot&#39;s license is compatible with the GNU GPL,
which means you can combine Parrot with GPL&#39;ed code.</p>

<p>Code accepted into the core interpreter must fall under the same terms as parrot.
Library code (for example the ICU library we&#39;re using for Unicode) we link into the interpreter can be covered by other licenses so long as their terms don&#39;t prohibit this.</p>

<li>Platform compatibility.</li><p class="pad"></p>

<p>Parrot has to work on most of Perl 5&#39;s platforms,
as well as a few of its own.
Perl 5 runs on eighty platforms; Parrot must run on Unix,
Windows,
Mac OS (X and Classic),
VMS,
Crays,
Windows CE,
and Palm OS,
just to name a few.
Among its processor architectures will be x86,
SPARC,
Alpha,
IA&#45;64,
ARM,
and 68x00 (Palms and old Macs).
If something doesn&#39;t work on all of these,
we can&#39;t use it in Parrot.</p>

<li>Speed,
size,
and flexibility.</li><p class="pad"></p>

<p>Not only does Parrot have to run on all those platforms,
but it must also run efficiently.
Parrot&#39;s core size is currently between 250K and 700K,
depending on compiler.
That&#39;s pushing it on the handheld platforms.
Any library used by Parrot must be fast enough to have a fairly small performance impact,
small enough to have little impact on core size,
and flexible enough to handle the varying demands of Perl,
Python,
Tcl,
Ruby,
Scheme,
and whatever else some clever or twisted hacker throws at Parrot.</p>
</ul>

<p>These tests are very hard to pass; currently we&#39;re expecting we&#39;ll probably have to write everything but the Unicode stuff.</p>

<h2><a name="Why_your_own_virtual_machine?_Why_not_compile_to_JVM/.NET?"
>Why your own virtual machine?
Why not compile to JVM/.NET? <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Those VMs are designed for statically typed languages.
That&#39;s fine,
since Java,
C#,
and lots of other languages are statically typed.
Perl isn&#39;t.
For a variety of reasons,
it means that Perl would run more slowly there than on an interpreter geared towards dynamic languages.</p>

<p>The .NET VM didn&#39;t even exist when we started development,
or at least we didn&#39;t know about it when we were working on the design.
We do now,
though it&#39;s still not suitable.</p>

<h2><a name="So_you_won&#39;t_run_on_JVM/.NET?"
>So you won&#39;t run on JVM/.NET? <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Sure we will.
They&#39;re just not our first target.
We build our own interpreter/VM,
then when that&#39;s working we start in on the JVM and/or .NET back ends.</p>

<h2><a name="What_about_insert_other_VM_here"
>What about <i>insert other VM here</i> <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>While I&#39;m sure that&#39;s a perfectly nice,
fast VM,
it&#39;s probably got the same issues as do the languages in the &#34;Why not something besides C&#34; question does.
I realize that the Scheme&#45;48 interpreter&#39;s darned fast,
for example,
but we&#39;re looking at the same sort of portability and talent pool problems that we are with,
say,
Erlang or Haskell as an implementation language.</p>

<h2><a name="Why_is_the_development_list_called_perl6&#45;internals?"
>Why is the development list called perl6&#45;internals? <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>The mailing list precedes the Parrot joke and subsequent unveiling of the True Grand Project by a number of months.
We&#39;ve just not gotten around to renaming the mailing list.
We will.</p>

<h2><a name="Pugs_is_going_great_shakes_&#45;_why_not_just_toss_Parrot_and_run_Perl_6_on_Pugs?"
>Pugs is going great shakes &#45; why not just toss Parrot and run Perl 6 on Pugs? <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Autrijus Tang,
the lead on the Pugs project,
notes that an <b>unoptimised</b> Parrot is already 30% faster than Haskell.
Add compiler optimisation and a few planned optimisations and Parrot will beat Pugs for speed hands down.
Autrijus thinks that Pugs could be made faster with some Haskell compiler tricks,
but it&#39;s harder work and less effective than the Parrot optimisations we already know how to do.</p>

<p>Perl 5 is highly portable,
and builds on around 50 different systems,
many far removed from Unix or MS Windows.
We&#39;d like Perl 6 to be able run everywhere that Perl 5 runs,
so we need to keep Parrot as portable as possible.
The Glasgow Haskell Compiler is a pain to build on minor systems,
and downright impossible on small systems.
So by going with Pugs and GHC we&#39;d be sacrificing portability.</p>

<p>As well,
other languages apart from Perl 6 are being targeted to Parrot.
Significant parts of Python,
TCL,
Perl 5,
and Basic have already been implemented and others are on the way.
Running multiple languages on the same Parrot engine allows them to be cross&#45;language compatible&#45;&#45; in other words,
one targeted language could directly invoke the methods of another at the bytecode level.</p>

<p>Finally there is a reason the Parrot design keeps talking about running bytecode direct from disk rather than relying on doing compiling (from Perl or with a JIT) in memory.
It&#39;s all very well doing such operations when running one program,
but think what happens on a multi&#45;user system when 300 people fire up &#34;parrot order.pbc&#34; &#45; 300 parrot processes all fighting for resources.
To quote Dan,</p>

<pre lang='und' xml:lang='und'>  non&#45;jit vss/rss is 29784 17312, JIT vss/rss is 122032 108916. A not
  insignificant difference :)</pre>

<p>With read only bytecode shared between processes, much of that &#34;non&#45;jit&#34; resident memory is going to be shared. So much less swapping. And don&#39;t think that this won&#39;t matter to you because you don&#39;t have 300 users all running the same program &#45; consider what happens if each Perl 6 module is compiled to bytecode. With read only bytecode 300 different Perl scripts all share the same memory for Carp.pbc, warnings.pbc, etc. Without, and they&#39;re all swapping like crazy...</p>

<h2><a name="OK,_so_Parrot_is_fast..._Pugs_can_back&#45;end_to_Parrot,_right?"
>OK, so Parrot is fast... Pugs can back&#45;end to Parrot, right? <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Yes (though at this time, that&#39;s in the early stages). Still, the ultimate goal is for Perl 6 to be self&#45;hosting (that is, written in itself) in order to improve introspection, debugger capabilities, compile&#45;time semantic modulation, etc. For this reason, Pugs will probably be the compiler that first compiles the ultimate Perl 6 compiler, but thereafter Pugs will no longer be the primary reference implementation. This is documented by the Pugs team at <a href='http://svn.perl.org/perl6/pugs/trunk/docs/01Overview.html'><a href="http://svn.perl.org/perl6/pugs/trunk/docs/01Overview.html">http://svn.perl.org/perl6/pugs/trunk/docs/01Overview.html</a></a></p>

<h1><a name="PARROT_AND_PERL"
>PARROT AND PERL <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<h2><a name="Why_re&#45;implement_Perl?"
>Why re&#45;implement Perl? <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Good question.</p>

<p>At The Perl Conference 4.0, in the summer of 2000, Larry Wall <a href='#LINKS'>announced</a> that it was time to recreate Perl from the ground up. This included the Perl language, the implementation of that language, the community of open source developers who volunteer to implement and maintain the language, and the larger community of programmers who use Perl.</p>

<p>A variety of reasons were given for embarking on this project:</p>

<ul>
<li>Perl5 is a stable, reliable, robust platform for developing software; it&#39;s not going away for a long time, even after Perl6 is released. (Proof: Perl4 is still out there, no matter how much we all want it to go away.)</li><p class="pad"></p>

<li>We have the ability to translate Perl5 into Perl6 if necessary. This preserves backward compatibility with a large body of existing Perl code, which is <i>very</i> important.</li><p class="pad"></p>

<li>The language can stand some revision: formats don&#39;t really belong in the core language, and typeglobs have outlived their usefulness. By revising the language now, we can make Perl better.</li><p class="pad"></p>

<li>Some warts really should be removed: <code lang='und' xml:lang='und'>system</code> should return <i>true</i> instead of <i>false</i> on success, and <code lang='und' xml:lang='und'>localtime</code> should return the year, not the year &#45; 1900.</li><p class="pad"></p>

<li>It would be nice to write the Perl to Bytecode compiler in Perl, instead of C. That would make it much easier for Perl hackers to hack on Perl.</li><p class="pad"></p>
</ul>

<h2><a name="You_want_to_write_the_Perl_compiler_in_Perl?"
>You want to write the Perl compiler in Perl? <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Sure. Why not? C, Java, Lisp, Scheme, and practically every other language is self&#45;hoisting. Why not?</p>

<h2><a name="Isn&#39;t_there_a_bootstrapping_problem?"
>Isn&#39;t there a bootstrapping problem? <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>No, not really. Don&#39;t forget that we can use Perl 5 to run Perl 5 programs, such as a Perl 5 to Parrot compiler.</p>

<h2><a name="How_will_Parrot_handle_both_Perl_5_and_Perl_6?"
>How will Parrot handle both Perl 5 and Perl 6? <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>We don&#39;t know yet, since it depends on the Perl 6 language definition. But we <i>could</i> use the more appropriate of two Perl compilers, depending of whether we&#39;re compiling Perl 5 or Perl 6. Larry has mumbled something about a <code lang='und' xml:lang='und'>package</code> statement declaring that the file is Perl 5, but we&#39;re still not quite sure on how that fits in.</p>

<h2><a name="Is_this_how_Parrot_will_run_Python,_Ruby,_and_Tcl_code?"
>Is this how Parrot will run Python, Ruby, and Tcl code? <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Probably.</p>

<h2><a name="Latin_and_Klingon_too?"
>Latin and Klingon too? <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>No, Parrot won&#39;t be twisted enough for Damian. Perhaps when Parrot is ported to a pair of supercool calcium ions, though...</p>

<h2><a name="Huh?"
>Huh? <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>You had to <a href='#LINKS'>be there</a>.</p>

<h1><a name="PARROT_IMPLEMENTATION_ISSUES"
>PARROT IMPLEMENTATION ISSUES <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<h2><a name="What&#39;s_with_the_whole_register_thing_machine?"
>What&#39;s with the whole register thing machine? <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Not much, why do you ask?</p>

<h2><a name="Don&#39;t_you_know_that_stack_machines_are_the_way_to_go_in_software?"
>Don&#39;t you know that stack machines are the way to go in software? <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>No, in fact, I don&#39;t.</p>

<h2><a name="But_look_at_all_the_successful_stack&#45;based_VMs!"
>But look at all the successful stack&#45;based VMs! <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Like what? There&#39;s just the JVM.</p>

<h2><a name="What_about_all_the_others?"
>What about all the others? <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p><b>What</b> others? That&#39;s it, unless you count Perl, Python, or Ruby.</p>

<h2><a name="Yeah_them!"
>Yeah them! <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Yeah, right. You never thought of them as VMs, admit it. :^)</p>

<p>Seriously, we&#39;re already running with a faster opcode dispatch than any of them are, and having registers just decreases the amount of stack thrash we get.</p>

<h2><a name="Right,_smarty._Then_name_a_successful_register&#45;based_VM!"
>Right, smarty. Then name a successful register&#45;based VM! <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>The 68K emulator Apple ships with all its PPC&#45;enabled versions of Mac OS.</p>

<h2><a name="Really?"
>Really? <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p><a href='#LINKS'>Really.</a></p>

<h2><a name="You&#39;re_not_using_reference_counting._Why_not?"
>You&#39;re not using reference counting. Why not? <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Reference counting has three big issues.</p>

<dl>
<dt><a name="Code_complexity"
>Code complexity</a></dt><p class="pad"></p>

<dd>Every single place where an object is referenced, and every single place where a reference is dropped, <i>must</i> properly alter the refcount of the objects being manipulated. One mistake and an object (and everything it references, directly or indirectly) lives forever or dies prematurely. Since a lot of code references objects, that&#39;s a lot of places to scatter reference counting code. While some of it can be automated, that&#39;s a lot of discipline that has to be maintained.</dd><p class="pad"></p>

<dd>It&#39;s enough of a problem to track down garbage collection systems as it is, and when your garbage collection system is scattered across your entire source base, and possibly across all your extensions, it&#39;s a massive annoyance. More sophisticated garbage collection systems, on the other hand, involve much less code. It is, granted, trickier code, but it&#39;s a small chunk of code, contained in one spot. Once you get that one chunk correct, you don&#39;t have to bother with the garbage collector any more.</dd><p class="pad"></p>

<dt><a name="Cost"
>Cost</a></dt><p class="pad"></p>

<dd>For reference counting to work right, you need to twiddle reference counts every time an object is referenced, or unreferenced. This generally includes even short&#45;lived objects that will exist only briefly before dying. The cost of a reference counting scheme is directly linked to the number of times code references, or unreferences, objects. A tracing system of one sort or another (and there are many) has an average&#45;case cost that&#39;s based on the number of live objects.</dd><p class="pad"></p>

<dd>There are a number of hidden costs in a reference&#45;counting scheme. Since the code to manipulate the reference counts <i>must</i> be scattered throughout the interpreter, the interpreter code is less dense than it would be without reference counts. That means that more of the processor&#39;s cache is dedicated to reference count code, code that is ultimately just interpreter bookkeeping, and not dedicated to running your program. The data is also less dense, as there has to be a reference count embedded in it. Once again, that means more cache used for each object during normal running, and lower cache density.</dd><p class="pad"></p>

<dd>A tracing collector, on the other hand, has much denser code, since all it&#39;s doing is running through active objects in a tight loop. If done right, the entire tracing system will fit nicely in a processor&#39;s L1 cache, which is about as tight as you can get. The data being accessed is also done in a linear fashion, at least in part, which lends itself well to processor&#39;s prefetch mechanisms where they exist. The garbage collection data can also be put in a separate area and designed in a way that&#39;s much tighter and more cache&#45;dense.</dd><p class="pad"></p>

<dd>Having said that, the worst&#45;case performance for a tracing garbage collecting system is worse than that of a reference counting system. Luckily the pathological cases are quite rare, and there are a number of fairly good techniques to deal with those. Refcounting schemes are also more deterministic than tracing systems, which can be an advantage in some cases. Making a tracing collector deterministic can be somewhat expensive.</dd><p class="pad"></p>

<dt><a name="Self&#45;referential_structures_live_forever"
>Self&#45;referential structures live forever</a></dt><p class="pad"></p>

<dd>Or nearly forever. Since the only time an object is destroyed is when its refcount drops to zero, data in a self&#45;referential structure will live on forever. It&#39;s possible to detect this and clean it up, of course... by implementing a full tracing garbage collector. That means that you have two full garbage collection systems rather than one, which adds to the code complexity.</dd><p class="pad"></p>
</dl>

<h2><a name="Could_we_do_a_partial_refcounting_scheme?"
>Could we do a partial refcounting scheme? <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Well... no. It&#39;s all or nothing. If we were going to do a partial scheme we might as well do a full scheme. (A partial refcounting scheme is actually more expensive, since partial schemes check to see whether refcounts need twiddling, and checks are more expensive than you might think)</p>

<h2><a name="Why_are_there_so_many_opcodes?"
>Why are there so many opcodes? <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Whether we have a lot or not actually depends on how you count. In absolute, unique op numbers we have more than pretty much any other processor, but that is in part because we have *no* runtime op variance.</p>

<p>It&#39;s also important to note that there&#39;s no less code involved (or, for the hardware, complexity) doing it our way or the decode&#45;at&#45;runtime way &#45;&#45; all the code is still there in every case, since we all have to do the same things (add a mix of ints, floats, and objects, with a variety of ways of finding them) so there&#39;s no real penalty to doing it our way. It actually simplifies the JIT some (no need to puzzle out the parameter types), so in that we get a win over other platforms since JIT expenses are paid by the user every run, while our form of decoding&#39;s only paid when you compile.</p>

<p>Finally, there&#39;s the big &#34;does it matter, and to whom?&#34; question. As someone actually writing parrot assembly, it looks like parrot only has one &#34;add&#34; op &#45;&#45; when emitting pasm or pir you use the &#34;add&#34; mnemonic. That it gets qualified and assembles down to one variant or another based on the (fixed at assemble time) parameters is just an implementation detail. For those of us writing op bodies, it just looks like we&#39;ve got an engine with full signature&#45;based dispatching (which, really, we do &#45;&#45; it&#39;s just a static variant), so rather than having to have a big switch statement or chain of ifs at the beginning of the add op we just write the specific variants identified by function prototype and leave it to the engine to choose the right variant.</p>

<p>Heck, we could, if we chose, switch over to a system with a single add op with tagged parameter types and do runtime decoding without changing the source for the ops at all &#45;&#45; the op preprocessor could glom them all together and autogenerate the big switch/if ladder at the head of the function. (We&#39;re not going to, of course, but we could.)</p>

<h2><a name="What_are_the_criteria_for_adding_and_deleting_opcodes?"
>What are the criteria for adding and deleting opcodes? <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>As for what the rationale is... well, it&#39;s a combination of whim and necessity for adding them, and brutal reality for deleting them.</p>

<p>Our ops fall into two basic categories. The first, like add, are just basic operations that any engine has to perform. The second, like time, are low&#45;level library functions.</p>

<p>For something like hardware, splitting standard library from the CPU makes sense &#45;&#45; often the library requires resources that the hardware doesn&#39;t have handy. Hardware is also often bit&#45;limited &#45;&#45; opcodes need to fit in 8 or 9 bits.</p>

<p>Parrot, on the other hand, *isn&#39;t* bit&#45;limited, since our ops are 32 bits. (A more efficient design on RISC systems where byte&#45;access is expensive.) That opens things up a bunch.</p>

<p>If you think about it, the core opcode functions and the core low&#45;level libraries are *always* available. Always. The library functions also have a very fixed parameter list. Fixed parameter list, guaranteed availability... looks like an opcode function to me. So they are. We could make them library functions instead, but all that&#39;d mean would be that they&#39;d be more expensive to call (our sub/method call is a bit heavyweight) and that you&#39;d have to do more work to find and call the functions. Seemed silly.</p>

<p>Or, I suppose, you could think of it as if we had *no* opcodes at all other than end and loadoplib. Heck, we&#39;ve a loadable opcode system &#45;&#45; it&#39;d not be too much of a stretch to consider all the opcode functions other than those two as just functions with a fast&#45;path calling system. The fact that a while bunch of &#39;em are available when you start up&#39;s just a convenience for you.</p>

<p>See <a href='http://www.nntp.perl.org/group/perl.perl6.internals/22003'><a href="http://www.nntp.perl.org/group/perl.perl6.internals/22003">http://www.nntp.perl.org/group/perl.perl6.internals/22003</a></a> for more details.</p>

<h1><a name="LINKS"
>LINKS <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>April Fool&#39;s Joke: <a href="http://www.perl.com/pub/a/2001/04/01/parrot.htm">http://www.perl.com/pub/a/2001/04/01/parrot.htm</a></p>

<p>apocalypses: <a href="http://dev.perl.org/perl6/apocalypse/">http://dev.perl.org/perl6/apocalypse/</a></p>

<p>exegeses: <a href="http://dev.perl.org/perl6/exegesis/">http://dev.perl.org/perl6/exegesis/</a></p>

<p>synopses: <a href="http://dev.perl.org/perl6/synopsis/">http://dev.perl.org/perl6/synopsis/</a></p>

<p>Java bytecode to Parrot bytecode: <a href="http://archive.develooper.com/perl6&#45;internals@perl.org/msg03864.html">http://archive.develooper.com/perl6&#45;internals@perl.org/msg03864.html</a></p>

<p><a href="http://www.perl.com/pub/a/2000/10/23/soto2000.html">http://www.perl.com/pub/a/2000/10/23/soto2000.html</a></p>

<p>be there: <a href="http://www.csse.monash.edu.au/~damian/papers/#Superpositions">http://www.csse.monash.edu.au/~damian/papers/#Superpositions</a></p>

<p>Really.: <a href="http://developer.apple.com/techpubs/mac/PPCSoftware/PPCSoftware&#45;13.html">http://developer.apple.com/techpubs/mac/PPCSoftware/PPCSoftware&#45;13.html</a></p>

<h1><a name="VERSION"
>VERSION <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>The FAQ is now in version control and &#34;Revision&#34; isn&#39;t really being tracked. The most recent SVN ID is <code lang='und' xml:lang='und'>$Id$</code></p>

<dl>
<dt><a name="Revision_0.5_&#45;_04_September_2002"
>Revision 0.5 &#45; 04 September 2002</a></dt><p class="pad"></p>

<dt><a name="Revision_0.4_&#45;_26_August_2002"
>Revision 0.4 &#45; 26 August 2002</a></dt><p class="pad"></p>

<dd>Fixed up the licensing bits</dd><p class="pad"></p>

<dt><a name="Revision_0.3_&#45;_13_March_2002"
>Revision 0.3 &#45; 13 March 2002</a></dt><p class="pad"></p>

<dd>Translated to POD and added &#34;Why aren&#39;t we using external tool or library <i>X</i>?&#34;</dd><p class="pad"></p>

<dt><a name="Revision_0.2_&#45;_03_December_2001"
>Revision 0.2 &#45; 03 December 2001</a></dt><p class="pad"></p>

<dd>Added the &#34;Parrot and Perl&#34; section and &#34;Why Re&#45;implement Perl&#34;. Incorporated Dan&#39;s Q&#38;A items.</dd><p class="pad"></p>

<dt><a name="Revision_0.1_&#45;_03_December_2001"
>Revision 0.1 &#45; 03 December 2001</a></dt><p class="pad"></p>

<dd>Adopted from Simon Cozens&#39;s article, &#34;Parrot: A Cross&#45;Language Virtual Machine Architecture&#34;.</dd><p class="pad"></p>
</dl>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
