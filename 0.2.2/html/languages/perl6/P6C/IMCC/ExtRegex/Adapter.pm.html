<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Untitled</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Untitled</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../../../../html/index.html">Contents</a> | <a href="../../../../../../html/languages.html">Language Implementations</a> | <a href="../../../../../../html/perl6.html">Perl6</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="P6C::IMCC::ExtRegex::Adapter"
><b>P6C::IMCC::ExtRegex::Adapter</b> <a href='#_top'><img alt='^' border=0 src='../../../../../../resources/up.gif'></a></a></h1>

<p>Convert the native perl6 compiler&#39;s representation of a regex parse tree into languages/regex&#39;s format.</p>

<dl>
<dt><a name="convert_p6tree"
>convert_p6tree</a></dt><p class="pad"></p>

<dd>Convert a P6C parse tree to a regex tree.
Main entry point.
Calls convert() to do the dirty work.</dd><p class="pad"></p>

<dt><a name="convert"
>convert</a></dt><p class="pad"></p>

<dd>Recursively perform the conversion.
For any node type <code lang='und' xml:lang='und'>TYPE</code>,
calls a method named <code lang='und' xml:lang='und'>convert_TYPE</code>.</dd><p class="pad"></p>

<dt><a name="convert_rule"
>convert_rule</a></dt><p class="pad"></p>

<dd>Grab the parse tree out of a P6C::rule and convert it,
then wrap it in a scan node unless there was a <code lang='und' xml:lang='und'>^</code> within it.
Probably buggy,
since there are probably ways of having a <code lang='und' xml:lang='und'>^</code> that does not apply to the entire expression.</dd><p class="pad"></p>

<dt><a name="convert_rx_alt"
>convert_rx_alt</a></dt><p class="pad"></p>

<dd>P6C::rx_alt(T) &#45;&#62; Regex::Ops::Tree::alternate(branches of T)</dd><p class="pad"></p>

<dt><a name="convert_rx_seq"
>convert_rx_seq</a></dt><p class="pad"></p>

<dd>P6C::rx_seq(T) &#45;&#62; Regex::Ops::Tree::seq(elements of T)</dd><p class="pad"></p>

<dt><a name="convert_rx_atom"
>convert_rx_atom</a></dt><p class="pad"></p>

<dd>Convert P6C::rx_atom(T) depending on what kind of atom T is.
A P6C::rx_val is converted directly; an ARRAY is treated as a code block; if T has a type field that is of type <code lang='und' xml:lang='und'>PerlArray</code>,
then it is matched as an array literal (as if it were an alternation of each of its elements); otherwise,
it is assumed to be a string.</dd><p class="pad"></p>

<dd>This also plays around with group captures.
It increments the group id ($1 &#45;&#62; $2 etc.) Which is overly simplistic and stupid.</dd><p class="pad"></p>

<dt><a name="intvalue"
>intvalue</a></dt><p class="pad"></p>

<dd>Utility routine to extract an integer value out of a P6C tree.</dd><p class="pad"></p>

<dt><a name="convert_rx_repeat"
>convert_rx_repeat</a></dt><p class="pad"></p>

<dd>P6C::rx_repeat(T) &#45;&#62; Regex::Ops::Tree::multi_match(T.min,
T.max,
T.greedyflag,
T.expr)</dd><p class="pad"></p>

<dt><a name="convert_rx_meta"
>convert_rx_meta</a></dt><p class="pad"></p>

<dd>Convert a metacharacter (backslashed character).
Things like \s and \x34 and things.
Fun stuff.
Lots missing.</dd><p class="pad"></p>

<dt><a name="convert_rx_any"
>convert_rx_any</a></dt><p class="pad"></p>

<dd>Convert P6C::rx_any,
which represents .
in a regex,
which just means to skip ahead one character.</dd><p class="pad"></p>

<dt><a name="convert_rx_any"
>convert_rx_any</a></dt><p class="pad"></p>

<dd>Convert zero&#45;width assertion.
Currently mishandles <code lang='und' xml:lang='und'>^</code> and <code lang='und' xml:lang='und'>$</code>.
Actually,
I think the <code lang='und' xml:lang='und'>$</code> implementation may be fine.
Doesn&#39;t implement anything else.</dd><p class="pad"></p>

<dt><a name="string_to_incexc"
>string_to_incexc</a></dt><p class="pad"></p>

<dd>Generate an inclusion/exclusion list out of a string representing a character class.
An inc/exc list L is a sequence of code points representing a character class,
which can also be thought of as a set of code points.
Anything less than the first element L[0] is not in the set; anything equal to the L[0] but less than or equal to L[1] is in the set; anything greater than L[1] but less than or equal to L[2] is not in the set,
etc.</dd><p class="pad"></p>

<dd>Examples:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  ()    &#45; the empty set
  (0)   &#45; the universal set
  (5)   &#45; anything 5 or greater
  (2,4) &#45; 2 or 3</pre>

<dd>FIXME: makes no attempt to handle unicode</dd><p class="pad"></p>

<dt><a name="ord_to_incexc"
>ord_to_incexc</a></dt><p class="pad"></p>

<dd>Generate an inclusion/exclusion list from a single code point. Unless it is negated, it is kind of silly to use this instead of a simple &#39;match&#39; op.</dd><p class="pad"></p>

<dt><a name="convert_rx_oneof"
>convert_rx_oneof</a></dt><p class="pad"></p>

<dd>Convert the P6C compiler&#39;s notion of a character class into languages/regex&#39;s.</dd><p class="pad"></p>

<dt><a name="convert_rx_assertion"
>convert_rx_assertion</a></dt><p class="pad"></p>

<dd>Placeholder for assertions.</dd><p class="pad"></p>

<dt><a name="convert_rx_call"
>convert_rx_call</a></dt><p class="pad"></p>

<dd>Argument: <code lang='und' xml:lang='und'>$tree</code> &#45; A P6C::rx_call object representing a call to a nested rule within a regex match tree</dd><p class="pad"></p>

<dt><a name="convert_sv_literal"
>convert_sv_literal</a></dt><p class="pad"></p>

<dd>Matching a literal value by breaking it up into individual characters. Which seems pretty stupid at the time I&#39;m documenting this, considering that I have code to match a whole string. Oh well; with optimization, it should boil down to pretty much the same thing. And maybe there&#39;s some brilliant reason why I chose to do it this way instead. (But I doubt it; I probably just did this one first.)</dd><p class="pad"></p>
</dl>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../../../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
