<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Untitled</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Untitled</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../../html/index.html">Contents</a> | <a href="../../../../html/languages.html">Language Implementations</a> | <a href="../../../../html/perl6.html">Perl6</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="Introduction_to_the_prototype_Perl6_Compiler"
>Introduction to the prototype Perl6 Compiler <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<h2><a name="Synopsis"
>Synopsis <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>A simple introduction and overview to P6C.
This document is only to be thought of as a reference to the general flow of things; to get complete details,
refer to the source code.
If you ignore this bit now,
don&#39;t worry,
it will be said many more times :)</p>

<h2><a name="Objects"
>Objects <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>There are 3 main types of objects that are used in P6C; it&#39;s best to become familiar with them before anything else:</p>

<dl>
<dt><a name="Raw_Parse_Object"
><b>Raw Parse Object</b></a></dt><p class="pad"></p>

<dd>Raw parse objects are generated by Parse::RecDescent when it uses the grammar found in <em lang='und' xml:lang='und'>P6C/Parser.pm</em>.
They contain the raw data from the parse.
After the parse,
these objects process themselves using their <code lang='und' xml:lang='und'>tree</code> methods,
defined in <em lang='und' xml:lang='und'>P6C/Tree.pm</em>.</dd><p class="pad"></p>

<dt><a name="Node_Object"
><b>Node Object</b></a></dt><p class="pad"></p>

<dd>Nodes are processed Parser objects,
and are defined in <em lang='und' xml:lang='und'>P6C/Nodes.pm</em>.
A tree of these objects is called an op tree.
This tree is used in generating IMC code with <em lang='und' xml:lang='und'>P6C/IMCC.pm</em>.
Names mostly correspond to the rulenames from the grammar,
but not entirely.
Some are omitted,
and two &#45;&#45; ValueList and Register &#45;&#45; are added.</dd><p class="pad"></p>

<dt><a name="Context_Object"
><b>Context Object</b></a></dt><p class="pad"></p>

<dd>Context objects are defined in <em lang='und' xml:lang='und'>P6C/Context.pm</em>,
and are actually a data member of Node objects (although they are added during the context propagation phase,
rather than the parse tree deciphering phase.) Context objects contain the current context information of the associated node.</dd><p class="pad"></p>
</dl>

<h2><a name="Flow_Control"
>Flow Control <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>As a brief overview,
the whole process works like this: First,
perl6 code is parsed using <em lang='und' xml:lang='und'>P6C/Parser.pm</em>,
which generates a raw parse tree.
The raw tree is then processed by methods found in <em lang='und' xml:lang='und'>P6C/Tree.pm</em>,
turning the raw parse objects into an optree.
Context is propagated onto the optree with <em lang='und' xml:lang='und'>P6C/Context.pm</em>,
and then evaluated and compiled to intermediate code by <code lang='und' xml:lang='und'>imcc</code>.
<code lang='und' xml:lang='und'>imcc</code> then translates...this into parrot assembly code,
which is then assembled into bytecode by the parrot assembler and run.
It&#39;s just that simple.</p>

<h2><a name="In_more_detail"
>In more detail <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>The first thing perl6 will do is start the first pass over your code: parse it.
Assuming a normal run (no flags),
perl6 will use the precompiled parser,
<em lang='und' xml:lang='und'>Perl6Grammar.pm</em>.
If you made any changes to the grammar in <em lang='und' xml:lang='und'>P6C/Parser.pm</em>,
you&#39;ll need to run your code with the &#45;&#45;force&#45;grammar flag to recompile it.</p>

<h2><a name="The_Parser"
>The Parser <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Before the grammar itself is described,
an overview of the parser will be helpful.
The parser works by recursively defining a statement down to its most basic levels,
and then turning the matched statement into a tree&#45;like structure of objects.
For instance,
a small program like this:</p>

<pre lang='und' xml:lang='und'> $x = 4;
 $y = $x + 6;
 print $y;</pre>

<p>Could be visualized as:</p>

<pre lang='und' xml:lang='und'> Program
    scalar expression
        operator &#39;=&#39;
            left  =&#62; variable
                        sigil   =&#62; &#39;$&#39;
                        varname =&#62; &#39;x&#39;
            right =&#62; scalar literal
                        type  =&#62; number
                        value =&#62; 4
    scalar expression
        operator &#39;=&#39;
            left  =&#62; variable
                        sigil   =&#62; &#39;$&#39;
                        varname =&#62; &#39;y&#39;
            right =&#62; scalar expression
                        operator &#39;+&#39;
                            left  =&#62; variable
                                        sigil   =&#62; &#39;$&#39;
                                        varname =&#62; &#39;x&#39;
                            right =&#62; scalar literal
                                        type  =&#62; number
                                        value =&#62; 6
    scalar expression
        prefix &#39;print&#39;
            args =&#62; variable
                        sigil   =&#62; &#39;$&#39;
                        varname =&#62; &#39;y&#39;</pre>

<p>Each node on this tree is actually an object in the form of a blessed anonymous array, created as a result of the grammar&#39;s autoaction. It holds the raw data from the parse; one element per production.</p>

<p>Next, on to the grammar. As stated earlier, the grammar is written in Parse::RecDescent. For almost all cases, rules should be written without an action as the final production, so that the autoaction that turns the match into an object can be applied. To get a real idea of what&#39;s going on, you should read through the grammar; it&#39;s long, but most rules are short. The base rule for the grammar is <code lang='und' xml:lang='und'>prog</code>, but you can probably start at <code lang='und' xml:lang='und'>stmt</code> unless you care about error handling and such.</p>

<p>A few notes about the grammar in general:</p>

<dl>
<dt><a name="&#34;Want&#34;_Rules"
><b>&#34;Want&#34; Rules</b></a></dt><p class="pad"></p>

<dd>Keywords and prefix operators use special &#34;want_for&#34; rules to match their correct definition. This is for modularity purposes. The prefix rule will match a keyword, and then do a hash lookup to find its corresponding &#34;want_for&#34; rule. For instance, if the &#34;grep&#34; keyword is found, then the lookup will then attempt to match the &#34;want_for_grep&#34; rule. The &#34;want_for&#34; rules match the &#34;body&#34; of the corresponding rule. Many builtin functions and unary operators will need their own individual &#34;want_rule&#34; for the parser to be accurate.</dd><p class="pad"></p>

<dt><a name="Regex_as_Speed_Optimizations"
><b>Regex as Speed Optimizations</b></a></dt><p class="pad"></p>

<dd>Simple rules have been redefined as compiled regular expressions for speed purposes. These include all of the binary operators, as well as the numerical constant, error flusher, and special string delimiter.</dd><p class="pad"></p>

<dt><a name="Special_Parser_Functions"
><b>Special Parser Functions</b></a></dt><p class="pad"></p>

<dd>A few notes about some of the functions in the parser: <code lang='und' xml:lang='und'>add_class</code> adds user&#45;defined classes to the parser, and <code lang='und' xml:lang='und'>add_function</code> does the same for functions. <code lang='und' xml:lang='und'>add_context</code> is used by <code lang='und' xml:lang='und'>add_function</code> to create the resulting &#34;want_for&#34; rule for the function (to handle prototypes if it has them), as well as generating the tree deciphering method (see &#34;Deciphering the Object Tree&#34; for more details). Finally, <code lang='und' xml:lang='und'>got_err</code> handles error messages.</dd><p class="pad"></p>
</dl>

<h2><a name="Deciphering_the_Object_Tree"
>Deciphering the Object Tree <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Once the parse is complete, the object tree is deciphered by a depth&#45;first recursive traversal of the parse tree using the <code lang='und' xml:lang='und'>tree</code> methods found in Tree. While there is a matching &#34;tree&#34; method for nearly every single rule defined in Parser, there is no way to &#34;generate&#34; the tree methods as they need to handle the data very specifically. However, the general gist of what they do is like this:</p>

<dl>
<dt><a name="Remove_junk_data_from_the_raw_object"
><b>Remove junk data from the raw object</b></a></dt><p class="pad"></p>

<dd>Removing junk amounts to removing the syntax that won&#39;t really matter to the compiler. For instance: removing the &#34;,&#34; from argument lists, removing special quote delimiters, or ignoring unnecessary whitespace. None of this syntax really matters internally, so it is thrown away.</dd><p class="pad"></p>

<dt><a name="Turn_the_data_into_a_processed_node_for_&#34;base&#34;_types"
><b>Turn the data into a processed node for &#34;base&#34; types</b></a></dt><p class="pad"></p>

<dd>If the object is a &#34;base&#34; type (i.e has a corresponding node type in <em lang='und' xml:lang='und'>P6C/Nodes.pm</em>), the proper information is extracted from the parse object and used to create and return a new node of that type.</dd><p class="pad"></p>

<dt><a name="Otherwise,_call_tree_on_the_remaining_sub&#45;objects"
><b>Otherwise, call tree on the remaining sub&#45;objects</b></a></dt><p class="pad"></p>

<dd>Calls the <code lang='und' xml:lang='und'>tree</code> methods of its members, gathers up the return values, and builds a branch of the optree.</dd><p class="pad"></p>
</dl>

<h2><a name="Propagating_Context"
>Propagating Context <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Propagating Context is another way of saying &#34;Figuring out what kind of value a node is expected to yield during compilation.&#34; Context information is added to a node by adding another member, <code lang='und' xml:lang='und'>ctx</code>, to the node, and setting its value equal to a context object. Context objects are defined in <em lang='und' xml:lang='und'>P6C/Context.pm</em>, which also contains the functions for figuring out context. <em lang='und' xml:lang='und'>P6C/Addcontext.pm</em> defines the <code lang='und' xml:lang='und'>ctx_left</code> and <code lang='und' xml:lang='und'>ctx_right</code> methods for each Node type (which deal with lvalue and rvalue context, respectively), that define how each Node type propagates its context.</p>

<h2><a name="Compiling_to_IMC"
>Compiling to IMC <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Once the parse tree has been post&#45;processed, the next stage is to travel through the op tree and compile it to IMC code. Each node type has a <code lang='und' xml:lang='und'>val</code> method that will be called by its parent node. This method gathers values from child nodes (by calling their <code lang='und' xml:lang='und'>val</code> methods), emits the code for the node&#39;s operation (using <code lang='und' xml:lang='und'>P6C/IMCC.pm::code</code>), and then returns the proper type for its context. Code is appended to the current function in the order in which it is generated, so subnodes have to be evaluated in the proper order. Things acting as lvalues need to define an <code lang='und' xml:lang='und'>assign</code> function. Currently only variables, variable declarations, and the ternary operator do so, but other things will need to as well at some point. Finally, regex nodes actually use an <code lang='und' xml:lang='und'>rx_val</code> function instead, which behaves differently, but serves basically the same purpose.</p>

<p>The compiler is very large, but there are a few things to note:</p>

<dl>
<dt><a name="scope"
><b>scope</b></a></dt><p class="pad"></p>

<dd>The compiler maintains a &#34;current function&#34; in which code is emitted, locals are declared, and symbol lookups begin. <code lang='und' xml:lang='und'>P6C/IMCC.pm::code($x)</code> will add the IMC code $x to the current function. Scope can further be manipulated &#34;inside&#34; a function by using <code lang='und' xml:lang='und'>push_scope</code>, which increases the depth of the scope by one, and <code lang='und' xml:lang='und'>pop_scope</code>, which lowers it by one.</dd><p class="pad"></p>

<dt><a name="symbol_table"
><b>symbol table</b></a></dt><p class="pad"></p>

<dd>The compiler also maintains a primitive symbol table. Locally scoped variables (right now, meaning &#34;function&#34; variables) can be added with <code lang='und' xml:lang='und'>add_localvar</code>. Global variables can be added with <code lang='und' xml:lang='und'>add_globalvar</code>. Lookups can be done with <code lang='und' xml:lang='und'>findvar</code>, which first searches the active function&#39;s locals, then parameters, and then finally globals. This implementation may change when lexical scoping is fully implemented.</dd><p class="pad"></p>

<dt><a name="code_generation"
><b>code generation</b></a></dt><p class="pad"></p>

<dd>There are many functions that aid in the generation of IMC code; see the <em lang='und' xml:lang='und'>P6C/IMCC.pm</em> documentation for more details.</dd><p class="pad"></p>
</dl>

<h2><a name="Finishing_the_process"
>Finishing the process <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>From this point on, most of the work is done by external parrot processes. First, <em lang='und' xml:lang='und'>P6C/IMCC.pm</em> is used to convert the op tree to .imc code. IMCC converts this code to .pasm. The assembler assembles the the .pasm to parrot bytecode, and then finally the bytecode is run by the driver.</p>

<h2><a name="Author_of_this_document"
>Author of this document <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Joseph F. Ryan (ryan.311@osu.edu)</p>

<p>$Id$</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
