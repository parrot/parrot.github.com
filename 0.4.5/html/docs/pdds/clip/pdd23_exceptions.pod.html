<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Parrot Exceptions</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Parrot Exceptions</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../../html/index.html">Contents</a> | <a href="../../../../html/docs.html">Documentation</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>docs/pdds/pdd23_exceptions.pod &#45; Parrot Exceptions</p>

<h1><a name="ABSTRACT"
>ABSTRACT <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>This document defines the requirements and implementation strategy for Parrot&#39;s exception system.</p>

<h1><a name="VERSION"
>VERSION <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>$Revision$</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>An exception system gives user&#45;developed code control over how run&#45;time error conditions are handled.
Exceptions are errors or unusual conditions that require special processing.
An exception handler performs the necessary steps to appropriately respond to a particular kind of exception.</p>

<p>Parrot is designed to support dynamic languages,
but Parrot compromises the principle of dynamic behavior when necessary.
For example,
Parrot requires any given subroutine to be fully compiled before it can be called.</p>

<p>Since the structure and content of a compiled subroutine are fixed at compile time,
it would be wasteful use the dynamic execution of opcodes at runtime to keep track of meta&#45;information about that structure &#45;&#45; <i>including the spans of opcodes that the programmer expects to throw exceptions,
and how the programmer wants to handle them.</i></p>

<h2><a name="Exception_PIR_Directives"
>Exception PIR Directives <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>These are the PIR directives relevant to exceptions and exception handlers:</p>

<dl>
<dt><a name=".begin_eh_LABEL"
><b>.begin_eh <i>LABEL</i></b></a></dt><p class="pad"></p>

<dd>A <code lang='und' xml:lang='und'>.begin_eh</code> directive marks the beginning of a span of opcodes which the programmer expects to throw an exception.
If an exception occurs in the execution of the given opcode span,
Parrot will transfer control to <i>LABEL</i>.</dd><p class="pad"></p>

<dd>[XXX &#45; Is a label a good approach?
Treating exception handlers as label jumps rather than full subroutines may be error&#45;prone,
but having the lexical stack conveniently at hand is worth a lot.]</dd><p class="pad"></p>

<dt><a name=".end_eh"
><b>.end_eh</b></a></dt><p class="pad"></p>

<dd>A <code lang='und' xml:lang='und'>.end_eh</code> marks the end of the most recent (innermost) still&#45;open exception handler opcode span.</dd><p class="pad"></p>
</dl>

<h2><a name="Exception_Opcodes"
>Exception Opcodes <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>These are the opcodes relevant to exceptions and exception handlers:</p>

<dl>
<dt><a name="throw_PMC"
><b>throw <i>PMC</i></b></a></dt><p class="pad"></p>

<dd>The <code lang='und' xml:lang='und'>throw</code> opcode throws the given PMC as an exception.</dd><p class="pad"></p>

<dd>Any PMC can be thrown,
as long as you&#39;re prepared to catch it.
If there&#39;s any chance of cross&#45;language calls &#45;&#45; and in a Parrot environment,
cross&#45;language operations are kind of the point &#45;&#45; then be prepared to catch object of classes you would never throw yourself.</dd><p class="pad"></p>

<dd>However,
it is <i>VERY STRONGLY RECOMMENDED</i> for inter&#45;HLL operation that any thrown PMC that can possibly escape your private sandbox should meet the minimal interface requirements of the <code lang='und' xml:lang='und'>parrot;exception</code> class.</dd><p class="pad"></p>

<dt><a name="rethrow"
><b>rethrow</b></a></dt><p class="pad"></p>

<dd>The <code lang='und' xml:lang='und'>rethrow</code> opcode rethrows the exception object which is currently being handled.
It can only be called from inside an exception handler.</dd><p class="pad"></p>

<dt><a name="die_&#45;&#45;_dead"
><b>die</b> <i>&#45;&#45; dead</i></a></dt><p class="pad"></p>

<dd>The <code lang='und' xml:lang='und'>die</code> opcode is,
ironically enough,
now dead.
This section of the docs will be deleted soon.</dd><p class="pad"></p>

<dt><a name="exit"
><b>exit</b></a></dt><p class="pad"></p>

<dd>The <code lang='und' xml:lang='und'>exit</code> opcode throws an exception of type <code lang='und' xml:lang='und'>parrot;exception;exit</code>.
If not caught,
this exception results eventually in Parrot executing <code lang='und' xml:lang='und'>exit(0)</code>.</dd><p class="pad"></p>

<dt><a name="pushaction_SUBPMC"
><b>pushaction <i>SUBPMC</i></b></a></dt><p class="pad"></p>

<dd><code lang='und' xml:lang='und'>pushaction</code> pushes a subroutine object onto the control stack.
If the control stack is unwound due to an exception (or <code lang='und' xml:lang='und'>popmark</code>,
or subroutine return),
the subroutine is invoked with an integer argument: <code lang='und' xml:lang='und'>0</code> means a normal return is in progress; <code lang='und' xml:lang='und'>1</code> means the stack is unwinding due to an exception.</dd><p class="pad"></p>

<dd>[XXX &#45; Seems like there&#39;s lots of room for dangerous collisions here.
Keep on the lookout.]</dd><p class="pad"></p>
</dl>

<h1><a name="STANDARD_EXCEPTION_CLASSES"
>STANDARD EXCEPTION CLASSES <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>Parrot comes with a small hierarchy of classes designed to be thrown.
Parrot throws them when internal Parrot errors occur,
and HLL creators and end users can throw them too.</p>

<p>[[[[ TODO &#45; introduce herarchy and minimal interface ]]]]</p>

<p>&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;[ WHERE CHIP LEFT OFF EDITING ]&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; &#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;[ TEXT BELOW THIS POINT IS PROBABLY WRONG ]&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;</p>

<h1><a name="HOW_PARROT_HANDLES_EXCEPTIONS"
>HOW PARROT HANDLES EXCEPTIONS <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>[I&#39;m not convinced the control stack is the right way to handle exceptions.
Most of Parrot is based on the continuation&#45;passing style of control,
shouldn&#39;t exceptions be based on it too?
See bug #38850.]</p>

<h2><a name="Opcodes_that_Throw_Exceptions"
>Opcodes that Throw Exceptions <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Exceptions have been incorporated into built&#45;in opcodes in a limited way,
but they aren&#39;t used consistently.</p>

<p>Divide by zero exceptions are thrown by <code lang='und' xml:lang='und'>div</code>,
<code lang='und' xml:lang='und'>fdiv</code>,
and <code lang='und' xml:lang='und'>cmod</code>.</p>

<p>The <code lang='und' xml:lang='und'>ord</code> opcode throws an exception when it&#39;s passed an empty argument,
or passed a string index that&#39;s outside the length of the string.</p>

<p>The <code lang='und' xml:lang='und'>classoffset</code> opcode throws an exception when it&#39;s asked to retrieve the attribute offset for a class that isn&#39;t in the object&#39;s inheritance hierarchy.</p>

<p>The <code lang='und' xml:lang='und'>find_charset</code> opcode throws an exception if the charset name it&#39;s looking up doesn&#39;t exist.
The <code lang='und' xml:lang='und'>trans_charset</code> opcode throws an exception on &#34;information loss&#34; (presumably,
this means when one charset doesn&#39;t have a one&#45;to&#45;one correspondence in the other charset).</p>

<p>The <code lang='und' xml:lang='und'>find_encoding</code> opcode throws an exception if the encoding name it&#39;s looking up doesn&#39;t exist.
The <code lang='und' xml:lang='und'>trans_encoding</code> opcode throws an exception on &#34;information loss&#34; (presumably,
this means when one encoding doesn&#39;t have a one&#45;to&#45;one correspondence in the other encoding).</p>

<p>Parrot&#39;s default version of the <code lang='und' xml:lang='und'>LexPad</code> PMC uses exceptions,
though other implementations can choose to return error values instead.
<code lang='und' xml:lang='und'>store_lex</code> throws an exception when asked to store a lexical variable in a name that doesn&#39;t exist.
<code lang='und' xml:lang='und'>find_lex</code> throws an exception when asked to retrieve a lexical name that doesn&#39;t exist.</p>

<p>Other opcodes respond to an <code lang='und' xml:lang='und'>errorson</code> setting to decide whether to throw an exception or return an error value.
<code lang='und' xml:lang='und'>find_global</code> throws an exception (or returns a Null PMC) if the global name requested doesn&#39;t exist.
<code lang='und' xml:lang='und'>find_name</code> throws an exception (or returns a Null PMC) if the name requested doesn&#39;t exist in a lexical,
current,
global,
or built&#45;in namespace.</p>

<p>It&#39;s a little odd that so few opcodes throw exceptions (these are the ones that are documented,
but a few others throw exceptions internally even though they aren&#39;t documented as doing so).
It&#39;s worth considering either expanding the use of exceptions consistently throughout the opcode set,
or eliminating exceptions from the opcode set entirely.
The strategy for error handling should be consistent,
whatever it is.
[I like the way <code lang='und' xml:lang='und'>LexPad</code>s and the <code lang='und' xml:lang='und'>errorson</code> settings provide the option for exception&#45;based or non&#45;exception&#45;based implementations,
rather than forcing one or the other.]</p>

<h2><a name="Excerpt"
>Excerpt <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>[Excerpt from &#34;Perl 6 and Parrot Essentials&#34; to seed discussion.
Out&#45;of&#45;date in some ways,
and in others it was simply speculative.]</p>

<p>Exceptions provide a way of calling a piece of code outside the normal flow of control.
They are mainly used for error reporting or cleanup tasks,
but sometimes exceptions are just a funny way to branch from one code location to another one.</p>

<p>Exceptions are objects that hold all the information needed to handle the exception: the error message,
the severity and type of the error,
etc.
The class of an exception object indicates the kind of exception it is.</p>

<p>Exception handlers are derived from continuations.
They are ordinary subroutines that follow the Parrot calling conventions,
but are never explicitly called from within user code.
User code pushes an exception handler onto the control stack with the <code lang='und' xml:lang='und'>push_eh</code> opcode.
The system calls the installed exception handler only when an exception is thrown.</p>

<pre lang='und' xml:lang='und'>    push_eh _handler            # push handler on control stack
    find_global P10, &#34;none&#34;     # may throw exception
    clear_eh                    # pop the handler off the stack
    ...

  _handler:                     # if not, execution continues here
    get_results &#39;(0,0)&#39;, P0, S0  # handler is called with (exception, message)
    ...</pre>

<p>If the global variable is found, the next statement (<code lang='und' xml:lang='und'>clear_eh</code>) pops the exception handler off the control stack and normal execution continues. If the <code lang='und' xml:lang='und'>find_global</code> call doesn&#39;t find <code lang='und' xml:lang='und'>none</code> it throws an exception by passing an exception object to the exception handler.</p>

<p>The first exception handler in the control stack sees every exception thrown. The handler has to examine the exception object and decide whether it can handle it (or discard it) or whether it should <code lang='und' xml:lang='und'>rethrow</code> the exception to pass it along to an exception handler deeper in the stack. The <code lang='und' xml:lang='und'>rethrow</code> opcode is only valid in exception handlers. It pushes the exception object back onto the control stack so Parrot knows to search for the next exception handler in the stack. The process continues until some exception handler deals with the exception and returns normally, or until there are no more exception handlers on the control stack. When the system finds no installed exception handlers it defaults to a final action, which normally means it prints an appropriate message and terminates the program.</p>

<p>When the system installs an exception handler, it creates a return continuation with a snapshot of the current interpreter context. If the exception handler just returns (that is, if the exception is cleanly caught) the return continuation restores the control stack back to its state when the exception handler was called, cleaning up the exception handler and any other changes that were made in the process of handling the exception.</p>

<p>Exceptions thrown by standard Parrot opcodes (like the one thrown by <code lang='und' xml:lang='und'>find_global</code> above or by the <code lang='und' xml:lang='und'>throw</code> opcode) are always resumable, so when the exception handler function returns normally it continues execution at the opcode immediately after the one that threw the exception. Other exceptions at the run&#45;loop level are also generally resumable.</p>

<pre lang='und' xml:lang='und'>  new P10, Exception            # create new Exception object
  set P10[&#34;_message&#34;], &#34;I die&#34;  # set message attribute
  throw P10                     # throw it</pre>

<p>Exceptions are designed to work with the Parrot calling conventions. Since the return addresses of <code lang='und' xml:lang='und'>bsr</code> subroutine calls and exception handlers are both pushed onto the control stack, it&#39;s generally a bad idea to combine the two.</p>

<h1><a name="ATTACHMENTS"
>ATTACHMENTS <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>None.</p>

<h1><a name="FOOTNOTES"
>FOOTNOTES <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>None.</p>

<h1><a name="REFERENCES"
>REFERENCES <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<pre lang='und' xml:lang='und'>  src/ops/core.ops
  src/exceptions.c
  runtime/parrot/include/except_types.pasm
  runtime/parrot/include/except_severity.pasm</pre>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
