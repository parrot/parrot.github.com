<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>PMC definition to C compiler</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">PMC definition to C compiler</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../html/index.html">Contents</a> | <a href="../../../html/tools.html">Tools</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>tools/build/pmc2c.pl &#45; PMC definition to C compiler</p>

<h1><a name="SYNOPSIS"
>SYNOPSIS <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Create <em lang='und' xml:lang='und'>src/pmc/foo.dump</em>:</p>

<pre lang='und' xml:lang='und'>    % perl tools/build/pmc2c.pl &#45;&#45;dump src/pmc/foo.pmc ...</pre>

<p>Create <em lang='und' xml:lang='und'>vtable.dump</em>:</p>

<pre lang='und' xml:lang='und'>    % perl tools/build/pmc2c.pl &#45;&#45;vtable</pre>

<p>Print a class tree for the specified PMCs:</p>

<pre lang='und' xml:lang='und'>    % perl tools/build/pmc2c.pl &#45;&#45;tree src/pmc/*.pmc</pre>

<p>Create <em lang='und' xml:lang='und'>src/pmc/foo.c</em> and <code lang='und' xml:lang='und'>pmc_foo.h</code> from <em lang='und' xml:lang='und'>src/pmc/foo.dump</em>:</p>

<pre lang='und' xml:lang='und'>    % perl tools/build/pmc2c.pl &#45;c src/pmc/foo.pmc ...</pre>

<p>Create fooX.c and pmc_fooX.h from fooX.dump files, also create libfoo.c containing the initialization function for all fooX PMCs.</p>

<pre lang='und' xml:lang='und'>    % perl tools/build/pmc2c.pl &#45;&#45;library libfoo &#45;c \
           src/pmc/foo1.pmc src/pmc/foo2.pmc ...</pre>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>The job of the PMC compiler is to take .pmc files and create C files that can be compiled for use with the Parrot interpreter.</p>

<h1><a name="COMMAND&#45;LINE_OPTIONS"
>COMMAND&#45;LINE OPTIONS <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<dl>
<dt><a name="&#45;&#45;debug"
><b><code lang='und' xml:lang='und'>&#45;&#45;debug</b></code></a></dt><p class="pad"></p>

<dd>Increase debug level</dd><p class="pad"></p>

<dt><a name="&#45;&#45;verbose"
><b><code lang='und' xml:lang='und'>&#45;&#45;verbose</b></code></a></dt><p class="pad"></p>

<dd>Increase verbose level</dd><p class="pad"></p>

<dt><a name="&#45;&#45;no&#45;lines"
><b><code lang='und' xml:lang='und'>&#45;&#45;no&#45;lines</b></code></a></dt><p class="pad"></p>

<dd>Omit source line info</dd><p class="pad"></p>

<dt><a name="&#45;&#45;no&#45;body"
><b><code lang='und' xml:lang='und'>&#45;&#45;no&#45;body</b></code></a></dt><p class="pad"></p>

<dd>Emit an empty body in the dump. This may be useful for debugging.</dd><p class="pad"></p>

<dt><a name="&#45;&#45;include=/path/to/pmc"
><b><code lang='und' xml:lang='und'>&#45;&#45;include=/path/to/pmc</b></code></a></dt><p class="pad"></p>

<dd>Specify include path where to find PMCs.</dd><p class="pad"></p>

<dt><a name="&#45;&#45;library=libname"
><b><code lang='und' xml:lang='und'>&#45;&#45;library=libname</b></code></a></dt><p class="pad"></p>

<dd>Specifiy the library name. This will create &#60;libname&#62;.c and pmc_&#60;libname&#62;.h. The initialization function will be named after libname and will initialize all PMCs in the library.</dd><p class="pad"></p>
</dl>

<h2><a name="Internals"
>Internals <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>To see the internal data structures please run:</p>

<pre lang='und' xml:lang='und'>    % perl tools/build/pmc2c.pl &#45;&#45;c &#45;&#45;deb &#45;&#45;deb sarray.pmc | less</pre>

<h2><a name="Compiling_PMCs"
>Compiling PMCs <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>First, the program determines the names of the .c and .h files from the basename of the .pmc file (e.g. <em lang='und' xml:lang='und'>perlint.pmc</em> &#45;&#62; <em lang='und' xml:lang='und'>perlint.c</em> and <em lang='und' xml:lang='und'>perlint.h</em>).</p>

<p>Next, the file is searched for <code lang='und' xml:lang='und'>/pmclass \w*/</code> which attempts to find the class being declared.</p>

<p>Once the class is found, all of its superclasses are scanned and their methods added to the methods of the current PMC. PMCs default to inheriting from &#39;default&#39;. Only single inheritance is supported.</p>

<p>Once the superclass is determined, it is processed and its method names are extracted and saved.</p>

<p>Next, each method body is processed with various directives (see below) getting replaced by their appropriate values.</p>

<p>Finally, the .c and .h files are generated. The appropriate base class header files are included.</p>

<p>If the <code lang='und' xml:lang='und'>noinit</code> flag was used, then no init function is generated. Otherwise, one is generated which sets up the vtable and enters it into the <code lang='und' xml:lang='und'>vtables</code> array.</p>

<p>The .c file is generated by appending the functions after the various directives have been replaced.</p>

<h2><a name="PMC_File_Syntax"
>PMC File Syntax <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>The basic syntax of a PMC file is</p>

<ol>
<li>A preamble, consisting of code to be copied directly to the .c file</li><p class="pad"></p>

<li>The <code lang='und' xml:lang='und'>pmclass</code> declaration:</li><p class="pad"></p>

<pre lang='und' xml:lang='und'>    pmclass PMCNAME [flags] {</pre>

<p>where <code lang='und' xml:lang='und'>flags</code> are:</p>

<dl>
<dt><a name="extends_PMCPARENT"
><b><code lang='und' xml:lang='und'>extends PMCPARENT</b></code></a></dt><p class="pad"></p>

<dd>All methods not defined in PMCNAME are inherited from the PMCPARENT class. If no parent class is defined, methods from <em lang='und' xml:lang='und'>default.pmc</em> are used.</dd><p class="pad"></p>

<dt><a name="abstract"
><b><code lang='und' xml:lang='und'>abstract</b></code></a></dt><p class="pad"></p>

<dd>This class cannot be instantiated. Abstract classes are shown with lower case class names in the class tree.</dd><p class="pad"></p>

<dt><a name="noinit"
><b><code lang='und' xml:lang='und'>noinit</b></code></a></dt><p class="pad"></p>

<dd>Used with <code lang='und' xml:lang='und'>abstract</code>: No <code lang='und' xml:lang='und'>class_init</code> code is generated.</dd><p class="pad"></p>

<dt><a name="const_too"
><b><code lang='und' xml:lang='und'>const_too</b></code></a></dt><p class="pad"></p>

<dd>Classes with this flag get 2 vtables and 2 enums, one pair with read/write set methods, and one with read&#45;only set methods.</dd><p class="pad"></p>

<dt><a name="need_ext"
><b><code lang='und' xml:lang='und'>need_ext</b></code></a></dt><p class="pad"></p>

<dd>The class needs a <code lang='und' xml:lang='und'>PMC_EXT</code> structure. For instance, any class using <code lang='und' xml:lang='und'>PMC_data</code> will have <code lang='und' xml:lang='und'>need_ext</code>.</dd><p class="pad"></p>

<dt><a name="does_interface"
><b><code lang='und' xml:lang='und'>does interface</b></code></a></dt><p class="pad"></p>

<dd>The class &#39;does&#39; the given interfaces (the collection of methods which the class implements).</dd><p class="pad"></p>

<dd>The default is &#34;scalar&#34;. Other currently used interfaces are:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    array    : container PMC with numerically&#45;keyed elements
    event    : PMC that can be used with event queue
    hash     : container PMC with string&#45;keyed elements
    library  : PMC that corresponds to a dynamic library
    ref      : PMC that references another PMC
    string   : PMC that behaves similarly to the base string type
    boolean  : PMC that does true/false only.
    integer  : PMC that behaves similarly to the base int type
    float    : PMC that behaves similarly to the base number type
    scalar   : (only used by the sample src/dynpmc/foo.pmc)</pre>

<dd>This is not a canonical list, but merely a snapshot of what&#39;s in use.</dd><p class="pad"></p>

<dt><a name="dynpmc"
><b><code lang='und' xml:lang='und'>dynpmc</b></code></a></dt><p class="pad"></p>

<dd>The class is a dynamic class. These have a special <code lang='und' xml:lang='und'>class_init</code> routine suitable for dynamic loading at runtime. See the <em lang='und' xml:lang='und'>src/dynpmc</em> directory for an example.</dd><p class="pad"></p>

<dt><a name="group_GROUP"
><b><code lang='und' xml:lang='und'>group GROUP</b></code></a></dt><p class="pad"></p>

<dd>The class is part of a group of interrelated PMCs that should be compiled together into a single shared library of the given name. Only valid for dynamic PMCs.</dd><p class="pad"></p>

<dt><a name="lib_LIB"
><b><code lang='und' xml:lang='und'>lib LIB</b></code></a></dt><p class="pad"></p>

<dd>The class needs an external library.</dd><p class="pad"></p>

<dt><a name="hll_HLL"
><b><code lang='und' xml:lang='und'>hll HLL</b></code></a></dt><p class="pad"></p>

<dd>The High level language this PMC corresponds to.</dd><p class="pad"></p>

<dt><a name="maps_Type"
><b><code lang='und' xml:lang='und'>maps Type</b></code></a></dt><p class="pad"></p>

<dd>The basic parrot PMC type that this PMC correspond to for <code lang='und' xml:lang='und'>.HLL</code> usage. For example:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    pmcclass TclInt hll Tcl maps Integer</pre>

<dd>allows this PMC to automatically be used when autoboxing <code lang='und' xml:lang='und'>I</code> registers to PMCs.</dd><p class="pad"></p>

<dd>Requires the <code lang='und' xml:lang='und'>hll</code> flag.</dd><p class="pad"></p>
</dl>

<li>A list of vtable method implementations</li><p class="pad"></p>

<li>The final close <code lang='und' xml:lang='und'>}</code></li><p class="pad"></p>
</ol>

<h2><a name="Method_Body_Substitutions"
>Method Body Substitutions <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>The vtable method bodies can use the following substitutions:</p>

<dl>
<dt><a name="SELF"
><b><code lang='und' xml:lang='und'>SELF</b></code></a></dt><p class="pad"></p>

<dd>Converted to the current PMC object of type <code lang='und' xml:lang='und'>PMC *</code>.</dd><p class="pad"></p>

<dt><a name="INTERP"
><b><code lang='und' xml:lang='und'>INTERP</b></code></a></dt><p class="pad"></p>

<dd>Converted to the interpreter object.</dd><p class="pad"></p>

<dt><a name="OtherClass.SELF.method(a,b,c)"
><b><code lang='und' xml:lang='und'>OtherClass.SELF.method(a,b,c)</b></code></a></dt><p class="pad"></p>

<dd>Calls the static vtable method &#39;method&#39; in <code lang='und' xml:lang='und'>OtherClass</code>.</dd><p class="pad"></p>

<dt><a name="SELF.method(a,b,c)"
><b><code lang='und' xml:lang='und'>SELF.method(a,b,c)</b></code></a></dt><p class="pad"></p>

<dd>Calls the vtable method &#39;method&#39; using the static type of <code lang='und' xml:lang='und'>SELF</code> (in other words, calls another method defined in the same file).</dd><p class="pad"></p>

<dt><a name="DYNSELF.method(a,b,c)"
><b><code lang='und' xml:lang='und'>DYNSELF.method(a,b,c)</b></code></a></dt><p class="pad"></p>

<dd>Calls the vtable method &#39;method&#39; using the dynamic type of <code lang='und' xml:lang='und'>SELF</code>.</dd><p class="pad"></p>

<dt><a name="DYNSELF(a,b,c)"
><b><code lang='und' xml:lang='und'>DYNSELF(a,b,c)</b></code></a></dt><p class="pad"></p>

<dd>Same as above, but calls the current method.</dd><p class="pad"></p>

<dt><a name="OtherClass.SUPER(a,b,c)"
><b><code lang='und' xml:lang='und'>OtherClass.SUPER(a,b,c)</b></code></a></dt><p class="pad"></p>

<dd>Calls the overridden implementation of the current method in <code lang='und' xml:lang='und'>OtherClass</code>.</dd><p class="pad"></p>

<dt><a name="SUPER(a,b,c)"
><b><code lang='und' xml:lang='und'>SUPER(a,b,c)</b></code></a></dt><p class="pad"></p>

<dd>Calls the overridden implementation of the current method in the nearest superclass, using the static type of <code lang='und' xml:lang='und'>SELF</code>.</dd><p class="pad"></p>

<dt><a name="DYNSUPER(a,b,c)"
><b><code lang='und' xml:lang='und'>DYNSUPER(a,b,c)</b></code></a></dt><p class="pad"></p>

<dd>As above, but uses the actual dynamic type of <code lang='und' xml:lang='und'>SELF</code>.</dd><p class="pad"></p>
</dl>

<h1><a name="AUTHOR"
>AUTHOR <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Leopold Toetsch.</p>

<p>Cleaned up by Matt Diephouse.</p>

<p>Many thanks to the author of <em lang='und' xml:lang='und'>pmc2c.pl</em>, many useful code pieces got reused.</p>

<h1><a name="FUNCTIONS"
>FUNCTIONS <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<h2><a name="my_$path_=_find_file(_[$dir1,_$dir2],_$file,_$die_unless_found_flag_);"
>my $path = find_file( [$dir1, $dir2], $file, $die_unless_found_flag ); <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Return the full path to $file (search in the given directories). Optionally, die with an error message if that file cannot be found.</p>

<h2><a name="dump_default()"
>dump_default() <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Create a .dump file for the default vtable (from which all PMCs inherit).</p>

<h2><a name="my_($balanced,_$remaining)_=_extract_balanced($code);"
>my ($balanced, $remaining) = extract_balanced($code); <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Remove a balanced {} construct from the beginning of $code. Return it and the remaining code.</p>

<h2><a name="my_($pre,_$class_name,_$flags)_=_parse_flags(\$code);"
>my ($pre, $class_name, $flags) = parse_flags(\$code); <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Extract a class signature from the code ref and return (a) the code found before the signature, (b) the name of the class, and (c) a hash ref containing the flags associated with the class (such as &#39;extends&#39; and &#39;does&#39;).</p>

<h2><a name="my_($name,_$attributes)_=_parse_pmc($code);"
>my ($name, $attributes) = parse_pmc($code); <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Parse PMC code and return the class name and a hash ref of attributes.</p>

<h2><a name="gen_parent_list(_[$dir1,_$dir2],_$class,_$classes_);"
>gen_parent_list( [$dir1, $dir2], $class, $classes ); <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Generate an ordered list of parent classes to put in the <i>$classes&#45;&#62;{class}&#45;&#62;{parents}</i> array, using the given directories to find parents.</p>

<h2><a name="dump_1_pmc($file);"
>dump_1_pmc($file); <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Returns the class structure from <i>$file</i> for a .dump file.</p>

<h2><a name="gen_super_meths($class,_$vtable)"
>gen_super_meths($class, $vtable) <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Generate a list of inherited methods for <i>$class</i> by searching the inheritence tree. The method list is found in <i>$vtable</i>.</p>

<h2><a name="add_defaulted($class_structure,_$vtable);"
>add_defaulted($class_structure, $vtable); <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Add methods to the class structure for each method found in the vtable. This is used to determine all of the &#39;default&#39; methods from the <em lang='und' xml:lang='und'>vtable.dump</em>.</p>

<h2><a name="dump_is_newer($file);"
>dump_is_newer($file); <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Return whether the dump of a file is newer than the PMC file. (If it&#39;s not, then the PMC file has changed and the dump has not been updated.)</p>

<h2><a name="dump_pmc(_[$dir1,_$dir2],_$file1,_$file2,_..._);"
>dump_pmc( [$dir1, $dir2], $file1, $file2, ... ); <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Create a .dump file for each of the passed files (which can be found in the given directories). A &#39;*.pmc&#39; glob may also be passed to emulate a proper shell in the presence of a dumb one.</p>

<h2><a name="read_dump(_[$dir1,_$dir2],_$file_);"
>read_dump( [$dir1, $dir2], $file ); <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Read in the class definition found in $file (which is found in one of the given directories) and recreate the data structure.</p>

<h2><a name="print_tree(_[$dir1,_$dir2],_0,_$file1,_$file2,_..._);"
>print_tree( [$dir1, $dir2], 0, $file1, $file2, ... ); <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Print the inheritence tree for each of the files, using the given directories to search for all of correct PMCs. The middle argument is the display depth, which is used for the recursive definition of this function.</p>

<h2><a name="gen_c(_[$dir1,_$dir2],_$file1,_$file2,_..._)"
>gen_c( [$dir1, $dir2], $file1, $file2, ... ) <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Generate the C source code file for each of the files passed in, using the directories passed in to search for the PMC dump files.</p>

<h2><a name="gen_def(_[$dir1,_$dir2],_\%pmc_)"
>gen_def( [$dir1, $dir2], \%pmc ) <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Generate a .def file for symbols to export for dynamic PMCs. Currently unused, but retained for being a basis for supporting platforms that need a symbol export list.</p>

<p>sub gen_def { my ($include, $pmcs) = @_;</p>

<pre lang='und' xml:lang='und'>    my ($pmcfilename, $pmcname);
    my %groups;
    foreach $pmcfilename (keys %$pmcs) {
        # Skip for non&#45;dynpmcs.
        next unless $pmcs&#45;&#62;{$pmcfilename}&#45;&#62;{flags}&#45;&#62;{dynpmc};

        # Get copy of name without extension.
        $pmcname = $pmcfilename;
        $pmcname =~ s/\.pmc$//;

        # Locate .h file and add everything it exports to a list.
        my @exports = ();
        my $file = find_file($include, &#34;pmc_$pmcname.h&#34;, 1);

        my $fh = open_file( &#34;&#60;&#34;, $file );
        while (&#60;$fh&#62;) {
            if (/^(?:extern\s+)?\w+\*?\s+\*?(\w+)\s*\([^)]+\)\s*;/) {
                push @exports, $1;
            }
        }
        close $fh;

        # Locate .c file and add everything it exports to a list.
        $file = find_file($include, &#34;$pmcname.c&#34;, 1);

        $fh = open_file( &#34;&#60;&#34;, $file );
        while (&#60;$fh&#62;) {
            if (/^(?:extern\s+)?\w+\*?\s+\*?(\w+)\s*\([^)]+\)\s*;/) {
                push @exports, $1;
            }
        }
        close $fh;

        # If it&#39;s in a group, put it in group&#39;s PMC array.
        if ($pmcs&#45;&#62;{$pmcfilename}&#45;&#62;{flags}&#45;&#62;{group}) {
            for (keys %{$pmcs&#45;&#62;{$pmcfilename}&#45;&#62;{flags}&#45;&#62;{group}}) {
                push @{$groups{$_}}, @exports;
            }
        }

        # Generate .def file for it.
        # XXX JW Needn&#39;t generate these for PMCs in a group?
        #        For now, simplifies sutff.
        $file =~ s/\.c$/.def/;
        $fh = open_file( &#34;&#62;&#34;, $file );
        print $fh &#34;LIBRARY $pmcname\nEXPORTS\n&#34;;
        print $fh &#34;\t$_\n&#34; foreach @exports;
        close $fh;
    }

    # Generate .def file for groups.
    for my $group (keys %groups) {
        # Get filename of where we&#39;ll stash the .def file.
        my $deffile = &#34;$group.def&#34;;

        # Does the DEF file already exist?
        my $defexists = &#45;e $deffile;

        # Open the file to append to it.
        my $fh = open_file( &#34;&#62;&#62;&#34;, $deffile );
        print $fh &#34;LIBRARY $group\nEXPORTS\n\tParrot_lib_${group}_load\n&#34; unless $defexists;
        print $fh &#34;\t$_\n&#34; foreach @{$groups{$group}};
        close $fh;
    }
}</pre>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
