<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
    <HEAD>
        <TITLE>Testing Parrot</TITLE>
        <LINK REL="stylesheet" TYPE="text/css"
            HREF="../../resources/perl.css"
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY>
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Testing Parrot</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../html/index.html">Contents</a> | <a href="../../html/docs.html">Documentation</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>docs/tests.pod &#45; Testing Parrot</p>

<h1><a name="A_basic_guide_to_writing_and_running_tests_for_Parrot"
>A basic guide to writing and running tests for Parrot <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>This is quick and dirty pointer to how the Parrot test suite is executed and to how new tests for Parrot should be written.
The testing system is liable to change in the future,
but tests written following the guidelines below should be easy to port into a new test suite.</p>

<h1><a name="How_to_test_parrot"
>How to test parrot <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>The easy way to test parrot is running <code lang='und' xml:lang='und'>make test</code>.
If you have updated your code recently and tests began failing,
go for a <code lang='und' xml:lang='und'>make realclean</code> and recompile parrot before complaining.</p>

<p>If your architecture supports JIT,
you can test parrot JIT engine using <code lang='und' xml:lang='und'>make testj</code>.
It works just like <code lang='und' xml:lang='und'>make test</code>,
but uses the JIT engine when possible.</p>

<p><code lang='und' xml:lang='und'>make languages&#45;test</code> runs the test suite for most language implementations in the languages directory.</p>

<h2><a name="Submitting_smoke_test_results"
>Submitting smoke test results <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Parrot has a status page with smoke test results <a href='http://smoke.parrotcode.org/smoke/'><a href="http://smoke.parrotcode.org/smoke/">http://smoke.parrotcode.org/smoke/</a></a>.
You can supply new tests results by just running <code lang='und' xml:lang='und'>make smoke</code>.
It will run the same tests as <code lang='und' xml:lang='und'>make test</code> would,
but will additionally create a HTML table with the test results.
At the end,
it will try to upload the test results to the smoke server.</p>

<p>It is also possible to run a smoke test on JIT.
For that,
try running <code lang='und' xml:lang='und'>make smokej</code>.</p>

<p><code lang='und' xml:lang='und'>make languages&#45;smoke</code> does smoke testing for most language implementations in the languages directory.</p>

<h1><a name="Location_of_the_test_files"
>Location of the test files <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>The parrot test files,
the <em lang='und' xml:lang='und'>*.t</em> files,
can be found in the <em lang='und' xml:lang='und'>t</em> directory.
A quick overview over the subdirs in <em lang='und' xml:lang='und'>t</em> can be found in <em lang='und' xml:lang='und'>t/README</em>.</p>

<p>The language implementations usually have their test files in <em lang='und' xml:lang='und'>languages/*/t</em>.</p>

<p>New tests should be added to an existing <em lang='und' xml:lang='und'>*.t</em> file.
If a previously untested feature is tested,
it might also make sense to create a new <em lang='und' xml:lang='und'>*.t</em> file.</p>

<h1><a name="How_to_write_a_test"
>How to write a test <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>Test scripts must emit text that conforms to the <code lang='und' xml:lang='und'>Test Anything Protocol</code>.
Test scripts are currently usually written in Perl 5 or PIR.
The Perl 5 module <code lang='und' xml:lang='und'><a href='../lib/Parrot/Test.pm.html'>Parrot::Test</a></code> and the PIR module <code lang='und' xml:lang='und'>Test;More</code> help with writing tests.</p>

<p>The testing framework needs to know how many tests it should expect.
So the number of planned tests needs to be incremented when adding a new test.
This is done near the top of a test file,
in a line that looks like:</p>

<pre lang='und' xml:lang='und'>  use Parrot::Test tests =&#62; 8;</pre>

<p>for Perl 5 based test scripts.</p>

<h2><a name="Testing_Parrot_Assembler"
>Testing Parrot Assembler <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>PASM tests are mostly used for testing ops. Appropriate test files for basic ops are <em lang='und' xml:lang='und'>t/op/*.t</em>. Perl Magic Cookies are tested in <em lang='und' xml:lang='und'>t/pmc/*.t</em>. Add the new test like this:</p>

<pre lang='und' xml:lang='und'>    pasm_output_is(&#60;&#60;&#39;CODE&#39;, &#60;&#60;&#39;OUTPUT&#39;, &#34;name for test&#34;);
        *** a big chunk of assembler, eg:
        print   1
        print   &#34;\n&#34; # you can even comment it if it&#39;s obscure
        end          # don&#39;t forget this...!
    CODE
    *** what you expect the output of the chunk to be, eg.
    1
    OUTPUT</pre>

<h2><a name="Testing_Parrot_Intermediate_Representation"
>Testing Parrot Intermediate Representation <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Writing tests in <b>PIR</b> is more convenient. This is done with <code lang='und' xml:lang='und'>pir_output_is</code> and friends.</p>

<pre lang='und' xml:lang='und'>    pir_output_is(&#60;&#60;&#39;CODE&#39;,&#60;&#60;&#39;OUT&#39;,&#39;nothing useful&#39;);
        .include &#39;library/config.pir&#39;

        .sub main :main
            print &#34;hi\n&#34;
        .end
    CODE
    hi
    OUT</pre>

<h2><a name="Testing_C_source"
>Testing C source <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>C source tests are usually located in <em lang='und' xml:lang='und'>t/src/*.t</em>. A simple test looks like:</p>

<pre lang='und' xml:lang='und'>    c_output_is(&#60;&#60;&#39;CODE&#39;, &#60;&#60;&#39;OUTPUT&#39;, &#34;name for test&#34;);
    #include &#60;stdio.h&#62;
    #include &#34;parrot/parrot.h&#34;
    #include &#34;parrot/embed.h&#34;

    static opcode_t *the_test(Parrot_Interp, opcode_t *, opcode_t *);

    int main(int argc, char* argv[]) {
        Parrot_Interp interp;
        interpreter = Parrot_new(NULL);

        if (!interpreter)
            return 1;

        Parrot_run_native(interp, the_test);
        printf(&#34;done\n&#34;);
    fflush(stdout);
        return 0;
    }

    static opcode_t*
    the_test(Parrot_Interp interp,
        opcode_t *cur_op, opcode_t *start)
    {
        /* Your test goes here. */

        return NULL;  /* always return NULL */
    }
    CODE
    # Anything that might be output prior to &#34;done&#34;.
    done
    OUTPUT</pre>

<p>Note that it&#39;s always a good idea to output &#34;done&#34; to confirm that the compiled code executed completely. When mixing <code lang='und' xml:lang='und'>printf</code> and <code lang='und' xml:lang='und'>Parrot_io_printf</code> always append a <code lang='und' xml:lang='und'>fflush(stdout);</code> after the former.</p>

<h2><a name="Testing_Perl5_components"
>Testing Perl5 components <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>At the present time most, if not all, of the programs used to configure, build and install Parrot are written in Perl 5. These programs take the form of program files (<em lang='und' xml:lang='und'>*.pl</em>) and Perl modules (<em lang='und' xml:lang='und'>*.pm</em>) holding subroutines and other variables imported into the program files. Examples of such program files can be found under <em lang='und' xml:lang='und'>tools/</em>; examples of such Perl modules can be found under <em lang='und' xml:lang='und'>lib/Parrot/</em>.</p>

<p>All of these Perl 5 components ought to be tested. Fortunately, over the last decade, under the leadership of Michael Schwern, chromatic, Andy Lester and many others, the Perl 5 community has developed a rigorous approach to testing in which:</p>

<dl>
<dt><a name="a"
>a</a></dt><p class="pad"></p>

<dd>Subroutines found in <em lang='und' xml:lang='und'>*.pl</em> files are extracted and placed in <em lang='und' xml:lang='und'>*.pm</em> modules.</dd><p class="pad"></p>

<dt><a name="b"
>b</a></dt><p class="pad"></p>

<dd>Those subroutines are then imported back into the program file.</dd><p class="pad"></p>

<dt><a name="c"
>c</a></dt><p class="pad"></p>

<dd>Those subroutines are also imported into test files (<em lang='und' xml:lang='und'>*.t</em>) where are tests are run by Test::Builder&#45;based modules such as Test::Simple and Test::More.</dd><p class="pad"></p>

<dt><a name="d"
>d</a></dt><p class="pad"></p>

<dd>Those test files are run by Test::Harness&#45;based functionality such as ExtUtils::MakeMaker&#39;s <em lang='und' xml:lang='und'>make test</em>, Module::Build&#39;s <em lang='und' xml:lang='und'>build test</em>, or Test::Harness&#39;s <em lang='und' xml:lang='und'>prove</em>.</dd><p class="pad"></p>

<dt><a name="e"
>e</a></dt><p class="pad"></p>

<dd>The extent to which the test files exercise all statements in the Perl modules being tested is measured in coverage analysis using CPAN module Devel::Cover.</dd><p class="pad"></p>

<dt><a name="f"
>f</a></dt><p class="pad"></p>

<dd>The underlying code is refactored and improved on the basis of the results of tests and coverage analysis.</dd><p class="pad"></p>
</dl>

<p>Tests reflecting this approach can be found in <em lang='und' xml:lang='und'>t/configure/</em>, <em lang='und' xml:lang='und'>t/postconfigure/</em>, <em lang='und' xml:lang='und'>t/tools/</em>, and so on.</p>

<p>It is our objective to test all Perl 5 components of the Parrot distribution using the methodology above.</p>

<h3><a name="Build_Tools_Tests"
>Build Tools Tests</a></h3>

<p>The files in <em lang='und' xml:lang='und'>t/postconfigure</em> are tests for build system. The build tools tests are intended to be run after someone has made changes in modules such as <em lang='und' xml:lang='und'>lib/Parrot/Pmc2cUtils/</em>, <em lang='und' xml:lang='und'>Ops2cUtils/</em> and <em lang='und' xml:lang='und'>Ops2pmutils/</em>. They&#39;re set up to be run after <em lang='und' xml:lang='und'><a href="../Configure.pl.html">Configure.pl</a></em> has completed but before make has been invoked. (In fact, they will generate errors if make has completed.) You can run them with any of the following:</p>

<pre lang='und' xml:lang='und'>     perl Configure.pl &#45;&#45;test
     perl Configure.pl &#45;&#45;test=build
     make buildtools_tests  (following Configure.pl)</pre>

<h2><a name="Testing_language_implementations"
>Testing language implementations <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Language implementations are usually tested with <code lang='und' xml:lang='und'>language_output_is</code> and friends.</p>

<h1><a name="Ideal_tests:"
>Ideal tests: <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<ul>
<li>Probe the boundaries (including edge cases, errors thrown etc.) of whatever code they&#39;re testing. These should include potentially out of band input unless we decide that compilers should check for this themselves.</li><p class="pad"></p>

<li>Are small and self contained, so that if the tested feature breaks we can identify where and why quickly.</li><p class="pad"></p>

<li>Are valid. Essentially, they should conform to the additional documentation that accompanies the feature (if any). [If there isn&#39;t any documentation, then feel free to add some and/or complain to the mailing list].</li><p class="pad"></p>

<li>Are a chunk of assembler and a chunk of expected output.</li><p class="pad"></p>
</ul>

<h1><a name="TODO_tests"
>TODO tests <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>In test driven development, tests are implemented first. So the tests are initially expected to fail. This can be expressed by marking the tests as TODO. See <a href='TODO'>Test::More</a> on how to do that.</p>

<h1><a name="SKIP_tests"
>SKIP tests <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>TODO test actually executed, so that unexpected success can be detected. In the case of missing requirements and in the case of serious breakdowns the execution of tests can be skipped. See <a href='TODO'>Test::More</a> on how to do that.</p>

<h1><a name="SEE_ALSO"
>SEE ALSO <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p><a href='http://qa.perl.org/'><a href="http://qa.perl.org/">http://qa.perl.org/</a></a> <a href='http://testanything.org/'><a href="http://testanything.org/">http://testanything.org/</a></a> <a href='http://en.wikipedia.org/wiki/Test_Anything_Protocol'><a href="http://en.wikipedia.org/wiki/Test_Anything_Protocol">http://en.wikipedia.org/wiki/Test_Anything_Protocol</a></a> <em lang='und' xml:lang='und'>t/TESTS.STATUS.pod</em> <em lang='und' xml:lang='und'>t/README</em></p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../resources/parrot_small.png"
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
