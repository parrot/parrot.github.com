<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
    <HEAD>
        <TITLE>Untitled</TITLE>
        <LINK REL="stylesheet" TYPE="text/css"
            HREF="../../../../../resources/perl.css"
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY>
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Untitled</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../../../html/index.html">Contents</a> | <a href="../../../../../html/compilers.html">Compilers</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<p>grammar C99::Grammar is PCT::Grammar;</p>

<p>## A.2.4 External definitions ## ## {{ _dumper(match) }}</p>

<p>token TOP { ^ &#60;external_declaration&#62;+ [ $ || &#60;.panic: Syntax error&#62; ] {*} }</p>

<p>rule external_declaration { | &#60;declaration&#62; {*} #= declaration | &#60;function_definition&#62; {*} #= function_definition # &#60;declaration_specifiers&#62; # [ # | &#60;declaration2&#62; # | &#60;func_decl2&#62; # ] }</p>

<p>rule func_decl2 { &#60;declarator&#62; &#60;declaration&#62;* &#60;compound_statement&#62; {*} }</p>

<p>rule declaration2 { [ &#60;init_declarator&#62; [&#39;,&#39; &#60;init_declarator&#62;]* ]?
&#39;;&#39; {*} }</p>

<p>rule function_definition { &#60;declaration_specifiers&#62; &#60;declarator&#62; &#60;declaration&#62;* &#60;compound_statement&#62; {*} }</p>

<p>## A.2.2 ##</p>

<p>rule declaration { &#60;declaration_specifiers&#62; [ &#60;init_declarator&#62; [&#39;,&#39; &#60;init_declarator&#62;]* ]?
&#39;;&#39; {*} }</p>

<p>rule declaration_specifiers { &#60;repeatable_declaration_specifiers&#62;* &#60;type_specifier&#62; &#60;repeatable_declaration_specifiers&#62;* {*} } #rule declaration_specifiers_orig { [ &#60;storage_class_specifier&#62; | &#60;type_specifier&#62; | &#60;type_qualifier&#62; | &#60;function_specifier&#62; ]+ {*} } #rule declaration_specifiers { [ &#60;declaration_specifiers_inside&#62; ]+ {*} } #rule declaration_specifiers_inside { [ &#60;storage_class_specifier&#62; | &#60;type_specifier&#62; | &#60;type_qualifier&#62; | &#60;function_specifier&#62; ] {{ _dumper(match) }} } token builtin_type_specifier { &#39;void&#39; | &#39;char&#39; | &#39;short&#39; | &#39;int&#39; | &#39;long&#39; | &#39;float&#39; | &#39;double&#39; | &#39;signed&#39; | &#39;unsigned&#39; | &#39;_Bool&#39; | &#39;_Complex&#39; | &#39;_Imaginary&#39; }</p>

<p>rule repeatable_declaration_specifiers { [ | &#60;storage_class_specifier&#62; | &#60;type_qualifier&#62; | &#60;function_specifier&#62; ] }</p>

<p>rule function_specifier { | &#39;inline&#39; | &#39;__inline__&#39; }</p>

<p>rule init_declarator { &#60;declarator&#62; [&#39;=&#39; &#60;initializer&#62;]?
{*} }</p>

<p>rule storage_class_specifier { [ | $&#60;typedef&#62;=[&#39;typedef&#39;] {*} #= typedef | $&#60;extern&#62;=[&#39;extern&#39;] {*} #= extern | $&#60;static&#62;=[&#39;static&#39;] {*} #= static | $&#60;auto&#62;=[&#39;auto&#39;] {*} #= auto | $&#60;register&#62;=[&#39;register&#39;] {*} #= register | $&#60;__extension__&#62;=[&#39;__extension__&#39;] {*} #= __extension__ ] }</p>

<p>rule type_specifier { #| &#60;builtin_type_specifier&#62; | &#60;builtin_type&#62; | $&#60;type&#62;=[ &#39;struct&#39; | &#39;union&#39; ] &#60;struct_or_union_specifier&#62; | &#39;enum&#39; &#60;enum_specifier&#62; | $&#60;typedef_name&#62;=&#60;identifier&#62; }</p>

<p>token builtin_type { [ [ $&#60;signed&#62;=[ &#39;signed&#39; | &#39;unsigned&#39; ] &#60;.ws&#62; ]?
[ | &#39;void&#39; | &#39;char&#39; | &#39;short&#39; &#60;.ws&#62; &#39;int&#39; &#62;&#62; | &#39;short&#39; | &#39;int&#39; | &#39;long&#39; &#60;.ws&#62; &#39;long&#39; &#60;.ws&#62; &#39;int&#39; &#62;&#62; | &#39;long&#39; &#60;.ws&#62; &#39;long&#39; &#62;&#62; | &#39;long&#39; &#60;.ws&#62; &#39;int&#39; &#62;&#62; | &#39;long&#39; &#60;.ws&#62; &#39;double&#39; &#62;&#62; | &#39;long&#39; | &#39;float&#39; | &#39;double&#39; | &#39;_Bool&#39; | &#39;_Complex&#39; | &#39;_Imaginary&#39; ] &#62;&#62; | &#39;unsigned&#39; | &#39;signed&#39; ] }</p>

<p>rule struct_or_union_specifier { | &#60;identifier&#62;?
&#39;{&#39; &#60;struct_declaration&#62;+ &#39;}&#39; | &#60;identifier&#62; }</p>

<p>rule struct_declaration { &#60;specifier_qualifier_list&#62; &#60;struct_declarator_list&#62;* &#39;;&#39; }</p>

<p>rule specifier_qualifier_list { &#60;type_qualifier&#62;* &#60;type_specifier&#62; &#60;type_qualifier&#62;* # [ # | &#60;type_specifier&#62; # | &#60;type_qualifier&#62; # ]+ }</p>

<p>rule struct_declarator_list { &#60;struct_declarator&#62; [&#39;,&#39; &#60;struct_declarator&#62;]* }</p>

<p>rule struct_declarator { | &#60;declarator&#62;?
&#39;:&#39; &#60;constant_expression&#62; | &#60;declarator&#62; }</p>

<p>rule enum_specifier { | &#60;identifier&#62;?
&#39;{&#39; &#60;enumerator_list&#62; [&#39;,&#39;]?
&#39;}&#39; | &#60;identifier&#62; }</p>

<p>rule enumerator_list { &#60;enumerator&#62; [&#39;,&#39; &#60;enumerator&#62;]* }</p>

<p>rule enumerator { &#60;enumeration_constant&#62; [&#39;=&#39; &#60;constant_expression&#62;]?
}</p>

<p>rule type_qualifier { $&#60;qualifier&#62;=[ |&#39;const&#39; |&#39;restrict&#39; |&#39;volatile&#39; |&#39;__const&#39; # gcc version of const |&#39;__restrict&#39; # gcc version of restricted |&#39;__volatile&#39; # gcc version of volatile |&#39;__extension__&#39; # gcc extension ] }</p>

<p>rule declarator { &#60;pointer&#62;?
&#60;direct_declarator&#62; {*} }</p>

<p>rule direct_declarator { &#60;declarator_prefix&#62; &#60;declarator_suffix&#62;* &#60;gcc_asm&#62;?
&#60;gcc_attribute&#62;* {*} }</p>

<p>rule declarator_prefix { | &#39;(&#39; &#60;declarator&#62; &#39;)&#39; {*} #= declarator | &#60;identifier&#62; {*} #= identifier }</p>

<p>rule declarator_suffix { | &#39;(&#39; &#60;parameter_type_list&#62; &#39;)&#39; {*} #= parameter_type_list | &#39;(&#39; &#60;identifier_list&#62;?
&#39;)&#39; {*} #= identifier_list ## old&#45;style C parameter declarations | &#39;[&#39; &#60;assignment_expression&#62;?
&#39;]&#39; | &#39;[&#39; &#39;*&#39; &#39;]&#39; }</p>

<p>rule gcc_attribute { &#39;__attribute__&#39; &#39;((&#39; &#60;gcc_attributes_list&#62;&#39;))&#39; }</p>

<p>rule gcc_attributes_list { [&#60;gcc_attr&#62; [&#39;,&#39; &#60;gcc_attr&#62;]* ]?</p>

<p>}</p>

<p>rule gcc_attr { | &#39;noreturn&#39; | &#39;__noreturn__&#39; | [ &#39;format&#39; | &#39;__format__&#39; ] &#39;(&#39; &#60;gcc_attr_formats&#62; &#39;,&#39; &#60;digit&#62;+ &#39;,&#39; &#60;digit&#62;+ &#39;)&#39; | &#39;__const__&#39; | &#39;__const&#39; | &#39;__nothrow__&#39; | &#39;__aligned__&#39; &#39;(&#39; &#60;digit&#62;+ &#39;)&#39; | &#39;__format_arg__&#39; &#39;(&#39; &#60;digit&#62;+ &#39;)&#39; | &#39;__nonnull__&#39; &#39;(&#39; &#60;digit_list_plus&#62; &#39;)&#39; | &#39;__mode__&#39; &#39;(&#39; &#60;gcc_attr_mode&#62; &#39;)&#39; | &#39;__sentinel__&#39; &#39;(&#39; &#60;digit&#62;+ &#39;)&#39; | &#39;__malloc__&#39; | &#39;__pure__&#39; | &#39;__warn_unused_result__&#39; }</p>

<p>rule digit_list_plus { &#60;digit&#62;+ [&#39;,&#39; &#60;digit&#62;+ ]* {*} }</p>

<p>token gcc_attr_mode { | &#39;__QI__&#39; | &#39;__DI__&#39; | &#39;__SI__&#39; | &#39;__HI__&#39; | &#39;byte&#39; | &#39;__byte__&#39; | &#39;word&#39; | &#39;__word__&#39; | &#39;pointer&#39; | &#39;__pointer__&#39; }</p>

<p>token gcc_attr_formats { | printf | __printf__ | scanf | strftime | gnu_printf | gnu_scanf | gnu_strftime | strfmon | __printf__ | __scanf__ | __strftime__ | __strfmon__ | ms_printf | ms_scanf | ms_strftime }</p>

<p>rule gcc_asm { [ &#39;asm&#39; | &#39;__asm__&#39; ] &#39;(&#39; [&#60;c_string_literal&#62; ]* &#39;)&#39; }</p>

<p>rule pointer { |&#39;*&#39; [ &#60;type_qualifier&#62; ]* &#60;pointer&#62; |&#39;*&#39; [ &#60;type_qualifier&#62; ]* }</p>

<p>rule parameter_type_list { &#60;parameter_list&#62; [$&#60;vararg&#62;=[&#39;,&#39; &#39;...&#39;]]?
{*} }</p>

<p>rule parameter_list { &#60;parameter_declaration&#62; [&#39;,&#39; &#60;parameter_declaration&#62;]* {*} }</p>

<p>rule parameter_declaration { &#60;declaration_specifiers&#62; [ | &#60;declarator&#62; {*} #= declarator | &#60;abstract_declarator&#62;?
{*} #= abstract_declarator ] &#60;repeatable_declaration_specifiers&#62;* }</p>

<p>rule identifier_list { &#60;identifier&#62; [&#39;,&#39; &#60;identifier&#62;]* }</p>

<p>rule type_name { &#60;specifier_qualifier_list&#62; &#60;abstract_declarator&#62;?
}</p>

<p>rule abstract_declarator { | &#60;pointer&#62; | &#60;pointer&#62;?
&#60;direct_abstract_declarator&#62; }</p>

<p>rule direct_abstract_declarator { [ | &#39;(&#39; &#60;abstract_declarator&#62; &#39;)&#39; | &#39;[&#39; &#60;assignment_expression&#62;?
&#39;]&#39; | &#39;[&#39; &#39;*&#39; &#39;]&#39; | &#39;(&#39; &#60;parameter_type_list&#62; &#39;)&#39; ] &#60;direct_abstract_declarator_1&#62;* }</p>

<p>rule direct_abstract_declarator_1 { | &#39;[&#39; &#60;assignment_expression&#62;?
&#39;]&#39; | &#39;[&#39; &#39;*&#39; &#39;]&#39; | &#39;(&#39; &#60;parameter_type_list&#62; &#39;)&#39; }</p>

<p>rule typedef_name_DEAD_CODE {</p>

<p>## a typedef name can be a return type specifier.
This is ambiguous,
because ## the parser doesn&#39;t know if it&#39;s a return type thingie or the name of the ## function.
Therefore,
typedef&#39;d names must be stored in a %hash,
so that ## this rule is not calling &#60;identifier&#62;,
but inspecting the registered ## typedef&#39;d names.
For now,
specify &#39;SOME_TYPEDEF_NAME&#39; as the only typedef&#39;d name.
## &#60;identifier&#62; #&#39;SOME_TYPEDEF_NAME&#39; }</p>

<p>rule initializer { | &#60;assignment_expression&#62; | &#39;{&#39; &#60;initializer_list&#62; [&#39;,&#39;]?
&#39;}&#39; }</p>

<p>rule initializer_list { &#60;initializer_item&#62; [&#39;,&#39; &#60;initializer_item&#62;]* }</p>

<p>rule initializer_item { &#60;designation&#62;?
&#60;initializer&#62; }</p>

<p>rule designation { &#60;designator&#62;+ &#39;=&#39; }</p>

<p>rule designator { | &#39;[&#39; &#60;constant_expression&#62; &#39;]&#39; | &#39;.&#39; &#60;identifier&#62; }</p>

<p>## A.2.3 Statements ##</p>

<p>rule statement { | &#60;labeled_statement&#62; | &#60;compound_statement&#62; {*} #= compound_statement | &#60;expression_statement&#62; {*} #= expression_statement | &#60;if_statement&#62; {*} #= if_statement | &#60;switch_statement&#62; | &#60;while_statement&#62; {*} #= while_statement | &#60;do_while_statement&#62; {*} #= do_while_statement | &#60;for1_statement&#62; {*} #= for1_statement | &#60;for2_statement&#62; {*} #= for2_statement | &#60;jump_statement&#62; {*} #= jump_statement }</p>

<p>rule labeled_statement { | &#60;identifier&#62; &#39;:&#39; &#60;statement&#62; | &#39;case&#39; &#60;constant_expression&#62; &#39;:&#39; &#60;statement&#62; | &#39;default&#39; &#39;:&#39; &#60;statement&#62; }</p>

<p>rule compound_statement { &#39;{&#39; &#60;block_item&#62;* &#39;}&#39; {*} }</p>

<p>rule block_item { | &#60;declaration&#62; {*} #= declaration | &#60;statement&#62; {*} #= statement }</p>

<p>rule expression_statement { &#60;expression&#62;?
&#39;;&#39; {*} }</p>

<p>rule if_statement { &#39;if&#39; &#39;(&#39; &#60;expression&#62; &#39;)&#39; &#60;statement&#62; [&#39;else&#39; $&#60;else&#62;=&#60;statement&#62;]?
{*} }</p>

<p>rule switch_statement { &#39;switch&#39; &#39;(&#39; &#60;expression&#62; &#39;)&#39; &#60;statement&#62; }</p>

<p>rule while_statement { &#39;while&#39; &#39;(&#39; &#60;expression&#62; &#39;)&#39; &#60;statement&#62; {*} }</p>

<p>rule do_while_statement { &#39;do&#39; &#60;statement&#62; &#39;while&#39; &#39;(&#39; &#60;expression&#62; &#39;)&#39; &#39;;&#39; {*} }</p>

<p>rule for1_statement { &#39;for&#39; &#39;(&#39; [$&#60;init&#62;=&#60;expression&#62;]?
&#39;;&#39; [$&#60;cond&#62;=&#60;expression&#62;]?
&#39;;&#39; [$&#60;step&#62;=&#60;expression&#62;]?
&#39;)&#39; &#60;statement&#62; {*} }</p>

<p>rule for2_statement { &#39;for&#39; &#39;(&#39; &#60;declaration&#62; [$&#60;cond&#62;=&#60;expression&#62;]?
&#39;;&#39; [$&#60;step&#62;=&#60;expression&#62;]?
&#39;)&#39; &#60;statement&#62; {*} }</p>

<p>rule jump_statement { | &#39;goto&#39; &#60;identifier&#62; &#39;;&#39; {*} #= goto | &#39;continue&#39; &#39;;&#39; {*} #= continue | &#39;break&#39; &#39;;&#39; {*} #= break | &#39;return&#39; &#60;expression&#62;?
&#39;;&#39; {*} #= return }</p>

<p>## A.1.1 Lexical elements ## ##rule token { ## | &#60;keyword&#62; ## | &#60;identifier&#62; ## | &#60;constant&#62; ## | &#60;c_string_literal&#62; ## | &#60;punctuator&#62; ##}</p>

<p>## A.1.2 Keywords ## token keyword { [ auto | enum | restrict | unsigned | break | extern | return | void | case | float | short | volatile | char | for | signed | while | const | goto | sizeof | _Bool | continue | if | static | _Complex | default | inline | struct | _Imaginary | do | int | switch | double | long | typedef | else | register | union ]&#62;&#62;</p>

<p>}</p>

<p>token reserved_word { &#60;keyword&#62; }</p>

<p>token identifier { &#60;!reserved_word&#62; &#60;.identifier_nondigit&#62; [ &#60;.identifier_nondigit&#62; | &#60;.digit&#62; ]* {*} }</p>

<p>token identifier_nondigit { &#60;alpha&#62; | &#60;[_]&#62; | &#60;universal_character_name&#62; }</p>

<p>## A.1.4 Universal character names ## token universal_character_name { | &#39;\u&#39; &#60;xdigit&#62;**{4} | &#39;\U&#39; &#60;xdigit&#62;**{8} }</p>

<p>## A.1.5 Constants ## token constant { | &#60;floating_constant&#62; {*} #= floating_constant | &#60;integer_constant&#62; {*} #= integer_constant | &#60;enumeration_constant&#62; {*} #= enumeration_constant | &#60;character_constant&#62; {*} #= character_constant }</p>

<p>token integer_constant { [ &#60;decimal_constant&#62; | &#60;hexadecimal_constant&#62; | &#60;octal_constant&#62; ] &#60;integer_suffix&#62;?
{*} }</p>

<p>token decimal_constant { &#60;[1..9]&#62; &#60;digit&#62;* }</p>

<p>token octal_constant { 0 &#60;[0..7]&#62;* }</p>

<p>token hexadecimal_constant { 0 &#60;[xX]&#62; &#60;xdigit&#62;+ }</p>

<p>token integer_suffix { | &#60;[uU]&#62; [ll?|LL?]?
| [ll?|LL?] &#60;[uU]&#62;?
}</p>

<p>token floating_constant { [ | &#60;decimal_floating_constant&#62; | &#60;hexadecimal_floating_constant&#62; ] {*} }</p>

<p>token decimal_floating_constant { [ | &#60;fractional_constant&#62; &#60;exponent_part&#62;?
| &#60;digit_sequence&#62; &#60;exponent_part&#62; ] &#60;floating_suffix&#62;?
}</p>

<p>token hexadecimal_prefix { 0 &#60;[xX]&#62; }</p>

<p>token hexadecimal_floating_constant { &#60;hexadecimal_prefix&#62; [ | &#60;hexadecimal_fractional_constant&#62; | &#60;hexadecimal_digit_sequence&#62; ] &#60;binary_exponent_part&#62; &#60;floating_suffix&#62;?
}</p>

<p>token fractional_constant { | &#60;digit_sequence&#62;?
\.
&#60;digit_sequence&#62; | &#60;digit_sequence&#62; \.
}</p>

<p>token exponent_part { &#60;[eE]&#62; [&#39;+&#39;|&#39;&#45;&#39;]?
&#60;digit_sequence&#62; }</p>

<p>token digit_sequence { &#60;digit&#62;+ }</p>

<p>token hexadecimal_fractional_constant { | &#60;hexadecimal_digit_sequence&#62;?
\.
&#60;hexadecimal_digit_sequence&#62; | &#60;hexadecimal_digit_sequence&#62; \.
}</p>

<p>token binary_exponent_part { &#60;[pP]&#62; [&#39;+&#39;|&#39;&#45;&#39;]?
&#60;digit_sequence&#62; }</p>

<p>token hexadecimal_digit_sequence { &#60;xdigit&#62;+ }</p>

<p>token floating_suffix { &#60;[fFlL]&#62; }</p>

<p>token enumeration_constant { &#60;identifier&#62; }</p>

<p>token character_constant { [L]?
\&#39; &#60;c_char&#62;+ \&#39; }</p>

<p>token &#60;c_char&#62; { &#60;&#45;[&#39;\\\n]&#62; | &#60;escape_sequence&#62; }</p>

<p>token escape_sequence { \\ [ &#60;[&#39;&#34;?\\abfnrtv]&#62; | &#60;octal_digit&#62;**{1..3} | x &#60;xdigit&#62;+ | &#60;universal_character_name&#62; ] }</p>

<p>## A.1.6 String literals token c_string_literal { [L]?
&#39;&#34;&#39; &#60;string_literal: &#39;&#34;&#39;&#62; &#39;&#34;&#39; {*} }</p>

<p>##\&#34; &#60;s_char&#62;* \&#34;</p>

<p>token s_char { &#60;&#45;[&#34;\\\n]&#62; | &#60;escape_sequence&#62; }</p>

<p>## A.2 Phrase structure grammar ##</p>

<p>## A.2.1 Expressions ##</p>

<p>rule constant_expression { &#60;conditional_expression&#62; {*} }</p>

<p>rule expression { &#60;assignment_expression&#62; [&#39;,&#39; &#60;assignment_expression&#62;]* {*} }</p>

<p>rule assignment_expression { [&#60;unary_expression&#62; &#60;assign_op&#62;]* &#60;conditional_expression&#62; {*} }</p>

<p>rule assign_op { &#39;=&#39;|&#39;*=&#39;|&#39;/=&#39;|&#39;%=&#39;|&#39;+=&#39;|&#39;&#45;=&#39;|&#39;&#60;&#60;=&#39;|&#39;&#62;&#62;=&#39;|&#39;&#38;=&#39;|&#39;^=&#39;|&#39;|=&#39; }</p>

<p>rule conditional_expression { &#60;logical_expression&#62; [&#39;?&#39; &#60;expression&#62; &#39;:&#39; &#60;conditional_expression&#62;]?
{*} }</p>

<p>rule logical_expression is optable { ...
}</p>

<p>proto &#39;infix:||&#39; is precedence(&#39;1&#39;) { ...
}</p>

<p>proto &#39;infix:&#38;&#38;&#39; is tighter(&#39;infix:||&#39;) { ...
}</p>

<p>proto &#39;infix:|&#39; is tighter(&#39;infix:&#38;&#38;&#39;) { ...
}</p>

<p>proto &#39;infix:^&#39; is tighter(&#39;infix:|&#39;) { ...
}</p>

<p>proto &#39;infix:&#38;&#39; is tighter(&#39;infix:^&#39;) { ...
}</p>

<p>proto &#39;infix:==&#39; is tighter(&#39;infix:&#38;&#39;) { ...
} proto &#39;infix:!=&#39; is equiv(&#39;infix:==&#39;) { ...
}</p>

<p>proto &#39;infix:&#60;&#39; is tighter(&#39;infix:==&#39;) { ...
} proto &#39;infix:&#62;&#39; is equiv(&#39;infix:&#60;&#39;) { ...
} proto &#39;infix:&#62;=&#39; is equiv(&#39;infix:&#60;&#39;) { ...
} proto &#39;infix:&#60;=&#39; is equiv(&#39;infix:&#60;&#39;) { ...
}</p>

<p>proto &#39;infix:&#60;&#60;&#39; is equiv(&#39;infix:&#60;&#39;) { ...
} proto &#39;infix:&#62;&#62;&#39; is equiv(&#39;infix:&#60;&#39;) { ...
}</p>

<p>proto &#39;infix:+&#39; is tighter(&#39;infix:&#60;&#60;&#39;) is pirop(&#39;n_add&#39;) { ...
} proto &#39;infix:&#45;&#39; is equiv(&#39;infix:+&#39;) is pirop(&#39;n_sub&#39;) { ...
}</p>

<p>proto &#39;infix:*&#39; is tighter(&#39;infix:+&#39;) is pirop(&#39;n_mul&#39;) { ...
} proto &#39;infix:/&#39; is equiv(&#39;infix:*&#39;) is pirop(&#39;n_div&#39;) { ...
} proto &#39;infix:%&#39; is equiv(&#39;infix:*&#39;) is pirop(&#39;n_mod&#39;) { ...
}</p>

<p>proto &#39;term:&#39; is tighter(&#39;infix:*&#39;) is parsed(&#38;cast_expression) { ...
}</p>

<p>rule postfix_expression_prefix { | &#60;primary_expression&#62; {*} #= primary_expression | &#39;(&#39; &#60;type_name&#62; &#39;)&#39; &#39;{&#39; &#60;initializer_list&#62; [&#39;,&#39;]?
&#39;}&#39; {*} #= #type_name }</p>

<p>rule postfix_expression { &#60;postfix_expression_prefix&#62; &#60;postfix_expression_suffix&#62;* {*} }</p>

<p>rule postfix_expression_suffix { | &#60;index&#62; {*} #= index | &#60;arguments&#62; {*} #= arguments | &#60;direct_field&#62; {*} #= direct_field | &#60;indirect_field&#62; {*} #= indirect_field | &#60;inc_or_dec&#62; {*} #= inc_or_dec }</p>

<p>rule inc_or_dec { $&#60;op&#62;=[&#39;++&#39;|&#39;&#45;&#45;&#39;] {*} }</p>

<p>rule index { &#39;[&#39; &#60;expression&#62; &#39;]&#39; {*} }</p>

<p>rule direct_field { &#39;.&#39; &#60;identifier&#62; {*} }</p>

<p>rule indirect_field { &#39;&#45;&#62;&#39; &#60;identifier&#62; {*} }</p>

<p>rule arguments { &#39;(&#39; &#60;argument_expression_list&#62;?
&#39;)&#39; {*} }</p>

<p>rule argument_expression_list { &#60;assignment_expression&#62; [&#39;,&#39; &#60;assignment_expression&#62;]* {*} }</p>

<p>rule unary_expression { | &#60;postfix_expression&#62; {*} #= postfix_expression | &#60;prefix_expression&#62; {*} #= prefix_expression | &#60;unary_operator&#62; &#60;cast_expression&#62; {*} #= unary_operator | &#39;sizeof&#39; &#60;unary_expression&#62; {*} #= sizeof | &#39;sizeof&#39; &#39;(&#39; &#60;type_name&#62; &#39;)&#39; {*} #= sizeof_type }</p>

<p>rule prefix_expression { $&#60;op&#62;=[&#39;++&#39;|&#39;&#45;&#45;&#39;] &#60;unary_expression&#62; {*} }</p>

<p>rule unary_operator { &#39;&#38;&#39; | &#39;*&#39; | &#39;+&#39; | &#39;&#45;&#39; | &#39;~&#39; | &#39;!&#39; }</p>

<p>rule cast_expression { [&#39;(&#39; &#60;type_name&#62; &#39;)&#39;]* &#60;unary_expression&#62; {*} }</p>

<p>rule primary_expression { | &#60;identifier&#62; {*} #= identifier | &#60;constant&#62; {*} #= constant | &#60;c_string_literal&#62; {*} #= c_string_literal | &#39;(&#39; &#60;expression&#62; &#39;)&#39; {*} #= expression }</p>

<p>token ws { [ | &#39;//&#39; \N* \n | &#39;/*&#39; .*?
&#39;*/&#39; | \s+ | &#60;.gcc_preprocess_id&#62; #| ^^ &#39;#&#39; \N \n #| &#39;#&#39; \N* \n {*} #= origin ]* }</p>

<p>token gcc_preprocess_id { ^^ &#39;#&#39; \s+ $&#60;line&#62;=[&#60;.digit&#62;+] \s+ &#60;c_string_literal&#62; $&#60;ilist&#62;=[ \s+ &#60;.digit&#62;+ ]* $$ {*} #= origin }</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../../../resources/parrot_small.png"
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
