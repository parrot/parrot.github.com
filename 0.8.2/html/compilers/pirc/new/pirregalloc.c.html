<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
    <HEAD>
        <TITLE>Untitled</TITLE>
        <LINK REL="stylesheet" TYPE="text/css"
            HREF="../../../../resources/perl.css"
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY>
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Untitled</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../../html/index.html">Contents</a> | <a href="../../../../html/compilers.html">Compilers</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>This file contains functions implementing a somewhat modified version of the linear scan register allocation algorithm.
This algorithm assumes there&#39;s a fixed number of registers,
which is not the case for Parrot.
Therefore,
the algorithm is modified in some places.</p>

<h1><a name="FUNCTIONS"
>FUNCTIONS <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<dl>
<dt><a name="static_void_reset_register_count(lsr_allocator_*_const_lsr)"
><b><code lang='und' xml:lang='und'>static void reset_register_count(lsr_allocator *const lsr)</b></code></a></dt><p class="pad"></p>

<dd>Reset the register counters; there&#39;s one counter for each register type (string,
num,
int,
pmc).</dd><p class="pad"></p>

<dt><a name="lsr_allocator_*_new_linear_scan_register_allocator(struct_lexer_state_*_lexer)"
><b><code lang='und' xml:lang='und'>lsr_allocator *new_linear_scan_register_allocator(struct lexer_state *lexer)</b></code></a></dt><p class="pad"></p>

<dd>Constructor for a linear scan register allocator.
Initializates the allocator,
and returns it.</dd><p class="pad"></p>

<dt><a name="void_destroy_linear_scan_regiser_allocator(lsr_allocator_*lsr)"
><b><code lang='und' xml:lang='und'>void destroy_linear_scan_regiser_allocator(lsr_allocator *lsr)</b></code></a></dt><p class="pad"></p>

<dd>Destructor for linear scan register allocator.
All live_interval objects are destroyed as well.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>live_interval *new_live_interval(lsr_allocator *const lsr, unsigned firstuse_location, pir_type type)</b></code></a></dt><p class="pad"></p>

<dd>Constructor for a live_interval struct object.
After creating the new interval object,
its startpoint and endpoint are initialized to the value in <code lang='und' xml:lang='und'>firstuse_location</code>.
Note that an interval has a type; the register allocator keeps a list of interval for each type,
because obviously you can&#39;t mix different types of registers.</dd><p class="pad"></p>

<dd>The newly created interval is added to the list of intervals.</dd><p class="pad"></p>

<dt><a name="void_add_live_interval(lsr_allocator_*_const_lsr,_live_interval_*_const_i,_pir_type_type)"
><b><code lang='und' xml:lang='und'>void add_live_interval(lsr_allocator *const lsr, live_interval *const i, pir_type type)</b></code></a></dt><p class="pad"></p>

<dd>Add live_interval <code lang='und' xml:lang='und'>i</code> to the list; this list is sorted on increasing start point.</dd><p class="pad"></p>

<dt><a name="static_void_add_interval_to_active(lsr_allocator_*lsr,_live_interval_*_i,_pir_type_type)"
><b><code lang='und' xml:lang='und'>static void add_interval_to_active(lsr_allocator *lsr, live_interval *i, pir_type type)</b></code></a></dt><p class="pad"></p>

<dd>Add interval <code lang='und' xml:lang='und'>i</code> to the list of active intervals; the list is sorted on increasing endpoint.</dd><p class="pad"></p>

<dt><a name="static_unsigned_get_free_reg(lsr_allocator_*_const_lsr,_pir_type_type)"
><b><code lang='und' xml:lang='und'>static unsigned get_free_reg(lsr_allocator *const lsr, pir_type type)</b></code></a></dt><p class="pad"></p>

<dd>Allocate a new register; if there&#39;s any old registers to be reused,
return such a second&#45;hand register; otherwise,
allocate a brand new one.</dd><p class="pad"></p>

<dt><a name="static_void_add_free_reg(lsr_allocator_*_const_lsr,_unsigned_regno,_pir_type_type)"
><b><code lang='und' xml:lang='und'>static void add_free_reg(lsr_allocator *const lsr, unsigned regno, pir_type type)</b></code></a></dt><p class="pad"></p>

<dd>Add register <code lang='und' xml:lang='und'>regno</code> to the list of free regs that can be reuse.</dd><p class="pad"></p>

<dt><a name="static_void_remove_from_active(live_interval_*i)"
><b><code lang='und' xml:lang='und'>static void remove_from_active(live_interval *i)</b></code></a></dt><p class="pad"></p>

<dd>Remove interval <code lang='und' xml:lang='und'>i</code> from the list of active intervals.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>static void expire_old_intervals(lsr_allocator *const lsr, live_interval *i, pir_type type)</b></code></a></dt><p class="pad"></p>

<dd>Go over all active intervals; if the endpoint of one of them is &#62;= than <code lang='und' xml:lang='und'>i</code>&#39;s start point,
the action is aborted.
This is why the <code lang='und' xml:lang='und'>active</code> list must be sorted on increasing endpoint.
Otherwise <code lang='und' xml:lang='und'>j</code> is &#39;removed&#39; from active,
as it has expired.
(the variable is no longer needed).</dd><p class="pad"></p>

<dt><a name="static_void_cache_interval_objects(lsr_allocator_*_const_lsr,_live_interval_*_interval)"
><b><code lang='und' xml:lang='und'>static void cache_interval_objects(lsr_allocator *const lsr, live_interval *interval)</b></code></a></dt><p class="pad"></p>

<dd>Store the interval <code lang='und' xml:lang='und'>interval</code> on a caching list; whenever a new <code lang='und' xml:lang='und'>live_interval</code> object is requested,
these interval objects can be re&#45;used,
instead of malloc()ing a new one.</dd><p class="pad"></p>

<dt><a name="void_linear_scan_register_allocation(lsr_allocator_*_const_lsr)"
><b><code lang='und' xml:lang='und'>void linear_scan_register_allocation(lsr_allocator *const lsr)</b></code></a></dt><p class="pad"></p>

<dd>Go over all live intervals; before handling any interval,
expire all old ones; they might have expired (see expire_old_intervals()).
Then,
allocate a new register; this can be one that was just expired.</dd><p class="pad"></p>
</dl>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../../resources/parrot_small.png"
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
