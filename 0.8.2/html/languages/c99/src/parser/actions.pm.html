<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
    <HEAD>
        <TITLE>Untitled</TITLE>
        <LINK REL="stylesheet" TYPE="text/css"
            HREF="../../../../../resources/perl.css"
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY>
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Untitled</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../../../html/index.html">Contents</a> | <a href="../../../../../html/languages.html">Language Implementations</a> | <a href="../../../../../html/c99.html">C99</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<p>class C99::Grammar::Actions;</p>

<p>method TOP($/) { for $&#60;external_declaration&#62; { my $fun := $( $_ );</p>

<pre lang='und' xml:lang='und'>        ## Look for the &#34;main&#34; function, and set that as the result
        ## object.
        if $fun.name() eq &#39;main&#39; {
             make $fun;
        }
    }
}</pre>

<p>method external_declaration($/, $key) { make $( $/{$key} ); }</p>

<p>method declaration($/) { my $past := PAST::Stmts.new( :node($/) );</p>

<pre lang='und' xml:lang='und'>    for $&#60;init_declarator&#62; {
           $past.push( $( $_ ) );
    }
    make $past;
}</pre>

<p>method init_declarator($/) { make $( $&#60;declarator&#62; ); }</p>

<p>method function_definition($/) { my $past := PAST::Block.new( :blocktype(&#39;declaration&#39;), :node($/) ); my $decl := $( $&#60;declarator&#62; ); $past.name( $decl.name() );</p>

<pre lang='und' xml:lang='und'>    my $body := $( $&#60;compound_statement&#62; );
    $past.push($body);
    make $past;
}</pre>

<p>method declaration($/) {</p>

<p>}</p>

<p>method declarator($/) { make $( $&#60;direct_declarator&#62; ); }</p>

<p>method direct_declarator($/) { my $past := $( $&#60;declarator_prefix&#62; ); #my $past := $( $&#60;declarator_suffix&#62;[0] ); #$past.name($pref.name()); make $past; }</p>

<p>method declarator_prefix($/, $key) { make $( $/{$key} ); }</p>

<p>method declarator_suffix($/, $key) { make $( $/{$key} ); }</p>

<p>method parameter_type_list($/) { my $past := $( $&#60;parameter_list&#62; ); if $&#60;vararg&#62; { $past.push( PAST::Var.new( :name(&#39;@vararg&#39;), :slurpy(1), :scope(&#39;parameter&#39;), :node($/) ) ); } make $past; }</p>

<p>method parameter_list($/) { ## create the function block here already; it&#39;s needed to store the parameters my $past := PAST::Block.new( :blocktype(&#39;declaration&#39;), :node($/) ); for $&#60;parameter_declaration&#62; { $past.push( $( $_ ) ); } make $past; }</p>

<p>method parameter_declaration($/, $key) { make $( $/{$key} ); }</p>

<p>method statement($/, $key) { make $( $/{$key} ); }</p>

<p>method jump_statement($/, $key) { if $key eq &#39;return&#39; { my $past := PAST::Op.new( :pirop(&#39;return&#39;), :node($/) ); if $&#60;expression&#62; { $past.push( $( $&#60;expression&#62;[0] ) ); } make $past; } else { $/.panic(&#34;$key is not implemented!&#34;); } }</p>

<p>method for1_statement($/) { my $past := PAST::Stmts.new( :node($/) ); my $body := $( $&#60;statement&#62; ); my $cond; if $&#60;cond&#62; { $cond := $( $&#60;cond&#62;[0] ); } else { # a missing condition is true $cond := PAST::Val.new( :returns(&#39;Integer&#39;), :value(&#39;1&#39;), :node($/) ); }</p>

<pre lang='und' xml:lang='und'>    if $&#60;init&#62; {
        my $init := $( $&#60;init&#62;[0] );
        $past.unshift($init);
    }


    if $&#60;step&#62; {
        my $step := $( $&#60;step&#62;[0] );
        $body := PAST::Stmts.new( $body, $step, :node($/) );
    }
    my $loop := PAST::Op.new( $cond, $body, :pasttype(&#39;while&#39;), :node($/) );
    $past.push($loop);

    make $past;
}</pre>

<p>method for2_statement($/) { my $past := PAST::Block.new( :blocktype(&#39;immediate&#39;), :node($/) ); my $loop := PAST::Op.new( :pasttype(&#39;while&#39;), :node($/) );</p>

<pre lang='und' xml:lang='und'>    $past.push( $( $&#60;declaration&#62; ) );
    my $body := $( $&#60;statement&#62; );

    if $&#60;step&#62; {
        my $step := $( $&#60;step&#62;[0] );
    }
    my $cond;
    if $&#60;cond&#62; {
        $cond := $( $&#60;cond&#62;[0] );
    }
    else {
        $cond := PAST::Val.new( :returns(&#39;Integer&#39;), :value(&#39;1&#39;), :node($/) );
    }
    $loop.push($cond);
    $loop.push($body);

    $past.push($loop);
    make $past;
}</pre>

<p>method expression($/) { if +$&#60;assignment_expression&#62; != 1 { my $past := PAST::Stmts.new( :node($/) ); for $&#60;assignment_expression&#62; { $past.push( $( $_ ) ); } make $past; } else { make $( $&#60;assignment_expression&#62;[0] ); } }</p>

<p>method expression_statement($/) { if $&#60;expression&#62; { make $( $&#60;expression&#62;[0] ); } else { make PAST::Op.new( :inline(&#39; # empty statement&#39;), :node($/) ); } }</p>

<p>method compound_statement($/) { my $past := PAST::Block.new( :blocktype(&#39;immediate&#39;), :node($/) ); #my $past := PAST::Stmts.new( :node($/) ); for $&#60;block_item&#62; { $past.push( $($_) ); } make $past; }</p>

<p>method if_statement($/) { my $cond := $( $&#60;expression&#62; ); my $then := $( $&#60;statement&#62; ); my $past := PAST::Op.new( $cond, $then, :pasttype(&#39;if&#39;), :node($/) ); if $&#60;else&#62; { $past.push( $( $&#60;else&#62;[0] ) ); } make $past; }</p>

<p>method do_while_statement($/) { my $cond := $( $&#60;expression&#62; ); my $body := $( $&#60;statement&#62; ); make PAST::Op.new( $cond, $body, :pasttype(&#39;repeat_while&#39;), :node($/) ); }</p>

<p>method while_statement($/) { my $cond := $( $&#60;expression&#62; ); my $body := $( $&#60;statement&#62; ); make PAST::Op.new( $cond, $body, :pasttype(&#39;while&#39;), :node($/) ); }</p>

<p>method block_item($/, $key) { make $( $/{$key} ); }</p>

<p>method constant($/, $key) { make $( $/{$key} ); }</p>

<p>method constant_expression($/) { make $( $&#60;conditional_expression&#62; ); }</p>

<p>method assignment_expression($/) { make $( $&#60;conditional_expression&#62; ); }</p>

<p>method conditional_expression($/) { my $cond := $( $&#60;logical_expression&#62; ); if $&#60;expression&#62; { my $then := $( $&#60;expression&#62;[0] ); my $else := $( $&#60;conditional_expression&#62;[0] ); make PAST::Op.new( $cond, $then, $else, :pasttype(&#39;if&#39;), :node($/) ); } else { make $cond; } }</p>

<p>method postfix_expression_prefix($/, $key) { make $( $/{$key} ); }</p>

<p>method postfix_expression_suffix($/, $key) { make $( $/{$key} ); }</p>

<p>method index($/) { my $expr := $( $&#60;expression&#62; ); ## XXX make PAST::Op.new( $expr, :name(&#39;xxx_index&#39;), :pasttype(&#39;call&#39;), :node($/) ); }</p>

<p>method direct_field($/) { my $field := $( $&#60;identifier&#62; ); ## XXX make PAST::Op.new( $field, :name(&#39;xxx_get_field&#39;), :pasttype(&#39;call&#39;), :node($/) ); }</p>

<p>method indirect_field($/) { my $field := $( $&#60;identifier&#62; ); ## XXX make PAST::Op.new( $field, :name(&#39;xxx_get_indirect&#39;), :pasttype(&#39;call&#39;), :node($/) ); }</p>

<p>method inc_or_dec($/) { my $opname := &#39;postfix:&#39; ~ ~$&#60;op&#62;; my $past := PAST::Op.new( :name($opname), :pasttype(&#39;call&#39;), :node($/) ); make $past; }</p>

<p>method arguments($/) { if $&#60;argument_expression_list&#62; { make $( $&#60;argument_expression_list&#62;[0] ); } else { make PAST::Op.new( :pasttype(&#39;call&#39;), :node($/) ); } }</p>

<p>method argument_expression_list($/) { my $past := PAST::Op.new( :pasttype(&#39;call&#39;), :node($/) ); for $&#60;assignment_expression&#62; { $past.push( $( $_ ) ); } make $past; }</p>

<p>method postfix_expression($/) { my $past := $( $&#60;postfix_expression_prefix&#62; ); for $&#60;postfix_expression_suffix&#62; { ## XXX my $args := $( $_ ); $args.unshift($past); $past := $args; } make $past; }</p>

<p>method prefix_expression($/) { my $opname := &#39;prefix:&#39; ~ ~$&#60;op&#62;; my $expr := $( $&#60;unary_expression&#62; ); make PAST::Op.new( $expr, :name($opname), :pasttype(&#39;call&#39;), :node($/) ); }</p>

<p>method primary_expression($/, $key) { make $( $/{$key} ); }</p>

<p>method unary_expression($/, $key) { make $( $/{$key} ); }</p>

<p>method integer_constant($/) { make PAST::Val.new( :value( ~$/ ), :returns(&#39;Integer&#39;), :node($/) ); }</p>

<p>method floating_constant($/) { make PAST::Val.new( :value( ~$/ ), :returns(&#39;Float&#39;), :node($/) ); }</p>

<p>method c_string_literal($/) { make PAST::Val.new( :value( ~$&#60;string_literal&#62; ), :node($/) ); #make PAST::Val.new( :value( ~$/ ), :node($/) ); }</p>

<p>method identifier($/) { ## XXX fix scopes ## XXX fix declarations so that :viviself can be removed make PAST::Var.new( :name( ~$/ ), :scope(&#39;package&#39;), :viviself(&#39;Integer&#39;), :node($/) ); }</p>

<p>method cast_expression($/) { make $( $&#60;unary_expression&#62; ); }</p>

<p>method logical_expression($/, $key) { if ($key eq &#39;end&#39;) { make $($&#60;expr&#62;); } else { my $past := PAST::Op.new( :name($&#60;type&#62;), :pasttype($&#60;top&#62;&#60;pasttype&#62;), :pirop($&#60;top&#62;&#60;pirop&#62;), :lvalue($&#60;top&#62;&#60;lvalue&#62;), :node($/) ); for @($/) { $past.push( $($_) ); } make $past; }</p>

<p>}</p>

<p># Local Variables: # mode: cperl # cperl&#45;indent&#45;level: 4 # fill&#45;column: 100 # End: # vim: expandtab shiftwidth=4:</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../../../resources/parrot_small.png"
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
