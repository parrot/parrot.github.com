<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Parrot Forth</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Parrot Forth</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../html/index.html">Contents</a> | <a href="../../../html/languages.html">Language Implementations</a> | <a href="../../../html/forth.html">Forth</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="TITLE"
>TITLE <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Parrot Forth</p>

<h1><a name="Introduction"
>Introduction <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>This document assumes that you&#39;re familiar with Forth.
If you aren&#39;t,
more help can be found at <a href="http://www.forth.org.">http://www.forth.org.</a></p>

<p>Parrot Forth is based on the ANS Forth standard,
with some GForth extensions,
as well as some local extensions specifically for interfacing with the underlying Parrot engine and interacting with other Parrot code.</p>

<h1><a name="Caveats"
>Caveats <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Please be aware that Parrot Forth is a work in progress and,
as such,
isn&#39;t yet done.
Not all of the ANS core and core&#45;ext words are in,
and bits and pieces of other sections of the ANS extension word set (such as some of the floating&#45;point words) are in place.</p>

<p>Parrot forth will eventually provide at least all the core and core&#45;ext words,
with the behaviour caveats as noted later on in this document.</p>

<h1><a name="Parrot_Extensions"
>Parrot Extensions <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>This section details the spots where Parrot Forth differs from ANS forth.</p>

<h2><a name="Parrot_variants_of_standard_structures"
>Parrot variants of standard structures <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Internally Parrot is very different from most forths,
in part because of its VM nature and in part through a desire to make it easy for Parrot Forth to interact with other Parrot languages.
This has resulted in a number of decisions that are,
for the most part,
legitimate interpretations of the standard (such as using a combined data stack) but unusual.</p>

<p>Some,
like the lack of double words and single&#45;precision floats,
may break programs that expect to be able to manipulate parts of values.
(As,
once you push a doubleword on to the stack you can treat each half as a separate single&#45;cell value,
albeit very machine&#45;dependently) That should be reasonably unusual,
so just don&#39;t do that.</p>

<dl>
<dt><a name="Combined_data_stack"
>Combined data stack</a></dt><p class="pad"></p>

<dd>Parrot uses a single stack to hold integers,
floats,
strings,
PMCs,
execution tokens,
and whatnot.
Each element takes a single cell on the stack.</dd><p class="pad"></p>

<dt><a name="Full_PMC_usage"
>Full PMC usage</a></dt><p class="pad"></p>

<dd>All values on the Forth stack are,
in fact,
PMCs rather than plain integers,
floats,
or whatever.
All integers are stored in Integer PMCs,
floats in Float PMCs,
and parrot strings in PerlString PMCs.</dd><p class="pad"></p>

<dd>This has a number of unfortunate efficiency issues,
but it makes the implementation much easier.</dd><p class="pad"></p>

<dd>This also means that Parrot Forth will do autocoercion on data elements.
The following:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  1.2 1.6 + .</pre>

<dd>will print <code lang='und' xml:lang='und'>2</code>, since <code lang='und' xml:lang='und'>+</code> is defined as integer addition. Note that this will not invoke the addition vtable methods on the two operands, but instead invokes the get_integer method for them. To use the vtable methods use the p variants of the operands. (<code lang='und' xml:lang='und'>p+</code>, <code lang='und' xml:lang='und'>p&#45;</code> and their friends)</dd><p class="pad"></p>

<dt><a name="No_doublewords"
>No doublewords</a></dt><p class="pad"></p>

<dd>Parrot integers are 32 bits. The words that act on doubles behave identically to their single&#45;word variants.</dd><p class="pad"></p>

<dt><a name="No_single/double_float_distinction"
>No single/double float distinction</a></dt><p class="pad"></p>

<dd>All floats are whatever Parrot was compiled with originally, generally 64&#45;bit doubleword floats. All float words that act on single or double words will act identically.</dd><p class="pad"></p>

<dt><a name="Unsignedness_is_ignored"
>Unsignedness is ignored</a></dt><p class="pad"></p>

<dd>Generally all math operations act on integers as if they were signed, and the engine acts accordingly. Unsigned variants of words act identically to their signed counterparts, including returning signed values where they might occur.</dd><p class="pad"></p>

<dt><a name="Fake_memory_store"
>Fake memory store</a></dt><p class="pad"></p>

<dd>Parrot forth doesn&#39;t provide direct access to actual RAM. Memory access is instead simuated with an array, with each cell in the array holding a single value.</dd><p class="pad"></p>

<dd>The array is initially set to hold 64K cells. Each cell may hold a single value (PMC, integer, float, Parrot String) so this is generally sufficient.</dd><p class="pad"></p>

<dt><a name="Extended_Constants"
>Extended Constants</a></dt><p class="pad"></p>

<dd>The <code lang='und' xml:lang='und'>constant</code> word associates the following word with the value on the stack, regardless of its type. <code lang='und' xml:lang='und'>constant</code>s, then, can be integers, Parrot strings, floats, or PMCs provided by external code.</dd><p class="pad"></p>

<dt><a name="Forth_Strings"
>Forth Strings</a></dt><p class="pad"></p>

<dd>The forth standard only mandates that strings, as used in counted string things, can hold up to 255 characters.</dd><p class="pad"></p>
</dl>

<h2><a name="Words_that_differ_from_ANS_forth"
>Words that differ from ANS forth <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<h2><a name="Extra_Parrot_words"
>Extra Parrot words <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>The following conventions are in effect</p>

<p><code lang='und' xml:lang='und'>v</code> is a stack value</p>

<p><code lang='und' xml:lang='und'>n</code> is a number</p>

<p><code lang='und' xml:lang='und'>s</code> is a parrot string</p>

<dl>
<dt><a name="p&#34;"
>p&#34;</a></dt><p class="pad"></p>

<dd>This word puts a parrot string on the stack. Parrot strings take up a single stack cell.</dd><p class="pad"></p>

<dt><a name="ireg_(v_n_&#45;&#45;_)"
>ireg (v n &#45;&#45; )</a></dt><p class="pad"></p>

<dd>Puts the integer value of V into the register indicated by N.</dd><p class="pad"></p>

<dd>Note that since this allows direct manipulation of Parrot&#39;s registers it can be dangerous to forth at runtime, as forth makes use of parrot&#39;s registers as it runs. Generally it&#39;s wise to stay in the range 0&#45;15, which are the registers used in parrot&#39;s calling conventions.</dd><p class="pad"></p>

<dt><a name="preg_(v_n_&#45;&#45;_)"
>preg (v n &#45;&#45; )</a></dt><p class="pad"></p>

<dd>Puts the PMC V into the register indicated by N.</dd><p class="pad"></p>

<dd>Note that since this allows direct manipulation of Parrot&#39;s registers it can be dangerous to forth at runtime, as forth makes use of parrot&#39;s registers as it runs. Generally it&#39;s wise to stay in the range 0&#45;15, which are the registers used in parrot&#39;s calling conventions.</dd><p class="pad"></p>

<dt><a name="nreg_(v_n_&#45;&#45;_)"
>nreg (v n &#45;&#45; )</a></dt><p class="pad"></p>

<dd>Puts the float value of V into the register indicated by N.</dd><p class="pad"></p>

<dd>Note that since this allows direct manipulation of Parrot&#39;s registers it can be dangerous to forth at runtime, as forth makes use of parrot&#39;s registers as it runs. Generally it&#39;s wise to stay in the range 0&#45;15, which are the registers used in parrot&#39;s calling conventions.</dd><p class="pad"></p>

<dt><a name="sreg_(v_n_&#45;&#45;_)"
>sreg (v n &#45;&#45; )</a></dt><p class="pad"></p>

<dd>Puts the string value of V into the register indicated by N.</dd><p class="pad"></p>

<dd>Note that since this allows direct manipulation of Parrot&#39;s registers it can be dangerous to forth at runtime, as forth makes use of parrot&#39;s registers as it runs. Generally it&#39;s wise to stay in the range 0&#45;15, which are the registers used in parrot&#39;s calling conventions.</dd><p class="pad"></p>

<dt><a name="invoke_(_&#45;&#45;_)"
>invoke ( &#45;&#45; )</a></dt><p class="pad"></p>

<dd>Call a Parrot sub. Registers had better be in the correct setup, or things are likely to die a horrible death.</dd><p class="pad"></p>

<dt><a name="findglobal_(_s_&#45;&#45;_p_)"
>findglobal ( s &#45;&#45; p )</a></dt><p class="pad"></p>

<dd>Takes the parrot string S and looks it up in the global table, putting the corresponding PMC for the symbol on the top of the stack.</dd><p class="pad"></p>

<dt><a name="loadpasm_(_s_&#45;&#45;_)"
>loadpasm ( s &#45;&#45; )</a></dt><p class="pad"></p>

<dd>Load and run the assembly file S. Useful for loading in libraries of subroutines or interfaces.</dd><p class="pad"></p>

<dt><a name="loadpir_(_s_&#45;&#45;_)"
>loadpir ( s &#45;&#45; )</a></dt><p class="pad"></p>

<dd>Load and run the PIR file S. Useful for loading in libraries of subroutines or interfaces.</dd><p class="pad"></p>

<dt><a name="resultP_(_&#45;&#45;_v_)"
>resultP ( &#45;&#45; v )</a></dt><p class="pad"></p>

<dd>Take the value in register P5 and put it on the top of the stack</dd><p class="pad"></p>

<dt><a name="resultI_(_&#45;&#45;_v_)"
>resultI ( &#45;&#45; v )</a></dt><p class="pad"></p>

<dd>Take the value in register I5 and put it on the top of the stack</dd><p class="pad"></p>

<dt><a name="resultS_(_&#45;&#45;_v_)"
>resultS ( &#45;&#45; v )</a></dt><p class="pad"></p>

<dd>Take the value in register S5 and put it on the top of the stack</dd><p class="pad"></p>

<dt><a name="resultN_(_&#45;&#45;_v_)"
>resultN ( &#45;&#45; v )</a></dt><p class="pad"></p>

<dd>Take the value in register N5 and put it on the top of the stack</dd><p class="pad"></p>

<dt><a name="s2p_(_c&#45;addr_u_&#45;&#45;_s_)"
>s2p ( c&#45;addr u &#45;&#45; s )</a></dt><p class="pad"></p>

<dd>Take the cell address and count off the stack and construct a Parrot ASCII string from it, putting that string on the stack</dd><p class="pad"></p>

<dt><a name="p2s_(_s_&#45;&#45;_c&#45;addr_u_)"
>p2s ( s &#45;&#45; c&#45;addr u )</a></dt><p class="pad"></p>

<dd>Take the parrot string off the stack and turn it into a Forth counted string, putting the cell address of the resulting data and the length on the stack.</dd><p class="pad"></p>

<dt><a name="substr_(s_n1_n2_&#45;&#45;_s_)"
>substr (s n1 n2 &#45;&#45; s )</a></dt><p class="pad"></p>

<dd>Extract a substring from parrot string S, from offset N1 for N2 characters, and put the resulting parrot string back on the stack.</dd><p class="pad"></p>

<dt><a name="concat_(s_s_&#45;&#45;_s_)"
>concat (s s &#45;&#45; s )</a></dt><p class="pad"></p>

<dd>Concatenate the two strings on top of the stack and create a new string, putting the new string on the stack.</dd><p class="pad"></p>

<dt><a name="getparams_(_&#45;&#45;_v*x_n_v*x_n_v*x_n_v*x_n_)"
>getparams ( &#45;&#45; v*x n v*x n v*x n v*x n )</a></dt><p class="pad"></p>

<dd>Unpack the parameters, as passed in via parrot&#39;s calling conventions, from registers to the Forth stack. The results will be the parameters topped by a count for each set of parameter types. The registers will be taken in numeric, string, integer, and PMC order. (So the top word on the stack is the number of PMC parameters passed)</dd><p class="pad"></p>

<dt><a name="decode&#45;by&#45;sig_(_s_&#45;&#45;_v*x_n_)"
>decode&#45;by&#45;sig ( s &#45;&#45; v*x n )</a></dt><p class="pad"></p>

<dd>Take the signature S, a parrot string with the function signature, and pull the parameters out of the registers based on that signature, properly handling the potential for the parameters to come in without prototyping. The top word on the stack is the parameter count.</dd><p class="pad"></p>

<dt><a name="export_(_xt_s_&#45;&#45;_)"
>export ( xt s &#45;&#45; )</a></dt><p class="pad"></p>

<dd>Export execution token XT as name S, in the global parrot namespace. S should be a parrot string, and fully qualified. This word will be called with registers set as per Parrot&#39;s calling conventions, so should decode the registers as need be to get its parameters in a Forth&#45;like state.</dd><p class="pad"></p>
</dl>

<h1><a name="CREDITS"
>CREDITS <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Original Implementation: Jeff Goff</p>

<p>Vicious and Brutal extending: Dan Sugalski</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
