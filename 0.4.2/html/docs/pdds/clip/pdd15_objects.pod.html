<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Object and Class semantics for Parrot</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Object and Class semantics for Parrot</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../../html/index.html">Contents</a> | <a href="../../../../html/docs.html">Documentation</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>docs/pdds/pdd15_objects.pod &#45; Object and Class semantics for Parrot</p>

<h1><a name="ABSTRACT"
>ABSTRACT <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>This PDD describes the semantics of Parrot&#39;s object and class systems.
The PDD is divided into two parts,
the semantics expressed to user programs through PMCs,
and the default back&#45;end class scheme.</p>

<p>Note that the class system is <i>not</i> the single mandated class scheme,
merely the one designed to express the semantics needed for Perl 6,
ruby,
and python.
Alternate class systems are certainly possible,
and direct compatibility with the system as described here isn&#39;t strictly necessary.</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>This is a reasonably straightforward object system.
It assumes that objects have:</p>

<ul>
<li>An array of attributes.
Note that attribute values are <i>always</i> PMCs.</li><p class="pad"></p>

<li>A parent class</li><p class="pad"></p>

<li>A custom (though possibly class&#45;wide) vtable</li><p class="pad"></p>
</ul>

<p>and that you can:</p>

<ul>
<li>Call a method on an object</li><p class="pad"></p>

<li>Get a method PMC for a method for an object (for deferred method calls)</li><p class="pad"></p>

<li>Fetch the class for an object</li><p class="pad"></p>

<li>Subclass an existing object (note that objects may not necessarily be able to have their classes changed arbitrarily,
but making a subclass and moving the object to it is allowable)</li><p class="pad"></p>

<li>Get an attribute by name or offset</li><p class="pad"></p>

<li>Set an attribute by name or offset</li><p class="pad"></p>
</ul>

<p>Additionally we assume that <i>all</i> objects can have properties on them,
as all PMCs can have properties.
The property get/set method may be overridden on a per&#45;class basis as any other vtable method may be.</p>

<p>For classes,
we assume that:</p>

<ul>
<li>Classes have an associated namespace.
(Which may be anonymous)</li><p class="pad"></p>

<li>Classes have one or more immediate parent classes</li><p class="pad"></p>

<li>Classes have a catalog of attribute names and offsets for all attributes.</li><p class="pad"></p>

<li>Classes have a list of interfaces they implement</li><p class="pad"></p>
</ul>

<p>And we further assume that classes can:</p>

<ul>
<li>Instantiate an object of their class</li><p class="pad"></p>

<li>Add parent classes</li><p class="pad"></p>

<li>Remove parent classes</li><p class="pad"></p>

<li>Add attributes</li><p class="pad"></p>

<li>Remove attributes</li><p class="pad"></p>

<li>Add interfaces</li><p class="pad"></p>

<li>Remove interfaces</li><p class="pad"></p>
</ul>

<p>This list is likely not definitive,
but it&#39;s enough to start with.
It also doesn&#39;t address the semantics of method calls,
which need to be dealt with,
possibly separately.
With that in mind,
the object system supports these features with a combination of PMC classes (not to be confused with object classes) and opcodes.</p>

<h1><a name="IMPLEMENTATION"
>IMPLEMENTATION <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>There are four pieces to the object implementation.
There are the PMCs for the classes and objects,
the opcodes the engine uses to do objecty things,
the specific vtable methods used to perform those objecty things,
and the supporting code provided by the interpreter engine to do the heavy lifting.</p>

<p>Please note that Parrot,
in general,
does <i>not</i> restrict operations on objects and classes.
If a language has restrictions on what can be done with them,
the language is responsible for making sure that disallowed things do not happen.
For example,
Parrot permits multiple inheritance,
and will not stop code that adds a new parent to an existing class.
If a language doesn&#39;t allow for multiple inheritance it must not emit code which would add multiple parents to a class.
(Parrot may,
at some point,
allow imposition of runtime restrictions on a class,
but currently it doesn&#39;t)</p>

<h2><a name="PMCs"
>PMCs <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>There are two PMC classes,
<code lang='und' xml:lang='und'>ParrotClass</code> and <code lang='und' xml:lang='und'>ParrotObject</code>.
ParrotObject PMCs are the actual objects,
and hold all the per&#45;object instance data.
ParrotClass PMCs hold all the class&#45;specific information.
Instantiating a new OO class creates a new ParrotClass PMC,
and enters the new OO class into Parrot&#39;s PMC class table,
at which point it is indistinguishable from any other PMC class.
(This doesn&#39;t mean that non&#45;ParrotClass things can be subclassed or treated as an OO class.
Neither is that forbidden.
Just unimplemented)</p>

<p>It&#39;s important to note that <i>all</i> &#39;standard&#39; classes are ParrotClass PMC instances,
and <i>all</i> &#39;standard&#39; objects are ParrotObject PMCs.
We do <i>not</i> create a brand new PMC class for each OO class,
and they all share the ParrotClass or ParrotObject vtable,
respectively.
This distinction is mostly an artifact of the implementation,
and may change in the future.</p>

<p>While the internals of the class and object PMCs should be considered black boxes,
here&#39;s some documentation as to what they are for implementation purposes.</p>

<p>The ParrotClass PMC holds a 6 element array,
which is:</p>

<dl>
<dt><a name="0"
>0</a></dt><p class="pad"></p>

<dd>An array PMC of the immediate parent classes</dd><p class="pad"></p>

<dt><a name="1"
>1</a></dt><p class="pad"></p>

<dd>The class name PMC</dd><p class="pad"></p>

<dt><a name="2"
>2</a></dt><p class="pad"></p>

<dd>An array of all parent PMCs,
in search order</dd><p class="pad"></p>

<dt><a name="3"
>3</a></dt><p class="pad"></p>

<dd>The class attribute section hash.
Keys are the class name in language&#45;defined format (so perl would be foo::bar,
while java would be some.damn.long.thing.with.dots),
values are the integer offset from the start of the attribute array where that class&#39; attributes start.</dd><p class="pad"></p>

<dt><a name="4"
>4</a></dt><p class="pad"></p>

<dd>The class attribute name hash.
Keys are the fully qualified attribute names and the values are the offset from the beginning of the attribute array of the particular attribute.</dd><p class="pad"></p>

<dt><a name="5"
>5</a></dt><p class="pad"></p>

<dd>The class attribute array.
This is an array of unqualified attribute names.</dd><p class="pad"></p>
</dl>

<p>Note that the attribute catalog holds <i>all</i> the attributes for an object.
This includes the attributes in the object&#39;s class as well as <i>all</i> the attributes defined in all the parent classes.
(Multiple inheritance makes this necessary &#45;&#45; the offsets of a class&#39; attributes will change from child class to child class)</p>

<p>ParrotClass PMCs also have the &#34;I am a class&#34; flag set on them.</p>

<p>The ParrotObject PMC is an array of meta&#45;information and attributes.
The elements of this array are:</p>

<dl>
<dt><a name="0"
>0</a></dt><p class="pad"></p>

<dd>The class PMC</dd><p class="pad"></p>

<dt><a name="1"
>1</a></dt><p class="pad"></p>

<dd>The class name PMC</dd><p class="pad"></p>

<dt><a name="2+"
>2+</a></dt><p class="pad"></p>

<dd>The attributes for the object</dd><p class="pad"></p>
</dl>

<p>Note that ParrotObject PMCs also have the &#34;I am an object&#34; flag set on them.</p>

<h2><a name="Opcodes"
>Opcodes <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>The following ops are provided to deal with objects.
Please note that method calls are governed by parrot&#39;s calling conventions,
and as such objects,
method PMCs,
return continuations,
and parameters must be in the right places,
though some ops will put parameters where they need to go.</p>

<dl>
<dt><a name="classoffset_Ix,_Py,_Sz"
>classoffset Ix,
Py,
Sz</a></dt><p class="pad"></p>

<dd>Returns the offset of the first attribute for class Sz in object Py.</dd><p class="pad"></p>

<dt><a name="getattribute_Px,_Py,_Iz"
>getattribute Px,
Py,
Iz</a></dt><p class="pad"></p>

<dd>Returns attribute Iz of object Py and puts it in Px.
Note that the attribute number is an absolute offset.</dd><p class="pad"></p>

<dt><a name="getattribute_Px,_Py,_Sz"
>getattribute Px,
Py,
Sz</a></dt><p class="pad"></p>

<dd>Get the attribute with the fully qualified name Sz from object Py and put it in Px.</dd><p class="pad"></p>

<dt><a name="setattribute_Px,_Iy,_Pz"
>setattribute Px,
Iy,
Pz</a></dt><p class="pad"></p>

<dd>Set the attribute Iy of object Px to Pz.
Note that this op stores the <b>actual</b> PMC rather than a copy,
and so if the PMC&#39;s value is subsequently changed,
the value of the attribute will also change.</dd><p class="pad"></p>

<dt><a name="setattribute_Px,_Sy,_Pz"
>setattribute Px,
Sy,
Pz</a></dt><p class="pad"></p>

<dd>Set the attribute of object Px with the fully qualified name Sy to Pz</dd><p class="pad"></p>

<dt><a name="fetchmethod_Px,_Py,_Sz"
>fetchmethod Px,
Py,
Sz</a></dt><p class="pad"></p>

<dd>Find the PMC for method Sz of object Py,
and put it in Px.
Note that how the method PMC returned behaves if it goes out of scope or if the class hierarchy changes or the method definitions change is entirely up to the class that provides the PMC.</dd><p class="pad"></p>

<dt><a name="callmethod"
>callmethod</a></dt><p class="pad"></p>

<dt><a name="callmethod_Sz"
>callmethod Sz</a></dt><p class="pad"></p>

<dd>Call a method.
If the method name is provided,
we find the PMC for the named method and put it in the sub/method slot.
If no name is provided we assume that all the calling conventions have already been set up and the method PMC is already in the proper place.</dd><p class="pad"></p>

<dt><a name="callmethodcc"
>callmethodcc</a></dt><p class="pad"></p>

<dt><a name="callmethodcc_Sx"
>callmethodcc Sx</a></dt><p class="pad"></p>

<dd>Make a method call,
automatically generating a return continuation.
If a method name is passed in we look up the method PMC for the object and put it in the method slot.
If a method name isn&#39;t provided then we assume that things are already properly set up.</dd><p class="pad"></p>

<dt><a name="tailcallmethod_(Unimplemented)"
>tailcallmethod (Unimplemented)</a></dt><p class="pad"></p>

<dt><a name="tailcallmethod_Sx_(Unimplemented)"
>tailcallmethod Sx (Unimplemented)</a></dt><p class="pad"></p>

<dd>Make a tailcall to method Sx.
If no method name is given,
we assume everything is already set up properly.</dd><p class="pad"></p>

<dt><a name="newclass_Px,_Sy"
>newclass Px,
Sy</a></dt><p class="pad"></p>

<dd>Create a new base class named Sy,
and put the PMC for it in Px</dd><p class="pad"></p>

<dt><a name="subclass_Px,_Py,_Sz"
>subclass Px,
Py,
Sz</a></dt><p class="pad"></p>

<dd>Create a new class,
named Sz,
which has Py as its immediate parent.</dd><p class="pad"></p>

<dt><a name="addparent_Px,_Py"
>addparent Px,
Py</a></dt><p class="pad"></p>

<dd>Add class Py to the end of the list of immediate parents of class Px.
Adds any attributes of Py (and its parent classes) that aren&#39;t already in Px.</dd><p class="pad"></p>

<dt><a name="removeparent_Px,_Py_(Unimplemented)"
>removeparent Px,
Py (Unimplemented)</a></dt><p class="pad"></p>

<dd>Remove class Py from the parent list of Px.
All parent classes of Py which aren&#39;t parent classes of what remains of Px&#39;s parent list are removed,
as are their attributes.</dd><p class="pad"></p>

<dt><a name="addattribute_Px,_Sy"
>addattribute Px,
Sy</a></dt><p class="pad"></p>

<dd>Add attribute Sy to class Px.
This will add the attribute slot to all objects of class Px and children of class Px,
with a default value of <code lang='und' xml:lang='und'>Null</code>.</dd><p class="pad"></p>

<dt><a name="removeattribute_Px,_Sy_(Unimplemented)"
>removeattribute Px,
Sy (Unimplemented)</a></dt><p class="pad"></p>

<dd>Remove the attribute Sy from class Px,
all objects of class Px,
and all objects of a child of class Px.</dd><p class="pad"></p>

<dt><a name="instantiate_Px,_Py,_Sz_(Unimplemented)"
>instantiate Px,
Py,
Sz (Unimplemented)</a></dt><p class="pad"></p>

<dd>Instantiate a brand new class,
based on the metadata in Py,
named Sz.</dd><p class="pad"></p>
</dl>

<h2><a name="Vtables"
>Vtables <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>To make this work all PMCs must have the following vtable entries.
They may,
for non&#45;objects,
throw an exception.</p>

<p>The catalog metadata for objects is considered to be attributes on the class,
so to get the offset for a class for an object,
you fetch the object&#39;s class then look up the offset attribute from it.
(The class attributes are detailed later) This is safe in general,
since the only code reasonably querying a class&#39; attribute list is the class code itself,
and if a class doesn&#39;t know whether it&#39;s a ParrotClass&#45;style class or not you&#39;ve got bigger problems.</p>

<dl>
<dt><a name="find_method(string_*)"
>find_method(string *)</a></dt><p class="pad"></p>

<dd>Returns the PMC for the named method.
If no method of this name exists,
nor can be constructed,
returns a Null PMC.</dd><p class="pad"></p>

<dd>Note that for languages which support default fallback methods,
such as Perl 5&#39;s AUTOLOAD,
this would be the place to return it if a normal lookup fails.</dd><p class="pad"></p>

<dt><a name="isa(class_*)"
>isa(class *)</a></dt><p class="pad"></p>

<dd>Returns true or false if the class passed in as a parameter is in the inheritance hierarchy of the object.</dd><p class="pad"></p>

<dt><a name="can(string_*)"
>can(string *)</a></dt><p class="pad"></p>

<dd>Returns true or false if the object can perform the requested method.
(Including with an AUTOLOAD)</dd><p class="pad"></p>

<dt><a name="does(class_*)"
>does(class *)</a></dt><p class="pad"></p>

<dd>Returns true or false to note whether the object in question implements the interface passed in.</dd><p class="pad"></p>

<dt><a name="get_attr(INTVAL)"
>get_attr(INTVAL)</a></dt><p class="pad"></p>

<dd>Returns the attribute at the passed&#45;in offset for the object.</dd><p class="pad"></p>

<dt><a name="get_attr(STRING*)"
>get_attr(STRING*)</a></dt><p class="pad"></p>

<dd>Returns the attribute with the fully qualified name for the object.</dd><p class="pad"></p>

<dt><a name="set_attr(INTVAL,_PMC_*)"
>set_attr(INTVAL,
PMC *)</a></dt><p class="pad"></p>

<dd>Sets the attribute for the passed&#45;in offset to the passed&#45;in PMC value</dd><p class="pad"></p>

<dt><a name="set_attr(STRING*,_PMC_*)"
>set_attr(STRING*,
PMC *)</a></dt><p class="pad"></p>

<dd>Set the attribute with the fully qualified name for the object.</dd><p class="pad"></p>

<dt><a name="get_class"
>get_class</a></dt><p class="pad"></p>

<dd>Returns the class PMC for the object.</dd><p class="pad"></p>
</dl>

<p>Currently Parrot only supports mutating a class&#39; metainformation for ParrotClass classes.
This is a restriction which will be lifted at some point soon.</p>

<h1><a name="What_The_Bytecode_Sees"
>What The Bytecode Sees <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>The bytecode is isolated from most of the internal details of the implementation.
This allows both for flexibility in the implementation and forward compatibility,
generally good things.
It also allows for multiple concurrent interoperable object systems.
The major thrust is for transparent use of objects,
though most class activity (including creation of subclasses and modifications of existing classes) should be transparent as well.</p>

<h1><a name="EXAMPLES"
>EXAMPLES <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>The following examples all assume we&#39;re working with basic ParrotObject objects and ParrotClass classes.</p>

<h2><a name="Creating_a_new_class"
>Creating a new class <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>To create a new class <code lang='und' xml:lang='und'>Foo</code> which has no parent classes:</p>

<pre lang='und' xml:lang='und'>   newclass $P0, &#34;Foo&#34;</pre>

<h2><a name="Creating_a_new_class_with_multiple_parents"
>Creating a new class with multiple parents <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>To create a class <code lang='und' xml:lang='und'>Foo</code> with the parents <code lang='und' xml:lang='und'>A</code> and <code lang='und' xml:lang='und'>B</code>, the code would be:</p>

<pre lang='und' xml:lang='und'>   getclass $P0, &#34;A&#34;
   getclass $P1, &#34;B&#34;
   subclass $P2, $P0, &#34;Foo&#34;
   addparent $P2, $P1</pre>

<h2><a name="Creating_a_new_class_with_attributes"
>Creating a new class with attributes <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Adding the attributes <code lang='und' xml:lang='und'>a</code> and <code lang='und' xml:lang='und'>b</code> to the new class <code lang='und' xml:lang='und'>Foo</code>:</p>

<pre lang='und' xml:lang='und'>  newclass $P0, &#34;Foo&#34;
  addattribute $P0, &#34;a&#34;   # This is offset 0 + classoffset
  addattribute $P0, &#34;b&#34;   # This is offset 1 + classoffset</pre>

<h2><a name="Instantiating_an_object"
>Instantiating an object <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Assuming we want an object of class <code lang='und' xml:lang='und'>Foo</code>:</p>

<pre lang='und' xml:lang='und'>  .local int FooType
  .local pmc MyObject
  find_type FooType, &#34;Foo&#34;
  new MyObject, FooType</pre>

<h2><a name="Calling_a_method_on_an_object"
>Calling a method on an object <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Calling the method <code lang='und' xml:lang='und'>Xyzzy</code> on an object, assuming the PDD03 calling conventions are respected:</p>

<pre lang='und' xml:lang='und'>  callmethod &#34;Xyzzy&#34;

  set S0, &#34;Xyzzy&#34;
  callmethod</pre>

<p>Or, if a return continuation needs constructing:</p>

<pre lang='und' xml:lang='und'>  callmethodcc &#34;Xyzzy&#34;

  set S0, &#34;Xyzzy&#34;
  callmethodcc</pre>

<h2><a name="Accessing_attributes_from_within_a_class"
>Accessing attributes from within a class <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Assuming we&#39;ve an object that has class <code lang='und' xml:lang='und'>Foo</code> in it somewhere and want to get the second attribute <code lang='und' xml:lang='und'>b</code> out of it:</p>

<pre lang='und' xml:lang='und'>  .local int BaseOffset
  .local int BOffset
  classoffset BaseOffset, $P0, &#34;Foo&#34;
  BOffset = BaseOffset + 1
  getattribute $P1, $P0, BOffset</pre>

<p>Or with named access, if it isn&#39;t time critical:</p>

<pre lang='und' xml:lang='und'>  getattribute $P1, $P0, &#34;Foo\x0b&#34;</pre>

<h1><a name="Explanations"
>Explanations <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>To get a new class, you can do a <code lang='und' xml:lang='und'>newclass</code>, which creates a new class with no parents besides parrot&#39;s default super&#45;ish parent class. (Which doesn&#39;t appear in the class list anywhere, though arguably it ought to)</p>

<p>To get a new child class, you have two potential options:</p>

<dl>
<dt><a name="Subclass_the_parent"
>Subclass the parent</a></dt><p class="pad"></p>

<dt><a name="Create_a_new_standalone_class_and_add_a_parent"
>Create a new standalone class and add a parent</a></dt><p class="pad"></p>
</dl>

<p>Both ways work. It is, however, more efficient to use the first method, and just subclass the immediate parent class of your new class.</p>

<p>When adding in extra parents in a multiple&#45;inheritance scenario, subclass the first class in the immediate parent list then use the <code lang='und' xml:lang='und'>addparent</code> op to add in the rest of the immediate parents.</p>

<p>Do be aware that, right now, you should <i>not</i> add attributes or parents to a class that&#39;s been subclassed or has had objects instantiated. This will leave the internal structures of the classes and objects in an inconsistent state and things won&#39;t work at all the way you want them to. At the moment parrot won&#39;t warn if you do this, but it will soon. The restriction on parent list changes and attribute addition will be lifted in future releases, though doing so will be an expensive operation.</p>

<h1><a name="VTABLE_OVERLOADING"
>VTABLE OVERLOADING <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>Classes may override the vtable methods, allowing objects of a class to behave like a primitive PMC. Each vtable slot has a corresponding named method that parrot looks for in your class hierarchy when an object is used in a primitive context.</p>

<p>To use these properly at a low&#45;level requires a good working knowledge of the way Parrot works&#45;&#45;generally for higher&#45;level languages the language compiler or runtime will provide easier&#45;to&#45;use wrappers. These methods are all prototyped, and take a single fixed argument list, and return at most a single value.</p>

<p>While vtable methods <i>may</i> take a continuation, those continuations may <i>not</i> escape the vtable method&#39;s execution. This is due to the way that vtable methods are called by the interpreter&#45;&#45;once a vtable method is exited any continuation taken within it is no longer valid and may not be used.</p>

<p>Note that any class method that wishes to use parrot&#39;s multi&#45;method dispatch system may do so. This is, in fact, encouraged, though it is not required. In the absence of explicit multimethod dispatch, a left&#45;side wins scheme is used.</p>

<p>The following list details the raw method names:</p>

<dl>
<dt><a name="__init"
>__init</a></dt><p class="pad"></p>

<dd>Called when the object is first created.</dd><p class="pad"></p>

<dt><a name="__init_pmc"
>__init_pmc</a></dt><p class="pad"></p>

<dt><a name="__init_pmc_props"
>__init_pmc_props</a></dt><p class="pad"></p>

<dt><a name="__morph"
>__morph</a></dt><p class="pad"></p>

<dt><a name="__mark"
>__mark</a></dt><p class="pad"></p>

<dd>Called when the DOD is tracing live PMCs. If this method is called then the code must mark all strings and PMCs that it contains as live, otherwise they may be collected.</dd><p class="pad"></p>

<dd>This method is only called if the PMC is flagged as having a special mark routine, and is not necessary for normal objects.</dd><p class="pad"></p>

<dt><a name="__destroy"
>__destroy</a></dt><p class="pad"></p>

<dd>Called when the object is destroyed. This method is only called if the PMC is marked as having an active finalizer.</dd><p class="pad"></p>

<dt><a name="__getprop"
>__getprop</a></dt><p class="pad"></p>

<dt><a name="__setprop"
>__setprop</a></dt><p class="pad"></p>

<dt><a name="__delprop"
>__delprop</a></dt><p class="pad"></p>

<dt><a name="__getprops"
>__getprops</a></dt><p class="pad"></p>

<dt><a name="__type"
>__type</a></dt><p class="pad"></p>

<dt><a name="__type_keyed"
>__type_keyed</a></dt><p class="pad"></p>

<dt><a name="__type_keyed_int"
>__type_keyed_int</a></dt><p class="pad"></p>

<dt><a name="__type_keyed_str"
>__type_keyed_str</a></dt><p class="pad"></p>

<dt><a name="__subtype"
>__subtype</a></dt><p class="pad"></p>

<dt><a name="__name"
>__name</a></dt><p class="pad"></p>

<dt><a name="__clone"
>__clone</a></dt><p class="pad"></p>

<dt><a name="__find_method"
>__find_method</a></dt><p class="pad"></p>

<dt><a name="__get_integer"
>__get_integer</a></dt><p class="pad"></p>

<dd>Return the integer value of the object</dd><p class="pad"></p>

<dt><a name="__get_integer_keyed"
>__get_integer_keyed</a></dt><p class="pad"></p>

<dt><a name="__get_integer_keyed_int"
>__get_integer_keyed_int</a></dt><p class="pad"></p>

<dt><a name="__get_integer_keyed_str"
>__get_integer_keyed_str</a></dt><p class="pad"></p>

<dt><a name="__get_number"
>__get_number</a></dt><p class="pad"></p>

<dd>Return the floating&#45;point value of the object</dd><p class="pad"></p>

<dt><a name="__get_number_keyed"
>__get_number_keyed</a></dt><p class="pad"></p>

<dt><a name="__get_number_keyed_int"
>__get_number_keyed_int</a></dt><p class="pad"></p>

<dt><a name="__get_number_keyed_str"
>__get_number_keyed_str</a></dt><p class="pad"></p>

<dt><a name="__get_bignum"
>__get_bignum</a></dt><p class="pad"></p>

<dd>Return the extended precision numeric value of the PMC</dd><p class="pad"></p>

<dt><a name="__get_string"
>__get_string</a></dt><p class="pad"></p>

<dd>Return the string value of the PMC</dd><p class="pad"></p>

<dt><a name="__get_string_keyed"
>__get_string_keyed</a></dt><p class="pad"></p>

<dt><a name="__get_string_keyed_int"
>__get_string_keyed_int</a></dt><p class="pad"></p>

<dt><a name="__get_string_keyed_str"
>__get_string_keyed_str</a></dt><p class="pad"></p>

<dt><a name="__get_bool"
>__get_bool</a></dt><p class="pad"></p>

<dd>Return the true/false value of the PMC</dd><p class="pad"></p>

<dt><a name="__get_bool_keyed"
>__get_bool_keyed</a></dt><p class="pad"></p>

<dt><a name="__get_bool_keyed_int"
>__get_bool_keyed_int</a></dt><p class="pad"></p>

<dt><a name="__get_bool_keyed_str"
>__get_bool_keyed_str</a></dt><p class="pad"></p>

<dt><a name="__get_pmc"
>__get_pmc</a></dt><p class="pad"></p>

<dd>Return the PMC for this PMC.</dd><p class="pad"></p>

<dt><a name="__get_pmc_keyed"
>__get_pmc_keyed</a></dt><p class="pad"></p>

<dt><a name="__get_pmc_keyed_int"
>__get_pmc_keyed_int</a></dt><p class="pad"></p>

<dt><a name="__get_pmc_keyed_str"
>__get_pmc_keyed_str</a></dt><p class="pad"></p>

<dt><a name="__get_pointer"
>__get_pointer</a></dt><p class="pad"></p>

<dt><a name="__get_pointer_keyed"
>__get_pointer_keyed</a></dt><p class="pad"></p>

<dt><a name="__get_pointer_keyed_int"
>__get_pointer_keyed_int</a></dt><p class="pad"></p>

<dt><a name="__get_pointer_keyed_str"
>__get_pointer_keyed_str</a></dt><p class="pad"></p>

<dt><a name="__set_integer_native"
>__set_integer_native</a></dt><p class="pad"></p>

<dd>Set the integer value of this PMC</dd><p class="pad"></p>

<dt><a name="__set_integer_same"
>__set_integer_same</a></dt><p class="pad"></p>

<dt><a name="__set_integer_keyed"
>__set_integer_keyed</a></dt><p class="pad"></p>

<dt><a name="__set_integer_keyed_int"
>__set_integer_keyed_int</a></dt><p class="pad"></p>

<dt><a name="__set_integer_keyed_str"
>__set_integer_keyed_str</a></dt><p class="pad"></p>

<dt><a name="__set_number_native"
>__set_number_native</a></dt><p class="pad"></p>

<dd>Set the floating&#45;point value of this PMC</dd><p class="pad"></p>

<dt><a name="__set_number_same"
>__set_number_same</a></dt><p class="pad"></p>

<dt><a name="__set_number_keyed"
>__set_number_keyed</a></dt><p class="pad"></p>

<dt><a name="__set_number_keyed_int"
>__set_number_keyed_int</a></dt><p class="pad"></p>

<dt><a name="__set_number_keyed_str"
>__set_number_keyed_str</a></dt><p class="pad"></p>

<dt><a name="__set_bignum_int"
>__set_bignum_int</a></dt><p class="pad"></p>

<dd>Set the extended&#45;precision value of this PMC</dd><p class="pad"></p>

<dt><a name="__set_string_native"
>__set_string_native</a></dt><p class="pad"></p>

<dd>Set the string value of this PMC</dd><p class="pad"></p>

<dt><a name="__set_string_same"
>__set_string_same</a></dt><p class="pad"></p>

<dt><a name="__set_string_keyed"
>__set_string_keyed</a></dt><p class="pad"></p>

<dt><a name="__set_string_keyed_int"
>__set_string_keyed_int</a></dt><p class="pad"></p>

<dt><a name="__set_string_keyed_str"
>__set_string_keyed_str</a></dt><p class="pad"></p>

<dt><a name="__set_bool"
>__set_bool</a></dt><p class="pad"></p>

<dd>Set the true/false value of this PMC</dd><p class="pad"></p>

<dt><a name="__assign_pmc"
>__assign_pmc</a></dt><p class="pad"></p>

<dd>Set the value to the value of the passed in</dd><p class="pad"></p>

<dt><a name="__set_pmc"
>__set_pmc</a></dt><p class="pad"></p>

<dd>Make the PMC refer to the PMC passed in</dd><p class="pad"></p>

<dt><a name="__set_pmc_keyed"
>__set_pmc_keyed</a></dt><p class="pad"></p>

<dt><a name="__set_pmc_keyed_int"
>__set_pmc_keyed_int</a></dt><p class="pad"></p>

<dt><a name="__set_pmc_keyed_str"
>__set_pmc_keyed_str</a></dt><p class="pad"></p>

<dt><a name="__set_pointer"
>__set_pointer</a></dt><p class="pad"></p>

<dt><a name="__set_pointer_keyed"
>__set_pointer_keyed</a></dt><p class="pad"></p>

<dt><a name="__set_pointer_keyed_int"
>__set_pointer_keyed_int</a></dt><p class="pad"></p>

<dt><a name="__set_pointer_keyed_str"
>__set_pointer_keyed_str</a></dt><p class="pad"></p>

<dt><a name="__elements"
>__elements</a></dt><p class="pad"></p>

<dd>Return the number of elements in the PMC, if the PMC is treated as an aggregate.</dd><p class="pad"></p>

<dt><a name="__pop_integer"
>__pop_integer</a></dt><p class="pad"></p>

<dt><a name="__pop_float"
>__pop_float</a></dt><p class="pad"></p>

<dt><a name="__pop_string"
>__pop_string</a></dt><p class="pad"></p>

<dt><a name="__pop_pmc"
>__pop_pmc</a></dt><p class="pad"></p>

<dt><a name="__push_integer"
>__push_integer</a></dt><p class="pad"></p>

<dt><a name="__push_float"
>__push_float</a></dt><p class="pad"></p>

<dt><a name="__push_string"
>__push_string</a></dt><p class="pad"></p>

<dt><a name="__push_pmc"
>__push_pmc</a></dt><p class="pad"></p>

<dt><a name="__shift_integer"
>__shift_integer</a></dt><p class="pad"></p>

<dt><a name="__shift_float"
>__shift_float</a></dt><p class="pad"></p>

<dt><a name="__shift_string"
>__shift_string</a></dt><p class="pad"></p>

<dt><a name="__shift_pmc"
>__shift_pmc</a></dt><p class="pad"></p>

<dt><a name="__unshift_integer"
>__unshift_integer</a></dt><p class="pad"></p>

<dt><a name="__unshift_float"
>__unshift_float</a></dt><p class="pad"></p>

<dt><a name="__unshift_string"
>__unshift_string</a></dt><p class="pad"></p>

<dt><a name="__unshift_pmc"
>__unshift_pmc</a></dt><p class="pad"></p>

<dt><a name="__splice"
>__splice</a></dt><p class="pad"></p>

<dt><a name="__add"
>__add</a></dt><p class="pad"></p>

<dt><a name="__add_int"
>__add_int</a></dt><p class="pad"></p>

<dt><a name="__add_float"
>__add_float</a></dt><p class="pad"></p>

<dt><a name="__subtract"
>__subtract</a></dt><p class="pad"></p>

<dt><a name="__subtract_int"
>__subtract_int</a></dt><p class="pad"></p>

<dt><a name="__subtract_float"
>__subtract_float</a></dt><p class="pad"></p>

<dt><a name="__multiply"
>__multiply</a></dt><p class="pad"></p>

<dt><a name="__multiply_int"
>__multiply_int</a></dt><p class="pad"></p>

<dt><a name="__multiply_float"
>__multiply_float</a></dt><p class="pad"></p>

<dt><a name="__divide"
>__divide</a></dt><p class="pad"></p>

<dt><a name="__divide_int"
>__divide_int</a></dt><p class="pad"></p>

<dt><a name="__divide_float"
>__divide_float</a></dt><p class="pad"></p>

<dt><a name="__modulus"
>__modulus</a></dt><p class="pad"></p>

<dt><a name="__modulus_int"
>__modulus_int</a></dt><p class="pad"></p>

<dt><a name="__modulus_float"
>__modulus_float</a></dt><p class="pad"></p>

<dt><a name="__cmodulus"
>__cmodulus</a></dt><p class="pad"></p>

<dt><a name="__cmodulus_int"
>__cmodulus_int</a></dt><p class="pad"></p>

<dt><a name="__cmodulus_float"
>__cmodulus_float</a></dt><p class="pad"></p>

<dt><a name="__neg"
>__neg</a></dt><p class="pad"></p>

<dt><a name="__bitwise_or"
>__bitwise_or</a></dt><p class="pad"></p>

<dt><a name="__bitwise_or_int"
>__bitwise_or_int</a></dt><p class="pad"></p>

<dt><a name="__bitwise_and"
>__bitwise_and</a></dt><p class="pad"></p>

<dt><a name="__bitwise_and_int"
>__bitwise_and_int</a></dt><p class="pad"></p>

<dt><a name="__bitwise_xor"
>__bitwise_xor</a></dt><p class="pad"></p>

<dt><a name="__bitwise_xor_int"
>__bitwise_xor_int</a></dt><p class="pad"></p>

<dt><a name="__bitwise_ors"
>__bitwise_ors</a></dt><p class="pad"></p>

<dt><a name="__bitwise_ors_str"
>__bitwise_ors_str</a></dt><p class="pad"></p>

<dt><a name="__bitwise_ands"
>__bitwise_ands</a></dt><p class="pad"></p>

<dt><a name="__bitwise_ands_str"
>__bitwise_ands_str</a></dt><p class="pad"></p>

<dt><a name="__bitwise_xors"
>__bitwise_xors</a></dt><p class="pad"></p>

<dt><a name="__bitwise_xors_str"
>__bitwise_xors_str</a></dt><p class="pad"></p>

<dt><a name="__bitwise_not"
>__bitwise_not</a></dt><p class="pad"></p>

<dt><a name="__bitwise_shl"
>__bitwise_shl</a></dt><p class="pad"></p>

<dt><a name="__bitwise_shl_int"
>__bitwise_shl_int</a></dt><p class="pad"></p>

<dt><a name="__bitwise_shr"
>__bitwise_shr</a></dt><p class="pad"></p>

<dt><a name="__bitwise_shr_int"
>__bitwise_shr_int</a></dt><p class="pad"></p>

<dt><a name="__concatenate"
>__concatenate</a></dt><p class="pad"></p>

<dt><a name="__concatenate_native"
>__concatenate_native</a></dt><p class="pad"></p>

<dt><a name="__is_equal"
>__is_equal</a></dt><p class="pad"></p>

<dt><a name="__is_same"
>__is_same</a></dt><p class="pad"></p>

<dt><a name="__cmp"
>__cmp</a></dt><p class="pad"></p>

<dt><a name="__cmp_num"
>__cmp_num</a></dt><p class="pad"></p>

<dt><a name="__cmp_string"
>__cmp_string</a></dt><p class="pad"></p>

<dt><a name="__logical_or"
>__logical_or</a></dt><p class="pad"></p>

<dt><a name="__logical_and"
>__logical_and</a></dt><p class="pad"></p>

<dt><a name="__logical_xor"
>__logical_xor</a></dt><p class="pad"></p>

<dt><a name="__logical_not"
>__logical_not</a></dt><p class="pad"></p>

<dt><a name="__repeat"
>__repeat</a></dt><p class="pad"></p>

<dt><a name="__repeat_int"
>__repeat_int</a></dt><p class="pad"></p>

<dt><a name="__increment"
>__increment</a></dt><p class="pad"></p>

<dt><a name="__decrement"
>__decrement</a></dt><p class="pad"></p>

<dt><a name="__exists_keyed"
>__exists_keyed</a></dt><p class="pad"></p>

<dt><a name="__exists_keyed_int"
>__exists_keyed_int</a></dt><p class="pad"></p>

<dt><a name="__exists_keyed_str"
>__exists_keyed_str</a></dt><p class="pad"></p>

<dt><a name="__defined"
>__defined</a></dt><p class="pad"></p>

<dt><a name="__defined_keyed"
>__defined_keyed</a></dt><p class="pad"></p>

<dt><a name="__defined_keyed_int"
>__defined_keyed_int</a></dt><p class="pad"></p>

<dt><a name="__defined_keyed_str"
>__defined_keyed_str</a></dt><p class="pad"></p>

<dt><a name="__delete_keyed"
>__delete_keyed</a></dt><p class="pad"></p>

<dt><a name="__delete_keyed_int"
>__delete_keyed_int</a></dt><p class="pad"></p>

<dt><a name="__delete_keyed_str"
>__delete_keyed_str</a></dt><p class="pad"></p>

<dt><a name="__nextkey_keyed"
>__nextkey_keyed</a></dt><p class="pad"></p>

<dt><a name="__nextkey_keyed_int"
>__nextkey_keyed_int</a></dt><p class="pad"></p>

<dt><a name="__nextkey_keyed_str"
>__nextkey_keyed_str</a></dt><p class="pad"></p>

<dt><a name="__substr"
>__substr</a></dt><p class="pad"></p>

<dt><a name="__substr_str"
>__substr_str</a></dt><p class="pad"></p>

<dt><a name="__invoke"
>__invoke</a></dt><p class="pad"></p>

<dt><a name="__can"
>__can</a></dt><p class="pad"></p>

<dt><a name="__does"
>__does</a></dt><p class="pad"></p>

<dt><a name="__isa"
>__isa</a></dt><p class="pad"></p>

<dt><a name="__freeze"
>__freeze</a></dt><p class="pad"></p>

<dt><a name="__thaw"
>__thaw</a></dt><p class="pad"></p>

<dt><a name="__thawfinish"
>__thawfinish</a></dt><p class="pad"></p>

<dt><a name="__visit"
>__visit</a></dt><p class="pad"></p>

<dt><a name="__share"
>__share</a></dt><p class="pad"></p>
</dl>

<h1><a name="TRANSLATION_AND_GLOSSARY"
>TRANSLATION AND GLOSSARY <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>Since every object system on the planet shares a common set of terms but uses them completely differently, this section defines</p>

<h2><a name="Glossary"
>Glossary <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="Property"
>Property</a></dt><p class="pad"></p>

<dd>A name and value pair attached to a PMC. Properties may be attached to the PMC in its role as a container or the PMC in its role as a value.</dd><p class="pad"></p>

<dd>Properties are global to the PMC. That is there can only be one property named &#34;FOO&#34; attached to a PMC, and it is globally visible to all inspectors of the PMCs properties. They are <i>not</i> restricted by class.</dd><p class="pad"></p>

<dd>Properties are generally assigned at runtime, and a particular property may or may not exist on a PMC at any particular time. Properties are not restricted to objects as such, and any PMC may have a property attached to it.</dd><p class="pad"></p>

<dt><a name="Attribute"
>Attribute</a></dt><p class="pad"></p>

<dd>An attribute is a slot in an object that contains a value, generally a PMC. (Containing non&#45;PMCs leads to interesting garbage collection issues at the moment) Attributes are referenced either by slot number or by class name/attribute name pairs. (At least conceptually)</dd><p class="pad"></p>

<dd>Attributes are set on a class&#45;wide basis, and all the objects of a class will have the same set of attributes. Generally attributes aren&#39;t added or removed from classes at runtime, as this would require resizing and moving the elements of the attribute arrays of existing objects, and potentially recompiling code with fixed attribute offsets embedded in it. Most OO languages don&#39;t allow attribute changes to existing classes, though parrot&#39;s base attribute system does allow this.</dd><p class="pad"></p>

<dd>The fully qualified name of an attribute is the classname, a null, and the attribute name. Parrot synthesizes the fully&#45;qualified name where it needs to.</dd><p class="pad"></p>

<dt><a name="Method"
>Method</a></dt><p class="pad"></p>

<dd>In its strictest sense, a method is a chunk of code that you call with an object in the object slot of the calling conventions.</dd><p class="pad"></p>

<dd>More generally, a method is some piece of code that you invoke by name through an object. You call the object&#39;s &#34;Invoke a method&#34; vtable entry, passing in the method name (Assuming we don&#39;t just get it from the sub name register, per calling conventions). The object is then responsible for doing something with the method being requested. Presumably it calls the method, though this isn&#39;t strictly required.</dd><p class="pad"></p>

<dt><a name="Delegate"
>Delegate</a></dt><p class="pad"></p>

<dd>An object that is transparently (to the user) embedded in another object. Delegate objects are used in those cases where we can&#39;t inherit from a class because the class is from a different object universe.</dd><p class="pad"></p>

<dd>As an example, assume you have a class A, which inherits from class B. The classes are incompatible, so Parrot can&#39;t automatically meld B into A, as it might if they were. When instantiating an object of class A, Parrot will automatically instantiate an object of class B and embed it in the object of class A. The object of class B is class A&#39;s delegate&#45;&#45;when a method call comes in that A can&#39;t handle, that method call is delegated to B.</dd><p class="pad"></p>

<dt><a name="Parent_class"
>Parent class</a></dt><p class="pad"></p>

<dd>Also called the super&#45;class. The parent class is, in an inheritance situation, the class being derived from. If A derives from B, B is the parent class of A.</dd><p class="pad"></p>

<dt><a name="Child_class"
>Child class</a></dt><p class="pad"></p>

<dd>Also called the sub&#45;class. The child class is, in an inheritance situation, the class doing the deriving. If A derives from B, A is the child class.</dd><p class="pad"></p>
</dl>

<h2><a name="Translation"
>Translation <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>The following list a set of languages, then within each language what the parrot term translates to.</p>

<dl>
<dt><a name="Python"
>Python</a></dt><p class="pad"></p>

<dl>
<dt><a name="Attribute"
>Attribute</a></dt><p class="pad"></p>

<dd>A Python attribute maps to a parrot property</dd><p class="pad"></p>
</dl>

<dt><a name=".NET"
>.NET</a></dt><p class="pad"></p>

<dl>
<dt><a name="Attribute"
>Attribute</a></dt><p class="pad"></p>

<dd>What .NET calls an attribute parrot calls a property</dd><p class="pad"></p>

<dt><a name="Property"
>Property</a></dt><p class="pad"></p>

<dd>What .NET calls a property we call an attribute</dd><p class="pad"></p>
</dl>

<dt><a name="Generic_Terminology"
>Generic Terminology</a></dt><p class="pad"></p>

<dl>
<dt><a name="Instance_Variable"
>Instance Variable</a></dt><p class="pad"></p>

<dd>Instance Variables map to what we call attributes</dd><p class="pad"></p>
</dl>
</dl>

<h1><a name="ATTACHMENTS"
>ATTACHMENTS <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>None.</p>

<h1><a name="FOOTNOTES"
>FOOTNOTES <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>None.</p>

<h1><a name="REFERENCES"
>REFERENCES <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>None.</p>

<h1><a name="VERSION"
>VERSION <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<h2><a name="CURRENT"
>CURRENT <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<pre lang='und' xml:lang='und'>    Maintainer: Dan Sugalski
    Class: Internals
    PDD Number: 15
    Version: 1.2
    Status: Developing
    Last Modified: February 09, 2004
    PDD Format: 1
    Language: English</pre>

<h2><a name="HISTORY"
>HISTORY <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="Version_1.3"
>Version 1.3</a></dt><p class="pad"></p>

<dd>April 3, 2004</dd><p class="pad"></p>

<dt><a name="Version_1.2"
>Version 1.2</a></dt><p class="pad"></p>

<dd>February 9, 2004</dd><p class="pad"></p>

<dt><a name="Version_1.1"
>Version 1.1</a></dt><p class="pad"></p>

<dd>March 11, 2002</dd><p class="pad"></p>

<dt><a name="version_1"
>version 1</a></dt><p class="pad"></p>

<dd>None. First version</dd><p class="pad"></p>
</dl>

<h1><a name="CHANGES"
>CHANGES <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<dl>
<dt><a name="Version_1.3"
>Version 1.3</a></dt><p class="pad"></p>

<dd>Removed some unimplemented notes. Changed vtables to get_*, set_* so that they match other vtable function syntax.</dd><p class="pad"></p>

<dt><a name="Version_1.2"
>Version 1.2</a></dt><p class="pad"></p>

<dd>A complete overhaul from the original spec.</dd><p class="pad"></p>

<dt><a name="Version_1.1"
>Version 1.1</a></dt><p class="pad"></p>

<dd>Removed attributes from the object interface and put them in the class interface section, where they belong.</dd><p class="pad"></p>

<dt><a name="Version_1.0"
>Version 1.0</a></dt><p class="pad"></p>

<dd>None. First version</dd><p class="pad"></p>
</dl>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
