<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Lua String Library</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Lua String Library</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../../html/index.html">Contents</a> | <a href="../../../../html/languages.html">Language Implementations</a> | <a href="../../../../html/lua.html">Lua</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>lib/luastring.pir &#45; Lua String Library</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>This library provides generic functions for string manipulation,
such as finding and extracting substrings,
and pattern matching.
When indexing a string in Lua,
the first character is at position 1 (not at 0,
as in C).
Indices are allowed to be negative and are interpreted as indexing backwards,
from the end of the string.
Thus,
the last character is at position <i>&#45;1</i>,
and so on.</p>

<p>The string library provides all its functions inside the table <code lang='und' xml:lang='und'>string</code>.
It also sets a metatable for strings where the <code lang='und' xml:lang='und'>__index</code> field points to the metatable itself.
Therefore,
you can use the string functions in object&#45;oriented style.
For instance,
<code lang='und' xml:lang='und'>string.byte(s, i)</code> can be written as <code lang='und' xml:lang='und'>s:byte(i)</code>.</p>

<p>See &#34;Lua 5.1 Reference Manual&#34;,
section 5.4 &#34;String Manipulation&#34;.</p>

<h2><a name="Functions"
>Functions <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="string.byte_(s_[,_i_[,_j]])"
><b><code lang='und' xml:lang='und'>string.byte (s [, i [, j]])</b></code></a></dt><p class="pad"></p>

<dd>Returns the internal numerical codes of the characters <code lang='und' xml:lang='und'>s[i]</code>,
<code lang='und' xml:lang='und'>s[i+1]</code>,...,
<code lang='und' xml:lang='und'>s[j]</code>.
The default value for <code lang='und' xml:lang='und'>i</code> is 1; the default value for <code lang='und' xml:lang='und'>j</code> is <code lang='und' xml:lang='und'>i</code>.</dd><p class="pad"></p>

<dd>Note that numerical codes are not necessarily portable across platforms.</dd><p class="pad"></p>

<dt><a name="string.char_(i1,_i2,_...)"
><b><code lang='und' xml:lang='und'>string.char (i1, i2, ...)</b></code></a></dt><p class="pad"></p>

<dd>Receives 0 or more integers.
Returns a string with length equal to the number of arguments,
in which each character has the internal numerical code equal to its correspondent argument.</dd><p class="pad"></p>

<dd>Note that numerical codes are not necessarily portable across platforms.</dd><p class="pad"></p>

<dt><a name="string.dump_(function)"
><b><code lang='und' xml:lang='und'>string.dump (function)</b></code></a></dt><p class="pad"></p>

<dd>Returns a string containing a binary representation of the given function,
so that a later <code lang='und' xml:lang='und'>loadstring</code> on this string returns a copy of the function.
<code lang='und' xml:lang='und'>function</code> must be a Lua function without upvalues.</dd><p class="pad"></p>

<dd>NOT YET IMPLEMENTED.</dd><p class="pad"></p>

<dt><a name="string.find_(s,_pattern_[,_init_[,_plain]])"
><b><code lang='und' xml:lang='und'>string.find (s, pattern [, init [, plain]])</b></code></a></dt><p class="pad"></p>

<dd>Looks for the first <i>match</i> of <code lang='und' xml:lang='und'>pattern</code> in the string <code lang='und' xml:lang='und'>s</code>.
If it finds a match,
then <code lang='und' xml:lang='und'>find</code> returns the indices of <code lang='und' xml:lang='und'>s</code> where this occurrence starts and ends; otherwise,
it returns <b>nil</b>.
A third,
optional numerical argument <code lang='und' xml:lang='und'>init</code> specifies where to start the search; its default value is 1 and may be negative.
A value of <b>true</b> as a fourth,
optional argument <code lang='und' xml:lang='und'>plain</code> turns off the pattern matching facilities,
so the function does a plain &#34;find substring&#34; operation,
with no characters in <code lang='und' xml:lang='und'>pattern</code> being considered &#34;magic&#34;.
Note that if <code lang='und' xml:lang='und'>plain</code> is given,
then <code lang='und' xml:lang='und'>init</code> must be given as well.</dd><p class="pad"></p>

<dd>If the pattern has captures,
then in a successful match the captured values are also returned,
after the two indices.</dd><p class="pad"></p>

<dt><a name="string.format_(formatstring,_e1,_e2,_...)"
><b><code lang='und' xml:lang='und'>string.format (formatstring, e1, e2, ...)</b></code></a></dt><p class="pad"></p>

<dd>Returns a formatted version of its variable number of arguments following the description given in its first argument (which must be a string).
The format string follows the same rules as the <code lang='und' xml:lang='und'>printf</code> family of standard C functions.
The only differences are that the options/modifiers <code lang='und' xml:lang='und'>*</code>,
<code lang='und' xml:lang='und'>l</code>,
<code lang='und' xml:lang='und'>L</code>,
<code lang='und' xml:lang='und'>n</code>,
<code lang='und' xml:lang='und'>p</code>,
and <code lang='und' xml:lang='und'>h</code> are not supported,
and there is an extra option,
<code lang='und' xml:lang='und'>q</code>.
The <code lang='und' xml:lang='und'>q</code> option formats a string in a form suitable to be safely read back by the Lua interpreter: The string is written between double quotes,
and all double quotes,
newlines,
and backslashes in the string are correctly escaped when written.
For instance,
the call</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    string.format(&#146;%q&#146;, &#146;a string with &#34;quotes&#34; and \n new line&#146;)</pre>

<dd>will produce the string:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    &#34;a string with \&#34;quotes\&#34; and \
     new line&#34;</pre>

<dd>The options <code lang='und' xml:lang='und'>c</code>, <code lang='und' xml:lang='und'>d</code>, <code lang='und' xml:lang='und'>E</code>, <code lang='und' xml:lang='und'>e</code>, <code lang='und' xml:lang='und'>f</code>, <code lang='und' xml:lang='und'>g</code>, <code lang='und' xml:lang='und'>G</code>, <code lang='und' xml:lang='und'>i</code>, <code lang='und' xml:lang='und'>o</code>, <code lang='und' xml:lang='und'>u</code>, <code lang='und' xml:lang='und'>X</code>, and <code lang='und' xml:lang='und'>x</code> all expect a number as argument, whereas <code lang='und' xml:lang='und'>q</code> and <code lang='und' xml:lang='und'>s</code> expect a string.</dd><p class="pad"></p>

<dd>This function does not accept string values containing embedded zeros.</dd><p class="pad"></p>

<dt><a name="string.gmatch_(s,_pattern)"
><b><code lang='und' xml:lang='und'>string.gmatch (s, pattern)</b></code></a></dt><p class="pad"></p>

<dd>Returns an iterator function that, each time it is called, returns the next captures from pattern <code lang='und' xml:lang='und'>pattern</code> over string <code lang='und' xml:lang='und'>s</code>.</dd><p class="pad"></p>

<dd>If <code lang='und' xml:lang='und'>pattern</code> specifies no captures, then the whole match is produced in each call.</dd><p class="pad"></p>

<dd>As an example, the following loop</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    s = &#34;hello world from Lua&#34;
    for w in string.gmatch(s, &#34;%a+&#34;) do
        print(w)
    end</pre>

<dd>will iterate over all the words from string <code lang='und' xml:lang='und'>s</code>, printing one per line. The next example collects all pairs <code lang='und' xml:lang='und'>key=value</code> from the given string into a table:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    t = {}
    s = &#34;from=world, to=Lua&#34;
    for k, v in string.gmatch(s, &#34;(%w+)=(%w+)&#34;) do
        t[k] = v
    end</pre>

<dt><a name="string.gsub_(s,_pat,_repl_[,_n])"
><b><code lang='und' xml:lang='und'>string.gsub (s, pat, repl [, n])</b></code></a></dt><p class="pad"></p>

<dd>Returns a copy of <code lang='und' xml:lang='und'>s</code> in which all occurrences of the pattern <code lang='und' xml:lang='und'>pat</code> have been replaced by a replacement string specified by <code lang='und' xml:lang='und'>repl</code>. <code lang='und' xml:lang='und'>gsub</code> also returns, as a second value, the total number of substitutions made.</dd><p class="pad"></p>

<dd>If <code lang='und' xml:lang='und'>repl</code> is a string, then its value is used for replacement. Any sequence in <code lang='und' xml:lang='und'>repl</code> of the form %<i>n</i>, with <i>n</i> between 1 and 9, stands for the value of the <i>n</i>&#45;th captured substring.</dd><p class="pad"></p>

<dd>If <code lang='und' xml:lang='und'>repl</code> is a function, then this function is called every time a match occurs, with all captured substrings passed as arguments, in order; if the pattern specifies no captures, then the whole match is passed as a sole argument. If the value returned by this function is a string, then it is used as the replacement string; otherwise, the replacement string is the empty string.</dd><p class="pad"></p>

<dd>The optional last parameter <code lang='und' xml:lang='und'>n</code> limits the maximum number of substitutions to occur. For instance, when <code lang='und' xml:lang='und'>n</code> is 1 only the first occurrence of <code lang='und' xml:lang='und'>pat</code> is replaced.</dd><p class="pad"></p>

<dt><a name="string.len_(s)"
><b><code lang='und' xml:lang='und'>string.len (s)</b></code></a></dt><p class="pad"></p>

<dd>Receives a string and returns its length. The empty string <code lang='und' xml:lang='und'>&#34;&#34;</code> has length 0. Embedded zeros are counted, so <code lang='und' xml:lang='und'>&#34;a\000b\000c&#34;</code> has length 5.</dd><p class="pad"></p>

<dt><a name="string.lower_(s)"
><b><code lang='und' xml:lang='und'>string.lower (s)</b></code></a></dt><p class="pad"></p>

<dd>Receives a string and returns a copy of that string with all uppercase letters changed to lowercase. All other characters are left unchanged. The definition of what is an uppercase letter depends on the current locale.</dd><p class="pad"></p>

<dt><a name="string.match_(s,_pattern_[,_init])"
><b><code lang='und' xml:lang='und'>string.match (s, pattern [, init])</b></code></a></dt><p class="pad"></p>

<dd>Looks for the first <i>match</i> of <code lang='und' xml:lang='und'>pattern</code> in the string <code lang='und' xml:lang='und'>s</code>. If it finds one, then <code lang='und' xml:lang='und'>match</code> returns the captures from the pattern; otherwise it returns <b>nil</b>. If <code lang='und' xml:lang='und'>pattern</code> specifies no captures, then the whole match is returned. A third, optional numerical argument <code lang='und' xml:lang='und'>init</code> specifies where to start the search; its default value is 1 and may be negative.</dd><p class="pad"></p>

<dt><a name="string.rep_(s,_n)"
><b><code lang='und' xml:lang='und'>string.rep (s, n)</b></code></a></dt><p class="pad"></p>

<dd>Returns a string that is the concatenation of <code lang='und' xml:lang='und'>n</code> copies of the string <code lang='und' xml:lang='und'>s</code>.</dd><p class="pad"></p>

<dt><a name="string.reverse_(s)"
><b><code lang='und' xml:lang='und'>string.reverse (s)</b></code></a></dt><p class="pad"></p>

<dd>Returns a string that is the string <code lang='und' xml:lang='und'>s</code> reversed.</dd><p class="pad"></p>

<dt><a name="string.sub_(s,_i_[,_j])"
><b><code lang='und' xml:lang='und'>string.sub (s, i [, j])</b></code></a></dt><p class="pad"></p>

<dd>Returns the substring of <code lang='und' xml:lang='und'>s</code> that starts at <code lang='und' xml:lang='und'>i</code> and continues until <code lang='und' xml:lang='und'>j</code>; <code lang='und' xml:lang='und'>i</code> and <code lang='und' xml:lang='und'>j</code> may be negative. If <code lang='und' xml:lang='und'>j</code> is absent, then it is assumed to be equal to &#45;1 (which is the same as the string length). In particular, the call <code lang='und' xml:lang='und'>string.sub(s,1,j)</code> returns a prefix of <code lang='und' xml:lang='und'>s</code> with length <code lang='und' xml:lang='und'>j</code>, and <code lang='und' xml:lang='und'>string.sub(s, &#45;i)</code> returns a suffix of <code lang='und' xml:lang='und'>s</code> with length <code lang='und' xml:lang='und'>i</code>.</dd><p class="pad"></p>

<dt><a name="string.upper_(s)"
><b><code lang='und' xml:lang='und'>string.upper (s)</b></code></a></dt><p class="pad"></p>

<dd>Receives a string and returns a copy of that string with all lowercase letters changed to uppercase. All other characters are left unchanged. The definition of what is a lowercase letter depends on the current locale.</dd><p class="pad"></p>
</dl>

<h1><a name="AUTHORS"
>AUTHORS <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>Francois Perrad</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
