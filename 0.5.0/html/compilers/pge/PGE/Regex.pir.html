<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>base class for grammars and built&#45;in rules</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">base class for grammars and built&#45;in rules</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../../html/index.html">Contents</a> | <a href="../../../../html/compilers.html">Compilers</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="TITLE"
>TITLE <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>Regex &#45; base class for grammars and built&#45;in rules</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>This implements the base classes for forming grammars,
and provides a number of built&#45;in rules.</p>

<h2><a name="Built&#45;in_regex"
>Built&#45;in regex <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="ident()"
><b><code lang='und' xml:lang='und'>ident()</b></code></a></dt><p class="pad"></p>

<dd>Match an identifier.</dd><p class="pad"></p>

<dt><a name="null()"
><b><code lang='und' xml:lang='und'>null()</b></code></a></dt><p class="pad"></p>

<dd>Match a null string (always returns true on first match).</dd><p class="pad"></p>

<dt><a name="fail()"
><b><code lang='und' xml:lang='und'>fail()</b></code></a></dt><p class="pad"></p>

<dd>Force a backtrack.
(Taken from A05.)</dd><p class="pad"></p>

<dt><a name="upper()"
><b><code lang='und' xml:lang='und'>upper()</b></code></a></dt><p class="pad"></p>

<dd>Match a single uppercase character.</dd><p class="pad"></p>

<dt><a name="lower()"
><b><code lang='und' xml:lang='und'>lower()</b></code></a></dt><p class="pad"></p>

<dd>Match a single lowercase character.</dd><p class="pad"></p>

<dt><a name="alpha()"
><b><code lang='und' xml:lang='und'>alpha()</b></code></a></dt><p class="pad"></p>

<dd>Match a single alphabetic character.</dd><p class="pad"></p>

<dt><a name="digit()"
><b><code lang='und' xml:lang='und'>digit()</b></code></a></dt><p class="pad"></p>

<dd>Match a single digit.</dd><p class="pad"></p>

<dt><a name="xdigit()"
><b><code lang='und' xml:lang='und'>xdigit()</b></code></a></dt><p class="pad"></p>

<dd>Match a single alphanumeric character.</dd><p class="pad"></p>

<dt><a name="space()"
><b><code lang='und' xml:lang='und'>space()</b></code></a></dt><p class="pad"></p>

<dd>Match a single whitespace character.</dd><p class="pad"></p>

<dt><a name="print()"
><b><code lang='und' xml:lang='und'>print()</b></code></a></dt><p class="pad"></p>

<dd>Match a single printable character.</dd><p class="pad"></p>

<dt><a name="graph()"
><b><code lang='und' xml:lang='und'>graph()</b></code></a></dt><p class="pad"></p>

<dd>Match a single &#34;graphical&#34; character.</dd><p class="pad"></p>

<dt><a name="blank()"
><b><code lang='und' xml:lang='und'>blank()</b></code></a></dt><p class="pad"></p>

<dd>Match a single &#34;blank&#34; character.</dd><p class="pad"></p>

<dt><a name="cntrl()"
><b><code lang='und' xml:lang='und'>cntrl()</b></code></a></dt><p class="pad"></p>

<dd>Match a single &#34;control&#34; character.</dd><p class="pad"></p>

<dt><a name="punct()"
><b><code lang='und' xml:lang='und'>punct()</b></code></a></dt><p class="pad"></p>

<dd>Match a single punctuation character.</dd><p class="pad"></p>

<dt><a name="alnum()"
><b><code lang='und' xml:lang='und'>alnum()</b></code></a></dt><p class="pad"></p>

<dd>Match a single alphanumeric character.</dd><p class="pad"></p>

<dt><a name="sp()"
><b><code lang='und' xml:lang='und'>sp()</b></code></a></dt><p class="pad"></p>

<dd>Match a single space character.
(Taken from E05.)</dd><p class="pad"></p>

<dt><a name="lt()"
><b><code lang='und' xml:lang='und'>lt()</b></code></a></dt><p class="pad"></p>

<dd>Match a single left angle bracket.
(Taken from E05.)</dd><p class="pad"></p>

<dt><a name="gt()"
><b><code lang='und' xml:lang='und'>gt()</b></code></a></dt><p class="pad"></p>

<dd>Match a single right angle bracket.
(Taken from E05.)</dd><p class="pad"></p>

<dt><a name="dot()"
><b><code lang='und' xml:lang='und'>dot()</b></code></a></dt><p class="pad"></p>

<dd>Match a single dot (&#39;.&#39;).
(Taken from E05.)</dd><p class="pad"></p>

<dt><a name="ws()"
><b><code lang='und' xml:lang='und'>ws()</b></code></a></dt><p class="pad"></p>

<dd>Match whitespace between tokens.</dd><p class="pad"></p>

<dt><a name="wb(PMC_mob)"
><b><code lang='und' xml:lang='und'>wb(PMC mob)</b></code></a></dt><p class="pad"></p>

<dd>Returns true if we&#39;re at a word boundary (as defined by Perl 5&#39;s \b regex).</dd><p class="pad"></p>

<dt><a name="before(PMC_mob,_STR_pattern)"
><b><code lang='und' xml:lang='und'>before(PMC mob, STR pattern)</b></code></a></dt><p class="pad"></p>

<dd>Perform lookahead &#45;&#45; i.e.,
check if we&#39;re at a position where <code lang='und' xml:lang='und'>pattern</code> matches.
Returns a zero&#45;width Match object on success.</dd><p class="pad"></p>

<dt><a name="after(PMC_mob,_STR_pattern)"
><b><code lang='und' xml:lang='und'>after(PMC mob, STR pattern)</b></code></a></dt><p class="pad"></p>

<dd>Perform lookbehind &#45;&#45; i.e.,
check if the string before the current position matches &#60;pattern&#62; (anchored at the end).
Returns a zero&#45;width Match object on success.</dd><p class="pad"></p>

<dd>XXX: Note that this implementation cheats in a big way.
S05 says that <code lang='und' xml:lang='und'>after</code> is implemented by reversing the syntax tree and looking for things in opposite order going to the left.
This implementation just grabs the (sub)string up to the current match position and tests that,
anchoring the pattern to the end of the substring.
It&#39;s cheap and potentially very inefficient,
but it &#34;works&#34; for now.</dd><p class="pad"></p>
</dl>

<h2><a name="Support_subroutines"
>Support subroutines <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="!cclass(mob,_cclass)"
><b><code lang='und' xml:lang='und'>!cclass(mob, cclass)</b></code></a></dt><p class="pad"></p>

<dd>Match according to character class <code lang='und' xml:lang='und'>cclass</code>.</dd><p class="pad"></p>

<dt><a name="!literal(mob,_literal)"
><b><code lang='und' xml:lang='und'>!literal(mob, literal)</b></code></a></dt><p class="pad"></p>

<dd>Match according to <code lang='und' xml:lang='und'>literal</code>.</dd><p class="pad"></p>
</dl>

<h1><a name="AUTHOR"
>AUTHOR <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>Patrick Michaud (pmichaud@pobox.com) is the author and maintainer.
Patches and suggestions should be sent to the Perl 6 compiler list (perl6&#45;compiler@perl.org).</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../../resources/parrot_small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
