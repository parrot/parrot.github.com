<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>compilers/imcc/symreg.c</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">compilers/imcc/symreg.c</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../html/index.html">Contents</a> | <a href="../../../html/compilers.html">Compilers</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>compilers/imcc/symreg.c</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>imcc symbol handling</p>

<p>XXX: SymReg stuff has become overused.
SymReg should be for symbolic registers,
reg allocation,
etc.
but we are now using it for extensive symbol table management.
Need to convert much of this over the use Symbol and SymbolTable (see symbol.h and symbol.c)</p>

<h2><a name="Functions"
>Functions <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="void_push_namespace(char_*_name)"
><b><code lang='und' xml:lang='und'>void push_namespace(char *name)</b></code></a></dt><p class="pad"></p>

<dd>TODO: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="void_pop_namespace(NULLOK(char_*name))"
><b><code lang='und' xml:lang='und'>void pop_namespace(NULLOK(char *name))</b></code></a></dt><p class="pad"></p>

<dd>TODO: Not yet documented!!!</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>static SymReg *_get_sym_typed(NOTNULL(const SymHash *hsh), NOTNULL(const char *name), int t)</b></code></a></dt><p class="pad"></p>

<dd>Gets a symbol from the hash</dd><p class="pad"></p>

<dt><a name="SymReg_*__mk_symreg(NOTNULL(SymHash*_hsh),_NOTNULL(char_*name),_int_t)"
><b><code lang='und' xml:lang='und'>SymReg *_mk_symreg(NOTNULL(SymHash *hsh), NOTNULL(char *name), int t)</b></code></a></dt><p class="pad"></p>

<dd>Makes a new SymReg from its varname and type</dd><p class="pad"></p>

<dd>char * name is a malloced string that will be used if the symbol needs to be created,
or freed if an old symbol is found.
This is a potentially dangerous semantic that should be changed.</dd><p class="pad"></p>

<dt><a name="SymReg_*_mk_symreg(PARROT_INTERP,_NOTNULL(char_*name),_int_t)"
><b><code lang='und' xml:lang='und'>SymReg *mk_symreg(PARROT_INTERP, NOTNULL(char *name), int t)</b></code></a></dt><p class="pad"></p>

<dd>TODO: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="PARROT_MALLOC_char_*_symreg_to_str(NOTNULL(const_SymReg_*s))"
><b><code lang='und' xml:lang='und'>PARROT_MALLOC char *symreg_to_str(NOTNULL(const SymReg *s))</b></code></a></dt><p class="pad"></p>

<dd>Dump a SymReg to a printable format.</dd><p class="pad"></p>

<dt><a name="SymReg_*_mk_temp_reg(PARROT_INTERP,_int_t)"
><b><code lang='und' xml:lang='und'>SymReg *mk_temp_reg(PARROT_INTERP, int t)</b></code></a></dt><p class="pad"></p>

<dd>TODO: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="SymReg_*_mk_pcc_sub(PARROT_INTERP,_NOTNULL(char_*name),_int_proto)"
><b><code lang='und' xml:lang='und'>SymReg *mk_pcc_sub(PARROT_INTERP, NOTNULL(char *name), int proto)</b></code></a></dt><p class="pad"></p>

<dd>TODO: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="void_add_namespace(PARROT_INTERP,_NOTNULL(struct__IMC_Unit_*unit))"
><b><code lang='und' xml:lang='und'>void add_namespace(PARROT_INTERP, NOTNULL(struct _IMC_Unit *unit))</b></code></a></dt><p class="pad"></p>

<dd>add current namespace to sub decl</dd><p class="pad"></p>

<dt><a name="void_add_pcc_arg(NOTNULL(SymReg_*r),_NOTNULL(SymReg_*arg))"
><b><code lang='und' xml:lang='und'>void add_pcc_arg(NOTNULL(SymReg *r), NOTNULL(SymReg *arg))</b></code></a></dt><p class="pad"></p>

<dd>Add a register or constant to the function arg list</dd><p class="pad"></p>

<dt><a name="void_add_pcc_param(NOTNULL(SymReg_*r),_NOTNULL(SymReg_*arg))"
><b><code lang='und' xml:lang='und'>void add_pcc_param(NOTNULL(SymReg *r), NOTNULL(SymReg *arg))</b></code></a></dt><p class="pad"></p>

<dd>TODO: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="void_add_pcc_result(NOTNULL(SymReg_*r),_NOTNULL(SymReg_*arg))"
><b><code lang='und' xml:lang='und'>void add_pcc_result(NOTNULL(SymReg *r), NOTNULL(SymReg *arg))</b></code></a></dt><p class="pad"></p>

<dd>TODO: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="void_add_pcc_multi(NOTNULL(SymReg_*r),_SymReg_*arg)"
><b><code lang='und' xml:lang='und'>void add_pcc_multi(NOTNULL(SymReg *r), SymReg *arg)</b></code></a></dt><p class="pad"></p>

<dd>TODO: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="void_add_pcc_return(NOTNULL(SymReg_*r),_NOTNULL(SymReg_*arg))"
><b><code lang='und' xml:lang='und'>void add_pcc_return(NOTNULL(SymReg *r), NOTNULL(SymReg *arg))</b></code></a></dt><p class="pad"></p>

<dd>TODO: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="void_add_pcc_sub(NOTNULL(SymReg_*r),_SymReg_*_arg)"
><b><code lang='und' xml:lang='und'>void add_pcc_sub(NOTNULL(SymReg *r), SymReg *arg)</b></code></a></dt><p class="pad"></p>

<dd>TODO: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="void_add_pcc_cc(NOTNULL(SymReg_*r),_SymReg_*arg)"
><b><code lang='und' xml:lang='und'>void add_pcc_cc(NOTNULL(SymReg *r), SymReg *arg)</b></code></a></dt><p class="pad"></p>

<dd>TODO: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="SymReg_*_mk_pasm_reg(PARROT_INTERP,_char_*name)"
><b><code lang='und' xml:lang='und'>SymReg *mk_pasm_reg(PARROT_INTERP, char *name)</b></code></a></dt><p class="pad"></p>

<dd>TODO: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="char_*__mk_fullname(NULLOK(const_Namespace_*ns),_NOTNULL(const_char_*name))"
><b><code lang='und' xml:lang='und'>char *_mk_fullname(NULLOK(const Namespace *ns), NOTNULL(const char *name))</b></code></a></dt><p class="pad"></p>

<dd>TODO: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="char_*_mk_fullname(NOTNULL(const_char_*name))"
><b><code lang='und' xml:lang='und'>char *mk_fullname(NOTNULL(const char *name))</b></code></a></dt><p class="pad"></p>

<dd>TODO: Not yet documented!!!</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_CANNOT_RETURN_NULL PARROT_WARN_UNUSED_RESULT SymReg *mk_ident(PARROT_INTERP, NOTNULL(char *name), int t)</b></code></a></dt><p class="pad"></p>

<dd>Makes a new identifier</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_CANNOT_RETURN_NULL PARROT_WARN_UNUSED_RESULT SymReg *mk_ident_ur(PARROT_INTERP, NOTNULL(char *name), int t)</b></code></a></dt><p class="pad"></p>

<dd>TODO: Not yet documented!!!</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_CANNOT_RETURN_NULL PARROT_WARN_UNUSED_RESULT static SymReg *mk_pmc_const_2(PARROT_INTERP, NOTNULL(IMC_Unit *unit), NOTNULL(SymReg *left), NOTNULL(SymReg *rhs))</b></code></a></dt><p class="pad"></p>

<dd>TODO: Not yet documented!!!</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>SymReg *mk_const_ident(PARROT_INTERP, NOTNULL(char *name), int t, NOTNULL(SymReg *val), int global)</b></code></a></dt><p class="pad"></p>

<dd>Makes a new identifier constant with value val</dd><p class="pad"></p>

<dt><a name="SymReg_*__mk_const(NOTNULL(SymHash_*hsh),_NOTNULL(const_char_*name),_int_t)"
><b><code lang='und' xml:lang='und'>SymReg *_mk_const(NOTNULL(SymHash *hsh), NOTNULL(const char *name), int t)</b></code></a></dt><p class="pad"></p>

<dd>Makes a new constant</dd><p class="pad"></p>

<dt><a name="SymReg_*_mk_const(PARROT_INTERP,_NOTNULL(const_char_*name),_int_t)"
><b><code lang='und' xml:lang='und'>SymReg *mk_const(PARROT_INTERP, NOTNULL(const char *name), int t)</b></code></a></dt><p class="pad"></p>

<dd>TODO: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_char_*_add_ns(PARROT_INTERP,_NOTNULL(char_*name))"
><b><code lang='und' xml:lang='und'>static char *add_ns(PARROT_INTERP, NOTNULL(char *name))</b></code></a></dt><p class="pad"></p>

<dd>add namespace to sub if any</dd><p class="pad"></p>

<dt><a name="SymReg_*__mk_address(PARROT_INTERP,_NOTNULL(SymHash_*hsh),_NOTNULL(char_*name),_int_uniq)"
><b><code lang='und' xml:lang='und'>SymReg *_mk_address(PARROT_INTERP, NOTNULL(SymHash *hsh), NOTNULL(char *name), int uniq)</b></code></a></dt><p class="pad"></p>

<dd>Makes a new address</dd><p class="pad"></p>

<dt><a name="SymReg_*_mk_address(PARROT_INTERP,_char_*name,_int_uniq)"
><b><code lang='und' xml:lang='und'>SymReg *mk_address(PARROT_INTERP, char *name, int uniq)</b></code></a></dt><p class="pad"></p>

<dd>Eventually make mk_address static</dd><p class="pad"></p>

<dt><a name="SymReg_*_mk_sub_label(PARROT_INTERP,_NOTNULL(char_*name))"
><b><code lang='und' xml:lang='und'>SymReg *mk_sub_label(PARROT_INTERP, NOTNULL(char *name))</b></code></a></dt><p class="pad"></p>

<dd>Make and store a new address label for a sub.
Label gets a fixup entry.</dd><p class="pad"></p>

<dt><a name="SymReg_*_mk_sub_address(PARROT_INTERP,_NOTNULL(char_*name))"
><b><code lang='und' xml:lang='und'>SymReg *mk_sub_address(PARROT_INTERP, NOTNULL(char *name))</b></code></a></dt><p class="pad"></p>

<dd>Make a symbol for a label,
symbol gets a fixup entry.</dd><p class="pad"></p>

<dt><a name="SymReg_*_mk_local_label(PARROT_INTERP,_NOTNULL(char_*name))"
><b><code lang='und' xml:lang='und'>SymReg *mk_local_label(PARROT_INTERP, NOTNULL(char *name))</b></code></a></dt><p class="pad"></p>

<dd>Make a local symbol,
no fixup entry.</dd><p class="pad"></p>

<dt><a name="SymReg_*_mk_label_address(PARROT_INTERP,_NOTNULL(char_*name))"
><b><code lang='und' xml:lang='und'>SymReg *mk_label_address(PARROT_INTERP, NOTNULL(char *name))</b></code></a></dt><p class="pad"></p>

<dd>TODO: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="PARROT_MALLOC_SymReg_*_dup_sym(NOTNULL(const_SymReg_*r))"
><b><code lang='und' xml:lang='und'>PARROT_MALLOC SymReg *dup_sym(NOTNULL(const SymReg *r))</b></code></a></dt><p class="pad"></p>

<dd>link keys to a keys structure = SymReg</dd><p class="pad"></p>

<dd>we might have</dd><p class="pad"></p>

<dd>what op type pbc.c:build_key() &#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; int const _kic VTCONST no int reg _ki VTREG no str const _kc VTCONST yes str reg _kc VTREG yes</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'> &#34;key&#34; &#39;;&#39; &#34;key&#34; _kc           &#45;&#62; (list of above)   yes
 &#34;key&#34; &#39;;&#39; $I0   _kc  VTREGKEY &#45;&#62; (list of above)   yes

 The information about which reg should be passed to build_key() is
 in the instruction.

 A key containing a variable has a special flag VTREGKEY
 because this key must be considered for life analysis for
 all the chain members, that are variables.

 An instruction with a keychain looks like this

 e.h. set I0, P[&#34;abc&#34;;0;I1]

 ins&#45;&#62;r[2]  = keychain  &#39;K&#39;
 keychain&#45;&#62;nextkey = SymReg(VTCONST) &#34;abc&#34;
             &#45;&#62;nextkey = SymReg(VTCONST) 0
                &#45;&#62;nextkey = SymReg(VTREG), ...&#45;&#62;reg = VTVAR I1
                   &#45;&#62;nextkey = 0

 We can&#39;t use the consts or keys in the chain directly,
 because a different usage would destroy the &#45;&#62;nextkey pointers
 so these are all copies.
 XXX and currently not freed</pre>

<dt><a name="SymReg_*_link_keys(PARROT_INTERP,_int_nargs,_NOTNULL(SymReg_*_keys[]),_int_force)"
><b><code lang='und' xml:lang='und'>SymReg *link_keys(PARROT_INTERP, int nargs, NOTNULL(SymReg *keys[]), int force)</b></code></a></dt><p class="pad"></p>

<dd>TODO: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="void_free_sym(NOTNULL(SymReg_*r))"
><b><code lang='und' xml:lang='und'>void free_sym(NOTNULL(SymReg *r))</b></code></a></dt><p class="pad"></p>

<dd>TODO: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="void_create_symhash(NOTNULL(SymHash_*hash))"
><b><code lang='und' xml:lang='und'>void create_symhash(NOTNULL(SymHash *hash))</b></code></a></dt><p class="pad"></p>

<dd>TODO: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_void_resize_symhash(NOTNULL(SymHash_*hsh))"
><b><code lang='und' xml:lang='und'>static void resize_symhash(NOTNULL(SymHash *hsh))</b></code></a></dt><p class="pad"></p>

<dd>TODO: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="void__store_symreg(NOTNULL(SymHash_*hsh),_NOTNULL(SymReg_*r))"
><b><code lang='und' xml:lang='und'>void _store_symreg(NOTNULL(SymHash *hsh), NOTNULL(SymReg *r))</b></code></a></dt><p class="pad"></p>

<dd>Stores a symbol into the hash</dd><p class="pad"></p>

<dt><a name="void_store_symreg(PARROT_INTERP,_NOTNULL(SymReg_*r))"
><b><code lang='und' xml:lang='und'>void store_symreg(PARROT_INTERP, NOTNULL(SymReg *r))</b></code></a></dt><p class="pad"></p>

<dd>TODO: Not yet documented!!!</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_CAN_RETURN_NULL PARROT_WARN_UNUSED_RESULT SymReg *_get_sym(NOTNULL(SymHash *hsh), NOTNULL(const char *name))</b></code></a></dt><p class="pad"></p>

<dd>Gets a symbol from the hash</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_CAN_RETURN_NULL PARROT_WARN_UNUSED_RESULT SymReg *get_sym(PARROT_INTERP, NOTNULL(const char *name))</b></code></a></dt><p class="pad"></p>

<dd>Gets a symbol from the current unit symbol table</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_CAN_RETURN_NULL PARROT_WARN_UNUSED_RESULT SymReg *_find_sym(PARROT_INTERP, NULLOK(const Namespace *nspace), NOTNULL(SymHash *hsh), NOTNULL(const char *name))</b></code></a></dt><p class="pad"></p>

<dd>find a symbol hash or ghash</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_CAN_RETURN_NULL PARROT_WARN_UNUSED_RESULT SymReg *find_sym(PARROT_INTERP, NOTNULL(const char *name))</b></code></a></dt><p class="pad"></p>

<dd>TODO: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="void_clear_sym_hash(NOTNULL(SymHash_*hsh))"
><b><code lang='und' xml:lang='und'>void clear_sym_hash(NOTNULL(SymHash *hsh))</b></code></a></dt><p class="pad"></p>

<dd>TODO: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="void_debug_dump_sym_hash(NOTNULL(SymHash_*hsh))"
><b><code lang='und' xml:lang='und'>void debug_dump_sym_hash(NOTNULL(SymHash *hsh))</b></code></a></dt><p class="pad"></p>

<dd>TODO: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="void_clear_locals(NULLOK(struct__IMC_Unit_*unit))"
><b><code lang='und' xml:lang='und'>void clear_locals(NULLOK(struct _IMC_Unit *unit))</b></code></a></dt><p class="pad"></p>

<dd>Deletes all local symbols and clears life info</dd><p class="pad"></p>

<dt><a name="void_clear_globals(PARROT_INTERP)"
><b><code lang='und' xml:lang='und'>void clear_globals(PARROT_INTERP)</b></code></a></dt><p class="pad"></p>

<dd>Clear global symbols</dd><p class="pad"></p>

<dt><a name="PARROT_PURE_FUNCTION_unsigned_int_hash_str(NOTNULL(const_char_*str))"
><b><code lang='und' xml:lang='und'>PARROT_PURE_FUNCTION unsigned int hash_str(NOTNULL(const char *str))</b></code></a></dt><p class="pad"></p>

<dd>TODO: Not yet documented!!!</dd><p class="pad"></p>
</dl>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../resources/parrot_small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
