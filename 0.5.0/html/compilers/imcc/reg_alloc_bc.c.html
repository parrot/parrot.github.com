<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>by Bill Coffman</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">by Bill Coffman</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../html/index.html">Contents</a> | <a href="../../../html/compilers.html">Compilers</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>compilers/imcc/reg_alloc_bc.c &#45; by Bill Coffman</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Register allocator:</p>

<p>This is a brute force register allocator.
It uses a graph&#45;coloring algorithm,
but the implementation is very kludgy.</p>

<p>It is a partial implementation of a Briggs&#45;style register allocator The following parts are just missing:</p>

<pre lang='und' xml:lang='und'> &#45; Renumbering
 &#45; Coaelesceing</pre>

<h2><a name="Functions"
>Functions <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="static_unsigned_int_bits_per_int(void)"
><b><code lang='und' xml:lang='und'>static unsigned int bits_per_int(void)</b></code></a></dt><p class="pad"></p>

<dd>TODO: Not yet documented!!!</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>static unsigned int *ig_get_word(int i, int j, int N, unsigned int *edgebits, int *bit_ofs)</b></code></a></dt><p class="pad"></p>

<dd>TODO: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_void_ig_set(int_i,_int_j,_int_N,_unsigned_int*_edgebits)"
><b><code lang='und' xml:lang='und'>static void ig_set(int i, int j, int N, unsigned int *edgebits)</b></code></a></dt><p class="pad"></p>

<dd>TODO: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="int_ig_test(int_i,_int_j,_int_N,_unsigned_int*_edgebits)"
><b><code lang='und' xml:lang='und'>int ig_test(int i, int j, int N, unsigned int *edgebits)</b></code></a></dt><p class="pad"></p>

<dd>TODO: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_unsigned_int*_ig_allocate(int_N)"
><b><code lang='und' xml:lang='und'>static unsigned int *ig_allocate(int N)</b></code></a></dt><p class="pad"></p>

<dd>TODO: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="void_imc_reg_alloc(PARROT_INTERP,_IMC_Unit_*_unit)"
><b><code lang='und' xml:lang='und'>void imc_reg_alloc(PARROT_INTERP, IMC_Unit *unit)</b></code></a></dt><p class="pad"></p>

<dd>imc_reg_alloc is the main loop of the allocation algorithm. It operates on a single compilation unit at a time.</dd><p class="pad"></p>

<dt><a name="void_free_reglist(IMC_Unit_*_unit)"
><b><code lang='und' xml:lang='und'>void free_reglist(IMC_Unit *unit)</b></code></a></dt><p class="pad"></p>

<dd>TODO: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_void_make_stat(IMC_Unit_*_unit,_int_*sets,_int_*cols)"
><b><code lang='und' xml:lang='und'>static void make_stat(IMC_Unit *unit, int *sets, int *cols)</b></code></a></dt><p class="pad"></p>

<dd>some statistics about register usage printed with &#45;&#45;verbose &#45;&#45;verbose</dd><p class="pad"></p>

<dt><a name="static_void_imc_stat_init(IMC_Unit_*_unit)"
><b><code lang='und' xml:lang='und'>static void imc_stat_init(IMC_Unit *unit)</b></code></a></dt><p class="pad"></p>

<dd>TODO: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_void_print_stat(Parrot_Interp_interp,_IMC_Unit_*_unit)"
><b><code lang='und' xml:lang='und'>static void print_stat(Parrot_Interp interp, IMC_Unit *unit)</b></code></a></dt><p class="pad"></p>

<dd>TODO: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_int_reg_sort_f(const_void_*a,_const_void_*b)"
><b><code lang='und' xml:lang='und'>static int reg_sort_f(const void *a, const void *b)</b></code></a></dt><p class="pad"></p>

<dd>sort list by line nr</dd><p class="pad"></p>

<dt><a name="static_void_sort_reglist(IMC_Unit_*unit)"
><b><code lang='und' xml:lang='und'>static void sort_reglist(IMC_Unit *unit)</b></code></a></dt><p class="pad"></p>

<dd>TODO: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_void_build_reglist(Parrot_Interp_interp,_IMC_Unit_*_unit,_int_first)"
><b><code lang='und' xml:lang='und'>static void build_reglist(Parrot_Interp interp, IMC_Unit *unit, int first)</b></code></a></dt><p class="pad"></p>

<dd>make a linear list of IDENTs and VARs, set n_symbols TODO split the whole life analysis into 4, one per register kind registers of different kind never interfer, but the reglist has them all</dd><p class="pad"></p>

<dt><a name="static_void_build_interference_graph(Parrot_Interp_interp,_IMC_Unit*_unit,_graph*_G)"
><b><code lang='und' xml:lang='und'>static void build_interference_graph(Parrot_Interp interp, IMC_Unit *unit, graph *G)</b></code></a></dt><p class="pad"></p>

<dd>creates the interference graph between the variables.</dd><p class="pad"></p>

<dd>data structure is a 2&#45;d array &#39;interference_graph&#39; bitmap where row/column indices represent the same index in the list of all symbols (unit&#45;&#62;reglist) in the current compilation unit.</dd><p class="pad"></p>

<dd>two variables interfere when they are alive at the same time</dd><p class="pad"></p>

<dt><a name="static_void_compute_du_chain(IMC_Unit_*_unit)"
><b><code lang='und' xml:lang='und'>static void compute_du_chain(IMC_Unit *unit)</b></code></a></dt><p class="pad"></p>

<dd>Compute a DU&#45;chain for each symbolic in a compilation unit</dd><p class="pad"></p>

<dt><a name="static_void_compute_one_du_chain(SymReg_*_r,_IMC_Unit_*_unit)"
><b><code lang='und' xml:lang='und'>static void compute_one_du_chain(SymReg *r, IMC_Unit *unit)</b></code></a></dt><p class="pad"></p>

<dd>TODO: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_void_compute_spilling_costs(Parrot_Interp_interp,_IMC_Unit_*_unit)"
><b><code lang='und' xml:lang='und'>static void compute_spilling_costs(Parrot_Interp interp, IMC_Unit *unit)</b></code></a></dt><p class="pad"></p>

<dd>Computes the cost of spilling each symbol. This is estimated by the number of times the symbol appears, weighted by X*loop_depth</dd><p class="pad"></p>

<dt><a name="static_int_interferes(PARROT_INTERP,_IMC_Unit_*_unit,_SymReg_*_r0,_SymReg_*_r1)"
><b><code lang='und' xml:lang='und'>static int interferes(PARROT_INTERP, IMC_Unit *unit, SymReg *r0, SymReg *r1)</b></code></a></dt><p class="pad"></p>

<dd>See if r0&#39;s chain interferes with r1.</dd><p class="pad"></p>

<dd>We currently decide that two vars interfere if they are both alive at any point. This could be improved, requiring that one is alive at the point of _definition_ of the other.</dd><p class="pad"></p>

<dt><a name="static_void_allocate_wanted_regs(IMC_Unit_*_unit)"
><b><code lang='und' xml:lang='und'>static void allocate_wanted_regs(IMC_Unit *unit)</b></code></a></dt><p class="pad"></p>

<dd>try to allocate as much as possible, an optimization ...</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>static void update_life(Parrot_Interp interp, IMC_Unit *unit, Instruction *ins, SymReg *r, int needs_fetch, int needs_store, int add)</b></code></a></dt><p class="pad"></p>

<dd>update bb and life_info after spilling this saves 4 costy routines NOTE {lhs_, }use_count are not set again, this is save, when no further optimization pass follows</dd><p class="pad"></p>

<dt><a name="PARROT_INLINE_static_void_spill(PARROT_INTERP,_IMC_Unit_*_unit,_int_spilled)"
><b><code lang='und' xml:lang='und'>PARROT_INLINE static void spill(PARROT_INTERP, IMC_Unit *unit, int spilled)</b></code></a></dt><p class="pad"></p>

<dd>Rewrites the unit instructions, inserting spill code in every ocurrence of the symbol. XXX this has tremendous potential for optimization. Spilling multiple variables would help tremendously.</dd><p class="pad"></p>

<dt><a name="static_int_spill_registers(Parrot_Interp_interp,_IMC_Unit*_unit,_graph*_G)"
><b><code lang='und' xml:lang='und'>static int spill_registers(Parrot_Interp interp, IMC_Unit *unit, graph *G)</b></code></a></dt><p class="pad"></p>

<dd>Use colors from G to allocate registers and spill the high colors.</dd><p class="pad"></p>

<dt><a name="static_void_compute_spill_benefit(Parrot_Interp_interp,_IMC_Unit_*_unit,_graph*_G)"
><b><code lang='und' xml:lang='und'>static void compute_spill_benefit(Parrot_Interp interp, IMC_Unit *unit, graph *G)</b></code></a></dt><p class="pad"></p>

<dd>Computes the cost of spilling each symbol. This is estimated by the number of times the symbol appears, weighted by X*loop_depth</dd><p class="pad"></p>

<dt><a name="static_void_apply_coloring(PARROT_INTERP,_IMC_Unit*_unit,_graph*_G)"
><b><code lang='und' xml:lang='und'>static void apply_coloring(PARROT_INTERP, IMC_Unit *unit, graph *G)</b></code></a></dt><p class="pad"></p>

<dd>Use colors from G to allocate registers and spill the high colors.</dd><p class="pad"></p>

<dt><a name="static_int_degree_comparator(const_void_*_u,_const_void_*_v)"
><b><code lang='und' xml:lang='und'>static int degree_comparator(const void *u, const void *v)</b></code></a></dt><p class="pad"></p>

<dd>TODO: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_int_ig_init_graph(PARROT_INTERP,_IMC_Unit*_unit,_graph*_G)"
><b><code lang='und' xml:lang='und'>static int ig_init_graph(PARROT_INTERP, IMC_Unit *unit, graph *G)</b></code></a></dt><p class="pad"></p>

<dd>TODO: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_void_ig_clear_graph(IMC_Unit*_unit,_graph*_G)"
><b><code lang='und' xml:lang='und'>static void ig_clear_graph(IMC_Unit *unit, graph *G)</b></code></a></dt><p class="pad"></p>

<dd>TODO: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_void_ig_precolor(PARROT_INTERP,_IMC_Unit*_unit,_graph*_G)"
><b><code lang='und' xml:lang='und'>static void ig_precolor(PARROT_INTERP, IMC_Unit *unit, graph *G)</b></code></a></dt><p class="pad"></p>

<dd>Set colors in G to pre&#45;allocated values, from allocate_wanted_regs</dd><p class="pad"></p>

<dt><a name="static_int_ig_find_color(SHIM_INTERP,_IMC_Unit_*unit,_int_x,_const_char_*avail)"
><b><code lang='und' xml:lang='und'>static int ig_find_color(SHIM_INTERP, IMC_Unit *unit, int x, const char *avail)</b></code></a></dt><p class="pad"></p>

<dd>find available color for register #x in available colors</dd><p class="pad"></p>

<dt><a name="static_int_ig_color_node(PARROT_INTERP,_IMC_Unit*_unit,_graph*_G,_int_j)"
><b><code lang='und' xml:lang='und'>static int ig_color_node(PARROT_INTERP, IMC_Unit *unit, graph *G, int j)</b></code></a></dt><p class="pad"></p>

<dd>select first available color, over 17</dd><p class="pad"></p>

<dt><a name="static_void_ig_remove_node(PARROT_INTERP,_IMC_Unit_*unit,_graph*_G,_int_j)"
><b><code lang='und' xml:lang='und'>static void ig_remove_node(PARROT_INTERP, IMC_Unit *unit, graph *G, int j)</b></code></a></dt><p class="pad"></p>

<dd>TODO: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_void_ig_color_graph(PARROT_INTERP,_IMC_Unit*_unit,_graph*_G)"
><b><code lang='und' xml:lang='und'>static void ig_color_graph(PARROT_INTERP, IMC_Unit *unit, graph *G)</b></code></a></dt><p class="pad"></p>

<dd>The Matula Maximum Minimum Degree coloring algorithm (Degeneracy Coloring).</dd><p class="pad"></p>

<dd>Sort by degrees, remove lowest degree nodes, adjust other degrees, iterate. This algorithm for coloring, was adapted by Chaitin for register allocation. Briggs later made more modifications. The interesting part is spilling, which really has nothing to do with theoretical graph coloring. Stay tuned to this channel as the saga continues ...</dd><p class="pad"></p>
</dl>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../resources/parrot_small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
