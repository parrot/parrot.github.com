<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>The Grammar of languages/PIR</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">The Grammar of languages/PIR</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../../html/index.html">Contents</a> | <a href="../../../../html/languages.html">Language Implementations</a> | <a href="../../../../html/pir.html">PIR</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>pirgrammar.pod &#45; The Grammar of languages/PIR</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>This document provides a more readable grammar of languages/PIR.
The actual specification for PIR is a bit more complex.
This grammar for humans does not contain error handling and other issues unimportant for this PIR reference.</p>

<h1><a name="STATUS"
>STATUS <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>For a bugs and issues,
see the section KNOWN ISSUES AND BUGS.</p>

<p>The grammar includes some constructs that <b>are</b> in the IMCC parser,
but are not implemented.</p>

<p>Please note that languages/PIR is <b>not</b> the official definition of the PIR language.
The reference implementation of PIR is IMCC,
located in <code lang='und' xml:lang='und'>parrot/compilers/IMCC</code>.
However,
languages/PIR tries to be as close to IMCC as possible.
IMCC&#39;s grammar could use some cleaning up; languages/PIR might be a basis to start with a clean reimplementation of PIR in C (using Lex/Yacc).</p>

<h1><a name="VERSION"
>VERSION <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>0.2.0</p>

<h1><a name="LEXICAL_CONVENTIONS"
>LEXICAL CONVENTIONS <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<h2><a name="PIR_Directives"
>PIR Directives <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>PIR has a number of directives.
All directives start with a dot.
Macro identifiers (when using a macro,
on expansion) also start with a dot (see below).
Therefore,
it is important not to use any of the PIR directives as a macro identifier.
The PIR directives are:</p>

<pre lang='und' xml:lang='und'>  .arg            .invocant          .pcc_begin
  .const          .lex               .pcc_call
  .emit           .line              .pcc_end_return
  .end            .loadlib           .pcc_end_yield
  .endnamespace   .local             .pcc_end
  .eom            .meth_call         .pragma
  .get_results    .namespace         .return
  .globalconst    .nci_call          .result
  .HLL_map        .param             .sub
  .HLL            .pcc_begin_return  .yield
  .include        .pcc_begin_yield</pre>

<h2><a name="Registers"
>Registers <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>PIR has two types of registers: real registers and symbolic or temporary (or <i>virtual</i> if you like) registers. Real registers are actual registers in the Parrot VM. The symbolic, or temporary registers are mapped to those actual registers. Real registers are written like:</p>

<pre lang='und' xml:lang='und'>  [S|N|I|P]n, where n is a positive integer.</pre>

<p>whereas symbolic registers have a <b>$</b> prefix, like this: <code lang='und' xml:lang='und'>$P10</code>.</p>

<p>Symbolic registers can be thought of local variable identifiers that don&#39;t need a declaration. This prevents you from writing <code lang='und' xml:lang='und'>.local</code> directives if you&#39;re in a hurry. Of course, it would make the code more self&#45;documenting if <code lang='und' xml:lang='und'>.local</code>s would be used.</p>

<h2><a name="Constants"
>Constants <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>An integer constant is a string of one or more digits. Examples: <code lang='und' xml:lang='und'>0</code>, <code lang='und' xml:lang='und'>42</code>.</p>

<p>A floatin&#45;point constant is a string of one or more digits, followed by a dot and one or more digits. Examples: <code lang='und' xml:lang='und'>1.1</code>, <code lang='und' xml:lang='und'>42.567</code></p>

<p>A string constant is a single or double quoted series of characters. Examples: <code lang='und' xml:lang='und'>&#39;hello world&#39;</code>, <code lang='und' xml:lang='und'>&#34;Parrot&#34;</code>.</p>

<p>TODO: PMC constants.</p>

<h2><a name="Identifiers"
>Identifiers <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>An identifier starts with a character from [_a&#45;zA&#45;Z], followed by zero or more characters from [_a&#45;zA&#45;Z0&#45;9].</p>

<p>Examples: <code lang='und' xml:lang='und'>x</code>, <code lang='und' xml:lang='und'>x1</code>, <code lang='und' xml:lang='und'>_foo</code></p>

<h2><a name="Labels"
>Labels <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>A label is an identifier with a colon attached to it.</p>

<p>Examples: <code lang='und' xml:lang='und'>LABEL:</code></p>

<h2><a name="Macro_identifiers"
>Macro identifiers <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>A macro identifier is an identifier prefixed with an dot. A macro identifier is used when <i>expanding</i> the macro (on usage), not in the macro definition.</p>

<p>Examples: <code lang='und' xml:lang='und'>.myMacro</code></p>

<h1><a name="GRAMMAR_RULES"
>GRAMMAR RULES <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<h2><a name="Compilation_Units"
>Compilation Units <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>A PIR program consists of one or more compilation units. A compilation unit is a global, sub, constant or macro definition, or a pragma or emit block. PIR is a line oriented language, which means that each statement ends in a newline (indicated as &#34;nl&#34;). Moreover, compilation units are always separated by a newline. Each of the different compilation units are discussed in this document.</p>

<pre lang='und' xml:lang='und'>  program:
    compilation_unit [ nl compilation_unit ]*

  compilation_unit:
      global_def
    | sub_def
    | const_def
    | expansion
    | pragma
    | emit</pre>

<h2><a name="Subroutine_definitions"
>Subroutine definitions <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<pre lang='und' xml:lang='und'>  sub_def:
    &#34;.sub&#34; sub_id sub_pragmas* nl body

  sub_id:
    identifier | string_constant

  sub_pragma:
      &#34;:load&#34;
    | &#34;:init&#34;
    | &#34;:immediate&#34;
    | &#34;:postcomp&#34;
    | &#34;:main&#34;
    | &#34;:anon&#34;
    | &#34;:lex&#34;
    | vtable_pragma
    | multi_pragma
    | outer_pragma

  vtable_pragma:
    &#34;:vtable&#34; parenthesized_string?

  parenthesized_string:
    &#34;(&#34; string_constant &#34;)&#34;

  multi_pragma:
    &#34;:multi&#34; &#34;(&#34; multi_types? &#34;)&#34;

  outer_pragma:
    &#34;:outer&#34; &#34;(&#34; sub_id &#34;)&#34;

  multi_tyes:
    multi_type [ &#34;,&#34; multi_type ]*

  multi_type:
      type
    | &#34;_&#34;
    | keylist
    | identifier
    | string_constant

  body:
    param_decl*
    labeled_pir_instr*
    &#34;.end&#34;

  param_decl:
    &#34;.param&#34;  [ [ string_constant &#34;=&#62;&#34; ] type identifier ] [ get_flags | &#34;:unique_reg&#34; ]* nl

  get_flags:
    [ &#34;:slurpy&#34;
    | &#34;:optional&#34;
    | &#34;:opt_flag&#34;
    | named_flag
    ]+

  named_flag:
    &#34;:named&#34; parenthesized_string?</pre>

<h3><a name="Examples_subroutine"
>Examples subroutine</a></h3>

<p>The simplest example for a subroutine definition looks like:</p>

<pre lang='und' xml:lang='und'>  .sub foo
  # PIR instructions go here
  .end</pre>

<p>The body of the subroutine can contain PIR instructions. The subroutine can be given one or more flags, indicating the sub should behave in a special way. Below is a list of these flags and their meaning. The flag <code lang='und' xml:lang='und'>:unique_reg</code> is discussed in the section defining local declarations.</p>

<ul>
<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'> :load</pre>

<p>Run this subroutine during the <b>load_library</b> opcode. <b>:load</b> is ignored, if another subroutine in that file is marked with <b>:main</b>. If multiple subs have the <b>:load</b> pragma, the subs are run in source code order.</p>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'> :init</pre>

<p>Run the subroutine when the program is run directly (that is, not loaded as a module). This is different from <b>:load</b>, which runs a subroutine when a library is being loaded. To get both behaviours, use <b>:init :load</b>.</p>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'> :postcomp</pre>

<p>Same as <code lang='und' xml:lang='und'>:immediate</code>, except that the sub is not executed when compilation was triggered by a <code lang='und' xml:lang='und'>load_bytecode</code> instruction (in a different file).</p>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'> :immediate</pre>

<p>This subroutine is executed immediately after being compiled. (Analagous to <code lang='und' xml:lang='und'>BEGIN</code> in perl5.)</p>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'> :main</pre>

<p>Indicates that the sub being defined is the entry point of the program. It can be compared to the main function in C.</p>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'> :method</pre>

<p>Indicates the sub being defined is an instance method. The method belongs to the class whose namespace is currently active. (so, to define a method for a class &#39;Foo&#39;, the &#39;Foo&#39; namespace should be currently active). In the method body, the object PMC can be referred to with <code lang='und' xml:lang='und'>self</code>.</p>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'> :vtable or vtable(&#39;x&#39;)</pre>

<p>Indicates the sub being defined replaces a vtable entry. This flag can only be used when defining a method.</p>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'> :multi(type [, type]*)</pre>

<p>Engage in multiple dispatch with the listed types.</p>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'> :outer(&#39;bar&#39;)</pre>

<p>Indicates the sub being defined is lexically nested within the subroutine &#39;bar&#39;.</p>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'> :anon</pre>

<p>Do not install this subroutine in the namespace. Allows the subroutine name to be reused.</p>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'> :lex</pre>

<p>Indicates the sub being defined needs to store lexical variables. This flag is not necessary if any lexical declarations are done (see below), the PIR compiler will figure this out by itself. The <code lang='und' xml:lang='und'>:lex</code> attribute is necessary to tell Parrot the subroutine will store or find lexicals.</p>
</ul>

<p>The sub flags are listed after the sub name. The subroutine name can also be a string instead of a bareword, as is shown in this example:</p>

<pre lang='und' xml:lang='und'>  .sub &#39;foo&#39; :load :init :anon
  # PIR body
  .end</pre>

<p>Parameter definitions have the following syntax:</p>

<pre lang='und' xml:lang='und'>  .sub main
    .param int argc :optional
    .param int has_argc :optional
    .param num nParam
    .param pmc argv :slurpy
    .param string sParam :named(&#39;foo&#39;)    
    # body
  .end</pre>

<p>As shown, parameter definitions may take flags as well. These flags are listed here:</p>

<ul>
<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'> :slurpy</pre>

<p>The parameter should be of type <code lang='und' xml:lang='und'>pmc</code> and acts like a container that <code lang='und' xml:lang='und'>slurps</code> up all remaining arguments. Details can be found in PDD03 &#45; Parrot Calling Conventions.</p>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'> :named(&#39;x&#39;)</pre>

<p>The parameter is known in the called sub by name <code lang='und' xml:lang='und'>&#39;x&#39;</code>. The <code lang='und' xml:lang='und'>:named</code> flag can also be used <b>without</b> an identifier, in combination with the <code lang='und' xml:lang='und'>:flat</code> or <code lang='und' xml:lang='und'>:slurpy</code> flag, i.e. on a container holding several values:</p>

<pre lang='und' xml:lang='und'>  .param pmc args :slurpy :named</pre>

<p>and</p>

<pre lang='und' xml:lang='und'>  .arg args :flat :named</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'> :optional</pre>

<p>Indicates the parameter being defined is optional.</p>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'> :opt_flag</pre>

<p>This flag can be given to a parameter defined <i>after</i> an optional parameter. During runtime, the parameter is automatically given a value, and is <i>not</i> passed by the caller. The value of this parameter indicates whether the previous (optional) parameter was present.</p>
</ul>

<p>The correct order of the parameters depends on the flag they have.</p>

<h2><a name="PIR_instructions"
>PIR instructions <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<pre lang='und' xml:lang='und'>  labeled_pir_instr:
    label? instr nl

  labeled_pasm_instr:
    label? pasm_instr nl

  instr:
    pir_instr | pasm_instr</pre>

<p>NOTE: the rule &#39;pasm_instr&#39; is not included in this reference grammar. pasm_instr defines the syntax for pure PASM instructions.</p>

<pre lang='und' xml:lang='und'>  pir_instr:
      local_decl
    | lexical_decl
    | const_def
    | globalconst_def
    | conditional_stat
    | assignment_stat
    | open_namespace
    | close_namespace
    | return_stat
    | sub_invocation
    | macro_invocation
    | jump_stat
    | source_info</pre>

<h2><a name="Local_declarations"
>Local declarations <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<pre lang='und' xml:lang='und'>  local_decl:
    &#34;.local&#34; type local_id_list

  local_id_list:
    local_id [ &#34;,&#34; local_id ]*

  local_id:
    identifier &#34;:unique_reg&#34;?</pre>

<h3><a name="Examples_local_declarations"
>Examples local declarations</a></h3>

<p>Local temporary variables can be declared by the directives <code lang='und' xml:lang='und'>.local</code>.</p>

<pre lang='und' xml:lang='und'>  .local int i
  .local num a, b, c</pre>

<p>The optional <code lang='und' xml:lang='und'>:unique_reg</code> modifier will force the register allocator to associate the identifier with a unique register for the duration of the compilation unit.</p>

<pre lang='und' xml:lang='und'>  .local int j :unique_reg</pre>

<h2><a name="Lexical_declarations"
>Lexical declarations <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<pre lang='und' xml:lang='und'>  lexical_decl:
    &#34;.lex&#34; string_constant &#34;,&#34; target</pre>

<h3><a name="Example_lexical_declarations"
>Example lexical declarations</a></h3>

<p>The declaration</p>

<pre lang='und' xml:lang='und'>  .lex &#39;i&#39;, $P0</pre>

<p>indicates that the value in $P0 is stored as a lexical variable, named by &#39;i&#39;. Once the above lexical declaration is written, and given the following statement:</p>

<pre lang='und' xml:lang='und'>  $P1 = new &#39;Integer&#39;</pre>

<p>then the following two statements have an identical effect:</p>

<ul>
<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  $P0 = $P1</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  store_lex &#34;i&#34;, $P1</pre>
</ul>

<p>Likewise, these two statements also have an identical effect:</p>

<ul>
<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  $P1 = $P0</pre>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  $P1 = find_lex &#34;i&#34;</pre>
</ul>

<p>Instead of a register, one can also specify a local variable, like so:</p>

<pre lang='und' xml:lang='und'>  .local pmc p
  .lex &#39;i&#39;, p</pre>

<p>The same is true when a parameter should be stored as a lexical:</p>

<pre lang='und' xml:lang='und'>  .param pmc p
  .lex &#39;i&#39;, p</pre>

<p>So, now it is also clear why <code lang='und' xml:lang='und'>.lex &#39;i&#39;, p</code> is <b>not</b> a declaration of p: it needs a separate declaration, because it may either be a <code lang='und' xml:lang='und'>.local</code> or a <code lang='und' xml:lang='und'>.param</code>. The <code lang='und' xml:lang='und'>.lex</code> directive merely is a shortcut for saving and retrieving lexical variables.</p>

<h2><a name="Constant_definitions"
>Constant definitions <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<pre lang='und' xml:lang='und'>  const_def:
    &#34;.const&#34; type identifier &#34;=&#34; constant_expr</pre>

<h3><a name="Example_constant_definitions"
>Example constant definitions</a></h3>

<pre lang='und' xml:lang='und'>  .const int answer = 42</pre>

<p>defines an integer constant by name &#39;answer&#39;, giving it a value of 42. Note that the constant type and the value type should match, i.e. you cannot assign a floating point number to an integer constant. The PIR parser will check for this.</p>

<h2><a name="Global_constant_definitions"
>Global constant definitions <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<pre lang='und' xml:lang='und'>  globalconst_def:
    &#34;.globalconst&#34; type identifier &#34;=&#34; constant_expr</pre>

<h3><a name="Example_global_constant_definitions"
>Example global constant definitions</a></h3>

<p>This directive is similar to <code lang='und' xml:lang='und'>const_def</code>, except that once a <code lang='und' xml:lang='und'>global constant</code> has been defined, it is accessible from <b>all</b> subroutines.</p>

<pre lang='und' xml:lang='und'>  .sub main :main
    .global const int answer = 42
    foo()
  .end

  .sub foo
    print answer # prints 42
  .end</pre>

<h2><a name="Conditional_statements"
>Conditional statements <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<pre lang='und' xml:lang='und'>  conditional_stat:
      [ &#34;if&#34; | &#34;unless&#34; ]
    [ [ &#34;null&#34; target &#34;goto&#34; identifier ]
    | [ simple_expr [ relational_op simple_expr ]? ]
    ] &#34;goto&#34; identifier</pre>

<h3><a name="Examples_conditional_statements"
>Examples conditional statements</a></h3>

<p>The syntax for <code lang='und' xml:lang='und'>if</code> and <code lang='und' xml:lang='und'>unless</code> statements is the same, except for the keyword itself. Therefore the examples will use either.</p>

<pre lang='und' xml:lang='und'>  if null $P0 goto L1</pre>

<p>Checks whether <code lang='und' xml:lang='und'>$P0</code> is <code lang='und' xml:lang='und'>null</code>, if it is, flow of control jumps to label <code lang='und' xml:lang='und'>L1</code></p>

<pre lang='und' xml:lang='und'>  unless $P0 goto L2
  unless x   goto L2
  unless 1.1 goto L2</pre>

<p>Unless $P0, x or 1.1 are &#39;true&#39;, flow of control jumps to L2. When the argument is a PMC (like the first example), true&#45;ness depends on the PMC itself. For instance, in some languages, the number 0 is defined as &#39;true&#39;, in others it is considered &#39;false&#39; (like C).</p>

<pre lang='und' xml:lang='und'>  if x &#60; y goto L1
  if y != z  goto L1</pre>

<p>are examples that check for the logical expression after <code lang='und' xml:lang='und'>if</code>. Any of the <i>relational</i> operators may be used here.</p>

<h2><a name="Branching_statements"
>Branching statements <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<pre lang='und' xml:lang='und'>  jump_stat:
    &#34;goto&#34; identifier</pre>

<h3><a name="Examples_branching_statements"
>Examples branching statements</a></h3>

<pre lang='und' xml:lang='und'>  goto MyLabel</pre>

<p>The program will continue running at label &#39;MyLabel:&#39;.</p>

<h2><a name="Operators"
>Operators <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<pre lang='und' xml:lang='und'>  relational_op:
      &#34;==&#34; | &#34;!=&#34; | &#34;&#60;=&#34; | &#34;&#60;&#34; | &#60;&#34;=&#34; | &#60;&#34;&#34;

  binary_op:
      &#34;+&#34;  | &#34;&#45;&#34;   | &#34;/&#34;  | &#34;**&#34;
    | &#34;*&#34;  | &#34;%&#34;   | &#34;&#60;&#60;&#34; | &#60;&#34;&#62;&#62;&#34;
    | &#60;&#34;&#62;&#34; | &#34;&#38;&#38;&#34;  | &#34;||&#34; | &#34;~~&#34;
    | &#34;|&#34;  | &#34;&#38;&#34;   | &#34;~&#34;  | &#34;.&#34;

  assign_op:
      &#34;+=&#34; | &#34;&#45;=&#34; | &#34;/=&#34; | &#34;%=&#34;  | &#34;*=&#34;  | &#34;.=&#34;
    | &#34;&#38;=&#34; | &#34;|=&#34; | &#34;~=&#34; | &#34;&#60;&#60;=&#34; | &#60;&#34;&#62;=&#34; | &#60;&#34;&#62;&#62;=&#34;

  unary_op:
      &#34;!&#34; | &#34;&#45;&#34; | &#34;~&#34;</pre>

<h2><a name="Expressions"
>Expressions <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<pre lang='und' xml:lang='und'>  expression:
      simple_expr
    | simple_expr binary_op simple_expr
    | unary_op simple_expr

  simple_expr:
      float_constant
    | int_constant
    | string_constant
    | target</pre>

<h3><a name="Example_expressions"
>Example expressions</a></h3>

<pre lang='und' xml:lang='und'>  42
  42 + x
  1.1 / 0.1
  &#34;hello&#34; . &#34;world&#34;
  str1 . str2
  &#45;100
  ~obj
  !isSomething</pre>

<p>Arithmetic operators are only allowed on floating&#45;point numbers and integer values (or variables of that type). Likewise, string concatenation (&#34;.&#34;) is only allowed on strings. These checks are <b>not</b> done by the PIR parser.</p>

<h2><a name="Assignments"
>Assignments <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<pre lang='und' xml:lang='und'>  assignment_stat:
      target &#34;=&#34; short_sub_call
    | target &#34;=&#34; target keylist
    | target &#34;=&#34; expression
    | target &#34;=&#34; &#34;new&#34; string_constant
    | target &#34;=&#34; &#34;new&#34; keylist
    | target &#34;=&#34; &#34;find_type&#34; [ string_constant | string_reg | id ]
    | target &#34;=&#34; heredoc
    | target assign_op simple_expr
    | target keylist &#34;=&#34; simple_expr
    | result_var_list &#34;=&#34; short_sub_call</pre>

<p>NOTE: the definition of assignment statements is <b>not</b> complete yet. As languages/PIR evolves, this will be completed.</p>

<pre lang='und' xml:lang='und'>  keylist:
    &#34;[&#34; keys &#34;]&#34;

  keys:
    key [ sep key ]*

  sep:
    &#34;,&#34; | &#34;;&#34;

  key:
      simple_expr
    | simple_expr &#34;..&#34;
    | &#34;..&#34; simple_expr
    | simple_expr &#34;..&#34; simple_expr

  result_var_list:
    &#34;(&#34; result_vars? &#34;)&#34;

  result_vars:
    result_var [ &#34;,&#34; result_var ]*

  result_var:
    target get_flags?</pre>

<h3><a name="Examples_assignment_statements"
>Examples assignment statements</a></h3>

<pre lang='und' xml:lang='und'>  $I1 = 1 + 2
  $I1 += 1
  $P0 = foo()
  $I0 = $P0[1]
  $I0 = $P0[12.34]
  $I0 = $P0[&#34;Hello&#34;]
  $P0 = new 42 # but this is really not very clear, better use identifiers

  $S0 = &#60;&#60;&#39;HELLO&#39;
  ...
  HELLO

  .local int a, b, c
  (a, b, c) = foo()</pre>

<h2><a name="Heredoc"
>Heredoc <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>NOTE: the heredoc rules are not complete or tested. Some work is required here.</p>

<pre lang='und' xml:lang='und'>  heredoc:
    &#34;&#60;&#60;&#34; string_constant nl
    heredoc_string
    heredoc_label

  heredoc_label:
    ^^ identifier

  heredoc_string:
    [ \N | \n ]*</pre>

<h3><a name="Example_Heredoc"
>Example Heredoc</a></h3>

<pre lang='und' xml:lang='und'>  .local string str
  str = &#60;&#60;&#39;ENDOFSTRING&#39;
    this text
         is stored in the
               variable
      named &#39;str&#39;. Whitespace and newlines
    are                  stored as well.
  ENDOFSTRING</pre>

<p>Note that the Heredoc identifier should be at the beginning of the line, no whitespace in front of it is allowed. Printing <code lang='und' xml:lang='und'>str</code> would print:</p>

<pre lang='und' xml:lang='und'>    this text
         is stored in the
               variable
      named &#39;str&#39;. Whitespace and newlines
    are                  stored as well.</pre>

<p>In IMCC, a heredoc identifier can be specified as an argument, like this:</p>

<pre lang='und' xml:lang='und'>    foo(42, &#34;hello&#34;, &#60;&#60;&#39;EOS&#39;)

    This is a heredoc text argument.

  EOS</pre>

<p>In IMCC, only <b>one</b> such argument can be specified. The languages/PIR implementation aims to allow for <b>any</b> number of heredoc arguments, like this:</p>

<pre lang='und' xml:lang='und'>    foo(&#60;&#60;&#39;STR1&#39;, &#60;&#60;&#39;STR2&#39;)

    argument 1
  STR1
    argument 2
  STR2</pre>

<p><b>Currently, this is not working.</b></p>

<h2><a name="Invoking_subroutines_and_methods"
>Invoking subroutines and methods <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<pre lang='und' xml:lang='und'>  sub_invocation:
    long_sub_call | short_sub_call

  long_sub_call:
    &#34;.pcc_begin&#34; nl
    arguments
    [ method_call | non_method_call] nl
    [ local_decl nl ]*
    result_values
    &#34;.pcc_end&#34;

  non_method_call:
    [ &#34;.pcc_call&#34; | &#34;.nci_call&#34; ] target

  method_call:
    &#34;.invocant&#34; target nl
    &#34;.meth_call&#34; [ target | string_constant ]

  parenthesized_args:
    &#34;(&#34; args &#34;)&#34;

  args:
    arg [ &#34;,&#34; arg ]

  arg:
    [ float_constant
    | int_constant
    | string_constant [ &#34;=&#62;&#34; target ]?
    | target
    ]
    set_flags?


  arguments:
    [ &#34;.arg&#34; simple_expr set_flags? nl ]*

  result_values:
    [ &#34;.result&#34; target get_flags? nl ]*

  set_flags:
    [ &#34;:flat&#34;
    | named_flag
    ]+</pre>

<h3><a name="Example_long_subroutine_call"
>Example long subroutine call</a></h3>

<p>The long subroutine call syntax is very suitable to be generated by a language compiler targeting Parrot. Its syntax is rather verbose, but easy to read. The minimal invocation looks like this:</p>

<pre lang='und' xml:lang='und'>  .pcc_begin
  .pcc_call $P0
  .pcc_end</pre>

<p>Invoking instance methods is a simple variation:</p>

<pre lang='und' xml:lang='und'>  .pcc_begin
  .invocant $P0
  .meth_call $P1
  .pcc_end</pre>

<p>Passing arguments and retrieving return values is done like this:</p>

<pre lang='und' xml:lang='und'>  .pcc_begin
  .arg 42
  .pcc_call $P0
  .local int res
  .result res
  .pcc_end</pre>

<p>Arguments can take flags as well. The following argument flags are defined:</p>

<ul>
<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'> :flat</pre>

<p>Flatten the (aggregate) argument. This argument can only be of type <code lang='und' xml:lang='und'>pmc</code>.</p>

<li></li><p class="pad"></p>

<pre lang='und' xml:lang='und'> :named(&#39;x&#39;)</pre>

<p>Pass the denoted argument into the named parameter that is denoted by &#39;x&#39;, like so:</p>

<pre lang='und' xml:lang='und'> .param int myX :named(&#39;x&#39;)   # the type &#39;int&#39; is just an example</pre>

<p>As was mentioned at the parameter declaration section, the <code lang='und' xml:lang='und'>:named</code> section can be used on an aggregate value in combination with the <code lang='und' xml:lang='und'>:flat</code> flag.</p>

<pre lang='und' xml:lang='und'> .arg pmc myArgs :flat :named</pre>
</ul>

<pre lang='und' xml:lang='und'>  .local pmc arr
  arr = new .Array
  arr = 2
  arr[0] = 42
  arr[1] = 43
  .pcc_begin
  .arg arr :flat
  .arg $I0 :named(&#39;intArg&#39;)
  .pcc_call foo
  .pcc_end</pre>

<p>The Native Calling Interface (NCI) allows for calling C routines, in order to talk to the world outside of Parrot. Its syntax is a slight variation; it uses <code lang='und' xml:lang='und'>.nci_call</code> instead of <code lang='und' xml:lang='und'>.pcc_call</code>.</p>

<pre lang='und' xml:lang='und'>  .pcc_begin
  .nci_call $P0
  .pcc_end</pre>

<h2><a name="Short_subroutine_invocation"
>Short subroutine invocation <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<pre lang='und' xml:lang='und'>  short_sub_call:
    invocant? [ target | string_constant ] parenthesized_args

  invocant:
    target&#34;.&#34;</pre>

<h3><a name="Example_short_subroutine_call"
>Example short subroutine call</a></h3>

<p>The short subroutine call syntax is useful when manually writing PIR code. Its simplest form is:</p>

<pre lang='und' xml:lang='und'>  foo()</pre>

<p>Or a method call:</p>

<pre lang='und' xml:lang='und'>  obj.&#39;toString&#39;() # call the method &#39;toString&#39;
  obj.x() # call the method whose name is stored in &#39;x&#39;.</pre>

<p>Note that no spaces are allowed between the invocant and the dot; <code lang='und' xml:lang='und'>&#34;obj . &#39;toString&#39;&#34;</code> is not valid, this will be interpreted as a concatenation.</p>

<p>And of course, using the short version, passing arguments can be done as well, including all flags that were defined for the long version. The same example from the &#39;long subroutine invocation&#39; is now shown in its short version:</p>

<pre lang='und' xml:lang='und'>  .local pmc arr
  arr = new .Array
  arr = 2
  arr[0] = 42
  arr[1] = 43
  foo(arr :flat, $I0 :named(&#39;intArg&#39;))</pre>

<p>In order to do a Native Call Interface invocation, the subroutine to be invoked needs to be in referenced from a PMC register, as its name is <b>not</b> visible from Parrot. A NCI call looks like this:</p>

<pre lang='und' xml:lang='und'>  .local pmc nci_sub, nci_lib
  .local string c_function, signature

  nci_lib = loadlib &#34;myLib&#34;

  # name of the C function to be called
  c_function = &#34;sayHello&#34;

  # set signature to &#34;void&#34; (no arguments)
  signature  = &#34;v&#34;

  # get a PMC representing the C function
  nci_sub = dlfunc nci_lib, c_function, signature

  # and invoke
  nci_sub()</pre>

<h2><a name="Return_values_from_subroutines"
>Return values from subroutines <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<pre lang='und' xml:lang='und'>  return_stat:
      long_return_stat
    | short_return_stat
    | long_yield_stat
    | short_yield_stat
    | tail_call

  long_return_stat:
    &#34;.pcc_begin_return&#34; nl
    return_directive*
    &#34;.pcc_end_return&#34;

  return_directive:
    &#34;.return&#34; simple_expr set_flags? nl</pre>

<h3><a name="Example_long_return_statement"
>Example long return statement</a></h3>

<p>Returning values from a subroutine is in fact similar to passing arguments <i>to</i> a subroutine. Therefore, the same flags can be used:</p>

<pre lang='und' xml:lang='und'>  .pcc_begin_return
  .return 42 :named(&#39;answer&#39;)
  .return $P0 :flat
  .pcc_end_return</pre>

<p>In this example, the value <code lang='und' xml:lang='und'>42</code> is passed into the return value that takes the named return value known by <code lang='und' xml:lang='und'>&#39;answer&#39;</code>. The aggregate value in <code lang='und' xml:lang='und'>$P0</code> is flattened, and each of its values is passed as a return value.</p>

<h2><a name="Short_return_statement"
>Short return statement <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<pre lang='und' xml:lang='und'>  short_return_stat:
    &#34;.return&#34; parenthesized_args</pre>

<h3><a name="Example_short_return_statement"
>Example short return statement</a></h3>

<pre lang='und' xml:lang='und'>  .return(myVar, &#34;hello&#34;, 2.76, 3.14);</pre>

<p>Just as the return values in the <code lang='und' xml:lang='und'>long return statement</code> could take flags, the <code lang='und' xml:lang='und'>short return statement</code> may as well:</p>

<pre lang='und' xml:lang='und'>  .return(42 :named(&#39;answer&#39;), $P0 :flat)</pre>

<h2><a name="Long_yield_statements"
>Long yield statements <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<pre lang='und' xml:lang='und'>  long_yield_stat:
    &#34;.pcc_begin_yield&#34; nl
    return_directive*
    &#34;.pcc_end_yield&#34;</pre>

<h3><a name="Example_long_yield_statement"
>Example long yield statement</a></h3>

<p>A <code lang='und' xml:lang='und'>yield</code> statement works the same as a normal return value, except that the point where the subroutine was left is stored somewhere, so that the subroutine can be resumed from that point as soon as the subroutine is invoked again. Returning values is identical to <i>normal</i> return statements.</p>

<pre lang='und' xml:lang='und'>  .sub foo
    .pcc_begin_yield
    .return 42
    .pcc_end_yield

    # and later in the sub, one could return another value:

    .pcc_begin_yield
    .return 43
    .pcc_end_yield
  .end

  # when invoking twice:
  foo() # returns 42
  foo() # returns 43</pre>

<h2><a name="Short_yield_statements"
>Short yield statements <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<pre lang='und' xml:lang='und'>  short_yield_stat:
    &#34;.yield&#34; parenthesized_args</pre>

<h3><a name="Example_short_yield_statement"
>Example short yield statement</a></h3>

<p>Again, the short version is identical to the short version of the return statement as well.</p>

<pre lang='und' xml:lang='und'>  .yield(&#34;hello&#34;, 42)</pre>

<h2><a name="Tail_calls"
>Tail calls <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<pre lang='und' xml:lang='und'>  tail_call:
    &#34;.return&#34; short_sub_call</pre>

<h3><a name="Example_tail_call"
>Example tail call</a></h3>

<pre lang='und' xml:lang='und'>  .return foo()</pre>

<p>Returns the return values from <code lang='und' xml:lang='und'>foo</code>. This is implemented by a tail call, which is more efficient than:</p>

<pre lang='und' xml:lang='und'>  .local pmc results = foo()
  .return(results)</pre>

<p>The call to <code lang='und' xml:lang='und'>foo</code> can be considered a normal function call with respect to parameters: it can take the exact same format using argument flags. The tail call can also be a method call, like so:</p>

<pre lang='und' xml:lang='und'>  .return obj.&#39;foo&#39;()</pre>

<h2><a name="Symbol_namespaces"
>Symbol namespaces <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<pre lang='und' xml:lang='und'>  open_namespace:
    &#34;.namespace&#34; identifier

  close_namespace:
    &#34;.endnamespace&#34; identifier</pre>

<h3><a name="Example_open/close_namespaces"
>Example open/close namespaces</a></h3>

<pre lang='und' xml:lang='und'>  .sub main
    .local int x
    x = 42
    say x
    .namespace NESTED
    .local int x
    x = 43
    say x
    .endnamespace NESTED
    say x
  .end</pre>

<p>Will print:</p>

<pre lang='und' xml:lang='und'>  42
  43
  42</pre>

<p>Please note that it is <b>not</b> necessary to <i>pair</i> these statements; it is acceptable to open a <code lang='und' xml:lang='und'>.namespace</code> without closing it. The scope of the <code lang='und' xml:lang='und'>.namespace</code> is limited to the subroutine.</p>

<h2><a name="Emit_blocks"
>Emit blocks <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<pre lang='und' xml:lang='und'>  emit:
    &#34;.emit&#34; nl
    labeled_pasm_instr*
    &#34;.eom&#34;</pre>

<h3><a name="Example_Emit_block"
>Example Emit block</a></h3>

<p>An emit block only allows PASM instructions, not PIR instructions.</p>

<pre lang='und' xml:lang='und'>  .emit
     set I0, 10
     new P0, .Integer
     ret
   _foo:
     print &#34;This is PASM subroutine &#34;foo&#34;
     ret
  .eom</pre>

<h2><a name="Expansions"
>Expansions <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<pre lang='und' xml:lang='und'>  expansion:
      macro_def
    | include
    | pasm_constant


  include:
    &#34;.include&#34; string_constant

  pasm_constant:
    &#34;.constant&#34; identifier [ constant_value | register ]</pre>

<h2><a name="Macros"
>Macros <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<pre lang='und' xml:lang='und'>  macro_def:
    &#34;.macro&#34; identifier macro_parameters? nl
    macro_body

  macro_parameters:
    &#34;(&#34; id_list? &#34;)&#34;

  macro_body:
    &#60;labeled_pir_instr&#62;*
    &#34;.endm&#34; nl

  macro_invocation:
    macro_id parenthesized_args?</pre>

<p>Note that before a macro body will be parsed, some grammar rules will be changed. In a macro body, local variable declarations are done using the <code lang='und' xml:lang='und'>.macro_local</code> directive. <b>TODO: decide on keyword for this</b>.</p>

<p>The <code lang='und' xml:lang='und'>.label</code> directive is available for declaring unique labels.</p>

<pre lang='und' xml:lang='und'>  macro_label:
    &#34;.label&#34; &#34;$&#34;identifier&#34;:&#34;</pre>

<h3><a name="Example_Macros"
>Example Macros</a></h3>

<p>When the following macro is defined:</p>

<pre lang='und' xml:lang='und'>  .macro add2(n)
    inc .n
    inc .n
  .endm</pre>

<p>then one can write in a subroutine:</p>

<pre lang='und' xml:lang='und'>  .sub foo
    .local int myNum
    myNum = 42
    .add2(myNum)
    print myNum  # prints 44
  .end</pre>

<h2><a name="PIR_Pragmas"
>PIR Pragmas <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<pre lang='und' xml:lang='und'>  pragma:
      new_operators
    | loadlib
    | namespace
    | hll_mapping
    | hll_specifier
    | source_info

  new_operators:
    &#34;.pragma&#34; &#34;n_operators&#34; int_constant

  loadlib:
    &#34;.loadlib&#34; string_constant

  namespace:
    &#34;.namespace&#34; [ &#34;[&#34; namespace_id &#34;]&#34; ]?

  hll_specifier:
    &#34;.HLL&#34; string_constant &#34;,&#34; string_constant

  hll_mapping:
    &#34;.HLL_map&#34; string_constant &#34;,&#34; string_constant

  namespace_id:
    string_constant [ &#34;;&#34; string_constant ]*

  source_info:
    &#34;.line&#34; int_constant [ &#34;,&#34; string_constant ]?

  id_list:
    identifier [ &#34;,&#34; identifier ]*</pre>

<h3><a name="Examples_pragmas"
>Examples pragmas</a></h3>

<pre lang='und' xml:lang='und'>  .include &#34;myLib.pir&#34;</pre>

<p>includes the source from the file &#34;myLib.pir&#34; at the point of this directive.</p>

<pre lang='und' xml:lang='und'>  .pragma n_operators 1</pre>

<p>makes Parrot automatically create new PMCs when using arithmetic operators, like:</p>

<pre lang='und' xml:lang='und'>  $P1 = new &#39;Integer&#39;
  $P2 = new &#39;Integer&#39;
  $P1 = 42
  $P2 = 43
  $P0 = $P1 * $P2
  # now, $P0 is automatically assigned a newly created PMC.


  .line 100
  .line 100, &#34;myfile.pir&#34;</pre>

<p>NOTE: currently, the line directive is implemented in IMCC as #line. See the PROPOSALS document for more information on this.</p>

<pre lang='und' xml:lang='und'>  .namespace [&#39;Foo&#39;] # namespace Foo

  .namespace [&#39;Object&#39;;&#39;Foo&#39;] # nested namespace

  .namespace # no [ id ] means the root namespace is activated</pre>

<p>The first line opens the namespace &#39;Foo&#39;. When doing Object Oriented programming, this would indicate that sub or method definitions belong to the class &#39;Foo&#39;. Of course, you can also define namespaces without doing OO&#45;programming.</p>

<p>Please note that this <code lang='und' xml:lang='und'>.namespace</code> directive is <i>different</i> from the <code lang='und' xml:lang='und'>.namespace</code> directive that is used within subroutines.</p>

<pre lang='und' xml:lang='und'>  .HLL &#34;Lua&#34;, &#34;lua_group&#34;</pre>

<p>is an example of specifying the High Level Language (HLL) for which the PIR is being generated. It is a shortcut for setting the namespace to &#39;Lua&#39;, and for loading the PMCs in the lua_group library.</p>

<pre lang='und' xml:lang='und'>  .HLL_map &#34;Integer&#34;, &#34;LuaNumber&#34;</pre>

<p>is a way of telling Parrot, that whenever an Integer is created somewhere in the system (C code), instead a LuaNumber object is created.</p>

<pre lang='und' xml:lang='und'>  .loadlib &#34;myLib&#34;</pre>

<p>is a shortcut for telling Parrot that the library &#34;myLib&#34; should be loaded when running the program. In fact, it is a shortcut for:</p>

<pre lang='und' xml:lang='und'>  .sub _load :load :anon
    loadlib &#34;myLib&#34;
  .end</pre>

<p>TODO: check flags and syntax for this.</p>

<h2><a name="Tokens,_types_and_targets"
>Tokens, types and targets <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<pre lang='und' xml:lang='und'>  string_constant:
    [ encoding_specifier? charset_specifier ]?  quoted_string

  encoding_specifier:
    &#34;utf8:&#34;

  charset_specifier:
      &#34;ascii:&#34;
    | &#34;binary:&#34;
    | &#34;unicode:&#34;
    | &#34;iso&#45;8859&#45;1:&#34;

  type:
      &#34;int&#34;
    | &#34;num&#34;
    | &#34;pmc&#34;
    | &#34;string&#34;

  target:
    identifier | register</pre>

<h3><a name="Notes_on_Tokens,_types_and_targets"
>Notes on Tokens, types and targets</a></h3>

<p>A string constant can be written like:</p>

<pre lang='und' xml:lang='und'>  &#34;Hello world&#34;</pre>

<p>but if desirable, the character set can be specified:</p>

<pre lang='und' xml:lang='und'>  unicode:&#34;Hello world&#34;</pre>

<p>When using the &#34;unicode&#34; character set, one can also specify an encoding specifier; currently only <code lang='und' xml:lang='und'>utf8</code> is allowed:</p>

<pre lang='und' xml:lang='und'>  utf8:unicode:&#34;hello world&#34;</pre>

<p>IMCC currently allows identifiers to be used as types. During the parse, the identifier is checked whether it is a defined class. The built&#45;in types int, num, pmc and string are always available.</p>

<p>A <code lang='und' xml:lang='und'>target</code> is something that can be assigned to, it is an L&#45;value (but of course may be read just like an R&#45;value). It is either an identifier or a register.</p>

<h1><a name="AUTHOR"
>AUTHOR <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>Klaas&#45;Jan Stol [parrotcode@gmail.com]</p>

<h1><a name="KNOWN_ISSUES_AND_BUGS"
>KNOWN ISSUES AND BUGS <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>Some work should be done on:</p>

<ul>
<li>Heredoc parsing</li><p class="pad"></p>

<li>Test. A lot.</li><p class="pad"></p>

<p>Bugs or improvements may be sent to the author, and are of course greatly appreciated. Moreover, if you find any missing constructs that are in IMCC, indications of these would be appreciated as well.</p>

<p>Please see the PROPOSALS document for some proposals of the author to clean up the official grammar of PIR (as defined by the IMCC compiler).</p>
</ul>

<h1><a name="REFERENCES"
>REFERENCES <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<ul>
<li>languages/PIR/lib/pir.pg &#45; The actual PIR grammar implementation</li><p class="pad"></p>

<li>PDD03 &#45; Parrot Calling Conventions</li><p class="pad"></p>

<li>PDD20 &#45; Lexically scoped variables in Parrot</li><p class="pad"></p>

<li>docs/imcc/calling_conventions.pod &#45; definition of sub flags (:init etc)</li><p class="pad"></p>

<li>docs/imcc/syntax.pod &#45; official syntax for IMCC/PIR.</li><p class="pad"></p>
</ul>

<h1><a name="CHANGES"
>CHANGES <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>0.2.0</p>

<ul>
<li>Many clean ups; remove experimental <code lang='und' xml:lang='und'>:wrap</code> flag, remove <code lang='und' xml:lang='und'>.global</code> directive, remove <code lang='und' xml:lang='und'>.sym</code> directive, add <code lang='und' xml:lang='und'>.label</code> directive for macros, remove <code lang='und' xml:lang='und'>.pcc_sub</code>; remove some comments that are not true any more. In all, it&#39;s getting much cleaner!</li><p class="pad"></p>
</ul>

<p>0.1.4</p>

<ul>
<li>Added <code lang='und' xml:lang='und'>expansion</code> rule, moved <code lang='und' xml:lang='und'>include</code> and <code lang='und' xml:lang='und'>macro_def</code> rules to that rule. Added <code lang='und' xml:lang='und'>pasm_constant</code> definition.</li><p class="pad"></p>

<li>Removed newlines in operator definition to save some lines for readability.</li><p class="pad"></p>
</ul>

<p>0.1.3</p>

<ul>
<li>Updated short sub invocation for NCI invocations.</li><p class="pad"></p>

<li>Added an example for <code lang='und' xml:lang='und'>.globalconst</code>.</li><p class="pad"></p>

<li>Added some remarks at section for Macros.</li><p class="pad"></p>

<li>Added some remarks here and there, and fixed some style issues.</li><p class="pad"></p>
</ul>

<p>0.1.2</p>

<ul>
<li>Removed <code lang='und' xml:lang='und'>.immediate</code>, it is <code lang='und' xml:lang='und'>:immediate</code>, and thus not a PIR directive, but a flag. This was a mistake.</li><p class="pad"></p>

<li>Added <code lang='und' xml:lang='und'>.globalconst</code></li><p class="pad"></p>

<li>Added macro parsing example (it is now fixed in languages/PIR).</li><p class="pad"></p>

<li>Added reference to official doc for IMCC syntax.</li><p class="pad"></p>

<li>Added <code lang='und' xml:lang='und'>:unique_reg</code> to allowed flags for incoming parameters.</li><p class="pad"></p>
</ul>

<p>0.1.1</p>

<ul>
<li>Switch to x.y.z version number; many fixes will follow.</li><p class="pad"></p>

<li>Added more examples.</li><p class="pad"></p>

<li>Fixed some errors.</li><p class="pad"></p>
</ul>

<p>0.1</p>

<ul>
<li>Initial version having a version number.</li><p class="pad"></p>
</ul>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../../resources/parrot_small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
