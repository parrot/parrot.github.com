<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Exceptions</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Exceptions</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../html/index.html">Contents</a> | <a href="../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>src/exceptions.c &#45; Exceptions</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>Define the internal interpreter exceptions.</p>

<ul>
<li>This is experimental code.</li><p class="pad"></p>

<li>The <code lang='und' xml:lang='und'>enum_class</code> of the Exception isn&#39;t fixed.</li><p class="pad"></p>

<li>The interface isn&#39;t fixed.</li><p class="pad"></p>

<li>Much of this may change in the future.</li><p class="pad"></p>
</ul>

<h2><a name="Functions"
>Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a
><b><code lang='und' xml:lang='und'>PARROT_API PARROT_DOES_NOT_RETURN void internal_exception(int exitcode, NOTNULL(const char *format), ...)</b></code></a></dt><p class="pad"></p>

<dd>Signal a fatal exception.
This involves printing an error message to stderr,
and calling <code lang='und' xml:lang='und'>Parrot_exit</code> to invoke exit handlers and exit the process with the given exitcode.
No error handlers are used,
so it is not possible for Parrot bytecode to intercept a fatal error (cf.
<code lang='und' xml:lang='und'>real_exception</code>).
Furthermore,
no stack unwinding is done,
so the exit handlers run in the current dynamic environment.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_DOES_NOT_RETURN void do_panic(NULLOK_INTERP, NULLOK(const char *message), NULLOK(const char *file), unsigned int line)</b></code></a></dt><p class="pad"></p>

<dd>Panic handler.</dd><p class="pad"></p>

<dt><a name="PARROT_API_void_push_exception(PARROT_INTERP,_NOTNULL(PMC_*handler))"
><b><code lang='und' xml:lang='und'>PARROT_API void push_exception(PARROT_INTERP, NOTNULL(PMC *handler))</b></code></a></dt><p class="pad"></p>

<dd>Add the exception handler on the stack.</dd><p class="pad"></p>

<dt><a name="static_void_run_cleanup_action(PARROT_INTERP,_NOTNULL(Stack_Entry_t_*e))"
><b><code lang='und' xml:lang='und'>static void run_cleanup_action(PARROT_INTERP, NOTNULL(Stack_Entry_t *e))</b></code></a></dt><p class="pad"></p>

<dd>TODO: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="PARROT_API_void_Parrot_push_action(PARROT_INTERP,_PMC_*sub)"
><b><code lang='und' xml:lang='und'>PARROT_API void Parrot_push_action(PARROT_INTERP, PMC *sub)</b></code></a></dt><p class="pad"></p>

<dd>Push an action handler onto the dynamic environment.</dd><p class="pad"></p>

<dt><a name="PARROT_API_void_Parrot_push_mark(PARROT_INTERP,_INTVAL_mark)"
><b><code lang='und' xml:lang='und'>PARROT_API void Parrot_push_mark(PARROT_INTERP, INTVAL mark)</b></code></a></dt><p class="pad"></p>

<dd>Push a cleanup mark onto the dynamic environment.</dd><p class="pad"></p>

<dt><a name="PARROT_API_void_Parrot_pop_mark(PARROT_INTERP,_INTVAL_mark)"
><b><code lang='und' xml:lang='und'>PARROT_API void Parrot_pop_mark(PARROT_INTERP, INTVAL mark)</b></code></a></dt><p class="pad"></p>

<dd>Pop items off the dynamic environment up to the mark.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_WARN_UNUSED_RESULT PARROT_CAN_RETURN_NULL static PMC *find_exception_handler(PARROT_INTERP, NOTNULL(PMC *exception))</b></code></a></dt><p class="pad"></p>

<dd>Find the exception handler for <code lang='und' xml:lang='und'>exception</code>.</dd><p class="pad"></p>

<dt><a name="PARROT_WARN_UNUSED_RESULT_INTVAL_count_exception_handlers(PARROT_INTERP)"
><b><code lang='und' xml:lang='und'>PARROT_WARN_UNUSED_RESULT INTVAL count_exception_handlers(PARROT_INTERP)</b></code></a></dt><p class="pad"></p>

<dd>Return the number of exception handlers on the exeception handler stack.</dd><p class="pad"></p>

<dt><a name="PARROT_WARN_UNUSED_RESULT_PMC_*_get_exception_handler(PARROT_INTERP,_INTVAL_target_depth)"
><b><code lang='und' xml:lang='und'>PARROT_WARN_UNUSED_RESULT PMC *get_exception_handler(PARROT_INTERP, INTVAL target_depth)</b></code></a></dt><p class="pad"></p>

<dd>Return an exception handler by index into the exeception handler stack.</dd><p class="pad"></p>

<dt><a name="PARROT_WARN_UNUSED_RESULT_PMC_*_get_all_exception_handlers(PARROT_INTERP)"
><b><code lang='und' xml:lang='und'>PARROT_WARN_UNUSED_RESULT PMC *get_all_exception_handlers(PARROT_INTERP)</b></code></a></dt><p class="pad"></p>

<dd>Return an array of all exception handlers.</dd><p class="pad"></p>

<dt><a name="PARROT_API_void_pop_exception(PARROT_INTERP)"
><b><code lang='und' xml:lang='und'>PARROT_API void pop_exception(PARROT_INTERP)</b></code></a></dt><p class="pad"></p>

<dd>Pops the topmost exception handler off the stack.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_API PARROT_WARN_UNUSED_RESULT PMC *new_c_exception_handler(PARROT_INTERP, Parrot_exception *jb)</b></code></a></dt><p class="pad"></p>

<dd>Generate an exception handler,
that catches PASM level exceptions inside a C function.
This could be a separate class too,
for now just a private flag bit is set.</dd><p class="pad"></p>

<dt><a name="PARROT_API_void_push_new_c_exception_handler(PARROT_INTERP,_Parrot_exception_*jb)"
><b><code lang='und' xml:lang='und'>PARROT_API void push_new_c_exception_handler(PARROT_INTERP, Parrot_exception *jb)</b></code></a></dt><p class="pad"></p>

<dd>Pushes an new C exception handler onto the stack.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_API PARROT_CAN_RETURN_NULL opcode_t *throw_exception(PARROT_INTERP, PMC *exception, SHIM(void *dest))</b></code></a></dt><p class="pad"></p>

<dd>Throw the exception.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_API PARROT_WARN_UNUSED_RESULT opcode_t *rethrow_exception(PARROT_INTERP, NOTNULL(PMC *exception))</b></code></a></dt><p class="pad"></p>

<dd>Rethrow the exception.</dd><p class="pad"></p>

<dt><a name="PARROT_DOES_NOT_RETURN_void_rethrow_c_exception(PARROT_INTERP)"
><b><code lang='und' xml:lang='und'>PARROT_DOES_NOT_RETURN void rethrow_c_exception(PARROT_INTERP)</b></code></a></dt><p class="pad"></p>

<dd>Return back to runloop,
assumes exception is still in todo (see RT#45915) and that this is called from within a handler setup with <code lang='und' xml:lang='und'>new_c_exception</code>.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_WARN_UNUSED_RESULT static size_t dest2offset(PARROT_INTERP, NOTNULL(const opcode_t *dest))</b></code></a></dt><p class="pad"></p>

<dd>Translate an absolute bytecode location to an offset used for resuming after an exception had occurred.</dd><p class="pad"></p>

<dt><a name="PARROT_WARN_UNUSED_RESULT_static_opcode_t_*_create_exception(PARROT_INTERP)"
><b><code lang='und' xml:lang='und'>PARROT_WARN_UNUSED_RESULT static opcode_t *create_exception(PARROT_INTERP)</b></code></a></dt><p class="pad"></p>

<dd>Create an exception.</dd><p class="pad"></p>

<dt><a name="PARROT_API_size_t_handle_exception(PARROT_INTERP)"
><b><code lang='und' xml:lang='und'>PARROT_API size_t handle_exception(PARROT_INTERP)</b></code></a></dt><p class="pad"></p>

<dd>Handle an exception.</dd><p class="pad"></p>

<dt><a name="PARROT_API_void_new_internal_exception(PARROT_INTERP)"
><b><code lang='und' xml:lang='und'>PARROT_API void new_internal_exception(PARROT_INTERP)</b></code></a></dt><p class="pad"></p>

<dd>Create a new internal exception buffer,
either by allocating it or by getting one from the free list.</dd><p class="pad"></p>

<dt><a name="PARROT_API_void_free_internal_exception(PARROT_INTERP)"
><b><code lang='und' xml:lang='und'>PARROT_API void free_internal_exception(PARROT_INTERP)</b></code></a></dt><p class="pad"></p>

<dd>Place internal exception buffer back on the free list.</dd><p class="pad"></p>

<dt><a name="void_destroy_exception_list(PARROT_INTERP)"
><b><code lang='und' xml:lang='und'>void destroy_exception_list(PARROT_INTERP)</b></code></a></dt><p class="pad"></p>

<dd>TODO: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="void_really_destroy_exception_list(NULLOK(Parrot_exception_*e))"
><b><code lang='und' xml:lang='und'>void really_destroy_exception_list(NULLOK(Parrot_exception *e))</b></code></a></dt><p class="pad"></p>

<dd>TODO: Not yet documented!!!</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_API PARROT_DOES_NOT_RETURN void do_exception(PARROT_INTERP, INTVAL severity, long error)</b></code></a></dt><p class="pad"></p>

<dd>Called from interrupt code.
Does a <code lang='und' xml:lang='und'>longjmp</code> in front of the runloop,
which calls <code lang='und' xml:lang='und'>handle_exception()</code>,
returning the handler address where execution then resumes.</dd><p class="pad"></p>

<dt><a name="_"
></a></dt><p class="pad"></p>

<dd>*/</dd><p class="pad"></p>

<dd>PARROT_API PARROT_DOES_NOT_RETURN void do_exception(PARROT_INTERP,
INTVAL severity,
long error) { Parrot_exception * const the_exception = interp&#45;&#62;exceptions;</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    the_exception&#45;&#62;error = error;
    the_exception&#45;&#62;severity = severity;
    the_exception&#45;&#62;msg = NULL;
    the_exception&#45;&#62;resume = NULL;
    longjmp(the_exception&#45;&#62;destination, 1);
}</pre>

<dd>/*</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_API PARROT_DOES_NOT_RETURN void real_exception(PARROT_INTERP, NULLOK(void *ret_addr), int exitcode, NOTNULL(const char *format), ...)</b></code></a></dt><p class="pad"></p>

<dd>Throws a real exception, with an error message constructed from the format string and arguments. <code lang='und' xml:lang='und'>ret_addr</code> is the address from which to resume, if some handler decides that is appropriate, or zero to make the error non&#45;resumable. <code lang='und' xml:lang='und'>exitcode</code> is a <code lang='und' xml:lang='und'>exception_type_enum</code> value.</dd><p class="pad"></p>

<dd>See also <code lang='und' xml:lang='und'>internal_exception()</code>, which signals fatal errors, and <code lang='und' xml:lang='und'>throw_exception</code>, which calls the handler.</dd><p class="pad"></p>

<dt><a name="void_Parrot_init_exceptions(PARROT_INTERP)"
><b><code lang='und' xml:lang='und'>void Parrot_init_exceptions(PARROT_INTERP)</b></code></a></dt><p class="pad"></p>

<dd>Create exception objects.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_API PARROT_DOES_NOT_RETURN void Parrot_confess(NOTNULL(const char *cond), NOTNULL(const char *file), unsigned int line)</b></code></a></dt><p class="pad"></p>

<dd>A better version of assert() that gives a backtrace if possible.</dd><p class="pad"></p>

<dt><a name="void_Parrot_print_backtrace(void)"
><b><code lang='und' xml:lang='und'>void Parrot_print_backtrace(void)</b></code></a></dt><p class="pad"></p>

<dd>TODO: Not yet documented!!!</dd><p class="pad"></p>
</dl>

<h1><a name="SEE_ALSO"
>SEE ALSO <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p><em lang='und' xml:lang='und'>include/parrot/exceptions.h</em>.</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../resources/parrot_small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
