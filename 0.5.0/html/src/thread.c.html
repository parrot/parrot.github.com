<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Thread handling stuff</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Thread handling stuff</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../html/index.html">Contents</a> | <a href="../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>src/thread.c &#45; Thread handling stuff</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>Threads are created by creating new <code lang='und' xml:lang='und'>ParrotInterpreter</code> objects.</p>

<h2><a name="Functions"
>Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a
><b><code lang='und' xml:lang='und'>PARROT_CAN_RETURN_NULL static PMC *make_local_copy(PARROT_INTERP, NOTNULL(Parrot_Interp from), NULLOK(PMC *arg))</b></code></a></dt><p class="pad"></p>

<dd>Create a local copy of the PMC if necessary.
(No copy is made if it is marked shared.) This includes workarounds for Parrot_clone() not doing the Right Thing with subroutines (specifically,
code segments aren&#39;t preserved and it is difficult to do so as long as Parrot_clone() depends on freezing).</dd><p class="pad"></p>

<dt><a name="static_Shared_gc_info_*_get_pool(PARROT_INTERP)"
><b><code lang='und' xml:lang='und'>static Shared_gc_info *get_pool(PARROT_INTERP)</b></code></a></dt><p class="pad"></p>

<dd>Get the shared gc information.
TODO: improve the docs here.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_CAN_RETURN_NULL static PMC *make_local_args_copy(PARROT_INTERP, Parrot_Interp old_interp, PMC *args)</b></code></a></dt><p class="pad"></p>

<dd>Make a local copy of the corresponding array of arguments.</dd><p class="pad"></p>

<dt><a name="PMC_*_pt_shared_fixup(PARROT_INTERP,_PMC_*pmc)"
><b><code lang='und' xml:lang='und'>PMC *pt_shared_fixup(PARROT_INTERP, PMC *pmc)</b></code></a></dt><p class="pad"></p>

<dd>Fixup a PMC to be sharable.
Right now,
reassigns the vtable to one owned by some master interpreter,
so the PMC can be safely reused after thread death.</dd><p class="pad"></p>

<dd>In the future the PMC returned might be different than the one passed,
e.g.,
if we need to reallocate the PMC in a different interpreter.</dd><p class="pad"></p>

<dt><a name="static_void_pt_thread_signal(NOTNULL(Parrot_Interp_self),_PARROT_INTERP)"
><b><code lang='und' xml:lang='und'>static void pt_thread_signal(NOTNULL(Parrot_Interp self), PARROT_INTERP)</b></code></a></dt><p class="pad"></p>

<dd>Wakeup a <code lang='und' xml:lang='und'>interp</code> which should have called pt_thread_wait().</dd><p class="pad"></p>

<dt><a name="void_pt_thread_wait_with(PARROT_INTERP,_Parrot_mutex_*mutex)"
><b><code lang='und' xml:lang='und'>void pt_thread_wait_with(PARROT_INTERP, Parrot_mutex *mutex)</b></code></a></dt><p class="pad"></p>

<dd>Wait for this interpreter to be signalled through its condition variable,
dealing properly with GC issues.
<code lang='und' xml:lang='und'>*mutex</code> is assumed locked on entry and will be locked on exit from this function.
If a GC run occurs in the middle of this function,
then a spurious wakeup may occur.</dd><p class="pad"></p>

<dt><a name="static_void_pt_thread_wait(PARROT_INTERP)"
><b><code lang='und' xml:lang='und'>static void pt_thread_wait(PARROT_INTERP)</b></code></a></dt><p class="pad"></p>

<dd>Wait for us to be signalled.
GC matters are handled correctly.
<code lang='und' xml:lang='und'>interpreter_array_mutex</code> is assumed held.
Spurious wakeups may occur.</dd><p class="pad"></p>

<dt><a name="PARROT_CAN_RETURN_NULL_static_void*_thread_func(void_*arg)"
><b><code lang='und' xml:lang='und'>PARROT_CAN_RETURN_NULL static void *thread_func(void *arg)</b></code></a></dt><p class="pad"></p>

<dd>The actual thread function.</dd><p class="pad"></p>
</dl>

<h2><a name="Helper_functions_used_also_for_running_plain_interpreters"
>Helper functions used also for running plain interpreters <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="void_pt_clone_code(Parrot_Interp_d,_Parrot_Interp_s)"
><b><code lang='und' xml:lang='und'>void pt_clone_code(Parrot_Interp d, Parrot_Interp s)</b></code></a></dt><p class="pad"></p>

<dd>Copy/clone the packfile/code from interpreter <code lang='und' xml:lang='und'>s</code> to <code lang='und' xml:lang='und'>d</code>.
All resources are created in <code lang='und' xml:lang='und'>d</code>.</dd><p class="pad"></p>

<dt><a name="static_void_pt_ns_clone(Parrot_Interp_d,_PMC_*dest_ns,_Parrot_Interp_s,_PMC_*source_ns)"
><b><code lang='und' xml:lang='und'>static void pt_ns_clone(Parrot_Interp d, PMC *dest_ns, Parrot_Interp s, PMC *source_ns)</b></code></a></dt><p class="pad"></p>

<dd>Clone all globals from <code lang='und' xml:lang='und'>s</code> to <code lang='und' xml:lang='und'>d</code>.</dd><p class="pad"></p>

<dt><a name="void_pt_clone_globals(Parrot_Interp_d,_Parrot_Interp_s)"
><b><code lang='und' xml:lang='und'>void pt_clone_globals(Parrot_Interp d, Parrot_Interp s)</b></code></a></dt><p class="pad"></p>

<dd>TODO: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="void_pt_thread_prepare_for_run(Parrot_Interp_d,_Parrot_Interp_s)"
><b><code lang='und' xml:lang='und'>void pt_thread_prepare_for_run(Parrot_Interp d, Parrot_Interp s)</b></code></a></dt><p class="pad"></p>

<dd>Setup code,
and TODO ...</dd><p class="pad"></p>
</dl>

<h2><a name="ParrotThread_methods"
>ParrotThread methods <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="PMC_*_pt_transfer_sub(Parrot_Interp_d,_Parrot_Interp_s,_NULLOK(PMC_*sub))"
><b><code lang='und' xml:lang='und'>PMC *pt_transfer_sub(Parrot_Interp d, Parrot_Interp s, NULLOK(PMC *sub))</b></code></a></dt><p class="pad"></p>

<dd>create a clone of the sub suitable for the other interpreter</dd><p class="pad"></p>

<dt><a name="int_pt_thread_run(PARROT_INTERP,_PMC*_dest_interp,_PMC*_sub,_PMC_*arg)"
><b><code lang='und' xml:lang='und'>int pt_thread_run(PARROT_INTERP, PMC *dest_interp, PMC *sub, PMC *arg)</b></code></a></dt><p class="pad"></p>

<dd>Run the <code lang='und' xml:lang='und'>*sub</code> PMC in a separate thread using interpreter in <code lang='und' xml:lang='und'>*dest_interp</code>.</dd><p class="pad"></p>

<dd><code lang='und' xml:lang='und'>arg</code> should be an array of arguments for the subroutine.
int</dd><p class="pad"></p>

<dt><a name="int_pt_thread_run_1(PARROT_INTERP,_PMC*_dest_interp,_PMC*_sub,_PMC_*arg)"
><b><code lang='und' xml:lang='und'>int pt_thread_run_1(PARROT_INTERP, PMC *dest_interp, PMC *sub, PMC *arg)</b></code></a></dt><p class="pad"></p>

<dd>Runs a type 1 thread.
Nothing is shared,
both interpreters are free running without any communication.</dd><p class="pad"></p>

<dt><a name="int_pt_thread_run_2(PARROT_INTERP,_PMC*_dest_interp,_PMC*_sub,_PMC_*arg)"
><b><code lang='und' xml:lang='und'>int pt_thread_run_2(PARROT_INTERP, PMC *dest_interp, PMC *sub, PMC *arg)</b></code></a></dt><p class="pad"></p>

<dd>Runs a type 2 thread.
No shared variables,
threads are communicating by sending messages.</dd><p class="pad"></p>

<dt><a name="int_pt_thread_run_3(PARROT_INTERP,_PMC*_dest_interp,_PMC*_sub,_PMC_*arg)"
><b><code lang='und' xml:lang='und'>int pt_thread_run_3(PARROT_INTERP, PMC *dest_interp, PMC *sub, PMC *arg)</b></code></a></dt><p class="pad"></p>

<dd>Run a type 3 thread.
Threads may have shared variables and are managed in a thread pool.</dd><p class="pad"></p>

<dt><a name="void_pt_thread_yield(void)"
><b><code lang='und' xml:lang='und'>void pt_thread_yield(void)</b></code></a></dt><p class="pad"></p>

<dd>Relinquishes hold on the processor.</dd><p class="pad"></p>

<dt><a name="static_Parrot_Interp_pt_check_tid(UINTVAL_tid,_NOTNULL(const_char_*from))"
><b><code lang='und' xml:lang='und'>static Parrot_Interp pt_check_tid(UINTVAL tid, NOTNULL(const char *from))</b></code></a></dt><p class="pad"></p>

<dd>Helper function.
Check if <code lang='und' xml:lang='und'>tid</code> is valid.
The caller holds the mutex.
Returns the interpreter for <code lang='und' xml:lang='und'>tid</code>.</dd><p class="pad"></p>

<dt><a name="static_void_mutex_unlock(void_*arg)"
><b><code lang='und' xml:lang='und'>static void mutex_unlock(void *arg)</b></code></a></dt><p class="pad"></p>

<dd>Unlocks the mutex <code lang='und' xml:lang='und'>*arg</code>.</dd><p class="pad"></p>

<dt><a name="static_int_is_suspended_for_gc(PARROT_INTERP)"
><b><code lang='und' xml:lang='und'>static int is_suspended_for_gc(PARROT_INTERP)</b></code></a></dt><p class="pad"></p>

<dd>Returns true iff <code lang='und' xml:lang='und'>interp</code> is suspended so a global GC can be performed.
interpreter_array_mutex must be held.</dd><p class="pad"></p>

<dt><a name="static_QUEUE_ENTRY_*_remove_queued_suspend_gc(PARROT_INTERP)"
><b><code lang='und' xml:lang='und'>static QUEUE_ENTRY *remove_queued_suspend_gc(PARROT_INTERP)</b></code></a></dt><p class="pad"></p>

<dd>XXX should this function be in a different file?</dd><p class="pad"></p>

<dd>TODO: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_int_pt_gc_count_threads(PARROT_INTERP)"
><b><code lang='und' xml:lang='und'>static int pt_gc_count_threads(PARROT_INTERP)</b></code></a></dt><p class="pad"></p>

<dd>interpreter_array_mutex must be held</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>static void pt_gc_wait_for_stage(PARROT_INTERP, thread_gc_stage_enum from_stage, thread_gc_stage_enum to_stage)</b></code></a></dt><p class="pad"></p>

<dd>TODO: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_void_pt_gc_wakeup_check(PARROT_INTERP)"
><b><code lang='und' xml:lang='und'>static void pt_gc_wakeup_check(PARROT_INTERP)</b></code></a></dt><p class="pad"></p>

<dd>Check if we need to wake threads to perform garbage collection.
This is called after thread death.
interpreter_array_mutex is assumed held.</dd><p class="pad"></p>

<dt><a name="static_void_pt_suspend_one_for_gc(PARROT_INTERP)"
><b><code lang='und' xml:lang='und'>static void pt_suspend_one_for_gc(PARROT_INTERP)</b></code></a></dt><p class="pad"></p>

<dd>Suspend a single interpreter for GC.
<code lang='und' xml:lang='und'>interpreter_array_mutex</code> assumed held.</dd><p class="pad"></p>

<dt><a name="static_void_pt_suspend_all_for_gc(PARROT_INTERP)"
><b><code lang='und' xml:lang='und'>static void pt_suspend_all_for_gc(PARROT_INTERP)</b></code></a></dt><p class="pad"></p>

<dd>Get all threads to perform a GC run.</dd><p class="pad"></p>

<dt><a name="void_pt_suspend_self_for_gc(PARROT_INTERP)"
><b><code lang='und' xml:lang='und'>void pt_suspend_self_for_gc(PARROT_INTERP)</b></code></a></dt><p class="pad"></p>

<dd>Suspend this thread for a full GC run.</dd><p class="pad"></p>

<dd>XXX FIXME &#45;&#45; if GC is blocked,
we need to do a GC run as soon as it becomes unblocked.</dd><p class="pad"></p>

<dt><a name="PMC*_pt_thread_join(NOTNULL(Parrot_Interp_parent),_UINTVAL_tid)"
><b><code lang='und' xml:lang='und'>PMC *pt_thread_join(NOTNULL(Parrot_Interp parent), UINTVAL tid)</b></code></a></dt><p class="pad"></p>

<dd>Join (wait for) a joinable thread.</dd><p class="pad"></p>

<dt><a name="void_pt_join_threads(PARROT_INTERP)"
><b><code lang='und' xml:lang='und'>void pt_join_threads(PARROT_INTERP)</b></code></a></dt><p class="pad"></p>

<dd>Possibly wait for other running threads.
This is called when destroying <code lang='und' xml:lang='und'>interp</code>.</dd><p class="pad"></p>

<dt><a name="static_Parrot_Interp_detach(UINTVAL_tid)"
><b><code lang='und' xml:lang='und'>static Parrot_Interp detach(UINTVAL tid)</b></code></a></dt><p class="pad"></p>

<dd>Helper for detach and kill.</dd><p class="pad"></p>

<dd>Returns the interpreter,
if it didn&#39;t finish yet.</dd><p class="pad"></p>

<dt><a name="void_pt_thread_detach(UINTVAL_tid)"
><b><code lang='und' xml:lang='und'>void pt_thread_detach(UINTVAL tid)</b></code></a></dt><p class="pad"></p>

<dd>Detaches (make non&#45;joinable) the thread.</dd><p class="pad"></p>

<dt><a name="void_pt_thread_kill(UINTVAL_tid)"
><b><code lang='und' xml:lang='und'>void pt_thread_kill(UINTVAL tid)</b></code></a></dt><p class="pad"></p>

<dd>Kills the thread.</dd><p class="pad"></p>
</dl>

<h2><a name="Threaded_interpreter_book&#45;keeping"
>Threaded interpreter book&#45;keeping <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="void_pt_add_to_interpreters(PARROT_INTERP,_Parrot_Interp_new_interp)"
><b><code lang='und' xml:lang='und'>void pt_add_to_interpreters(PARROT_INTERP, Parrot_Interp new_interp)</b></code></a></dt><p class="pad"></p>

<dd>All threaded interpreters are stored in an array.
Assumes that caller holds LOCK.</dd><p class="pad"></p>
</dl>

<h2><a name="DOD_Synchronization_Functions"
>DOD Synchronization Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="void_pt_DOD_start_mark(PARROT_INTERP)"
><b><code lang='und' xml:lang='und'>void pt_DOD_start_mark(PARROT_INTERP)</b></code></a></dt><p class="pad"></p>

<dd>DOD is gonna start the mark phase.
In the presence of shared PMCs,
we can only run one DOD run at a time because <code lang='und' xml:lang='und'>PMC&#45;&#62;next_for_GC</code> may be changed.</dd><p class="pad"></p>

<dd><code lang='und' xml:lang='und'>flags</code> are the DOD flags.
We check if we need to collect shared objects or not.</dd><p class="pad"></p>

<dd>TODO &#45; Have a count of shared PMCs and check it during DOD.</dd><p class="pad"></p>

<dd>TODO &#45; Evaluate if a interpreter lock is cheaper when <code lang='und' xml:lang='und'>dod_mark_ptr</code> is updated.</dd><p class="pad"></p>

<dt><a name="void_pt_DOD_mark_root_finished(PARROT_INTERP)"
><b><code lang='und' xml:lang='und'>void pt_DOD_mark_root_finished(PARROT_INTERP)</b></code></a></dt><p class="pad"></p>

<dd>DOD is finished for the root set.</dd><p class="pad"></p>

<dt><a name="void_pt_DOD_stop_mark(PARROT_INTERP)"
><b><code lang='und' xml:lang='und'>void pt_DOD_stop_mark(PARROT_INTERP)</b></code></a></dt><p class="pad"></p>

<dd>DOD&#39;s mark phase is done.</dd><p class="pad"></p>

<dt><a name="PARROT_API_void_Parrot_shared_DOD_block(PARROT_INTERP)"
><b><code lang='und' xml:lang='und'>PARROT_API void Parrot_shared_DOD_block(PARROT_INTERP)</b></code></a></dt><p class="pad"></p>

<dd>Block stop&#45;the&#45;world DOD runs.</dd><p class="pad"></p>

<dt><a name="PARROT_API_void_Parrot_shared_DOD_unblock(PARROT_INTERP)"
><b><code lang='und' xml:lang='und'>PARROT_API void Parrot_shared_DOD_unblock(PARROT_INTERP)</b></code></a></dt><p class="pad"></p>

<dd>Unblock stop&#45;the&#45;world DOD runs.</dd><p class="pad"></p>
</dl>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../resources/parrot_small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
