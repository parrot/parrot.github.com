<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Hash table</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Hash table</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../html/index.html">Contents</a> | <a href="../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>src/hash.c &#45; Hash table</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>A hashtable contains an array of bucket indexes.
Buckets are nodes in a linked list,
each containing a <code lang='und' xml:lang='und'>void *</code> key and value.
During hash creation,
the types of key and value as well as appropriate compare and hashing functions can be set.</p>

<p>This hash implementation uses just one piece of malloced memory.
The <code lang='und' xml:lang='und'>hash&#45;&#62;bs</code> bucket store points to this region.</p>

<p>This hash doesn&#39;t move during GC,
therefore a lot of the old caveats don&#39;t apply.</p>

<h2><a name="Functions"
>Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a
><b><code lang='und' xml:lang='und'>PARROT_WARN_UNUSED_RESULT static size_t key_hash_STRING(PARROT_INTERP, NOTNULL(STRING *value), size_t seed)</b></code></a></dt><p class="pad"></p>

<dd>Return the hashed value of the key <code lang='und' xml:lang='und'>value</code>.
See also string.c.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_WARN_UNUSED_RESULT static int STRING_compare(PARROT_INTERP, NOTNULL(const void *search_key), NOTNULL(const void *bucket_key))</b></code></a></dt><p class="pad"></p>

<dd>Compares the two strings,
returning 0 if they are identical.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_WARN_UNUSED_RESULT PARROT_PURE_FUNCTION static int pointer_compare(SHIM_INTERP, NULLOK(const void *a), NULLOK(const void *b))</b></code></a></dt><p class="pad"></p>

<dd>Compares the two pointers,
returning 0 if they are identical</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_WARN_UNUSED_RESULT PARROT_PURE_FUNCTION static size_t key_hash_pointer(SHIM_INTERP, NULLOK(void *value), size_t seed)</b></code></a></dt><p class="pad"></p>

<dd>Returns a hashvalue for a pointer.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_WARN_UNUSED_RESULT PARROT_PURE_FUNCTION static size_t key_hash_cstring(SHIM_INTERP, NOTNULL(const void *value), size_t seed)</b></code></a></dt><p class="pad"></p>

<dd>TODO: Not yet documented!!!</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_WARN_UNUSED_RESULT PARROT_PURE_FUNCTION static int cstring_compare(SHIM_INTERP, NOTNULL(const char *a), NOTNULL(const char *b))</b></code></a></dt><p class="pad"></p>

<dd>C string versions of the <code lang='und' xml:lang='und'>key_hash</code> and <code lang='und' xml:lang='und'>compare</code> functions.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_WARN_UNUSED_RESULT PARROT_PURE_FUNCTION size_t key_hash_int(SHIM_INTERP, NULLOK(void *value), size_t seed)</b></code></a></dt><p class="pad"></p>

<dd>Custom <code lang='und' xml:lang='und'>key_hash</code> function.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_WARN_UNUSED_RESULT PARROT_PURE_FUNCTION int int_compare(SHIM_INTERP, NULLOK(const void *a), NULLOK(const void *b))</b></code></a></dt><p class="pad"></p>

<dd>Custom <code lang='und' xml:lang='und'>compare</code> function.</dd><p class="pad"></p>

<dt><a name="PARROT_API_void_parrot_dump_hash(SHIM_INTERP,_NOTNULL(const_Hash_*hash))"
><b><code lang='und' xml:lang='und'>PARROT_API void parrot_dump_hash(SHIM_INTERP, NOTNULL(const Hash *hash))</b></code></a></dt><p class="pad"></p>

<dd>Print out the hash in human&#45;readable form.
Except it&#39;s empty.</dd><p class="pad"></p>

<dt><a name="PARROT_API_void_parrot_mark_hash(PARROT_INTERP,_NOTNULL(Hash_*hash))"
><b><code lang='und' xml:lang='und'>PARROT_API void parrot_mark_hash(PARROT_INTERP, NOTNULL(Hash *hash))</b></code></a></dt><p class="pad"></p>

<dd>Marks the hash and its contents as live.</dd><p class="pad"></p>

<dt><a name="static_void_hash_thaw(PARROT_INTERP,_NOTNULL(Hash_*hash),_NOTNULL(visit_info*_info))"
><b><code lang='und' xml:lang='und'>static void hash_thaw(PARROT_INTERP, NOTNULL(Hash *hash), NOTNULL(visit_info *info))</b></code></a></dt><p class="pad"></p>

<dd>This is used by freeze/thaw to visit the contents of the hash.</dd><p class="pad"></p>

<dd><code lang='und' xml:lang='und'>pinfo</code> is the visit info,
(see include/parrot/pmc_freeze.h&#62;).</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>static void hash_freeze(PARROT_INTERP, NOTNULL(const Hash *const hash), NOTNULL(visit_info *info))</b></code></a></dt><p class="pad"></p>

<dd>TODO: Not yet documented!!!</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_API void parrot_hash_visit(PARROT_INTERP, NOTNULL(Hash *hash), NOTNULL(void *pinfo))</b></code></a></dt><p class="pad"></p>

<dd>TODO: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_void_expand_hash(PARROT_INTERP,_NOTNULL(Hash_*hash))"
><b><code lang='und' xml:lang='und'>static void expand_hash(PARROT_INTERP, NOTNULL(Hash *hash))</b></code></a></dt><p class="pad"></p>

<dd>For a hashtable of size N,
we use <code lang='und' xml:lang='und'>MAXFULL_PERCENT</code> % of N as the number of buckets.
This way,
as soon as we run out of buckets on the free list,
we know that it&#39;s time to resize the hashtable.</dd><p class="pad"></p>

<dd>Algorithm for expansion: We exactly double the size of the hashtable.
Keys are assigned to buckets with the formula</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>        bucket_index = hash(key) % parrot_hash_size</pre>

<dd>so when doubling the size of the hashtable, we know that every key is either already in the correct bucket, or belongs in the current bucket plus <code lang='und' xml:lang='und'>parrot_hash_size</code> (the old <code lang='und' xml:lang='und'>parrot_hash_size</code>). In fact, because the hashtable is always a power of two in size, it depends only on the next bit in the hash value, after the ones previously used.</dd><p class="pad"></p>

<dd>So we scan through all the buckets in order, moving the buckets that need to be moved. No bucket will be scanned twice, and the cache should be reasonably happy because the hashtable accesses will be two parallel sequential scans. (Of course, this also mucks with the <code lang='und' xml:lang='und'>&#45;&#62;next</code> pointers, and they&#39;ll be all over memory.)</dd><p class="pad"></p>

<dt><a name="PARROT_API_void_parrot_new_hash(SHIM_INTERP,_NOTNULL(Hash_**hptr))"
><b><code lang='und' xml:lang='und'>PARROT_API void parrot_new_hash(SHIM_INTERP, NOTNULL(Hash **hptr))</b></code></a></dt><p class="pad"></p>

<dd>Returns a new Parrot STRING hash in <code lang='und' xml:lang='und'>hptr</code>.</dd><p class="pad"></p>

<dt><a name="PARROT_API_void_parrot_new_pmc_hash(PARROT_INTERP,_NOTNULL(PMC_*container))"
><b><code lang='und' xml:lang='und'>PARROT_API void parrot_new_pmc_hash(PARROT_INTERP, NOTNULL(PMC *container))</b></code></a></dt><p class="pad"></p>

<dd>Create a new Parrot STRING hash in PMC_struct_val(container)</dd><p class="pad"></p>

<dt><a name="PARROT_API_void_parrot_new_cstring_hash(SHIM_INTERP,_NOTNULL(Hash_**hptr))"
><b><code lang='und' xml:lang='und'>PARROT_API void parrot_new_cstring_hash(SHIM_INTERP, NOTNULL(Hash **hptr))</b></code></a></dt><p class="pad"></p>

<dd>Returns a new C string hash in <code lang='und' xml:lang='und'>hptr</code>.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>static void init_hash(NOTNULL(Hash *hash), PARROT_DATA_TYPE val_type, Hash_key_type hkey_type, hash_comp_fn compare, hash_hash_key_fn keyhash)</b></code></a></dt><p class="pad"></p>

<dd>TODO: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="PARROT_API_void_parrot_hash_destroy(SHIM_INTERP,_NOTNULL(Hash_*hash))"
><b><code lang='und' xml:lang='und'>PARROT_API void parrot_hash_destroy(SHIM_INTERP, NOTNULL(Hash *hash))</b></code></a></dt><p class="pad"></p>

<dd>TODO: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="void_parrot_chash_destroy(PARROT_INTERP,_NOTNULL(Hash_*hash))"
><b><code lang='und' xml:lang='und'>void parrot_chash_destroy(PARROT_INTERP, NOTNULL(Hash *hash))</b></code></a></dt><p class="pad"></p>

<dd>TODO: Not yet documented!!!</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>void parrot_new_hash_x(NOTNULL(Hash **hptr), PARROT_DATA_TYPE val_type, Hash_key_type hkey_type, hash_comp_fn compare, hash_hash_key_fn keyhash)</b></code></a></dt><p class="pad"></p>

<dd>Returns a new hash in <code lang='und' xml:lang='und'>hptr</code>.</dd><p class="pad"></p>

<dd>FIXME: This function can go back to just returning the hash struct pointer once Buffers can define their own custom mark routines.</dd><p class="pad"></p>

<dd>The problem is: During DODs stack walking the item on the stack must be a PMC. When an auto <code lang='und' xml:lang='und'>Hash*</code> is seen, it doesn&#39;t get properly marked (only the <code lang='und' xml:lang='und'>Hash*</code> buffer is marked, not its contents). By passing the <code lang='und' xml:lang='und'>**hptr</code> up to the Hash&#39;s init function, the newly constructed PMC is on the stack <i>including</i> this newly constructed Hash, so that it gets marked properly.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>void parrot_new_pmc_hash_x(SHIM_INTERP, NOTNULL(PMC *container), PARROT_DATA_TYPE val_type, Hash_key_type hkey_type, hash_comp_fn compare, hash_hash_key_fn keyhash)</b></code></a></dt><p class="pad"></p>

<dd>Like parrot_new_hash_x but w/o the described problems. The passed in <code lang='und' xml:lang='und'>container</code> PMC gets stored in the Hash end the newly created Hash is in PMC_struct_val(container).</dd><p class="pad"></p>

<dt><a name="PARROT_API_void_parrot_new_pointer_hash(SHIM_INTERP,_NOTNULL(Hash_**hptr))"
><b><code lang='und' xml:lang='und'>PARROT_API void parrot_new_pointer_hash(SHIM_INTERP, NOTNULL(Hash **hptr))</b></code></a></dt><p class="pad"></p>

<dd>Create a new HASH with void * keys and values.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_API PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL PMC *Parrot_new_INTVAL_hash(PARROT_INTERP, UINTVAL flags)</b></code></a></dt><p class="pad"></p>

<dd>Create a new Hash PMC with INTVAL keys and values. <code lang='und' xml:lang='und'>flags</code> can be <code lang='und' xml:lang='und'>PObj_constant_FLAG</code> or 0.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_API PARROT_WARN_UNUSED_RESULT PARROT_PURE_FUNCTION INTVAL parrot_hash_size(PARROT_INTERP, NOTNULL(const Hash *hash))</b></code></a></dt><p class="pad"></p>

<dd>Return the number of used entries in the hash.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_API PARROT_WARN_UNUSED_RESULT PARROT_CAN_RETURN_NULL void *parrot_hash_get_idx(SHIM_INTERP, NOTNULL(const Hash *hash), NOTNULL(PMC *key))</b></code></a></dt><p class="pad"></p>

<dd>Called by iterator.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_API PARROT_WARN_UNUSED_RESULT PARROT_CAN_RETURN_NULL HashBucket *parrot_hash_get_bucket(PARROT_INTERP, NOTNULL(const Hash *hash), NOTNULL(void *key))</b></code></a></dt><p class="pad"></p>

<dd>Returns the bucket for <code lang='und' xml:lang='und'>key</code>.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_API PARROT_WARN_UNUSED_RESULT PARROT_CAN_RETURN_NULL void *parrot_hash_get(PARROT_INTERP, NOTNULL(Hash *hash), NOTNULL(void *key))</b></code></a></dt><p class="pad"></p>

<dd>Returns the value keyed by <code lang='und' xml:lang='und'>key</code> or <code lang='und' xml:lang='und'>NULL</code> if no bucket is found.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_API PARROT_WARN_UNUSED_RESULT INTVAL parrot_hash_exists(PARROT_INTERP, NOTNULL(Hash *hash), NOTNULL(void *key))</b></code></a></dt><p class="pad"></p>

<dd>Returns whether the key exists in the hash.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_API PARROT_IGNORABLE_RESULT PARROT_CANNOT_RETURN_NULL HashBucket *parrot_hash_put(PARROT_INTERP, NOTNULL(Hash *hash), NOTNULL(void *key), NULLOK(void *value))</b></code></a></dt><p class="pad"></p>

<dd>Puts the key and value into the hash. Note that <code lang='und' xml:lang='und'>key</code> is <b>not</b> copied.</dd><p class="pad"></p>

<dt><a name="PARROT_API_void_parrot_hash_delete(PARROT_INTERP,_NOTNULL(Hash_*hash),_NOTNULL(void_*key))"
><b><code lang='und' xml:lang='und'>PARROT_API void parrot_hash_delete(PARROT_INTERP, NOTNULL(Hash *hash), NOTNULL(void *key))</b></code></a></dt><p class="pad"></p>

<dd>Deletes the key from the hash.</dd><p class="pad"></p>

<dt><a name="PARROT_API_void_parrot_hash_clone(PARROT_INTERP,_NOTNULL(Hash_*hash),_NOTNULL(Hash_*dest))"
><b><code lang='und' xml:lang='und'>PARROT_API void parrot_hash_clone(PARROT_INTERP, NOTNULL(Hash *hash), NOTNULL(Hash *dest))</b></code></a></dt><p class="pad"></p>

<dd>Clones <code lang='und' xml:lang='und'>hash</code> to <code lang='und' xml:lang='und'>dest</code>.</dd><p class="pad"></p>
</dl>

<h1><a name="SEE_ALSO"
>SEE ALSO <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p><em lang='und' xml:lang='und'>docs/pdds/pdd08_keys.pod</em>.</p>

<h1><a name="TODO"
>TODO <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>Future optimizations:</p>

<ul>
<li>Stop reallocating the bucket pool, and instead add chunks on. (Saves pointer fixups and copying during <code lang='und' xml:lang='und'>realloc</code>.)</li><p class="pad"></p>

<li>Hash contraction (don&#39;t if it&#39;s worth it)</li><p class="pad"></p>
</ul>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../resources/parrot_small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
