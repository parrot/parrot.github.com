<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Stack handling routines for Parrot</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Stack handling routines for Parrot</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../html/index.html">Contents</a> | <a href="../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>src/stacks.c &#45; Stack handling routines for Parrot</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>The stack is stored as a linked list of chunks (<code lang='und' xml:lang='und'>Stack_Chunk</code>),
where each chunk has room for one entry.</p>

<h2><a name="Functions"
>Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="Stack_Chunk_t_*_new_stack(Interp_*interpreter,_const_char_*name)"
><b><code lang='und' xml:lang='und'>Stack_Chunk_t *new_stack(Interp *interpreter, const char *name)</b></code></a></dt><p class="pad"></p>

<dd>Create a new stack and name it.
<code lang='und' xml:lang='und'>stack&#45;&#62;name</code> is used for debugging/error reporting.</dd><p class="pad"></p>

<dt><a name="void_mark_stack(Interp_*interpreter,_Stack_Chunk_t_*chunk)"
><b><code lang='und' xml:lang='und'>void mark_stack(Interp *interpreter, Stack_Chunk_t *chunk)</b></code></a></dt><p class="pad"></p>

<dd>Mark entries in a stack structure during DOD.</dd><p class="pad"></p>

<dt><a name="void_stack_destroy(Stack_Chunk_t_*_top)"
><b><code lang='und' xml:lang='und'>void stack_destroy(Stack_Chunk_t *top)</b></code></a></dt><p class="pad"></p>

<dd>GC does it all.</dd><p class="pad"></p>

<dt><a name="size_t_stack_height(Interp_*interpreter,_const_Stack_Chunk_t_*top)"
><b><code lang='und' xml:lang='und'>size_t stack_height(Interp *interpreter, const Stack_Chunk_t *top)</b></code></a></dt><p class="pad"></p>

<dd>Returns the height of the stack.
The maximum &#34;depth&#34; is height &#45; 1.</dd><p class="pad"></p>

<dt><a name="Stack_Entry_t_*_stack_entry(Interp_*interpreter,_Stack_Chunk_t_*stack,_INTVAL_depth)"
><b><code lang='und' xml:lang='und'>Stack_Entry_t *stack_entry(Interp *interpreter, Stack_Chunk_t *stack, INTVAL depth)</b></code></a></dt><p class="pad"></p>

<dd>If <code lang='und' xml:lang='und'>depth &#62;= 0</code>,
return the entry at that depth from the top of the stack,
with 0 being the top entry.
If <code lang='und' xml:lang='und'>depth &#60; 0</code>,
then return the entry <code lang='und' xml:lang='und'>|depth|</code> entries from the bottom of the stack.
Returns <code lang='und' xml:lang='und'>NULL</code> if <code lang='und' xml:lang='und'>|depth| </code> number&#62; of entries in stack.</dd><p class="pad"></p>

<dt><a name="void_rotate_entries(Interp_*interpreter,_Stack_Chunk_t_**stack_p,_INTVAL_num_entries)"
><b><code lang='und' xml:lang='und'>void rotate_entries(Interp *interpreter, Stack_Chunk_t **stack_p, INTVAL num_entries)</b></code></a></dt><p class="pad"></p>

<dd>Rotate the top N entries by one.
If <code lang='und' xml:lang='und'>N </code> 0&#62;,
the rotation is bubble up,
so the top most element becomes the Nth element.
If <code lang='und' xml:lang='und'>N &#60; 0</code>,
the rotation is bubble down,
so that the Nth element becomes the top most element.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>void stack_push(Interp *interpreter, Stack_Chunk_t **stack_p, void *thing, Stack_entry_type type, Stack_cleanup_method cleanup)</b></code></a></dt><p class="pad"></p>

<dd>Push something on the generic stack.</dd><p class="pad"></p>

<dd>Note that the cleanup pointer,
if non&#45;<code lang='und' xml:lang='und'>NULL</code>,
points to a routine that&#39;ll be called when the entry is removed from the stack.
This is handy for those cases where you need some sort of activity to take place when an entry is removed,
such as when you push a lexical lock onto the call stack,
or localize (or tempify,
or whatever we&#39;re calling it) variable or something.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>void *stack_pop(Interp *interpreter, Stack_Chunk_t **stack_p, void *where, Stack_entry_type type)</b></code></a></dt><p class="pad"></p>

<dd>Pop off an entry and return a pointer to the contents.</dd><p class="pad"></p>

<dt><a name="void_*_pop_dest(Interp_*interpreter)"
><b><code lang='und' xml:lang='und'>void *pop_dest(Interp *interpreter)</b></code></a></dt><p class="pad"></p>

<dd>Pop off a destination entry and return a pointer to the contents.</dd><p class="pad"></p>

<dt><a name="void_*_stack_peek(Interp_*interpreter,_Stack_Chunk_t_*stack_base,_Stack_entry_type_*type)"
><b><code lang='und' xml:lang='und'>void *stack_peek(Interp *interpreter, Stack_Chunk_t *stack_base, Stack_entry_type *type)</b></code></a></dt><p class="pad"></p>

<dd>Peek at stack and return pointer to entry and the type of the entry.</dd><p class="pad"></p>

<dt><a name="Stack_entry_type_get_entry_type(Interp_*interpreter,_Stack_Entry_t_*entry)"
><b><code lang='und' xml:lang='und'>Stack_entry_type get_entry_type(Interp *interpreter, Stack_Entry_t *entry)</b></code></a></dt><p class="pad"></p>

<dd>Returns the stack entry type of <code lang='und' xml:lang='und'>entry</code>.</dd><p class="pad"></p>
</dl>

<h1><a name="SEE_ALSO"
>SEE ALSO <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p><em lang='und' xml:lang='und'>include/parrot/stacks.h</em>,
<em lang='und' xml:lang='und'>include/parrot/enums.h</em>,
and <em lang='und' xml:lang='und'><a href="stack_common.c.html">src/stack_common.c</a></em></p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
