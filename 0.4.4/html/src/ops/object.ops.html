<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>object.ops</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">object.ops</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../html/index.html">Contents</a> | <a href="../../../html/ops.html">Ops</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>object.ops</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Parrot&#39;s library of object ops</p>

<dl>
<dt><a name="callmethodcc(in_PMC,_in_STR)"
><b>callmethodcc</b>(in PMC,
in STR)</a></dt><p class="pad"></p>

<dd>Call method $2 with invocant $1 and generate a new return continuation.
The invocant ($1) is used for method lookup.
The object is passed as the first argument in <b>set_args</b>.</dd><p class="pad"></p>

<dd>Throws a Method_Not_Found_Exception for a non&#45;existent method.</dd><p class="pad"></p>

<dt><a name="callmethodcc(in_PMC,_in_PMC)"
><b>callmethodcc</b>(in PMC,
in PMC)</a></dt><p class="pad"></p>

<dd>Like above but use the Sub object $2 as method.</dd><p class="pad"></p>

<dt><a name="callmethod(in_PMC,_in_STR,_in_PMC)"
><b>callmethod</b>(in PMC,
in STR,
in PMC)</a></dt><p class="pad"></p>

<dt><a name="callmethod(in_PMC,_in_PMC,_in_PMC)"
><b>callmethod</b>(in PMC,
in PMC,
in PMC)</a></dt><p class="pad"></p>

<dd>Like above,
but use continuation $3 instead of creating a new continuation.</dd><p class="pad"></p>

<dt><a name="tailcallmethod(in_PMC,_in_STR)"
><b>tailcallmethod</b>(in PMC,
in STR)</a></dt><p class="pad"></p>

<dt><a name="tailcallmethod(in_PMC,_in_PMC)"
><b>tailcallmethod</b>(in PMC,
in PMC)</a></dt><p class="pad"></p>

<dd>Make a tailcall to method $2 with invocant $1.</dd><p class="pad"></p>

<dt><a name="fetchmethod(out_PMC,_in_PMC,_in_STR)"
><b>fetchmethod</b>(out PMC,
in PMC,
in STR)</a></dt><p class="pad"></p>

<dd>Find the method $3 for object $2 and put it in $1.
Throws a Method_Not_Found_Exception for a non&#45;existent method.
The returned PMC may be outdated,
when the call is actually performed and changes to the underlying classes where made.</dd><p class="pad"></p>

<dt><a name="can(out_INT,_in_PMC,_in_STR)"
><b>can</b>(out INT,
in PMC,
in STR)</a></dt><p class="pad"></p>

<dd>Sets $1 to true or false,
depending on whether $2 &#45;&#62;can the method in $3.</dd><p class="pad"></p>

<dt><a name="does(out_INT,_in_PMC,_in_STR)"
><b>does</b>(out INT,
in PMC,
in STR)</a></dt><p class="pad"></p>

<dd>Sets $1 to true or false,
depending on whether $2 &#45;&#62;does the interface in $3.</dd><p class="pad"></p>

<dd>See <a href='TODO#build%2Fpmc2c.pl'>&#34;build/pmc2c.pl&#34; in tools</a> for a list of available interfaces.</dd><p class="pad"></p>

<dt><a name="isa(out_INT,_in_PMC,_in_STR)"
><b>isa</b>(out INT,
in PMC,
in STR)</a></dt><p class="pad"></p>

<dt><a name="isa(out_INT,_in_PMC,_in_KEY)"
><b>isa</b>(out INT,
in PMC,
in KEY)</a></dt><p class="pad"></p>

<dd>Sets $1 to true or false,
depending on whether $2 isa $3.</dd><p class="pad"></p>

<dt><a name="newclass(out_PMC,_in_STR)"
><b>newclass</b>(out PMC,
in STR)</a></dt><p class="pad"></p>

<dd>Creates a new Parrot&#45;style class,
named $2,
and puts the new PMC for it into $1.</dd><p class="pad"></p>

<dt><a name="newclass(out_PMC,_in_KEY)"
><b>newclass</b>(out PMC,
in KEY)</a></dt><p class="pad"></p>

<dd>Create a new Parrot&#45;style class,
with the hierachical name given in $2.</dd><p class="pad"></p>

<dt><a name="subclass(out_PMC,_in_PMC)"
><b>subclass</b>(out PMC,
in PMC)</a></dt><p class="pad"></p>

<dt><a name="subclass(out_PMC,_in_PMC,_in_STR)"
><b>subclass</b>(out PMC,
in PMC,
in STR)</a></dt><p class="pad"></p>

<dt><a name="subclass(out_PMC,_in_STR)"
><b>subclass</b>(out PMC,
in STR)</a></dt><p class="pad"></p>

<dt><a name="subclass(out_PMC,_in_STR,_in_STR)"
><b>subclass</b>(out PMC,
in STR,
in STR)</a></dt><p class="pad"></p>

<dd>Create a new class,
put in $1,
that is a subclass of $2.
$3,
if available,
is the name of the new class&#45;&#45;if not,
the subclass is an anonymous subclass.</dd><p class="pad"></p>

<dt><a name="subclass(out_PMC,_in_PMC,_in_KEY)"
><b>subclass</b>(out PMC,
in PMC,
in KEY)</a></dt><p class="pad"></p>

<dt><a name="subclass(out_PMC,_in_KEY,_in_KEY)"
><b>subclass</b>(out PMC,
in KEY,
in KEY)</a></dt><p class="pad"></p>

<dt><a name="subclass(out_PMC,_in_STR,_in_KEY)"
><b>subclass</b>(out PMC,
in STR,
in KEY)</a></dt><p class="pad"></p>

<dd>Create a new class $1,
that is a subclass of $2.
If $3 isn&#39;t a NULL key,
it&#39;s the name of the class.</dd><p class="pad"></p>

<dt><a name="getclass(out_PMC,_in_STR)"
><b>getclass</b>(out PMC,
in STR)</a></dt><p class="pad"></p>

<dt><a name="getclass(out_PMC,_in_KEY)"
><b>getclass</b>(out PMC,
in KEY)</a></dt><p class="pad"></p>

<dd>Find the PMC for a class,
by name.</dd><p class="pad"></p>

<dt><a name="singleton(in_PMC)_(unimplemented)"
><b>singleton</b>(in PMC) <b>(unimplemented)</b></a></dt><p class="pad"></p>

<dd>Take the object in $1 and put it into its own singleton class,
which is an anonymous subclass of the object&#39;s current class.</dd><p class="pad"></p>

<dt><a name="class(out_PMC,_in_PMC)"
><b>class</b>(out PMC,
in PMC)</a></dt><p class="pad"></p>

<dd>Get the class PMC for the object in $2 and put it in $1.</dd><p class="pad"></p>

<dt><a name="classname(out_STR,_in_PMC)"
><b>classname</b>(out STR,
in PMC)</a></dt><p class="pad"></p>

<dd>Get the class name for the class in $2 and put it in $1.</dd><p class="pad"></p>

<dt><a name="addparent(in_PMC,_in_PMC)"
><b>addparent</b>(in PMC,
in PMC)</a></dt><p class="pad"></p>

<dd>Add class $2 to the list of parent classes for $1.</dd><p class="pad"></p>

<dt><a name="removeparent(in_PMC,_in_PMC)"
><b>removeparent</b>(in PMC,
in PMC)</a></dt><p class="pad"></p>

<dd>Remove class $2 from class $1&#39;s list of parents.</dd><p class="pad"></p>

<dt><a name="addattribute(in_PMC,_in_STR)"
><b>addattribute</b>(in PMC,
in STR)</a></dt><p class="pad"></p>

<dd>Add the attribute named $2 to the class $1.</dd><p class="pad"></p>

<dt><a name="removeattribute(in_PMC,_in_STR)_(unimplemented)"
><b>removeattribute</b>(in PMC,
in STR) <b>(unimplemented)</b></a></dt><p class="pad"></p>

<dt><a name="removeattribute(in_PMC,_in_INT)_(unimplemented)"
><b>removeattribute</b>(in PMC,
in INT) <b>(unimplemented)</b></a></dt><p class="pad"></p>

<dd>Remove attribute $2 from class $1,
specified either by name or offset.</dd><p class="pad"></p>

<dt><a name="getattribute(out_PMC,_in_PMC,_in_INT)"
><b>getattribute</b>(out PMC,
in PMC,
in INT)</a></dt><p class="pad"></p>

<dt><a name="getattribute(out_PMC,_in_PMC,_in_STR)"
><b>getattribute</b>(out PMC,
in PMC,
in STR)</a></dt><p class="pad"></p>

<dd>Get attribute number $3 from object $2 and put the result in $1.
String attribute names have to be fully qualified.</dd><p class="pad"></p>

<dt><a name="setattribute(in_PMC,_in_INT,_in_PMC)"
><b>setattribute</b>(in PMC,
in INT,
in PMC)</a></dt><p class="pad"></p>

<dt><a name="setattribute(in_PMC,_in_STR,_in_PMC)"
><b>setattribute</b>(in PMC,
in STR,
in PMC)</a></dt><p class="pad"></p>

<dd>Set attribute $2 of object $1 to $3</dd><p class="pad"></p>

<dt><a name="classoffset(out_INT,_in_PMC,_in_STR)"
><b>classoffset</b>(out INT,
in PMC,
in STR)</a></dt><p class="pad"></p>

<dd>Returns the offset of the first attribute for class $3 in object $2.
Throws an exception if $3 isn&#39;t in $2&#39;s hierarchy.</dd><p class="pad"></p>

<dt><a name="adddoes(in_PMC,_in_STR)_(unimplemented)"
><b>adddoes</b>(in PMC,
in STR) <b>(unimplemented)</b></a></dt><p class="pad"></p>

<dd>Add $2 to the list of interfaces that this class claims to implement.</dd><p class="pad"></p>

<dt><a name="removedoes(in_PMC,_in_STR)_(unimplemented)"
><b>removedoes</b>(in PMC,
in STR) <b>(unimplemented)</b></a></dt><p class="pad"></p>

<dd>Remove $2 from the list of interfaces that this class claims to implement.</dd><p class="pad"></p>
</dl>

<h1><a name="COPYRIGHT"
>COPYRIGHT <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Copyright (C) 2001&#45;2004 The Perl Foundation.
All rights reserved.</p>

<h1><a name="LICENSE"
>LICENSE <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>This program is free software.
It is subject to the same license as the Parrot interpreter itself.</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
