<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Regex stack handling routines</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Regex stack handling routines</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../html/index.html">Contents</a> | <a href="../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>src/intlists.c &#45; Regex stack handling routines</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>intlist emulation code,
calls routines in <em lang='und' xml:lang='und'><a href="list.c.html">src/list.c</a></em>.</p>

<p>Here is the original documentation for intlist:</p>

<p>The basic data structure is a variant of a doubly&#45;linked list of &#39;chunks&#39;,
where a chunk is a <code lang='und' xml:lang='und'>Buffer</code> header subclass containing the link pointers and other metadata for the chunk.
As expected from it being a <code lang='und' xml:lang='und'>Buffer</code> header,
the <code lang='und' xml:lang='und'>PObj_bufstart</code> field points to the actual array of <code lang='und' xml:lang='und'>INTVAL</code>s.
The handle used by external code for one of these IntLists is just a pointer to a chunk,
always called &#39;list&#39; in this code.</p>

<p>For now,
all of the chunks are fixed&#45;length in size.
(That could easily be changed,
at the cost of another integer in each header.)</p>

<p>Notice that I said &#39;variant&#39; of a doubly&#45;linked list.
That is because if you start at &#39;list&#39; and follow prev pointers,
you will loop through all the used nodes of the list,
as usual.
But if you follow next pointers instead,
you might find a spare node hanging off the last node in the list (the last node is always <code lang='und' xml:lang='und'>list&#45;&#62;prev</code>,
so if there is a spare node,
it will be at <code lang='und' xml:lang='und'>list&#45;&#62;prev&#45;&#62;next</code>.
If no spare exists,
then <code lang='und' xml:lang='und'>list&#45;&#62;prev&#45;&#62;next==list</code>.)</p>

<p>The first node in the list may be partly full; the intermediate nodes are always completely full; and the last node may be partly full.
Each node has a <code lang='und' xml:lang='und'>.start</code> field,
giving the offset of the first valid element (always zero except for possibly the first node),
and a <code lang='und' xml:lang='und'>.end</code> field,
giving one past the offset of the last valid element (always equal to <code lang='und' xml:lang='und'>INTLIST_CHUNK_SIZE</code> except for possibly the last node).</p>

<p>To make it concrete,
let&#39;s walk through some sample operations.
To push onto the end of the list,
first find the last chunk: <code lang='und' xml:lang='und'>list&#45;&#62;prev</code>.
Then if <code lang='und' xml:lang='und'>chunk&#45;&#62;end &#60; INTLIST_CHUNK_SIZE</code>,
there is space to fit another element and so just stick it in.
If not,
we must add a chunk to the end of the list.
If there is a spare,
just link it fully into the list (forming a conventional doubly&#45;linked list).
Otherwise,
create a new chunk and link it fully into the list.
Easy enough.</p>

<p>To pop something off the end,
first go to the end chunk (<code lang='und' xml:lang='und'>list&#45;&#62;prev</code>).
Pop off an element and decrement <code lang='und' xml:lang='und'>.end</code> if the chunk is nonempty.
If it is empty,
make that last chunk into the spare (discarding the previous spare).
Then go to the previous chunk,
which is guaranteed to have <code lang='und' xml:lang='und'>.end</code> set to <code lang='und' xml:lang='und'>INTLIST_CHUNK_SIZE</code>,
and return <code lang='und' xml:lang='und'>data[.end&#45;&#45;]</code>.</p>

<p>The length of the list is always cached in the overall header chunk.
If an operation changes which chunk is the header (i.e.,
shift or unshift),
then the length is copied to the new header.</p>

<p>Invariants:</p>

<p>There is always space in <code lang='und' xml:lang='und'>list&#45;&#62;prev</code> to insert an element.</p>

<p>The &#39;list&#39; chunk is never empty unless the entire list is empty.</p>

<p>In combination,
the above invariants imply that the various operations are implemented as:</p>

<dl>
<dt><a name="push"
><b><code lang='und' xml:lang='und'>push</b></code></a></dt><p class="pad"></p>

<dd>Write element,
push a new chunk if necessary.</dd><p class="pad"></p>

<dt><a name="pop"
><b><code lang='und' xml:lang='und'>pop</b></code></a></dt><p class="pad"></p>

<dd>Check to see if we have to back up a chunk,
read element.</dd><p class="pad"></p>

<dt><a name="shift"
><b><code lang='und' xml:lang='und'>shift</b></code></a></dt><p class="pad"></p>

<dd>Read element,
discard chunk and advance if necessary.</dd><p class="pad"></p>

<dt><a name="unshift"
><b><code lang='und' xml:lang='und'>unshift</b></code></a></dt><p class="pad"></p>

<dd>Unshift a chunk if necessary,
write element.</dd><p class="pad"></p>
</dl>

<p>Direct aka indexed access of intlist data:</p>

<p>The classic method would be to walk the <code lang='und' xml:lang='und'>intlist&#45;&#62;next</code> pointers (or optimized,
the <code lang='und' xml:lang='und'>&#45;&#62;prev</code> pointers if an index near the end is requested) and locate the chunk,
that holds the wanted list item.</p>

<p>To speed things up,
especially for bigger lists,
there are additional fields in the &#39;list&#39; (the head chunk):</p>

<dl>
<dt><a name="chunk_list"
><b><code lang='und' xml:lang='und'>chunk_list</b></code></a></dt><p class="pad"></p>

<dd>Holds pointers to individual chunks.</dd><p class="pad"></p>

<dt><a name="collect_runs"
><b><code lang='und' xml:lang='und'>collect_runs</b></code></a></dt><p class="pad"></p>

<dd><code lang='und' xml:lang='und'>collect_runs</code> counter,
when <code lang='und' xml:lang='und'>chunk_list</code> was rebuilt last.</dd><p class="pad"></p>

<dt><a name="n_chunks"
><b><code lang='und' xml:lang='und'>n_chunks</b></code></a></dt><p class="pad"></p>

<dd>Used length in <code lang='und' xml:lang='und'>chunk_list</code></dd><p class="pad"></p>
</dl>

<p>If on any indexed access interpreter&#39;s collect_runs is different,
the chunks might have been moved,
so the chunk_list has to be rebuilt.</p>

<p>Getting data outside the array dimensions will return the value <code lang='und' xml:lang='und'>NULL</code>,
which will <code lang='und' xml:lang='und'>SIGSEGV</code>,
the intlist did an explicit exception,
so there is not much difference.
Of course,
a check for valid pointers could be added here.</p>

<h2><a name="Functions"
>Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="void_intlist_mark(Interp_*i,_IntList_*l)"
><b><code lang='und' xml:lang='und'>void intlist_mark(Interp *i, IntList *l)</b></code></a></dt><p class="pad"></p>

<dd>Marks the list as live.</dd><p class="pad"></p>

<dt><a name="IntList_*_intlist_clone(Interp_*i,_IntList_*list)"
><b><code lang='und' xml:lang='und'>IntList *intlist_clone(Interp *i, IntList *list)</b></code></a></dt><p class="pad"></p>

<dd>Returns a clone of the list.</dd><p class="pad"></p>

<dt><a name="IntList_*_intlist_new(Interp_*i)"
><b><code lang='und' xml:lang='und'>IntList *intlist_new(Interp *i)</b></code></a></dt><p class="pad"></p>

<dd>Returns a new list.</dd><p class="pad"></p>

<dt><a name="INTVAL_intlist_length(Interp_*interpreter,_IntList_*list)"
><b><code lang='und' xml:lang='und'>INTVAL intlist_length(Interp *interpreter, IntList *list)</b></code></a></dt><p class="pad"></p>

<dd>Returns the length of the list.</dd><p class="pad"></p>

<dt><a name="void_intlist_assign(Interp_*i,_IntList_*l,_INTVAL_idx,_INTVAL_val)"
><b><code lang='und' xml:lang='und'>void intlist_assign(Interp *i, IntList *l, INTVAL idx, INTVAL val)</b></code></a></dt><p class="pad"></p>

<dd>Assigns &#60;val&#62; to the item at <code lang='und' xml:lang='und'>idx</code>.</dd><p class="pad"></p>

<dt><a name="void_intlist_push(Interp_*i,_IntList_*l,_INTVAL_val)"
><b><code lang='und' xml:lang='und'>void intlist_push(Interp *i, IntList *l, INTVAL val)</b></code></a></dt><p class="pad"></p>

<dd>Pushes <code lang='und' xml:lang='und'>val</code> on the end of the list.</dd><p class="pad"></p>

<dt><a name="void_intlist_unshift(Interp_*i,_IntList_**l,_INTVAL_val)"
><b><code lang='und' xml:lang='und'>void intlist_unshift(Interp *i, IntList **l, INTVAL val)</b></code></a></dt><p class="pad"></p>

<dd>Pushes <code lang='und' xml:lang='und'>val</code> on the front of the list.</dd><p class="pad"></p>

<dt><a name="INTVAL_intlist_pop(Interp_*i,_IntList_*l)"
><b><code lang='und' xml:lang='und'>INTVAL intlist_pop(Interp *i, IntList *l)</b></code></a></dt><p class="pad"></p>

<dd>Popping/shifting into a sparse hole returns 0.</dd><p class="pad"></p>

<dt><a name="INTVAL_intlist_shift(Interp_*i,_IntList_**l)"
><b><code lang='und' xml:lang='und'>INTVAL intlist_shift(Interp *i, IntList **l)</b></code></a></dt><p class="pad"></p>

<dd>Removes and returns the first item on the list.</dd><p class="pad"></p>

<dt><a name="INTVAL_intlist_get(Interp_*i,_IntList_*l,_INTVAL_idx)"
><b><code lang='und' xml:lang='und'>INTVAL intlist_get(Interp *i, IntList *l, INTVAL idx)</b></code></a></dt><p class="pad"></p>

<dd>Returns the item at <code lang='und' xml:lang='und'>idx</code>.</dd><p class="pad"></p>

<dt><a name="void_intlist_dump(FILE_*fp,_IntList_*list,_int_verbose)"
><b><code lang='und' xml:lang='und'>void intlist_dump(FILE *fp, IntList *list, int verbose)</b></code></a></dt><p class="pad"></p>

<dd>Prints out the list in human&#45;readable form.</dd><p class="pad"></p>
</dl>

<h1><a name="SEE_ALSO"
>SEE ALSO <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p><em lang='und' xml:lang='und'>include/parrot/intlist.h</em>,
<em lang='und' xml:lang='und'><a href="list.c.html">src/list.c</a></em> and <em lang='und' xml:lang='und'>include/parrot/list.h</em>.</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
