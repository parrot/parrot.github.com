<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
    <HEAD>
        <TITLE>Exceptions</TITLE>
        <LINK REL="stylesheet" TYPE="text/css"
            HREF="../../resources/perl.css"
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY>
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Exceptions</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../html/index.html">Contents</a> | <a href="../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>src/exceptions.c &#45; Exceptions</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>Define the internal interpreter exceptions.</p>

<ul>
<li>This is experimental code.</li><p class="pad"></p>

<li>The <code lang='und' xml:lang='und'>enum_class</code> of the Exception isn&#39;t fixed.</li><p class="pad"></p>

<li>The interface isn&#39;t fixed.</li><p class="pad"></p>

<li>Much of this may change in the future.</li><p class="pad"></p>
</ul>

<h2><a name="Functions"
>Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="void_internal_exception"
><b><code lang='und' xml:lang='und'>void internal_exception</b></code></a></dt><p class="pad"></p>

<dd>Signal a fatal exception.
This involves printing an error message to stderr,
and calling <code lang='und' xml:lang='und'>Parrot_exit</code> to invoke exit handlers and exit the process with the given exitcode.
No error handlers are used,
so it is not possible for Parrot bytecode to intercept a fatal error (cf.
<code lang='und' xml:lang='und'>real_exception</code>).
Furthermore,
no stack unwinding is done,
so the exit handlers run in the current dynamic environment.</dd><p class="pad"></p>

<dt><a name="void_do_panic"
><b><code lang='und' xml:lang='und'>void do_panic</b></code></a></dt><p class="pad"></p>

<dd>Panic handler.</dd><p class="pad"></p>

<dt><a name="void_push_exception"
><b><code lang='und' xml:lang='und'>void push_exception</b></code></a></dt><p class="pad"></p>

<dd>Add the exception handler on the stack.</dd><p class="pad"></p>

<dt><a name="static_void_run_cleanup_action"
><b><code lang='und' xml:lang='und'>static void run_cleanup_action</b></code></a></dt><p class="pad"></p>

<dd>Runs the sub PMC from the Stack_Entry_t pointer with an INTVAL arg of 0.
Used in <code lang='und' xml:lang='und'>Parrot_push_action</code>.</dd><p class="pad"></p>

<dt><a name="void_Parrot_push_action"
><b><code lang='und' xml:lang='und'>void Parrot_push_action</b></code></a></dt><p class="pad"></p>

<dd>Pushes an action handler onto the dynamic environment.</dd><p class="pad"></p>

<dt><a name="void_Parrot_push_mark"
><b><code lang='und' xml:lang='und'>void Parrot_push_mark</b></code></a></dt><p class="pad"></p>

<dd>Push a cleanup mark onto the dynamic environment.</dd><p class="pad"></p>

<dt><a name="void_Parrot_pop_mark"
><b><code lang='und' xml:lang='und'>void Parrot_pop_mark</b></code></a></dt><p class="pad"></p>

<dd>Pop items off the dynamic environment up to the mark.</dd><p class="pad"></p>

<dt><a name="static_PMC_*_find_exception_handler"
><b><code lang='und' xml:lang='und'>static PMC *find_exception_handler</b></code></a></dt><p class="pad"></p>

<dd>Find the exception handler for <code lang='und' xml:lang='und'>exception</code>.</dd><p class="pad"></p>

<dt><a name="INTVAL_count_exception_handlers"
><b><code lang='und' xml:lang='und'>INTVAL count_exception_handlers</b></code></a></dt><p class="pad"></p>

<dd>Return the number of exception handlers on the exeception handler stack.</dd><p class="pad"></p>

<dt><a name="PMC_*_get_exception_handler"
><b><code lang='und' xml:lang='und'>PMC *get_exception_handler</b></code></a></dt><p class="pad"></p>

<dd>Return an exception handler by index into the exeception handler stack.</dd><p class="pad"></p>

<dt><a name="PMC_*_get_all_exception_handlers"
><b><code lang='und' xml:lang='und'>PMC *get_all_exception_handlers</b></code></a></dt><p class="pad"></p>

<dd>Return an array of all exception handlers.</dd><p class="pad"></p>

<dt><a name="void_pop_exception"
><b><code lang='und' xml:lang='und'>void pop_exception</b></code></a></dt><p class="pad"></p>

<dd>Pops the topmost exception handler off the stack.</dd><p class="pad"></p>

<dt><a name="PMC*_new_c_exception_handler"
><b><code lang='und' xml:lang='und'>PMC *new_c_exception_handler</b></code></a></dt><p class="pad"></p>

<dd>Generate an exception handler,
that catches PASM level exceptions inside a C function.
This could be a separate class too,
for now just a private flag bit is set.</dd><p class="pad"></p>

<dt><a name="void_push_new_c_exception_handler"
><b><code lang='und' xml:lang='und'>void push_new_c_exception_handler</b></code></a></dt><p class="pad"></p>

<dd>Pushes an new C exception handler onto the stack.</dd><p class="pad"></p>

<dt><a name="opcode_t_*_throw_exception"
><b><code lang='und' xml:lang='und'>opcode_t *throw_exception</b></code></a></dt><p class="pad"></p>

<dd>Throw the exception.</dd><p class="pad"></p>

<dt><a name="opcode_t_*_rethrow_exception"
><b><code lang='und' xml:lang='und'>opcode_t *rethrow_exception</b></code></a></dt><p class="pad"></p>

<dd>Rethrow the exception.</dd><p class="pad"></p>

<dt><a name="void_rethrow_c_exception"
><b><code lang='und' xml:lang='und'>void rethrow_c_exception</b></code></a></dt><p class="pad"></p>

<dd>Return back to runloop,
assumes exception is still in todo (see RT#45915) and that this is called from within a handler setup with <code lang='und' xml:lang='und'>new_c_exception</code>.</dd><p class="pad"></p>

<dt><a name="static_opcode_t_*_create_exception"
><b><code lang='und' xml:lang='und'>static opcode_t *create_exception</b></code></a></dt><p class="pad"></p>

<dd>Create an exception.</dd><p class="pad"></p>

<dt><a name="size_t_handle_exception"
><b><code lang='und' xml:lang='und'>size_t handle_exception</b></code></a></dt><p class="pad"></p>

<dd>Handle an exception.</dd><p class="pad"></p>

<dt><a name="void_new_internal_exception"
><b><code lang='und' xml:lang='und'>void new_internal_exception</b></code></a></dt><p class="pad"></p>

<dd>Create a new internal exception buffer,
either by allocating it or by getting one from the free list.</dd><p class="pad"></p>

<dt><a name="void_free_internal_exception"
><b><code lang='und' xml:lang='und'>void free_internal_exception</b></code></a></dt><p class="pad"></p>

<dd>Place internal exception buffer back on the free list.</dd><p class="pad"></p>

<dt><a name="void_destroy_exception_list"
><b><code lang='und' xml:lang='und'>void destroy_exception_list</b></code></a></dt><p class="pad"></p>

<dd>Destroys (and frees the memory of) the exception buffers list and the associated exceptions free list for the specified interpreter.</dd><p class="pad"></p>

<dt><a name="void_really_destroy_exception_list"
><b><code lang='und' xml:lang='und'>void really_destroy_exception_list</b></code></a></dt><p class="pad"></p>

<dd>Takes a pointer to an exception (which had better be the last one in the list).
Walks back through the list,
freeing the memory of each one,
until it encounters NULL.
Used by <code lang='und' xml:lang='und'>destroy_exception_list</code>.</dd><p class="pad"></p>

<dt><a name="void_do_exception"
><b><code lang='und' xml:lang='und'>void do_exception</b></code></a></dt><p class="pad"></p>

<dd>Called from interrupt code.
Does a <code lang='und' xml:lang='und'>longjmp</code> in front of the runloop,
which calls <code lang='und' xml:lang='und'>handle_exception()</code>,
returning the handler address where execution then resumes.</dd><p class="pad"></p>

<dt><a name="void_do_str_exception"
><b><code lang='und' xml:lang='und'>void do_str_exception</b></code></a></dt><p class="pad"></p>

<dt><a name="void_do_pmc_exception"
><b><code lang='und' xml:lang='und'>void do_pmc_exception</b></code></a></dt><p class="pad"></p>

<dd>*/</dd><p class="pad"></p>

<dd>PARROT_API PARROT_DOES_NOT_RETURN void do_str_exception(PARROT_INTERP,
ARGIN(STRING *msg)) { Parrot_exception * const the_exception = interp&#45;&#62;exceptions;</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    the_exception&#45;&#62;error = E_RuntimeError;
    the_exception&#45;&#62;severity = EXCEPT_error;
    the_exception&#45;&#62;msg = msg;
    the_exception&#45;&#62;resume = NULL;
    longjmp(the_exception&#45;&#62;destination, 1);
}</pre>

<dd>PARROT_API PARROT_DOES_NOT_RETURN void do_pmc_exception(PARROT_INTERP, ARGIN(PMC *msg)) { Parrot_exception * const the_exception = interp&#45;&#62;exceptions;</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    the_exception&#45;&#62;error = E_RuntimeError;
    the_exception&#45;&#62;severity = EXCEPT_error;
    the_exception&#45;&#62;msg = VTABLE_get_string(interp, msg);;
    the_exception&#45;&#62;resume = NULL;
    longjmp(the_exception&#45;&#62;destination, 1);
}</pre>

<dd>PARROT_API PARROT_DOES_NOT_RETURN void do_exception(PARROT_INTERP, INTVAL severity, long error) { Parrot_exception * const the_exception = interp&#45;&#62;exceptions;</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    the_exception&#45;&#62;error = error;
    the_exception&#45;&#62;severity = severity;
    the_exception&#45;&#62;msg = NULL;
    the_exception&#45;&#62;resume = NULL;
    longjmp(the_exception&#45;&#62;destination, 1);
}</pre>

<dd>/*</dd><p class="pad"></p>

<dt><a name="void_real_exception"
><b><code lang='und' xml:lang='und'>void real_exception</b></code></a></dt><p class="pad"></p>

<dd>Throws a real exception, with an error message constructed from the format string and arguments. <code lang='und' xml:lang='und'>ret_addr</code> is the address from which to resume, if some handler decides that is appropriate, or zero to make the error non&#45;resumable. <code lang='und' xml:lang='und'>exitcode</code> is a <code lang='und' xml:lang='und'>exception_type_enum</code> value.</dd><p class="pad"></p>

<dd>See also <code lang='und' xml:lang='und'>internal_exception()</code>, which signals fatal errors, and <code lang='und' xml:lang='und'>throw_exception</code>, which calls the handler.</dd><p class="pad"></p>

<dt><a name="void_Parrot_init_exceptions"
><b><code lang='und' xml:lang='und'>void Parrot_init_exceptions</b></code></a></dt><p class="pad"></p>

<dd>Create exception objects.</dd><p class="pad"></p>

<dt><a name="void_Parrot_assert"
><b><code lang='und' xml:lang='und'>void Parrot_assert</b></code></a></dt><p class="pad"></p>

<dd>A better version of assert() that gives a backtrace.</dd><p class="pad"></p>

<dt><a name="void_Parrot_confess"
><b><code lang='und' xml:lang='und'>void Parrot_confess</b></code></a></dt><p class="pad"></p>

<dd>Prints a backtrace and message for a failed assertion.</dd><p class="pad"></p>

<dt><a name="void_Parrot_print_backtrace"
><b><code lang='und' xml:lang='und'>void Parrot_print_backtrace</b></code></a></dt><p class="pad"></p>

<dd>Displays the primrose path to disaster, (the stack frames leading up to the abort). Used by <code lang='und' xml:lang='und'>Parrot_confess</code>.</dd><p class="pad"></p>
</dl>

<h1><a name="SEE_ALSO"
>SEE ALSO <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p><em lang='und' xml:lang='und'>include/parrot/exceptions.h</em>.</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../resources/parrot_small.png"
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
