<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
    <HEAD>
        <TITLE>Thread handling stuff</TITLE>
        <LINK REL="stylesheet" TYPE="text/css"
            HREF="../../resources/perl.css"
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY>
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Thread handling stuff</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../html/index.html">Contents</a> | <a href="../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>src/thread.c &#45; Thread handling stuff</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>Threads are created by creating new <code lang='und' xml:lang='und'>ParrotInterpreter</code> objects.</p>

<h2><a name="Functions"
>Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="static_PMC_*_make_local_copy"
><b><code lang='und' xml:lang='und'>static PMC *make_local_copy</b></code></a></dt><p class="pad"></p>

<dd>Creates a local copy of the PMC if necessary.
(No copy is made if it is marked shared.) This includes workarounds for Parrot_clone() not doing the Right Thing with subroutines (specifically,
code segments aren&#39;t preserved and it is difficult to do so as long as Parrot_clone() depends on freezing).</dd><p class="pad"></p>

<dt><a name="static_Shared_gc_info_*_get_pool"
><b><code lang='und' xml:lang='und'>static Shared_gc_info *get_pool</b></code></a></dt><p class="pad"></p>

<dd>Gets the shared gc information.
For now this is global data; ideally it will become something other than a static variable.
If everything uses this function,
it will be easier to change.</dd><p class="pad"></p>

<dt><a name="void_pt_free_pool"
><b><code lang='und' xml:lang='und'>void pt_free_pool</b></code></a></dt><p class="pad"></p>

<dd>Frees the shared GC information.
This clears any global data when joining all threads at parent interpreter destruction.</dd><p class="pad"></p>

<dt><a name="static_PMC_*_make_local_args_copy"
><b><code lang='und' xml:lang='und'>static PMC *make_local_args_copy</b></code></a></dt><p class="pad"></p>

<dd>Make a local copy of the corresponding array of arguments.</dd><p class="pad"></p>

<dt><a name="PMC_*_pt_shared_fixup"
><b><code lang='und' xml:lang='und'>PMC *pt_shared_fixup</b></code></a></dt><p class="pad"></p>

<dd>Modifies a PMC to be sharable.
Right now,
reassigns the vtable to one owned by some master interpreter,
so the PMC can be safely reused after thread death.</dd><p class="pad"></p>

<dd>In the future the PMC returned might be different than the one passed,
e.g.,
if we need to reallocate the PMC in a different interpreter.</dd><p class="pad"></p>

<dt><a name="static_void_pt_thread_signal"
><b><code lang='und' xml:lang='und'>static void pt_thread_signal</b></code></a></dt><p class="pad"></p>

<dd>Wakes up an <code lang='und' xml:lang='und'>interp</code> which should have called pt_thread_wait().</dd><p class="pad"></p>

<dt><a name="void_pt_thread_wait_with"
><b><code lang='und' xml:lang='und'>void pt_thread_wait_with</b></code></a></dt><p class="pad"></p>

<dd>Waits for this interpreter to be signalled through its condition variable,
dealing properly with GC issues.
<code lang='und' xml:lang='und'>*mutex</code> is assumed locked on entry and will be locked on exit from this function.
If a GC run occurs in the middle of this function,
then a spurious wakeup may occur.</dd><p class="pad"></p>

<dt><a name="static_void_pt_thread_wait"
><b><code lang='und' xml:lang='und'>static void pt_thread_wait</b></code></a></dt><p class="pad"></p>

<dd>Waits for a signal,
handling GC matters correctly.
<code lang='und' xml:lang='und'>interpreter_array_mutex</code> is assumed held.
Spurious wakeups may occur.</dd><p class="pad"></p>

<dt><a name="static_void*_thread_func"
><b><code lang='und' xml:lang='und'>static void *thread_func</b></code></a></dt><p class="pad"></p>

<dd>The actual thread function.</dd><p class="pad"></p>
</dl>

<h2><a name="Helper_functions_used_also_for_running_plain_interpreters"
>Helper functions used also for running plain interpreters <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="void_pt_clone_code"
><b><code lang='und' xml:lang='und'>void pt_clone_code</b></code></a></dt><p class="pad"></p>

<dd>Copies/clones the packfile/code from interpreter <code lang='und' xml:lang='und'>s</code> to <code lang='und' xml:lang='und'>d</code>.
All resources are created in <code lang='und' xml:lang='und'>d</code>.</dd><p class="pad"></p>

<dt><a name="static_void_pt_ns_clone"
><b><code lang='und' xml:lang='und'>static void pt_ns_clone</b></code></a></dt><p class="pad"></p>

<dd>Clones all globals from <code lang='und' xml:lang='und'>s</code> to <code lang='und' xml:lang='und'>d</code>.</dd><p class="pad"></p>

<dt><a name="void_pt_clone_globals"
><b><code lang='und' xml:lang='und'>void pt_clone_globals</b></code></a></dt><p class="pad"></p>

<dd>Copies the global namespace when cloning a new interpreter.</dd><p class="pad"></p>

<dt><a name="void_pt_thread_prepare_for_run"
><b><code lang='und' xml:lang='und'>void pt_thread_prepare_for_run</b></code></a></dt><p class="pad"></p>

<dd>Sets up a new thread to run.</dd><p class="pad"></p>
</dl>

<h2><a name="ParrotThread_methods"
>ParrotThread methods <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="PMC_*_pt_transfer_sub"
><b><code lang='und' xml:lang='und'>PMC *pt_transfer_sub</b></code></a></dt><p class="pad"></p>

<dd>Clones the sub so that it&#39;s suitable for the other interpreter.</dd><p class="pad"></p>

<dt><a name="int_pt_thread_run"
><b><code lang='und' xml:lang='und'>int pt_thread_run</b></code></a></dt><p class="pad"></p>

<dd>Runs the <code lang='und' xml:lang='und'>*sub</code> PMC in a separate thread using the interpreter in <code lang='und' xml:lang='und'>*dest_interp</code>.</dd><p class="pad"></p>

<dd><code lang='und' xml:lang='und'>arg</code> should be an array of arguments for the subroutine.</dd><p class="pad"></p>

<dt><a name="int_pt_thread_run_1"
><b><code lang='und' xml:lang='und'>int pt_thread_run_1</b></code></a></dt><p class="pad"></p>

<dd>Runs a thread that shares nothing and does not communicate with the other interpreter.</dd><p class="pad"></p>

<dt><a name="int_pt_thread_run_2"
><b><code lang='und' xml:lang='und'>int pt_thread_run_2</b></code></a></dt><p class="pad"></p>

<dd>Runs an interpreter in a thread with no shared variables,
but which communicates by sending messages.</dd><p class="pad"></p>

<dt><a name="int_pt_thread_run_3"
><b><code lang='und' xml:lang='und'>int pt_thread_run_3</b></code></a></dt><p class="pad"></p>

<dd>Runs an interpreter in a thread,
allowing shared variables and using a thread pool.</dd><p class="pad"></p>

<dt><a name="void_pt_thread_yield"
><b><code lang='und' xml:lang='und'>void pt_thread_yield</b></code></a></dt><p class="pad"></p>

<dd>Relinquishes hold on the processor.</dd><p class="pad"></p>

<dt><a name="static_Parrot_Interp_pt_check_tid"
><b><code lang='und' xml:lang='und'>static Parrot_Interp pt_check_tid</b></code></a></dt><p class="pad"></p>

<dd>Helper function.
Checks if the given thread ID is valid.
The caller holds the mutex.
Returns the interpreter for <code lang='und' xml:lang='und'>tid</code>.</dd><p class="pad"></p>

<dt><a name="static_void_mutex_unlock"
><b><code lang='und' xml:lang='und'>static void mutex_unlock</b></code></a></dt><p class="pad"></p>

<dd>Unlocks the mutex <code lang='und' xml:lang='und'>*arg</code>.</dd><p class="pad"></p>

<dt><a name="static_int_is_suspended_for_gc"
><b><code lang='und' xml:lang='und'>static int is_suspended_for_gc</b></code></a></dt><p class="pad"></p>

<dd>Returns true iff <code lang='und' xml:lang='und'>interp</code> is suspended for a global GC run.
Be sure to hold <code lang='und' xml:lang='und'>interpreter_array_mutex</code>.</dd><p class="pad"></p>

<dt><a name="static_QUEUE_ENTRY_*_remove_queued_suspend_gc"
><b><code lang='und' xml:lang='und'>static QUEUE_ENTRY *remove_queued_suspend_gc</b></code></a></dt><p class="pad"></p>

<dd>Removes an event requesting that the interpreter suspend itself for a garbage&#45;collection run from the event queue.</dd><p class="pad"></p>

<dt><a name="static_int_pt_gc_count_threads"
><b><code lang='und' xml:lang='und'>static int pt_gc_count_threads</b></code></a></dt><p class="pad"></p>

<dd>Returns the number of active threads in the system (running or suspended).
Be sure to hold <code lang='und' xml:lang='und'>interpreter_array_mutex</code>.</dd><p class="pad"></p>

<dt><a name="static_void_pt_gc_wait_for_stage"
><b><code lang='und' xml:lang='und'>static void pt_gc_wait_for_stage</b></code></a></dt><p class="pad"></p>

<dd>Waits until all threads have reached the desired stage.
Takes an interpreter,
starting stage and ending stage as arguments.
Updates the thread information.
Used in <code lang='und' xml:lang='und'>pt_DOD_start_mark</code> and <code lang='und' xml:lang='und'>pt_DOD_stop_mark</code>.</dd><p class="pad"></p>

<dt><a name="static_void_pt_gc_wakeup_check"
><b><code lang='und' xml:lang='und'>static void pt_gc_wakeup_check</b></code></a></dt><p class="pad"></p>

<dd>Checks if it&#39;s necessary to wake threads to perform garbage collection.
This is called after thread death.
Be sure to hold <code lang='und' xml:lang='und'>interpreter_array_mutex</code>.</dd><p class="pad"></p>

<dt><a name="static_void_pt_suspend_one_for_gc"
><b><code lang='und' xml:lang='und'>static void pt_suspend_one_for_gc</b></code></a></dt><p class="pad"></p>

<dd>Suspends a single interpreter for GC.
Be sure to hold <code lang='und' xml:lang='und'>interpreter_array_mutex</code>.</dd><p class="pad"></p>

<dt><a name="static_void_pt_suspend_all_for_gc"
><b><code lang='und' xml:lang='und'>static void pt_suspend_all_for_gc</b></code></a></dt><p class="pad"></p>

<dd>Notifies all threads to perform a GC run.</dd><p class="pad"></p>

<dt><a name="void_pt_suspend_self_for_gc"
><b><code lang='und' xml:lang='und'>void pt_suspend_self_for_gc</b></code></a></dt><p class="pad"></p>

<dd>Suspends this thread for a full GC run.</dd><p class="pad"></p>

<dd>XXX FIXME &#45;&#45; if GC is blocked,
we need to do a GC run as soon as it becomes unblocked.</dd><p class="pad"></p>

<dt><a name="PMC*_pt_thread_join"
><b><code lang='und' xml:lang='und'>PMC *pt_thread_join</b></code></a></dt><p class="pad"></p>

<dd>Joins (by waiting for) a joinable thread.</dd><p class="pad"></p>

<dt><a name="void_pt_join_threads"
><b><code lang='und' xml:lang='und'>void pt_join_threads</b></code></a></dt><p class="pad"></p>

<dd>Possibly waits for other running threads.
This is called when destroying <code lang='und' xml:lang='und'>interp</code>.</dd><p class="pad"></p>

<dt><a name="static_Parrot_Interp_detach"
><b><code lang='und' xml:lang='und'>static Parrot_Interp detach</b></code></a></dt><p class="pad"></p>

<dd>Helper for detach and kill.</dd><p class="pad"></p>

<dd>Returns the interpreter,
if it didn&#39;t finish yet.</dd><p class="pad"></p>

<dt><a name="void_pt_thread_detach"
><b><code lang='und' xml:lang='und'>void pt_thread_detach</b></code></a></dt><p class="pad"></p>

<dd>Detaches the thread,
making it non&#45;joinable.</dd><p class="pad"></p>

<dt><a name="void_pt_thread_kill"
><b><code lang='und' xml:lang='und'>void pt_thread_kill</b></code></a></dt><p class="pad"></p>

<dd>Kills the thread.</dd><p class="pad"></p>
</dl>

<h2><a name="Threaded_interpreter_book&#45;keeping"
>Threaded interpreter book&#45;keeping <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="void_pt_add_to_interpreters"
><b><code lang='und' xml:lang='und'>void pt_add_to_interpreters</b></code></a></dt><p class="pad"></p>

<dd>Stores the given interpreter in the array of all interpreters.
Be sure to hold <code lang='und' xml:lang='und'>interpreter_array_mutex</code>.</dd><p class="pad"></p>
</dl>

<h2><a name="DOD_Synchronization_Functions"
>DOD Synchronization Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="void_pt_DOD_start_mark"
><b><code lang='und' xml:lang='und'>void pt_DOD_start_mark</b></code></a></dt><p class="pad"></p>

<dd>Record that the mark phase of DOD is about to begin.
In the presence of shared PMCs,
we can only run one DOD run at a time because <code lang='und' xml:lang='und'>PMC&#45;&#62;next_for_GC</code> may be changed.</dd><p class="pad"></p>

<dd><code lang='und' xml:lang='und'>flags</code> are the DOD flags.
We check if we need to collect shared objects or not.</dd><p class="pad"></p>

<dd>TODO &#45; Have a count of shared PMCs and check it during DOD.</dd><p class="pad"></p>

<dd>TODO &#45; Evaluate if a interpreter lock is cheaper when <code lang='und' xml:lang='und'>dod_mark_ptr</code> is updated.</dd><p class="pad"></p>

<dt><a name="void_pt_DOD_mark_root_finished"
><b><code lang='und' xml:lang='und'>void pt_DOD_mark_root_finished</b></code></a></dt><p class="pad"></p>

<dd>Records that DOD has finished for the root set.
UNIMPLEMENTED</dd><p class="pad"></p>

<dt><a name="void_pt_DOD_stop_mark"
><b><code lang='und' xml:lang='und'>void pt_DOD_stop_mark</b></code></a></dt><p class="pad"></p>

<dd>Records that the mark phase of DOD has completed.</dd><p class="pad"></p>

<dt><a name="void_Parrot_shared_DOD_block"
><b><code lang='und' xml:lang='und'>void Parrot_shared_DOD_block</b></code></a></dt><p class="pad"></p>

<dd>Blocks stop&#45;the&#45;world DOD runs.</dd><p class="pad"></p>

<dt><a name="void_Parrot_shared_DOD_unblock"
><b><code lang='und' xml:lang='und'>void Parrot_shared_DOD_unblock</b></code></a></dt><p class="pad"></p>

<dd>Unblocks stop&#45;the&#45;world DOD runs.</dd><p class="pad"></p>
</dl>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../resources/parrot_small.png"
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
