<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
    <HEAD>
        <TITLE>Stack handling routines for Parrot</TITLE>
        <LINK REL="stylesheet" TYPE="text/css"
            HREF="../../resources/perl.css"
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY>
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Stack handling routines for Parrot</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../html/index.html">Contents</a> | <a href="../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>src/stacks.c &#45; Stack handling routines for Parrot</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>The stack is stored as a linked list of chunks (<code lang='und' xml:lang='und'>Stack_Chunk</code>),
where each chunk has room for one entry.</p>

<h2><a name="Functions"
>Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="Stack_Chunk_t_*_new_stack"
><b><code lang='und' xml:lang='und'>Stack_Chunk_t *new_stack</b></code></a></dt><p class="pad"></p>

<dd>Create a new stack and name it.
<code lang='und' xml:lang='und'>stack&#45;&#62;name</code> is used for debugging/error reporting.</dd><p class="pad"></p>

<dt><a name="void_mark_stack"
><b><code lang='und' xml:lang='und'>void mark_stack</b></code></a></dt><p class="pad"></p>

<dd>Mark entries in a stack structure during DOD.</dd><p class="pad"></p>

<dt><a name="void_stack_destroy"
><b><code lang='und' xml:lang='und'>void stack_destroy</b></code></a></dt><p class="pad"></p>

<dd>stack_destroy() doesn&#39;t need to do anything,
since GC does it all.</dd><p class="pad"></p>

<dt><a name="size_t_stack_height"
><b><code lang='und' xml:lang='und'>size_t stack_height</b></code></a></dt><p class="pad"></p>

<dd>Returns the height of the stack.
The maximum &#34;depth&#34; is height &#45; 1.</dd><p class="pad"></p>

<dt><a name="Stack_Entry_t_*_stack_entry"
><b><code lang='und' xml:lang='und'>Stack_Entry_t *stack_entry</b></code></a></dt><p class="pad"></p>

<dd>If <code lang='und' xml:lang='und'>depth &#62;= 0</code>,
return the entry at that depth from the top of the stack,
with 0 being the top entry.
If <code lang='und' xml:lang='und'>depth &#60; 0</code>,
then return the entry <code lang='und' xml:lang='und'>|depth|</code> entries from the bottom of the stack.
Returns <code lang='und' xml:lang='und'>NULL</code> if <code lang='und' xml:lang='und'>|depth| </code> number&#62; of entries in stack.</dd><p class="pad"></p>

<dt><a name="void_rotate_entries"
><b><code lang='und' xml:lang='und'>void rotate_entries</b></code></a></dt><p class="pad"></p>

<dd>Rotate the top N entries by one.
If <code lang='und' xml:lang='und'>N &#62; 0</code>,
the rotation is bubble up,
so the top most element becomes the Nth element.
If <code lang='und' xml:lang='und'>N &#60; 0</code>,
the rotation is bubble down,
so that the Nth element becomes the top most element.</dd><p class="pad"></p>

<dd>*/</dd><p class="pad"></p>

<dd>PARROT_API void rotate_entries(PARROT_INTERP,
ARGMOD(Stack_Chunk_t **stack_p),
INTVAL num_entries) { Stack_Chunk_t * const stack = *stack_p;</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    if (num_entries &#62;= &#45;1 &#38;&#38; num_entries &#60;= 1) {
        return;
    }

    if (num_entries &#60; 0) {
        INTVAL i;
        Stack_Entry_t temp;
        INTVAL depth;

        num_entries = &#45;num_entries;
        depth = num_entries &#45; 1;

        if (stack_height(interp, stack) &#60; (size_t)num_entries) {
            real_exception(interp, NULL, ERROR_STACK_SHALLOW, &#34;Stack too shallow!&#34;);
        }

        /* XXX Dereferencing stack_entry here is a cavalcade of danger */
        temp = *stack_entry(interp, stack, depth);
        for (i = depth; i &#62; 0; i&#45;&#45;) {
            *stack_entry(interp, stack, i) =
                *stack_entry(interp, stack, i &#45; 1);
        }

        *stack_entry(interp, stack, 0) = temp;
    }
    else {
        INTVAL i;
        Stack_Entry_t temp;
        INTVAL depth = num_entries &#45; 1;

        if (stack_height(interp, stack) &#60; (size_t)num_entries) {
            real_exception(interp, NULL, ERROR_STACK_SHALLOW, &#34;Stack too shallow!&#34;);
        }
        /* XXX Dereferencing stack_entry here is a cavalcade of danger */
        temp = *stack_entry(interp, stack, 0);
        for (i = 0; i &#60; depth; i++) {
            *stack_entry(interp, stack, i) =
                *stack_entry(interp, stack, i + 1);
        }

        *stack_entry(interp, stack, depth) = temp;
    }
}</pre>

<dd>/*</dd><p class="pad"></p>

<dt><a name="void_stack_push"
><b><code lang='und' xml:lang='und'>void stack_push</b></code></a></dt><p class="pad"></p>

<dd>Push something on the generic stack.</dd><p class="pad"></p>

<dd>Note that the cleanup pointer, if non&#45;<code lang='und' xml:lang='und'>NULL</code>, points to a routine that&#39;ll be called when the entry is removed from the stack. This is handy for those cases where you need some sort of activity to take place when an entry is removed, such as when you push a lexical lock onto the call stack, or localize (or tempify, or whatever we&#39;re calling it) variable or something.</dd><p class="pad"></p>

<dd>*/</dd><p class="pad"></p>

<dd>PARROT_API void stack_push(PARROT_INTERP, ARGMOD(Stack_Chunk_t **stack_p), ARGIN(void *thing), Stack_entry_type type, NULLOK(Stack_cleanup_method cleanup)) { Stack_Entry_t * const entry = (Stack_Entry_t *)stack_prepare_push(interp, stack_p);</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    /* Remember the type */
    entry&#45;&#62;entry_type = type;
    /* Remember the cleanup function */
    entry&#45;&#62;cleanup = cleanup;
    /* Store our thing */
    switch (type) {
        case STACK_ENTRY_INT:
        case STACK_ENTRY_MARK:
            UVal_int(entry&#45;&#62;entry) = *(INTVAL *)thing;
            break;
        case STACK_ENTRY_FLOAT:
            UVal_num(entry&#45;&#62;entry) = *(FLOATVAL *)thing;
            break;
        case STACK_ENTRY_ACTION:
        case STACK_ENTRY_PMC:
            UVal_pmc(entry&#45;&#62;entry) = (PMC *)thing;
            break;
        case STACK_ENTRY_STRING:
            UVal_str(entry&#45;&#62;entry) = (STRING *)thing;
            break;
        case STACK_ENTRY_POINTER:
        case STACK_ENTRY_DESTINATION:
            UVal_ptr(entry&#45;&#62;entry) = thing;
            break;
        default:
            real_exception(interp, NULL, ERROR_BAD_STACK_TYPE,
                    &#34;Invalid Stack_Entry_type!&#34;);
    }
}</pre>

<dd>/*</dd><p class="pad"></p>

<dt><a name="void_*_stack_pop"
><b><code lang='und' xml:lang='und'>void *stack_pop</b></code></a></dt><p class="pad"></p>

<dd>Pop off an entry and return a pointer to the contents.</dd><p class="pad"></p>

<dd>*/</dd><p class="pad"></p>

<dd>PARROT_API PARROT_CAN_RETURN_NULL void * stack_pop(PARROT_INTERP, ARGMOD(Stack_Chunk_t **stack_p), ARGOUT_NULLOK(void *where), Stack_entry_type type) { Stack_Entry_t * const entry = (Stack_Entry_t *)stack_prepare_pop(interp, stack_p);</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    /* Types of 0 mean we don&#39;t care */
    if (type &#38;&#38; entry&#45;&#62;entry_type != type) {
        real_exception(interp, NULL, ERROR_BAD_STACK_TYPE,
                           &#34;Wrong type on top of stack!\n&#34;);
    }

    /* Cleanup routine? */
    if (entry&#45;&#62;cleanup != STACK_CLEANUP_NULL)
        (*entry&#45;&#62;cleanup) (interp, entry);

    /* Sometimes the caller doesn&#39;t care what the value was */
    if (where == NULL)
        return NULL;

    /* Snag the value */
    switch (type) {
    case STACK_ENTRY_MARK:
    case STACK_ENTRY_INT:
        *(INTVAL *)where   = UVal_int(entry&#45;&#62;entry);
        break;
    case STACK_ENTRY_FLOAT:
        *(FLOATVAL *)where = UVal_num(entry&#45;&#62;entry);
        break;
    case STACK_ENTRY_ACTION:
    case STACK_ENTRY_PMC:
        *(PMC **)where     = UVal_pmc(entry&#45;&#62;entry);
        break;
    case STACK_ENTRY_STRING:
        *(STRING **)where  = UVal_str(entry&#45;&#62;entry);
        break;
    case STACK_ENTRY_POINTER:
    case STACK_ENTRY_DESTINATION:
        *(void **)where    = UVal_ptr(entry&#45;&#62;entry);
        break;
    default:
        real_exception(interp, NULL, ERROR_BAD_STACK_TYPE,
                           &#34;Wrong type on top of stack!\n&#34;);
    }

    return where;
}</pre>

<dd>/*</dd><p class="pad"></p>

<dt><a name="void_*_pop_dest"
><b><code lang='und' xml:lang='und'>void *pop_dest</b></code></a></dt><p class="pad"></p>

<dd>Pop off a destination entry and return a pointer to the contents.</dd><p class="pad"></p>

<dt><a name="void_*_stack_peek"
><b><code lang='und' xml:lang='und'>void *stack_peek</b></code></a></dt><p class="pad"></p>

<dd>Peek at stack and return pointer to entry and the type of the entry.</dd><p class="pad"></p>

<dt><a name="Stack_entry_type_get_entry_type"
><b><code lang='und' xml:lang='und'>Stack_entry_type get_entry_type</b></code></a></dt><p class="pad"></p>

<dd>Returns the stack entry type of <code lang='und' xml:lang='und'>entry</code>.</dd><p class="pad"></p>

<dt><a name="void_Parrot_dump_dynamic_environment"
><b><code lang='und' xml:lang='und'>void Parrot_dump_dynamic_environment</b></code></a></dt><p class="pad"></p>

<dd>Print a representation of the dynamic stack to the standard error (using <code lang='und' xml:lang='und'>PIO_eprintf</code>). This is used only temporarily for debugging.</dd><p class="pad"></p>
</dl>

<h1><a name="SEE_ALSO"
>SEE ALSO <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p><em lang='und' xml:lang='und'>include/parrot/stacks.h</em>, <em lang='und' xml:lang='und'>include/parrot/enums.h</em>, and <em lang='und' xml:lang='und'><a href="stack_common.c.html">src/stack_common.c</a></em></p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../resources/parrot_small.png"
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
