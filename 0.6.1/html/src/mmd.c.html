<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
    <HEAD>
        <TITLE>Multimethod dispatch for binary opcode functions</TITLE>
        <LINK REL="stylesheet" TYPE="text/css"
            HREF="../../resources/perl.css"
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY>
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Multimethod dispatch for binary opcode functions</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../html/index.html">Contents</a> | <a href="../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>src/mmd.c &#45; Multimethod dispatch for binary opcode functions</p>

<h1><a name="SYNOPSIS"
>SYNOPSIS <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>This system is set up to handle type&#45;based dispatching for binary (i.e.
two&#45;arg) functions.
This includes,
though isn&#39;t necessarily limited to,
binary operators such as addition or subtraction.</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>The MMD system is straightforward,
and currently must be explicitly invoked,
for example by a vtable function.
(We may reserve the right to use MMD in all circumstances,
but currently do not).</p>

<h2><a name="API"
>API <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>For the purposes of the API,
each MMD&#45;able function is assigned a unique number which is used to find the correct function table.
This is the <code lang='und' xml:lang='und'>func_num</code> parameter in the following functions.
While Parrot isn&#39;t restricted to a predefined set of functions,
it <i>does</i> set things up so that all the binary vtable functions have a MMD table preinstalled for them,
with default behaviour.</p>

<h2><a name="Remarks"
>Remarks <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p><code lang='und' xml:lang='und'>binop_mmd_funcs&#45;&#62;x</code> and <code lang='und' xml:lang='und'>&#45;&#62;y</code> are table sizes not highest type in table.</p>

<h2><a name="Functions"
>Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="static_void_dump_mmd"
><b><code lang='und' xml:lang='und'>static void dump_mmd</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="funcptr_t_get_mmd_dispatch_type"
><b><code lang='und' xml:lang='und'>funcptr_t get_mmd_dispatch_type</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_funcptr_t_get_mmd_dispatcher"
><b><code lang='und' xml:lang='und'>static funcptr_t get_mmd_dispatcher</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_PMC_*_mmd_deref"
><b><code lang='und' xml:lang='und'>static PMC *mmd_deref</b></code></a></dt><p class="pad"></p>

<dd>If <code lang='und' xml:lang='und'>value</code> is a reference&#45;like PMC,
dereference it so we can make an MMD call on the &#39;real&#39; value.</dd><p class="pad"></p>

<dt><a name="static_void_mmd_ensure_writable"
><b><code lang='und' xml:lang='und'>static void mmd_ensure_writable</b></code></a></dt><p class="pad"></p>

<dd>Make sure <code lang='und' xml:lang='und'>pmc</code> is writable enough for <code lang='und' xml:lang='und'>function</code>.</dd><p class="pad"></p>

<dt><a name="PMC*_mmd_dispatch_p_ppp"
><b><code lang='und' xml:lang='und'>PMC *mmd_dispatch_p_ppp</b></code></a></dt><p class="pad"></p>

<dd>Dispatch to a multimethod that returns a PMC.
<code lang='und' xml:lang='und'>left</code>,
<code lang='und' xml:lang='und'>right</code>,
and <code lang='und' xml:lang='und'>dest</code> are all PMC pointers,
while <code lang='und' xml:lang='und'>func_num</code> is the MMD table that should be used to do the dispatching.
If the <code lang='und' xml:lang='und'>dest</code> pointer is NULL,
it dispatches two a two&#45;argument function that returns a new <code lang='und' xml:lang='und'>dest</code> always.</dd><p class="pad"></p>

<dd>The MMD system will figure out which function should be called based on the types of <code lang='und' xml:lang='und'>left</code> and <code lang='und' xml:lang='und'>right</code> and call it,
passing in <code lang='und' xml:lang='und'>left</code>,
<code lang='und' xml:lang='und'>right</code>,
and possibly <code lang='und' xml:lang='und'>dest</code> like any other binary vtable function.</dd><p class="pad"></p>

<dt><a name="PMC*_mmd_dispatch_p_pip"
><b><code lang='und' xml:lang='und'>PMC *mmd_dispatch_p_pip</b></code></a></dt><p class="pad"></p>

<dd>Like <code lang='und' xml:lang='und'>mmd_dispatch_p_ppp</code>,
right argument is a native INTVAL.</dd><p class="pad"></p>

<dt><a name="PMC*_mmd_dispatch_p_pnp"
><b><code lang='und' xml:lang='und'>PMC *mmd_dispatch_p_pnp</b></code></a></dt><p class="pad"></p>

<dd>Like <code lang='und' xml:lang='und'>mmd_dispatch_p_ppp</code>,
right argument is a native FLOATVAL.</dd><p class="pad"></p>

<dt><a name="PMC*_mmd_dispatch_p_psp"
><b><code lang='und' xml:lang='und'>PMC *mmd_dispatch_p_psp</b></code></a></dt><p class="pad"></p>

<dd>Like <code lang='und' xml:lang='und'>mmd_dispatch_p_ppp</code>,
right argument is a native STRING *.</dd><p class="pad"></p>

<dt><a name="void_mmd_dispatch_v_pp"
><b><code lang='und' xml:lang='und'>void mmd_dispatch_v_pp</b></code></a></dt><p class="pad"></p>

<dd>Inplace dispatch function for <code lang='und' xml:lang='und'>left &#60;op=&#62; right</code>.</dd><p class="pad"></p>

<dt><a name="void_mmd_dispatch_v_pi"
><b><code lang='und' xml:lang='und'>void mmd_dispatch_v_pi</b></code></a></dt><p class="pad"></p>

<dd>Inplace dispatch function for <code lang='und' xml:lang='und'>left &#60;op=&#62; right</code>.</dd><p class="pad"></p>

<dt><a name="void_mmd_dispatch_v_pn"
><b><code lang='und' xml:lang='und'>void mmd_dispatch_v_pn</b></code></a></dt><p class="pad"></p>

<dd>Inplace dispatch function for <code lang='und' xml:lang='und'>left &#60;op=&#62; right</code>.</dd><p class="pad"></p>

<dt><a name="void_mmd_dispatch_v_ps"
><b><code lang='und' xml:lang='und'>void mmd_dispatch_v_ps</b></code></a></dt><p class="pad"></p>

<dd>Inplace dispatch function for <code lang='und' xml:lang='und'>left &#60;op=&#62; right</code>.</dd><p class="pad"></p>

<dt><a name="INTVAL_mmd_dispatch_i_pp"
><b><code lang='und' xml:lang='und'>INTVAL mmd_dispatch_i_pp</b></code></a></dt><p class="pad"></p>

<dd>Like <code lang='und' xml:lang='und'>mmd_dispatch_p_ppp()</code>,
only it returns an <code lang='und' xml:lang='und'>INTVAL</code>.
This is used by MMD compare functions.</dd><p class="pad"></p>

<dt><a name="void_mmd_add_function"
><b><code lang='und' xml:lang='und'>void mmd_add_function</b></code></a></dt><p class="pad"></p>

<dd>Add a new binary MMD function to the list of functions the MMD system knows of.
<code lang='und' xml:lang='und'>func_num</code> is the number of the new function.
<code lang='und' xml:lang='und'>function</code> is ignored.</dd><p class="pad"></p>

<dd>RT#45941 change this to a MMD register interface that takes a function *name*.</dd><p class="pad"></p>

<dt><a name="static_void_mmd_expand_x"
><b><code lang='und' xml:lang='und'>static void mmd_expand_x</b></code></a></dt><p class="pad"></p>

<dd>Expands the function table in the X dimension to include <code lang='und' xml:lang='und'>new_x</code>.</dd><p class="pad"></p>

<dt><a name="static_void_mmd_expand_y"
><b><code lang='und' xml:lang='und'>static void mmd_expand_y</b></code></a></dt><p class="pad"></p>

<dd>Expands the function table in the Y direction.</dd><p class="pad"></p>

<dt><a name="void_mmd_add_by_class"
><b><code lang='und' xml:lang='und'>void mmd_add_by_class</b></code></a></dt><p class="pad"></p>

<dd>Add a function to the MMD table by class name,
rather than class number.
Handles the case where the named class isn&#39;t loaded yet.</dd><p class="pad"></p>

<dd>Adds a new MMD function <code lang='und' xml:lang='und'>funcptr</code> to the <code lang='und' xml:lang='und'>func_num</code> function table that will be invoked when the left parameter is of class <code lang='und' xml:lang='und'>left_class</code> and the right parameter is of class <code lang='und' xml:lang='und'>right_class</code>.
Both classes are <code lang='und' xml:lang='und'>STRING *</code>s that hold the PMC class names for the left and right sides.
If either class isn&#39;t yet loaded,
Parrot will cache the information such that the function will be installed if at some point in the future both classes are available.</dd><p class="pad"></p>

<dd>Currently this is done by just assigning class numbers to the classes,
which the classes will pick up and use if they&#39;re later loaded,
but we may later put the functions into a deferred table that we scan when PMC classes are loaded.
Either way,
the function will be guaranteed to be installed when it&#39;s needed.</dd><p class="pad"></p>

<dd>The function table must exist,
but if it is too small,
it will automatically be expanded.</dd><p class="pad"></p>

<dt><a name="void_mmd_register"
><b><code lang='und' xml:lang='und'>void mmd_register</b></code></a></dt><p class="pad"></p>

<dd>Register a function <code lang='und' xml:lang='und'>funcptr</code> for MMD function table <code lang='und' xml:lang='und'>func_num</code> for classes <code lang='und' xml:lang='und'>left_type</code> and <code lang='und' xml:lang='und'>right_type</code>.
The left and right types are <code lang='und' xml:lang='und'>INTVAL</code>s that represent the class ID numbers.</dd><p class="pad"></p>

<dd>The function table must exist,
but if it is too small,
it will automatically be expanded.</dd><p class="pad"></p>

<dd>Adding a new function to the table can be interestingly non&#45;trivial,
so we get to be tricky.</dd><p class="pad"></p>

<dd>If the left or right types are larger than anything we&#39;ve seen so far,
it means that we have to expand the table.
Making Y larger is simple &#45;&#45; just realloc with some more rows.
Making X larger is less simple.
In either case,
we punt to other functions.</dd><p class="pad"></p>

<dd>RT#45943 &#45; Currently the MMD system doesn&#39;t handle inheritance and best match searching,
as it assumes that all PMC types have no parent type.
This can be considered a bug,
and will be resolved at some point in the future.</dd><p class="pad"></p>

<dt><a name="void_mmd_register_sub"
><b><code lang='und' xml:lang='und'>void mmd_register_sub</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="void_mmd_destroy"
><b><code lang='und' xml:lang='und'>void mmd_destroy</b></code></a></dt><p class="pad"></p>

<dd>Frees all the memory allocated used the MMD subsystem.</dd><p class="pad"></p>

<dt><a name="PMC_*_mmd_vtfind"
><b><code lang='und' xml:lang='und'>PMC *mmd_vtfind</b></code></a></dt><p class="pad"></p>

<dd>Return an MMD PMC function for the given data types.
The return result is either a Sub PMC (for PASM MMD functions) or a NCI PMC holding the C function pointer in PMC_struct_val.</dd><p class="pad"></p>

<dt><a name="PMC_*_Parrot_MMD_search_default_infix"
><b><code lang='und' xml:lang='und'>PMC *Parrot_MMD_search_default_infix</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="PMC_*_Parrot_mmd_sort_candidate_list"
><b><code lang='und' xml:lang='und'>PMC *Parrot_mmd_sort_candidate_list</b></code></a></dt><p class="pad"></p>

<dd>Given an array PMC (usually a MultiSub) sort the mmd candidates by their manhatten distance to the current args.</dd><p class="pad"></p>

<dt><a name="static_PMC*_mmd_arg_tuple_inline"
><b><code lang='und' xml:lang='und'>static PMC *mmd_arg_tuple_inline</b></code></a></dt><p class="pad"></p>

<dd>Return a list of argument types.
PMC arguments are specified as function arguments.</dd><p class="pad"></p>

<dt><a name="static_PMC*_mmd_arg_tuple_func"
><b><code lang='und' xml:lang='und'>static PMC *mmd_arg_tuple_func</b></code></a></dt><p class="pad"></p>

<dd>Return a list of argument types.
PMC arguments are take from registers according to calling conventions.</dd><p class="pad"></p>

<dt><a name="static_PMC*_mmd_search_default"
><b><code lang='und' xml:lang='und'>static PMC *mmd_search_default</b></code></a></dt><p class="pad"></p>

<dd>Default implementation of MMD search.
Search scopes for candidates,
walk the class hierarchy,
sort all candidates by their Manhattan distance,
and return result</dd><p class="pad"></p>

<dt><a name="static_void_mmd_search_classes"
><b><code lang='und' xml:lang='und'>static void mmd_search_classes</b></code></a></dt><p class="pad"></p>

<dd>Search all the classes in all MultiSubs of the candidates <code lang='und' xml:lang='und'>cl</code> and return a list of all candidates.
<code lang='und' xml:lang='und'>start_at_parent</code> is 0 to start at the class itself or 1 to search from the first parent class.</dd><p class="pad"></p>

<dt><a name="static_INTVAL_distance_cmp"
><b><code lang='und' xml:lang='und'>static INTVAL distance_cmp</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_PMC*_mmd_cvt_to_types"
><b><code lang='und' xml:lang='und'>static PMC *mmd_cvt_to_types</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_UINTVAL_mmd_distance"
><b><code lang='und' xml:lang='und'>static UINTVAL mmd_distance</b></code></a></dt><p class="pad"></p>

<dd>Create Manhattan Distance of sub <code lang='und' xml:lang='und'>pmc</code> against given argument types.
0xffff is the maximum distance</dd><p class="pad"></p>

<dt><a name="static_void_mmd_sort_candidates"
><b><code lang='und' xml:lang='und'>static void mmd_sort_candidates</b></code></a></dt><p class="pad"></p>

<dd>Sort the candidate list <code lang='und' xml:lang='und'>cl</code> by Manhattan Distance</dd><p class="pad"></p>

<dt><a name="static_PMC*_mmd_search_scopes"
><b><code lang='und' xml:lang='und'>static PMC *mmd_search_scopes</b></code></a></dt><p class="pad"></p>

<dd>Search all scopes for MMD candidates matching the arguments given in <code lang='und' xml:lang='und'>arg_tuple</code>.</dd><p class="pad"></p>

<dt><a name="static_int_mmd_is_hidden"
><b><code lang='und' xml:lang='und'>static int mmd_is_hidden</b></code></a></dt><p class="pad"></p>

<dd>Check if the given multi sub is hidden by any inner multi sub (already in the candidate list <code lang='und' xml:lang='und'>cl</code>.</dd><p class="pad"></p>

<dt><a name="static_int_mmd_maybe_candidate"
><b><code lang='und' xml:lang='und'>static int mmd_maybe_candidate</b></code></a></dt><p class="pad"></p>

<dd>If the candidate <code lang='und' xml:lang='und'>pmc</code> is a Sub PMC,
push it on the candidate list and return TRUE to stop further search.</dd><p class="pad"></p>

<dd>If the candidate is a MultiSub remember all matching Subs and return FALSE to continue searching outer scopes.</dd><p class="pad"></p>

<dt><a name="static_int_mmd_search_cur_namespace"
><b><code lang='und' xml:lang='und'>static int mmd_search_cur_namespace</b></code></a></dt><p class="pad"></p>

<dd>Search the current package namespace for matching candidates.
Return TRUE if the MMD search should stop.</dd><p class="pad"></p>

<dt><a name="static_PMC*_mmd_get_ns"
><b><code lang='und' xml:lang='und'>static PMC *mmd_get_ns</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_PMC*_mmd_make_ns"
><b><code lang='und' xml:lang='und'>static PMC *mmd_make_ns</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_void_mmd_search_builtin"
><b><code lang='und' xml:lang='und'>static void mmd_search_builtin</b></code></a></dt><p class="pad"></p>

<dd>Search the builtin namespace for matching candidates.
This is the last search in all the namespaces.</dd><p class="pad"></p>

<dt><a name="void_mmd_create_builtin_multi_stub"
><b><code lang='und' xml:lang='und'>void mmd_create_builtin_multi_stub</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_void_mmd_create_builtin_multi_meth_2"
><b><code lang='und' xml:lang='und'>static void mmd_create_builtin_multi_meth_2</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_void_mmd_create_builtin_multi_meth"
><b><code lang='und' xml:lang='und'>static void mmd_create_builtin_multi_meth</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="void_Parrot_mmd_register_table"
><b><code lang='und' xml:lang='und'>void Parrot_mmd_register_table</b></code></a></dt><p class="pad"></p>

<dd>Register MMD functions for this PMC type.</dd><p class="pad"></p>

<dt><a name="void_Parrot_mmd_rebuild_table"
><b><code lang='und' xml:lang='und'>void Parrot_mmd_rebuild_table</b></code></a></dt><p class="pad"></p>

<dd>Rebuild the static MMD_table for the given class type and MMD function number.
If <code lang='und' xml:lang='und'>type</code> is negative all classes are rebuilt.
If <code lang='und' xml:lang='und'>func_nr</code> is negative all MMD functions are rebuilt.</dd><p class="pad"></p>
</dl>

<h1><a name="SEE_ALSO"
>SEE ALSO <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p><em lang='und' xml:lang='und'>include/parrot/mmd.h</em>,
<em lang='und' xml:lang='und'>http://svn.perl.org/perl6/doc/trunk/design/apo/A12.pod</em>,
<em lang='und' xml:lang='und'>http://svn.perl.org/perl6/doc/trunk/design/syn/S12.pod</em></p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../resources/parrot_small.png"
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
