<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
    <HEAD>
        <TITLE>Parrot Strings</TITLE>
        <LINK REL="stylesheet" TYPE="text/css"
            HREF="../../../../resources/perl.css"
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY>
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Parrot Strings</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../../html/index.html">Contents</a> | <a href="../../../../html/docs.html">Documentation</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>docs/pdds/pdd28_strings.pod &#45; Parrot Strings</p>

<h1><a name="ABSTRACT"
>ABSTRACT <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>This PDD describes the conventions for strings in Parrot,
including but not limited to support for multiple character sets,
encodings and languages.</p>

<h1><a name="VERSION"
>VERSION <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>$Revision$</p>

<h1><a name="DEFINITIONS"
>DEFINITIONS <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<h2><a name="Character"
>Character <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>A character is the abstract description of a symbol.
It&#39;s the smallest chunk of text a computer knows how to deal with.
Internally to the computer,
a character (just like everything else) is a number,
so a few further definitions are needed.</p>

<h2><a name="Character_Set"
>Character Set <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>The Unicode Standard prefers the concepts of <i>character repertoire</i> (a collection of characters) and <i>character code</i> (a mapping which tells you what number represents which character in the repertoire).
Character set is commonly used to mean the standard which defines both a repertoire and a code.</p>

<h2><a name="Codepoint"
>Codepoint <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>A codepoint is the numeric representation of a character according to a given character set.
So in ASCII,
the character <code lang='und' xml:lang='und'>A</code> has codepoint 0x41.</p>

<h2><a name="Encoding"
>Encoding <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>An encoding determines how a codepoint is represented inside a computer.
Simple encodings like ASCII define that the codepoints 0&#45;127 simply live as their numeric equivalents inside an eight&#45;bit bytes.
Other fixed&#45;width encodings like UTF&#45;16 use more bytes to encode more codepoints.
Variable&#45;width encodings like UTF&#45;8 use one byte for codepoints 0&#45;127,
two bytes for codepoints 127&#45;2047,
and so on.</p>

<p>Character sets and encodings are related but separate concepts.
An encoding is the lower&#45;level representation of a string&#39;s data,
whereas the character set determines higher&#45;level semantics.
Typically,
character set functions will ask a string&#39;s encoding functions to retrieve data from the string,
and then process the retrieved data.</p>

<h2><a name="Combining_Character"
>Combining Character <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>A combining character is a Unicode concept.
It is a character which modifies the preceding character.
For instance,
accents,
lines,
circles,
boxes,
etc.
which are not to be displayed on their own,
but to be composed with the preceding character.</p>

<h2><a name="Grapheme"
>Grapheme <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>In linguistics,
a grapheme is a single symbol in a writing system (letter,
number,
punctuation mark,
kanji,
hiragana,
Arabic glyph,
Devanagari symbol,
etc),
including any modifiers (diacritics,
etc).</p>

<p>The Unicode Standard defines a <i>grapheme cluster</i> (commonly simplified to just <i>grapheme</i>) as one or more characters forming a visible whole when displayed,
in other words,
a bundle of a character and all of its combining characters.
Because graphemes are the highest&#45;level abstract idea of a &#34;character&#34;,
they&#39;re useful for converting between character sets.</p>

<h2><a name="Normalization_Form"
>Normalization Form <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>A normalization form standardizes the representation of a string by transforming a sequence of combining characters into a more complex character (composition),
or by transforming a complex character into a sequence of composing characters (decomposition).
The decomposition forms also define a standard order for the composing characters,
to allow string comparisons.
The Unicode Standard defines four normalization forms: NFC and NFKC are composition,
NFD and NFKD are decomposition.
See <a href='TODO#%2Fwww.unicode.org%2Freports%2Ftr15%2F'>Unicode Normalization Forms</a> for more details.</p>

<h2><a name="Grapheme_Normalization_Form"
>Grapheme Normalization Form <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Grapheme normalization form (NFG) is a normalization which allocates exactly one codepoint to each grapheme.</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<ul>
<li>Parrot supports multiple string formats,
and so users of Parrot strings must be aware at all times of string encoding issues and how these relate to the string interface.</li><p class="pad"></p>

<li>Parrot provides an interface for interacting with strings and converting between character sets and encodings.</li><p class="pad"></p>

<li>Operations that require understanding the semantics of a string must respect the character set of the string.</li><p class="pad"></p>

<li>Operations that require understanding the layout of the string must respect the encoding of the string.</li><p class="pad"></p>

<li>In addition to common string formats,
Parrot provides an additional string format that is a sequence of 32&#45;bit Unicode codepoints in NFG.</li><p class="pad"></p>
</ul>

<h1><a name="IMPLEMENTATION"
>IMPLEMENTATION <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>Parrot was designed from the outset to support multiple string formats: multiple character sets and multiple encodings.
We don&#39;t standardize on Unicode internally,
converting all strings to Unicode strings,
because for the majority of use cases it&#39;s still far more efficient to deal with whatever input data the user sends us.</p>

<p>Consumers of Parrot strings need to be aware that there is a plurality of string encodings inside Parrot.
(Producers of Parrot strings can do whatever is most efficient for them.) To put it in simple terms: if you find yourself writing <code lang='und' xml:lang='und'>*s++</code> or any other C string idioms,
you need to stop and think if that&#39;s what you really mean.
Not everything is byte&#45;based anymore.</p>

<h2><a name="Grapheme_Normalization_Form"
>Grapheme Normalization Form <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Unicode characters can be expressed in a number of different ways according to the Unicode Standard.
This is partly to do with maintaining compatibility with existing character encodings.
For instance,
in Serbo&#45;Croatian and Slovenian,
there&#39;s a letter which looks like an <code lang='und' xml:lang='und'>i</code> without the dot but with two grave (<code lang='und' xml:lang='und'>`</code>) accents (&#521;).
Unicode can represent this letter as a composed character <code lang='und' xml:lang='und'>0x209</code>,
also known as <code lang='und' xml:lang='und'>LATIN SMALL LETTER I WITH DOUBLE GRAVE</code>,
which does the job all in one go.
It can also represent this letter as a decomposed sequence: <code lang='und' xml:lang='und'>LATIN SMALL LETTER I</code> (<code lang='und' xml:lang='und'>0x69</code>) followed by <code lang='und' xml:lang='und'>COMBINING DOUBLE GRAVE ACCENT</code> (<code lang='und' xml:lang='und'>0x30F</code>).
We use the term <i>grapheme</i> to refer to a &#34;letter&#34; whether it&#39;s represented by a single codepoint or multiple codepoints.</p>

<p>String operations on this kind of variable&#45;byte encoding can be complex and expensive.
Operations like comparison and traversal require a series of computations and lookaheads,
because any given grapheme may be a sequence of combining characters.
The Unicode Standard defines several &#34;normalization forms&#34; that help with this problem.
Normalization Form C (NFC),
for example,
decomposes everything,
then re&#45;composes as much as possible.
So if you see the integer stream <code lang='und' xml:lang='und'>0x69 0x30F</code>,
it needs to be replaced by <code lang='und' xml:lang='und'>0x209</code>.
However,
Unicode&#39;s normalization forms don&#39;t go quite far enough to completely solve the problem.
For example,
Serbo&#45;Croat is sometimes also written with Cyrillic letters rather than Latin letters.
Unicode doesn&#39;t have a single composed character for the Cyrillic equivalent of the Serbo&#45;Croat <code lang='und' xml:lang='und'>LATIN SMALL LETTER I WITH DOUBLE GRAVE</code>,
so it is represented as a decomposed pair <code lang='und' xml:lang='und'>CYRILLIC SMALL LETTER I</code> (<code lang='und' xml:lang='und'>0x438</code>) with <code lang='und' xml:lang='und'>COMBINING DOUBLE GRAVE ACCENT</code> (<code lang='und' xml:lang='und'>0x30F</code>).
This means that even in the most normalized Unicode form,
string manipulation code must always assume a variable&#45;byte encoding,
and use expensive lookaheads.
The cost is incurred on every operation,
though the particular string operated on might not contain combining characters.
It&#39;s particularly noticeable in parsing and regular expression matches,
where backtracking operations may re&#45;traverse the characters of a simple string hundreds of times.</p>

<p>In order to reduce the cost of variable&#45;byte operations and simplify some string manipulation tasks,
Parrot defines an additional normalization: Normalization Form G (NFG).
In NFG,
every grapheme is guaranteed to be represented by a single codepoint.
Graphemes that don&#39;t have a single codepoint representation in Unicode are given a dynamically generated codepoint unique to the NFG string.</p>

<p>An NFG string is a sequence of signed 32&#45;bit Unicode codepoints.
It&#39;s equivalent to UCS&#45;4 except for the normalization form semantics.
UCS&#45;4 specifies an encoding for Unicode codepoints from 0 to 0x7FFFFFFF.
In other words,
any codepoints with the first bit set are undefined.
NFG interprets the unused bit as a sign bit,
and reserves all negative codepoints as dynamic codepoints.
A negative codepoint acts as an index into a lookup table,
which maps between a dynamic codepoint and its associated decomposition.</p>

<p>In practice,
this goes as follows: When our Russified Serbo&#45;Croat string is converted to NFG,
it is normalized to a single character having the codepoint <code lang='und' xml:lang='und'>0xFFFFFFFFF</code> (in other words,
&#45;1 in 2&#39;s complement).
At the same time,
Parrot inserts an entry into the string&#39;s grapheme table at array index &#45;1,
containing the Unicode decomposition of the grapheme <code lang='und' xml:lang='und'>0x00000438 0x000000030F</code>.</p>

<p>Parrot will provide both grapheme&#45;aware and codepoint&#45;aware string operations,
such as iterators for string traversal and calculations of string length.
Individual language implementations can choose between the two types of operations depending on whether their string semantics are character&#45;based or codepoint&#45;based.
For languages that don&#39;t currently have Unicode support,
the grapheme operations will allow them to safely manipulate Unicode data without changing their string semantics.</p>

<h3><a name="Advantages"
>Advantages</a></h3>

<p>Applications that don&#39;t care about graphemes can handle a NFG codepoint in a string as if it&#39;s any other character.
Only applications that care about the specific properties of Unicode characters need to take the load of peeking inside the grapheme table and reading the decomposition.</p>

<p>Using negative numbers for dynamic codepoints allows Parrot to check if a particular codepoint is dynamic using a single sign&#45;comparison operation.
It also means that NFG can be used without conflict on encodings from 7&#45;bit (signed 8&#45;bit integers) to 63&#45;bit (using signed 64&#45;bit integers) and beyond.</p>

<p>Because any grapheme from any character set can be represented by a single NFG codepoint,
NFG strings are useful as an intermediate representation for converting between string types.</p>

<h3><a name="Disadvantages"
>Disadvantages</a></h3>

<p>A 32&#45;bit encoding is quite large,
considering the fact that the Unicode codespace only requires up to <code lang='und' xml:lang='und'>0x10FFFF</code>.
The Unicode Consortium&#39;s FAQ notes that most Unicode interfaces use UTF&#45;16 instead of UTF&#45;32,
out of memory considerations.
This means that although Parrot will use 32&#45;bit NFG strings for optimizations within operations,
for the most part individual users should use the native character set and encoding of their data,
rather than using NFG strings directly.</p>

<p>The conceptual cost of adding a normalization form beyond those defined in the Unicode Standard has to be considered.
However,
to fully support Unicode,
Parrot already needs to keep track of what normalization form a given string is in,
and provide functions to convert between normalization forms.
The conceptual cost of one additional normalization form is relatively small.</p>

<h3><a name="The_grapheme_table"
>The grapheme table</a></h3>

<p>When constructing strings in NFG,
graphemes not expressible as a single character in Unicode are represented by a dynamic codepoint index into the string&#39;s grapheme table.
When Parrot comes across a multi&#45;codepoint grapheme,
it must first determine whether or not the grapheme already has an entry in the grapheme table.
Therefore the table cannot strictly be an array,
as that would make lookup inefficient.
The grapheme table is represented,
then,
as both an array and a hash structure.
The array interface provides forward&#45;lookup and the hash interface reverse lookup.
Converting a multi&#45;codepoint grapheme into a dynamic codepoint can be demonstrated with the following Perl 5 pseudocode,
for the grapheme <code lang='und' xml:lang='und'>0x438 0x30F</code>:</p>

<pre lang='und' xml:lang='und'>   $codepoint = ($grapheme_lookup&#45;&#62;{0x438}{0x30F} ||= do {
                   push @grapheme_table, &#34;\x{438}\x{30F}&#34;;
                   ~ $#grapheme_table;
                });
   push @string, $codepoint;</pre>

<h2><a name="String_API"
>String API <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Strings have the following structure:</p>

<pre lang='und' xml:lang='und'>  struct parrot_string_t {
      UnionVal                      cache;
      Parrot_UInt                   flags;
      UINTVAL                       bufused;
      UINTVAL                       hashval;
      UINTVAL                       strlen;
      char                         *strstart;
      const struct _encoding       *encoding;
      const struct _charset        *charset;
      const struct _normalization  *normalization;
  };</pre>

<p>Deprecation note: the enum <code lang='und' xml:lang='und'>parrot_string_representation_t</code> will be removed.</p>

<p>The current string functions will on the whole be maintained, with some modifications for the addition of the NFG string format.</p>

<h3><a name="Conversions_between_normalization_form,_encoding,_and_charset"
>Conversions between normalization form, encoding, and charset</a></h3>

<p>Conversion will be done with a function called <code lang='und' xml:lang='und'>string_grapheme_copy</code>:</p>

<pre lang='und' xml:lang='und'>    INTVAL string_grapheme_copy(STRING *src, STRING *dst)</pre>

<p>Converting a string from one format to another involves creating a new empty string with the required attributes, and passing the source string and the new string to <code lang='und' xml:lang='und'>string_grapheme_copy</code>. This function iterates through the source string one grapheme at a time, using the character set function pointer <code lang='und' xml:lang='und'>get_grapheme</code> (which may read ahead multiple characters with strings that aren&#39;t in NFG). For each source grapheme, the function will call <code lang='und' xml:lang='und'>set_grapheme</code> on the destination string (which may append multiple characters in non&#45;NFG strings). This conversion effectively uses an intermediate NFG representation.</p>

<h2><a name="String_PMC_API"
>String PMC API <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<h1><a name="REFERENCES"
>REFERENCES <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p><a href="http://sirviente.9grid.es/sources/plan9/sys/doc/utf.ps">http://sirviente.9grid.es/sources/plan9/sys/doc/utf.ps</a> &#45; Plan 9&#39;s Runes are not dissimilar to NFG strings, and this is a good introduction to the Unicode world.</p>

<p><a href="http://www.unicode.org/reports/tr15/">http://www.unicode.org/reports/tr15/</a> &#45; The Unicode Consortium&#39;s explanation of different normalization forms.</p>

<p><a href="http://unicode.org/reports/tr29/">http://unicode.org/reports/tr29/</a> &#45; &#34;grapheme clusters&#34; in the Unicode Standard Annex</p>

<p>&#34;Unicode: A Primer&#34;, Tony Graham &#45; Arguably the most readable book on how Unicode works.</p>

<p>&#34;Advanced Perl Programming&#34;, Chapter 6, &#34;Unicode&#34;</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../../resources/parrot_small.png"
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
