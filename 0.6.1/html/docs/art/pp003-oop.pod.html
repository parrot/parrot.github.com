<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
    <HEAD>
        <TITLE>Untitled</TITLE>
        <LINK REL="stylesheet" TYPE="text/css"
            HREF="../../../resources/perl.css"
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY>
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Untitled</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../html/index.html">Contents</a> | <a href="../../../html/docs.html">Documentation</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="Programming_Parrot_&#45;&#45;_Using_objects"
>Programming Parrot &#45;&#45; Using objects <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Yes,
you&#39;ve read correctly.
Parrot has the ability to create and manipulate objects (aka,
object oriented programming).
While it may seem strange for a low&#45;level language like PIR to have the facility for object oriented programming,
it makes perfect sense in this particular case.
Remember,
Parrot&#39;s number one goal is to be the underlying implementation for Perl6,
which has object oriented features.
Parrot&#39;s secondary goal is to provide a good platform for other dynamic languages such as Python,
Ruby,
PHP,
Javascript,
etc.
and those languages too have the ability (if not the requirement) to be object oriented.
Thus Parrot contains facilities for a manipulating objects so that language implementors can easily express the appropriate object semantics for their language of interest.</p>

<h2><a name="Namespaces"
>Namespaces <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Before I begin talking about how to create classes and instantiate objects,
I first need to talk about an intimately related subject: namespaces.
Namespaces serve a twofold purpose,
they allow you to group related routines together and they allow you to give several subroutines the same name but different,
domain specific,
implementations.
These characteristics are,
oddly enough,
similar to the basic requirements for a class.</p>

<p>For instance,
you may put all of your subroutines dealing with people in a <code lang='und' xml:lang='und'>Person</code> namespace and all of your subroutines dealing with computer programs in the <code lang='und' xml:lang='und'>Process</code> namespace.
Both namespaces may have a subroutine called <code lang='und' xml:lang='und'>run()</code> but with radically different implementations.
Below is some code to illustrate this example:</p>

<h3><a name="Example_1:"
>Example 1:</a></h3>

<pre lang='und' xml:lang='und'>    .namespace [ &#34;Person&#34; ]

    .sub run
        print &#34;Run Forrest, Run!\n&#34;
    .end

    .namespace [ &#34;Process&#34; ]

    .sub run
        print &#34;Running process #53\n&#34;
    .end</pre>

<p>As you might guess, the <code lang='und' xml:lang='und'>.namespace</code> directive tells Parrot what namespace to group subroutines under. A namespace ends when another <code lang='und' xml:lang='und'>.namespace</code> directive changes the namespace or when the end of the file is reached. A bare <code lang='und' xml:lang='und'>.namespace</code> directive (i.e., with no name following it) changes back to the default namespace.</p>

<p>Perl programmers will recognize that Parrot <code lang='und' xml:lang='und'>.namespace</code> declarations are just like Perl <code lang='und' xml:lang='und'>package</code> declarations. But there are a few differences. I&#39;ll talk more about how Parrot uses namespaces and classes together in just a minute.</p>

<h2><a name="PIR_with_class"
>PIR with class <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Creating classes in Parrot is relatively easy. There are opcodes for it. The easiest to start with is <code lang='und' xml:lang='und'>newclass</code>; just say <code lang='und' xml:lang='und'>$P0 = newclass &#39;Foo&#39;</code> where $P0 can be any PMC thing (a register or a local variable) and &#39;Foo&#39; is the name of the class you want to create.</p>

<p>When you wish to instantiate objects that belong to the class you&#39;ve created, it&#39;s equally simple. Just say <code lang='und' xml:lang='und'>myobj = new &#34;Foo&#34;</code> where <code lang='und' xml:lang='und'>myobj</code> is a PMC and &#34;Foo&#34; is the classname you&#39;ve created with <code lang='und' xml:lang='und'>newclass</code>. Here&#39;s a simple example:</p>

<h3><a name="Example_2:_A_classic_Dog"
>Example 2: A classic Dog</a></h3>

<pre lang='und' xml:lang='und'>    .sub _ :main
        $P0 = newclass &#39;Dog&#39;
        .local pmc spot
        spot = new &#39;Dog&#39;
    .end</pre>

<p>You may notice that I didn&#39;t use the return value of <code lang='und' xml:lang='und'>newclass</code>. That&#39;s only because this is a simple example. :&#45;) I&#39;ll talk about what to do with the return value of <code lang='und' xml:lang='und'>newclass</code> a little later. Right now, let&#39;s talk about methods.</p>

<h2><a name="Madness_..._er,_Methods"
>Madness ... er, Methods <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>So now that I&#39;ve created a <code lang='und' xml:lang='und'>Dog</code> class, how do I add methods to it? Remember before when I talked about namespaces? Well, that&#39;s the answer. To add methods to a class, you create a namespace with the same name as the class and then put your subroutines in that namespace. PIR also provides a syntactic marker to let everyone know these subroutines are methods. When declaring the subroutine add the <code lang='und' xml:lang='und'>:method</code> modifier after the subroutine name. Here&#39;s a familiar example to anyone who has read <a href='TODO'>perlboot</a>.</p>

<h3><a name="Example_3:_Barnyard_animals"
>Example 3: Barnyard animals</a></h3>

<pre lang='und' xml:lang='und'>    .namespace [ &#34;Cow&#34; ]

    .sub speak :method
        print &#34;Moo\n&#34;
    .end

    .namespace [ &#34;Dog&#34; ]

    .sub speak :method
        print &#34;Woof\n&#34;
    .end

    .namespace [ &#34;Pig&#34; ]

    .sub speak :method
        print &#34;Oink\n&#34;
    .end

    .namespace

    .sub _ :main
        $P0 = newclass &#34;Cow&#34;
        $P0 = newclass &#34;Dog&#34;
        $P0 = newclass &#34;Pig&#34;

        .local pmc elsie, fido, porky

        elsie   = new &#34;Cow&#34;
        fido    = new &#34;Dog&#34;
        porky   = new &#34;Pig&#34;

        elsie.&#39;speak&#39;()
        fido.&#39;speak&#39;()
        porky.&#39;speak&#39;()
    .end</pre>

<p>It&#39;s important to note that even though I&#39;ve declared the namespaces and put subroutines in them, this does not automatically create classes. The <code lang='und' xml:lang='und'>newclass</code> declarations tell Parrot to create a class and as a side effect, namespaces with the same name as the class may be used to store methods for that class.</p>

<p>One thing you may notice about method calls is that the method names are quoted. Why is that? In the current design, quoting the method name is the only way to avoid ambiguity between actual method names and local variables that contain the method name.</p>

<h3><a name="Example_4:_variable_methods"
>Example 4: variable methods</a></h3>

<pre lang='und' xml:lang='und'>    .namespace [ &#39;Foo&#39; ]

    .sub foo :method
        print &#34;foo\n&#34;
    .end

    .sub bar :method
        print &#34;bar\n&#34;
    .end

    .namespace

    .sub _ :main
        $P0 = newclass &#34;Foo&#34;
        .local pmc f
        f = new &#34;Foo&#34;

        .local string m
        m = &#34;foo&#34;
        f.m()
        m = &#34;bar&#34;
        f.m()
    .end</pre>

<p>There has been some discussion of changing the syntax slightly so that when a variable is used for the method name, it is designated in some way so that the common case of calling a normal method name does not need to be quoted, but as of this writing, no such change has happened.</p>

<h2><a name="But_where_do_I_store_my_stuff?"
>But where do I store my stuff? <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>So far I&#39;ve talked about namespaces and creating classes and associating methods with those classes, but what about storing data in the class? Remember how the <code lang='und' xml:lang='und'>newclass</code> opcode returned a PMC that I didn&#39;t do anything to/with? Well, here&#39;s where it&#39;s used. The PMC returned from <code lang='und' xml:lang='und'>newclass</code> is the handle by which you manipulate the class. One such manipulation involves class &#34;attributes&#34;. Attributes are where you store your class&#45;specific data.</p>

<p>Parrot has several opcodes for manipulating attributes; they are: <code lang='und' xml:lang='und'>addattribute</code>, <code lang='und' xml:lang='und'>setattribute</code>, and <code lang='und' xml:lang='und'>getattribute</code>. The <code lang='und' xml:lang='und'>addattribute</code> opcode lets you add a spot in the class for storing a particular value which may be get and set with <code lang='und' xml:lang='und'>getattribute</code> and <code lang='und' xml:lang='und'>setattribute</code> respectively. The only restriction on these values is that currently all attributes must be PMCs.</p>

<p>So, say I wanted to give my barnyard animals names (I&#39;ll illustrate with just one animal and you can infer how to do the same for the rest):</p>

<h3><a name="Example_5:_Naming_my_animals"
>Example 5: Naming my animals</a></h3>

<pre lang='und' xml:lang='und'>    .namespace [ &#34;Dog&#34; ]

    .sub name :method
        .local pmc name
        name = getattribute self, &#34;name&#34;
        print name
    .end

    .sub speak :method
        print &#34;woof&#34;
    .end

    .namespace

    .sub _ :main
        $P0 = newclass &#34;Dog&#34;
        addattribute $P0, &#34;name&#34;

        .local pmc dog
        dog = new &#34;Dog&#34;
        $P0 = new &#34;String&#34;
        $P0 = &#34;Phideaux&#34;
        setattribute dog, &#34;name&#34;, $P0

        dog.&#39;name&#39;()
        print &#34; says &#34;
        dog.&#39;speak&#39;()
        print &#34;!\n&#34;
    .end</pre>

<p>Whew! There&#39;s a lot of new stuff in this code. I&#39;ll take them starting from the top of the program and working towards the bottom.</p>

<p>One of the benefits of tagging your subroutines as methods is that they get a PMC named <code lang='und' xml:lang='und'>self</code> that represents the object they are acting on behalf of. The <code lang='und' xml:lang='und'>name</code> method takes advantage of this to retrieve the attribute called &#34;name&#34; from the <code lang='und' xml:lang='und'>self</code> PMC and print it.</p>

<p>Immediately after I create the class called &#34;Dog&#34;, I use the PMC handle returned from <code lang='und' xml:lang='und'>newclass</code> to add an attribute called &#34;name&#34; to the class. This just allocates a slot in the class for the value, it does nothing more.</p>

<p>Next, I create a new Dog and give it a name. Because attributes may only be PMCs, in order to give the Dog a name, I first have to create a new String PMC (this is one of the PMCs builtin to Parrot) and assign the name I wish to give the dog to this PMC. Then I can pass this PMC as a parameter to <code lang='und' xml:lang='und'>setattribute</code> to give my Dog a name.</p>

<p>Seems kind of complicated, doesn&#39;t it? Especially when you think about doing this for each animal. Each animal namespace would have an identical version of the <code lang='und' xml:lang='und'>name</code> method. For each call to <code lang='und' xml:lang='und'>newclass</code> I&#39;d need to also call <code lang='und' xml:lang='und'>addattribute</code> so that all of the animals may have a name. Each time I wish to assign a name to an animal, I&#39;d first need to create a <code lang='und' xml:lang='und'>.String</code> and call <code lang='und' xml:lang='und'>setattribute</code> on it. Et cetera.</p>

<p>Surely there&#39;s a better way?!? There is ...</p>

<h2><a name="Inheritance"
>Inheritance <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>You saw it coming didn&#39;t you? What&#39;s object oriented programming without inheritance? Parrot has an opcode <code lang='und' xml:lang='und'>subclass</code> that lets you inherit data and methods from an existing class. We can use this ability to create a base class called &#34;Animal&#34; that contains the &#34;name&#34; attribute and 2 methods that are common to all animals: <code lang='und' xml:lang='und'>setname</code> and <code lang='und' xml:lang='und'>getname</code> Then, to create new animals, I just inherit from the Animal base class like so:</p>

<h3><a name="Example_6:_inheriting"
>Example 6: inheriting</a></h3>

<pre lang='und' xml:lang='und'>    ...
    $P0 = newclass &#34;Animal&#34;
    addattribute $P0, &#34;name&#34;
    $P0 = subclass &#34;Animal&#34;, &#34;Cow&#34;
    $P0 = subclass &#34;Animal&#34;, &#34;Dog&#34;
    $P0 = subclass &#34;Animal&#34;, &#34;Pig&#34;
    ...
    cow = new &#39;Cow&#39;
    cow.&#39;setname&#39;(&#34;Elsie&#34;)
    ...
    cow.&#39;getname&#39;()</pre>

<p>Each subclass will contain an attribute called &#34;name&#34; that can be used to store the name of the animal. The <code lang='und' xml:lang='und'>setname</code> method abstracts out the process of creating a <code lang='und' xml:lang='und'>.String</code> PMC and calling <code lang='und' xml:lang='und'>setattribute</code> on it. And finally the <code lang='und' xml:lang='und'>getname</code> method becomes a wrapper around <code lang='und' xml:lang='und'>getattribute</code>.</p>

<h2><a name="Wrapup"
>Wrapup <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>I hope this gives you an idea of how to do object oriented programming using Parrot. The opcodes illustrated here are what any language implementor that targets Parrot would use to implement object oriented features in their language. Of course there are more opcodes for richer object oriented behavior available in Parrot. This article only covers the basics. For more information see parrot/docs/pdds/pdd15_objects.pod.</p>

<p>At the end of this article is a more complete listing of the program that gives my barnyard animals voices. There are many improvements that can be made to this code so take this opportunity to read and experiment and learn more about OOP in Parrot.</p>

<h2><a name="Acknowledgements"
>Acknowledgements <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<blockquote>
<p>* Thanks to Randal Schwartz for providing a neat set of examples in <a href='TODO'>perlboot</a> from which this article shamelessly borrows. * Thanks to the Parrot people for feedback</p>
</blockquote>

<h2><a name="Author"
>Author <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Jonathan Scott Duff</p>

<h3><a name="Example_6:_Full_barnyard_listing"
>Example 6: Full barnyard listing</a></h3>

<pre lang='und' xml:lang='und'>    .namespace [ &#34;Animal&#34; ]

    .sub setname :method
        .param string name
        $P0 = new &#39;String&#39;
        $P0 = name
        setattribute self, &#34;name&#34;, $P0
    .end

    .sub getname :method
        $P0 = getattribute self, &#34;name&#34;
        print $P0
    .end

    .sub speak :method
        .local string name, sound
        name = self.&#39;getname&#39;()
        sound = self.&#39;sound&#39;()
        print name
        print &#34; says &#34;
        print sound
        print &#34;\n&#34;
    .end

    .namespace [ &#34;Cow&#34; ]

    .sub sound :method
        .return( &#34;moo&#34; )
    .end

    .namespace [ &#34;Dog&#34; ]

    .sub sound :method
        .return( &#34;woof&#34; )
    .end

    .namespace [ &#34;Pig&#34; ]

    .sub sound :method
        .return( &#34;oink&#34; )
    .end

    .namespace

    .sub _ :main
        $P0 = newclass &#34;Animal&#34;
        addattribute $P0, &#34;name&#34;
        $P0 = subclass &#34;Animal&#34;, &#34;Cow&#34;
        $P0 = subclass &#34;Animal&#34;, &#34;Dog&#34;
        $P0 = subclass &#34;Animal&#34;, &#34;Pig&#34;

        .local pmc cow, dog, pig

        cow   = new &#34;Cow&#34;
        cow.&#39;setname&#39;(&#34;Elsie&#34;)
        dog    = new &#34;Dog&#34;
        dog.&#39;setname&#39;(&#34;Snoopy&#34;)
        pig   = new &#34;Pig&#34;
        pig.&#39;setname&#39;(&#34;Porky&#34;)
        
        cow.&#39;speak&#39;()
        dog.&#39;speak&#39;()
        pig.&#39;speak&#39;()
    .end</pre>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../resources/parrot_small.png"
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
