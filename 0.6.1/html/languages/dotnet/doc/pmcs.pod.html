<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
    <HEAD>
        <TITLE>Untitled</TITLE>
        <LINK REL="stylesheet" TYPE="text/css"
            HREF="../../../../resources/perl.css"
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY>
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Untitled</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../../html/index.html">Contents</a> | <a href="../../../../html/languages.html">Language Implementations</a> | <a href="../../../../html/dotnet.html">.Net</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="PMCs"
>PMCs <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>This document details the PMCs (Parrot Magic Cookies) that are used to read in .NET assemblies and provide access to the data held in them from PIR.</p>

<h2><a name="DotNetAssembly"
>DotNetAssembly <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>This PMC represents an entire .NET CLI EXE or DLL file.
It handles loading of a .NET assembly and instantiates all other PMCs that relate to the assembly.
It also provides access to some of the global data</p>

<h3><a name="Synopsis"
>Synopsis</a></h3>

<pre lang='und' xml:lang='und'>  # Load an .NET CLI DLL or EXE file.
  $P1 = new .DotNetAssembly
  $P1 = &#34;Example.dll&#34;
  $P1.load()
  
  # Get name of loaded file.
  $S1 = $P1
  
  # Is it a DLL?
  $I1 = $P1.is_dll()
  if $I1 = 0 goto EXE
  print &#34;This is a DLL\n&#34;
  goto CONTINUE
EXE:
  print &#34;This is an EXE file\n&#34;
CONTINUE:
  
  # Get an array of classes.
  $P2 = $P1.get_classes()
  
  # Get the globals pseudo&#45;class.
  $P3 = $P1.get_global()</pre>

<h3><a name="Vtable_Methods"
>Vtable Methods</a></h3>

<h4><a name="set_string_native"
>set_string_native</a></h4>

<p>Sets the filename of the .NET assembly to be loaded.</p>

<h4><a name="get_string"
>get_string</a></h4>

<p>Gets the filename of the .NET assembly that is loaded or to be loaded.</p>

<h3><a name="Additional_Methods"
>Additional Methods</a></h3>

<p>With the exception of load, all of these methods should only be called when after the load method.</p>

<h4><a name="void_load()"
>void load()</a></h4>

<p>Attempts to load the .NET assembly whose filenmae is stored in the string representation of the PMC.</p>

<h4><a name="INTVAL_is_dll()"
>INTVAL is_dll()</a></h4>

<p>Returns a non&#45;zero integer if the file is a DLL and zero otherwise.</p>

<h4><a name="STRING*_get_internal_string(INTVAL_i)"
>STRING* get_internal_string(INTVAL i)</a></h4>

<p>Gets the string with at the position identifier i from the strings heap. This is the string heap that is used for internal identifiers and are UTF&#45;8 encoded.</p>

<h4><a name="STRING*_get_user_string(INTVAL_i)"
>STRING* get_user_string(INTVAL i)</a></h4>

<p>Gets the string at position i from the user strings heap. This is the string heap that is used for strings that make up various bits of user data. Strings on the user heap are encoded as 16&#45;bit unicode.</p>

<h4><a name="STRING*_get_blob(INTVAL_i)"
>STRING* get_blob(INTVAL i)</a></h4>

<p>Gets the blob at position i from the blobs heap. A blob is a lump of binary data; Parrot strings can handle these fine, though.</p>

<h4><a name="PMC*_get_classes()"
>PMC* get_classes()</a></h4>

<p>Returns a PMC array of classes that are defined by the assembly. Each element of the PMC array will be a DotNetClassMetadata PMC.</p>

<h4><a name="PMC*_get_class_order()"
>PMC* get_class_order()</a></h4>

<p>Returns an integer array specifying indexes into the PMC array of classes as returned by the get_classes method. This array provides an ordering that ensures parent types come before their children.</p>

<h4><a name="PMC*_get_global()"
>PMC* get_global()</a></h4>

<p>Returns a DotNetClassMetadata PMC representing the global pseudoclass. The fields and methods of this class are global variables/subs.</p>

<h4><a name="PMC*_get_field(INTVAL_i)"
>PMC* get_field(INTVAL i)</a></h4>

<p>Returns a DotNetFieldMetadata PMC representing the field at the given row of the Field metadata table.</p>

<h4><a name="PMC*_get_method(INTVAL_i)"
>PMC* get_method(INTVAL i)</a></h4>

<p>Returns a DotNetMethodMetadata PMC representing the method at the given row of the MethodDef metadata table.</p>

<h4><a name="PMC*_get_typerefs()"
>PMC* get_typerefs()</a></h4>

<p>Returns a PMC array of DotNetTypeRefMetadata PMCs, each one representing a type from an external module or assembly.</p>

<h4><a name="PMC*_get_memberrefs()"
>PMC* get_memberrefs()</a></h4>

<p>Returns a PMC array of DotNetMemberRefMetadata PMCs, each one representing a field or method (aka member) from an external module or assembly.</p>

<h2><a name="DotNetClassMetadata"
>DotNetClassMetadata <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>This PMC represents the metadata associated with a particular class.</p>

<h3><a name="Synopsis"
>Synopsis</a></h3>

<pre lang='und' xml:lang='und'>  # Imagining $P2 is an array of DotNetClassMetadata PMCs...
  $P3 = $P2[0]
  
  # Get name and namespace.
  $S1 = $P3
  $S2 = $P3.get_namespace()
  
  # Get flags bit vector
  $I1 = $P3.get_flags()
  
  # Get fields and methods.
  $P4 = $P3.get_fields()
  $P5 = $P3.get_methods()</pre>

<h3><a name="Vtable_methods"
>Vtable methods</a></h3>

<h4><a name="get_string"
>get_string</a></h4>

<p>Gets the name of the class.</p>

<h3><a name="Additional_methods"
>Additional methods</a></h3>

<h4><a name="get_namespace"
>get_namespace</a></h4>

<p>Returns a string that is the namespace the class is in.</p>

<h4><a name="get_flags"
>get_flags</a></h4>

<p>Returns a bit vector of flags set on the method. For details of what the flags mean, see Partition II Clause 22.1.4 of the .NET Specification.</p>

<h4><a name="PMC*_get_fields()"
>PMC* get_fields()</a></h4>

<p>Returns a PMC array of fields belonging to this class. Each element of the PMC array will be a DotNetFieldMetadata PMC.</p>

<h4><a name="PMC*_get_methods()"
>PMC* get_methods()</a></h4>

<p>Returns a PMC array of methods belonging to this class. Each element of the PMC array will be a DotNetMethodMetadata PMC.</p>

<h4><a name="get_parent_id()"
>get_parent_id()</a></h4>

<p>Returns the ID of the parent class.</p>

<h4><a name="get_parent_type()"
>get_parent_type()</a></h4>

<p>Returns the type of the parent class ID &#45; that is, whether it is a type in the current assembly or in another one.</p>

<h4><a name="get_interface_ids()"
>get_interface_ids()</a></h4>

<p>Returns an integer array PMC containing the IDs of the interfaces that the type implements.</p>

<h4><a name="get_interface_types()"
>get_interface_types()</a></h4>

<p>Returns an integer array PMC containing the type of each of the IDs that was returned by get_interface_ids.</p>

<h2><a name="DotNetMethodMetadata"
>DotNetMethodMetadata <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>This PMC represents the metadata associated with a particular method. Note that some additional metadata about a method is stored in a seperate header preceding the instruction stream itself. This data is not accessible through this PMC; the DotNetBytecode PMC provides access to that.</p>

<h3><a name="Synopsis"
>Synopsis</a></h3>

<pre lang='und' xml:lang='und'>  # Imagine $P1 contains an array of DotNetMethodMetadata PMCs...
  $P2 = $P1[0]
  
  # Get the name of the method.
  $S1 = $P2
  
  # Get the position of the blob holding a signature for the method.
  $I0 = $P2.get_signature()
  
  # Get flags bit vector
  $I1 = $P2.get_flags()
  
  # Get the method implementation (a DotNetBytecode PMC).
  $P4 = $P2.get_bytecode()
  
  # Get parameters (an array of DotNetParamMetadata PMCs).
  $P5 = $P2.get_params()</pre>

<h3><a name="Vtable_methods"
>Vtable methods</a></h3>

<h4><a name="get_string"
>get_string</a></h4>

<p>Gets the name of the method.</p>

<h3><a name="Additional_methods"
>Additional methods</a></h3>

<h4><a name="get_signature"
>get_signature</a></h4>

<p>Returns an integer specifying the position in the blobs heap of the signature for the method.</p>

<h4><a name="get_flags"
>get_flags</a></h4>

<p>Returns a bit vector of flags set on the method. For details of what the flags mean, see Partition II Clause 22.1.9 of the .NET Specification.</p>

<h4><a name="get_bytecode"
>get_bytecode</a></h4>

<p>Returns a DotNetBytecode PMC that allows the bytecode that specifies the method body to be walked over easily.</p>

<h4><a name="get_params"
>get_params</a></h4>

<p>Returns a PMC array of DotNetParamMetadata PMCs, one describing each of the parameters of the method.</p>

<h2><a name="DotNetFieldMetadata"
>DotNetFieldMetadata <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>This PMC represents the metadata associated with a particular field.</p>

<h3><a name="Synopsis"
>Synopsis</a></h3>

<pre lang='und' xml:lang='und'>  # Imagine $P1 contains an array of DotNetFieldMetadata PMCs...
  $P2 = $P1[0]
  
  # Get the name of the field.
  $S1 = $P2
  
  # Get the position of the blob holding a signature for the field.
  $I0 = $P2.get_signature()
  
  # Get flags bit vector
  $I1 = $P2.get_flags()</pre>

<h3><a name="Vtable_Methods"
>Vtable Methods</a></h3>

<h4><a name="get_string"
>get_string</a></h4>

<p>Gets the name of the field.</p>

<h3><a name="Additional_Methods"
>Additional Methods</a></h3>

<h4><a name="get_signature"
>get_signature</a></h4>

<p>Returns an integer specifying the position in the blobs heap of the signature for the field.</p>

<h4><a name="get_flags"
>get_flags</a></h4>

<p>Returns a bit vector of flags set on the field. For details of what the flags mean, see Partition II Clause 22.1.5 of the .NET Specification.</p>

<h3><a name="TODO"
>TODO</a></h3>

<p>No handling of fields with some RVAs.</p>

<h2><a name="DotNetParamMetadata"
>DotNetParamMetadata <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>This PMC represents a parameter of a method.</p>

<h3><a name="Synopsis"
>Synopsis</a></h3>

<pre lang='und' xml:lang='und'>  # Imagine $P1 contains an array of DotNetParamMetadata PMCs...
  $P2 = $P1[0]
  
  # Get the name of the parameter.
  $S1 = $P2
  
  # Get flags for the parameter.
  $I0 = $P2.get_flags()
  
  # Get sequence number.
  $I1 = $P2.get_sequence()</pre>

<h3><a name="Vtable_Methods"
>Vtable Methods</a></h3>

<h4><a name="get_string"
>get_string</a></h4>

<p>Gets the name of the parameter.</p>

<h3><a name="Additional_Methods"
>Additional Methods</a></h3>

<h4><a name="get_flags"
>get_flags</a></h4>

<p>Returns a bit vector of flags set on the parameter. For details of what the flags mean, see Partition II Clause 22.1.12 of the .NET Specification.</p>

<h4><a name="get_sequence"
>get_sequence</a></h4>

<p>Returns an integer specifying the sequence number of the parameter. This is the position of the parameter. Sequence number 0 corresponds to the return value rather than a parameter. Sequence numbers should then increase, according to the .NET specification, however gaps are allowed. Quite what a gap in the sequence would imply is unclear, however.</p>

<h2><a name="DotNetSignature"
>DotNetSignature <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Signatures in .NET are represented as binary blobs of data. This PMC, one assigned a string representing a blob, provides some assistance to programs walking signatures, hiding away the compression scheme. This PMC does not understand the structure of different types of signature.</p>

<h3><a name="Synopsis"
>Synopsis</a></h3>

<pre lang='und' xml:lang='und'>  $P0 = new DotNetSignature
  $S0 = assembly.get_blob(blob_position)
  $P0 = $S0
  type = $P0.read_byte()
  # etc</pre>

<h3><a name="Vtable_Methods"
>Vtable Methods</a></h3>

<h4><a name="set_string_native"
>set_string_native</a></h4>

<p>Assigns a string containing the concents of the signature blob. This must be done before any other operations are performed or an exception will be thrown. Doing this also resets the current internal position pointer to zero.</p>

<h3><a name="Additional_Methods"
>Additional Methods</a></h3>

<h4><a name="read_uint8"
>read_uint8</a></h4>

<p>Reads 1 unsigned byte of data. Updates the internal current position pointer.</p>

<h4><a name="read_compressed"
>read_compressed</a></h4>

<p>Reads a compressed integer, compressed according to the method described in Partition II Section 22.2 of the .NET specification. Updates the current internal position pointer.</p>

<h2><a name="DotNetBytecode"
>DotNetBytecode <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>This PMC provides useful methods for walking .NET CLI instruction streams and accessing data in the metadata encoded within the instruction stream, rather than the main metadata tables.</p>

<h3><a name="Synopsis"
>Synopsis</a></h3>

<pre lang='und' xml:lang='und'>  $P0.set_pos(0)
  $I0 = $P0.read_uint8()
  $N0 = $P0.read_float32()
  $I1 = $P0.get_pos() # $I1 will contain 5</pre>

<h3><a name="Vtable_Methods"
>Vtable Methods</a></h3>

<p>None.</p>

<h3><a name="Additional_Methods"
>Additional Methods</a></h3>

<h4><a name="get_locals_sig"
>get_locals_sig</a></h4>

<p>Returns an integer specifying the position in the blobs heap of the signature for the local variables of the method.</p>

<h4><a name="init_locals"
>init_locals</a></h4>

<p>Returns an integer that is 0 if the initialize locals flag is set for the method and a non&#45;zero value if it is.</p>

<h4><a name="get_eh"
>get_eh</a></h4>

<p>Returns a PMC array of DotNetEH (.NET exception handdler info) PMCs.</p>

<h4><a name="get_pos"
>get_pos</a></h4>

<p>Returns an integer value specifying the current offset into the instruction stream that is being held. This position is changed when any of the read_* methods are called.</p>

<h4><a name="set_pos"
>set_pos</a></h4>

<p>Sets the current offset into the instruction stream that is being held.</p>

<h4><a name="read_int8"
>read_int8</a></h4>

<p>Reads a signed 8&#45;bit integer and returns it as a native sized integer. Increments the current read position by 1 byte.</p>

<h4><a name="read_uint8"
>read_uint8</a></h4>

<p>Reads an unsigned 8&#45;bit integer and returns it as a native sized integer. Increments the current read position by 1 byte.</p>

<h4><a name="read_int16"
>read_int16</a></h4>

<p>Reads a signed 16&#45;bit integer and returns it as a native sized integer. Increments the current read position by 2 bytes.</p>

<h4><a name="read_uint16"
>read_uint16</a></h4>

<p>Reads an unsigned 16&#45;bit integer and returns it as a native sized integer. Increments the current read position by 2 bytes.</p>

<h4><a name="read_int32"
>read_int32</a></h4>

<p>Reads a signed 32&#45;bit integer and returns it as a native sized integer. Increments the current read position by 4 bytes.</p>

<h4><a name="read_uint32"
>read_uint32</a></h4>

<p>Reads an unsigned 32&#45;bit integer and returns it as a native sized integer. Increments the current read position by 4 bytes.</p>

<h4><a name="read_float32"
>read_float32</a></h4>

<p>Reads a 32&#45;bit (single precision) float and returns it as the native sized floating point number type used for Parrot&#39;s N registers. Increments the current read position by 4 bytes.</p>

<h4><a name="read_float64"
>read_float64</a></h4>

<p>Reads a 64&#45;bit (single precision) float and returns it as the native sized floating point number type used for Parrot&#39;s N registers. Increments the current read position by 8 bytes.</p>

<h3><a name="TODO"
>TODO</a></h3>

<p>Subtle issues relating to 32&#45;bit unsigned integers and I registers, 64&#45;bit integers.</p>

<h2><a name="DotNetTypeRefMetadata"
>DotNetTypeRefMetadata <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>This PMC represents the metadata associated with a type in an external module.</p>

<h3><a name="Synopsis"
>Synopsis</a></h3>

<pre lang='und' xml:lang='und'>  # Imagining $P2 is an array of DotNetTypeRefMetadata PMCs...
  $P3 = $P2[0]
  
  # Get name and namespace.
  $S1 = $P3
  $S2 = $P3.get_namespace()
  
  # Get resolution scope.
  $I1 = $P3.get_resolution_scope()</pre>

<h3><a name="Vtable_methods"
>Vtable methods</a></h3>

<h4><a name="get_string"
>get_string</a></h4>

<p>Gets the name of the class.</p>

<h3><a name="Additional_methods"
>Additional methods</a></h3>

<h4><a name="get_namespace"
>get_namespace</a></h4>

<p>Returns a string that is the namespace the class is in.</p>

<h4><a name="get_resolution_scope"
>get_resolution_scope</a></h4>

<p>Returns an integer that defines the module or assembly containing the implementation of the type.</p>

<h2><a name="DotNetMemberRefMetadata"
>DotNetMemberRefMetadata <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>XXX TO DO</p>

<h2><a name="DotNetEH"
>DotNetEH <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>XXX TO DO</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../../resources/parrot_small.png"
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
