<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Untitled</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Untitled</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../html/index.html">Contents</a> | <a href="../../../html/docs.html">Documentation</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="SEATBELTS"
>SEATBELTS <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>DEFINITELY UNDER CONSTRUCTION</p>

<p>I&#39;m trying to create as many seat belts and idiot lights as possible.
Using C macros and automatic function declaration generation makes this much easier for me to do,
and is far more maintainable.</p>

<p>Headerizer creates function declarations based on function definitions.
It scans the source files passed to it and extracts the function declarations.
Then it puts them into the appropriate .h file or,
in the case of static functions,
back into the source file itself.</p>

<p>The headerizer also adds function attributes as specified by the decorations on the source.</p>

<p>All of these macros are GCC&#45;specific right now,
but soon will have equivalent semantics for lint added to them.
This will make lint a far more powerful tool.
If/when we ever get splint going,
too,
we can add semantics there as well.</p>

<h1><a name="What&#39;s_a_shim?"
>What&#39;s a shim? <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Think of &#34;shim&#34; as shorthand for &#34;placeholder&#34;.
It&#39;s 64% shorter.</p>

<p>GCC (and lint and splint) likes to complain (as well it should) if you pass an argument into a function and don&#39;t use it.
If we know that we&#39;re not going to use an argument,
we can either remove the argument from the function declaration,
or mark it as unused.</p>

<p>Throwing the argument away is not always possible.
Usually,
it&#39;s because the function is one that gets referred to by a function pointer,
and all functions of this group must have the same,
say,
three args: Interp,
Foo and Bar.
Maybe a given function doesn&#39;t use Foo,
but we still have to accept Foo.
In this case,
we can in the body of the func,
<code lang='und' xml:lang='und'>UNUSED(Foo)</code>,
if we plan to use it in the future.
Or,
if we never will use it,
mark it as a <code lang='und' xml:lang='und'>SHIM(Foo)</code> in the declaration.</p>

<h1><a name="Decorators"
>Decorators <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<h2><a name="Function_decorators"
>Function decorators <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>XXX CLEAN THIS UP</p>

<p>* `/* WARN_UNUSED */` ** Use this to flag functions where it is definitely an error to call it without checking its return value.
** Headerizes to `__attribute__warn_unused_result__` * `/* MALLOC */` ** Denotes functions that return a new piece of memory,
such that losing the return value would cause a memory leak.
** Headerizes to `__attribute__malloc__` * `/* CONST */` ** For functions that operate only on their operands,
do not use global memory,
and have no side effects.
The compiler can optimize away repeated calls to CONST functions.
mod() is a good example.
rand() is an anti&#45;example.
Note that this sense of const is unrelated to the const qualifier on variables.
** Headerizes to `__attribute__malloc__` * `/* PURE */` ** Less stringent than CONST.
Can check global memory or dereference pointers.
strlen() is a good example.
** Headerizes to `__attribute__pure__` * `/* NORETURN */` ** For functions that never return.
This can help the compiler&#39;s program flow analysis.
Functions like exit() the compiler already knows about,
but others like internal_exception() we have to tell it about.
** Headerizes to `__attribute__noreturn__`</p>

<h2><a name="Function_argument_decorators"
>Function argument decorators <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>* `/* NN */` ** GCC warns if it determines that a NULL could be passed to this argument.
** Headerizes to `__attribute__nonnull__` * SHIM(int foo) ** Squelches warnings about being unused,
and since it manges the argument name,
you can&#39;t accidentally use the argument without specfically unshimming the argument.
** Headerizes to `int foo_unused __attribute__unused__`.</p>

<h2><a name="Interpreters"
>Interpreters <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>There are only two states for the interpreter: Used,
or shimmed.
If we&#39;re using it,
it has to be /NN/.
(Except in a couple of cases like real_exception) The interpreter is so common in functions,
we give it its own two macros: INTERP and SHIM_INTERP.</p>

<p>* `SHIM_INTERP` ** Headerizes to `SHIM(Interp *interp)` ** Because it&#39;s shimmed,
we&#39;re guaranteed we won&#39;t accidentally use it.
* `INTERP` ** Any interpreter that isn&#39;t a shimmed interpreter must be non&#45;null.
** Headerizes to `Interp *interp /*NN*/`</p>

<h1><a name="Examples"
>Examples <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<pre lang='und' xml:lang='und'>    PARROT_API
    PARROT_WARN_UNUSED_RESULT
    INTVAL
    string_str_index(PARROT_INTERP, NOTNULL(const STRING *s),
            NOTNULL(const STRING *s2), INTVAL start)</pre>

<p><code lang='und' xml:lang='und'>string_str_index</code> is part of the Parrot API, and returns an INTVAL. The interpreter is used somewhere in the function. String <code lang='und' xml:lang='und'>s</code> and <code lang='und' xml:lang='und'>s2</code> cannot be NULL. If the calling function ignores the return value, it&#39;s an error, because you&#39;d never want to call <code lang='und' xml:lang='und'>string_str_index()</code> without wanting to know its value.</p>

<pre lang='und' xml:lang='und'>    PARROT_API
    PARROT_PURE_FUNCTION
    INTVAL
    parrot_hash_size(SHIM_INTERP, NOTNULL(const Hash *hash))
    {
        return hash&#45;&#62;entries;
    }</pre>

<p>This function is a pure function because it only looks at its parameters or global memory. The interpreter doesn&#39;t get used, but needs to be passed because all PARROT_API functions have interpreters passed, so is flagged as a SHIM_INTERP.</p>

<p>We could put <code lang='und' xml:lang='und'>PARROT_WARN_UNUSED_RESULT</code> on this function, but since all <code lang='und' xml:lang='und'>PARROT_PURE_FUNCTION</code>s and <code lang='und' xml:lang='und'>PARROT_CONST_FUNCTION</code>s get flagged that way anyway, there&#39;s no need.</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
