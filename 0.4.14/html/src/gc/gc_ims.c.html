<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Incremental mark and sweep garbage collection</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Incremental mark and sweep garbage collection</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../html/index.html">Contents</a> | <a href="../../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>src/gc_ims.c &#45; Incremental mark and sweep garbage collection</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>The following comments describe a new garbage collection scheme for Parrot.</p>

<p>The scheme of this algorithm is described in the literature with these keywords:</p>

<pre lang='und' xml:lang='und'> &#45; non&#45;copying, mark &#38; sweep
 &#45; incremental
 &#45; realtime
 &#45; incremental update with write barrier</pre>

<p>Further we might try this optimization</p>

<pre lang='und' xml:lang='und'> &#45; treadmill optimization or
 &#45; implict reclamation</pre>

<h1><a name="Drawbacks_of_the_current_mark_and_sweep_collector."
>Drawbacks of the current mark and sweep collector. <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<pre lang='und' xml:lang='und'> * can take arbitrary time to complete (1s for 1 Meg objects)
 * can&#39;t be used in multi&#45;threaded Parrot
 * works fast for plain (non&#45;aggregate) objects but suffers badly
   for nested aggregates or HLL objects
 * the sweep phase takes time proportional to the allocated storage</pre>

<h1><a name="INCREMENTAL_GARBAGE_COLLECTION"
>INCREMENTAL GARBAGE COLLECTION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<h2><a name="Terms"
>Terms <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="object"
>object</a></dt><p class="pad"></p>

<dd>An item like a buffer header or a PMC which is managed by Parrot&#39;s dynamic memory system.</dd><p class="pad"></p>

<dt><a name="aggregate"
>aggregate</a></dt><p class="pad"></p>

<dd>An object that possibly holds references to other objects. For example an array, hash, or reference PMC.</dd><p class="pad"></p>

<dt><a name="tri&#45;color_marking"
>tri&#45;color marking</a></dt><p class="pad"></p>

<dd>All objects have one of three colors: white, grey, or black.</dd><p class="pad"></p>

<dd>At the beginning of a DOD run all objects are white (not yet visited). During marking objects are greyed (visited &#45; found alive), but their contents isn&#39;t yet scanned. A fully scanned grey object gets finally colored black. It will not again be rescanned in this DOD run.</dd><p class="pad"></p>

<dd>Only aggregates can be grey, non&#45;containers are blackened immediately.</dd><p class="pad"></p>

<dd>Objects on the free&#45;list are sometimes denoted having the color off&#45;white or ecru.</dd><p class="pad"></p>

<dt><a name="DOD"
>DOD</a></dt><p class="pad"></p>

<dd>Dead object detection. Please note that in Parrot src and docs this stands for the stop&#45;the&#45;world garbage collector that recycles objects.</dd><p class="pad"></p>

<dt><a name="GC"
>GC</a></dt><p class="pad"></p>

<dd>In Parrot tree the copying garbage collector that recycles string and buffer memory. Configure.pl has a switch to use a malloc library instead, which makes string and buffer memory non&#45;moving.</dd><p class="pad"></p>

<dt><a name="collector"
>collector</a></dt><p class="pad"></p>

<dd>The DOD and reclamation system.</dd><p class="pad"></p>

<dt><a name="mutator"
>mutator</a></dt><p class="pad"></p>

<dd>The normal operation of the program which may or may not change the collectors view of objects.</dd><p class="pad"></p>

<dt><a name="incremental"
>incremental</a></dt><p class="pad"></p>

<dd>Garbage collection and normal program operation is interleaved. This guarantees short and bounded pause times. Garbage collection doesn&#39;t significantly interrupt program execution, collector and mutator are running pseudo&#45;parallel.</dd><p class="pad"></p>

<dt><a name="root_set"
>root set</a></dt><p class="pad"></p>

<dd>All structures in the interpreter that might point to objects. E.g. stacks, globals, and of course the registers. All objects the interpreter works with, are directly or indirectly reachable starting from the root set.</dd><p class="pad"></p>

<dt><a name="the_tri&#45;color_invariant"
>the tri&#45;color invariant</a></dt><p class="pad"></p>

<dd>At no time a black object may reference a white one directly. Actually this is the strong incarnation of the invariant &#45; all paths from black objects to white objects lead over at least one grey object.</dd><p class="pad"></p>

<dd>The weak tri&#45;color invariant is: there is at least one such path to a white object, so that it&#39;s reachable.</dd><p class="pad"></p>

<dd>The strong invariant is the basic idea of mark and sweep too. But as the mutator isn&#39;t running during DOD the invariant is never violated.</dd><p class="pad"></p>

<dd>Due to this invariant, after the root set has been marked and when all greyed objects are marked (blackened), the white objects have to be dead.</dd><p class="pad"></p>

<dt><a name="paint_it_black"
>paint it black</a></dt><p class="pad"></p>

<dd>Or, which color do new objects have?</dd><p class="pad"></p>

<dd>Actually this should be tunable. Or it depends. If objects are born white and die immediately, they get collected in the same GC cycle. OTOH when these objects are stored into an existing (black) array, we have to do more work to keep the tri&#45;color invariant valid.</dd><p class="pad"></p>

<dd>Anyway, when allocating new objects white, the collector must run more often or must do more work per increment to make the algorithm stop somewhen.</dd><p class="pad"></p>

<dt><a name="write_barrier"
>write barrier</a></dt><p class="pad"></p>

<dd>To keep the tri&#45;color invariant valid all pointer stores into black objects have to be tracked. If a white object would be stored into a black array, and this object isn&#39;t refered to by another object it would get collected. The write barrier greys the white object, so that it get scanned later or alternatively greys the aggregate for a rescan. The latter can be better, if a sequence of such stores would happen.</dd><p class="pad"></p>
</dl>

<h2><a name="Data_structure_overview"
>Data structure overview <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>The incremental mark and sweep collector has an additional structure in the arena_base that keeps track of the collector&#39;s state. Pool and arena structures are unchanged. Only the allocation of new arena blocks is done much more fine grained in e.g. 8K blocks.</p>

<h2><a name="Implicit_reclamation_(optional)"
>Implicit reclamation (optional) <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="from&#45;space"
>from&#45;space</a></dt><p class="pad"></p>

<dd>The graph of all objects found live during the last collection.</dd><p class="pad"></p>

<dt><a name="to&#45;space"
>to&#45;space</a></dt><p class="pad"></p>

<dd>The work area of the collector. During marking live objects are &#34;moved&#34; from the from&#45;space into the to&#45;space. This is the same as the text_for_GC list used in src/dod.c. The to&#45;space is initially empty. During marking it gets greyed and finally all reachable objects are black.</dd><p class="pad"></p>

<dt><a name="free&#45;list"
>free&#45;list</a></dt><p class="pad"></p>

<dd>New objects are allocated from the free&#45;list. The free&#45;list is adjacent to the to&#45;space. Allocating a new objects thus means, moving the free pointer one word forward and paint the new object black.</dd><p class="pad"></p>
</dl>

<p>All objects get two additional pointers (forward, backward) and are arranged like in this scheme:</p>

<pre lang='und' xml:lang='und'>    &#60;&#45;&#45; allocation direction         marking &#45;&#45;&#62;
            |                          |
  [w] &#60;&#45;&#45;&#62; [w] &#60;&#45;&#45;&#62; [b] &#60;&#45;&#45;&#62; [b] &#60;&#45;&#45;&#62; [g] &#60;&#45;&#45;&#62; [g] &#60;&#45;&#45;&#62; [w] &#60;&#45;&#62; [w]

            ^        ^                 ^                 ^
            |        |                 |                 |
   free&#45;list&#45;ptr     to&#45;space          scan&#45;pointer      from&#45;space</pre>

<p>Objects get &#34;moved&#34; during collection by rearranging the doubly&#45;linked object pointers. At the end of a DOD run (when the last grey object is blackened), the from&#45;space and the free&#45;list are merged serving as the new free&#45;list of the next DOD cycle. This operation is just a few pointer manipulations that replaces the sweep phase of a mark and sweep collector.</p>

<h2><a name="Phases_of_operation"
>Phases of operation <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="a)_initialization"
>a) initialization</a></dt><p class="pad"></p>

<dd>After interpreter creation the DOD system is initialized by marking parts of the root set (globals, internal structures).</dd><p class="pad"></p>

<dt><a name="b)_program_operation"
>b) program operation</a></dt><p class="pad"></p>

<dd>For each bunch of allocated objects (A) the collector does k.A work, for some constant k &#62; 1. As new objects are allocated black the number of whites is reduced steadily. This means that the throttle factor k could be less then one too, but this could highly increase average memory usage.</dd><p class="pad"></p>

<dd>To keep the memory usage limited k &#62; 1 must hold.</dd><p class="pad"></p>

<dt><a name="c)_near_the_end_of_a_DOD_cycle"
>c) near the end of a DOD cycle</a></dt><p class="pad"></p>

<dd>The rest of the root set is scanned, i.e. the registers. By deferring scanning of registers all temporaries that might have exist somewhen just stay unscanned &#45; they will be collected in this DOD cycle, if we allocate new objects white or in the next DOD cycle.</dd><p class="pad"></p>

<dt><a name="d)_finishing_a_DOD_cycle"
>d) finishing a DOD cycle</a></dt><p class="pad"></p>

<dd>The current sweep of the whole arena is done, or with implicit reclamation:</dd><p class="pad"></p>

<dd>Garbage gets appended to the free&#45;list by merging the unscanned from&#45;space with the free&#45;list, these objects are all considered white. All other items are in the to&#45;space and are black. These objects constitute the from&#45;space of the new collection cycle.</dd><p class="pad"></p>

<dd>Now he meaning of the black bit is reversed effectively setting the new from&#45;space to white.</dd><p class="pad"></p>

<dd>The next DOD cycle is initialized in one step a) and the new cycle starts.</dd><p class="pad"></p>

<dd>Alternatively the mutator could run and allocate objects for some time, without starting the collector again, if there are plenty of free objects on all free&#45;lists.</dd><p class="pad"></p>

<dt><a name="e)_collect_buffer_memory"
>e) collect buffer memory</a></dt><p class="pad"></p>

<dd>Finally, we might trigger a collect run on string and buffer memory if there is an impending shortage of resources. While the copying compactor is rather independent of the collector that cleans object headers, it&#39;s more efficient to collect buffer memory when the live information is accurate. This avoids copying of dead buffer memory.</dd><p class="pad"></p>
</dl>

<h2><a name="Comparison_with_our_current_mark_and_sweep_collector"
>Comparison with our current mark and sweep collector <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<pre lang='und' xml:lang='und'>  MS  ... mark and sweep (stop&#45;the&#45;world)
  IMS ... incremental mark and sweep
  IMIR .. incremental mark implicit reclamation

                       MS                 IMS               IMIR
  &#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;
  operation            stop&#45;the&#45;world     incremental       incremental
  time per DOD cycle   unbounded          bounded           bounded
  size overhead        1 word             1 word            2 words
  time overhead        O(2*live + dead)   O(2*live + dead)  O(live)   2)</pre>

<p>Notes:</p>

<pre lang='und' xml:lang='und'>  2) it should be possible to mark containers at once by using the
     information of the from&#45;space pointers and tracking changes
     to the aggregate.</pre>

<h2><a name="Implementation_details_and_unsorted_remarks"
>Implementation details and unsorted remarks <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="the_object_graph"
>the object graph</a></dt><p class="pad"></p>

<dd>The MS and IMS scheme use the next_for_GC pointer for keeping track of references. This interferes with the freeze functionality, which can use the same pointer to keep track of visited objects.</dd><p class="pad"></p>

<dd>IMIR has a dedicated pointer pair to build the object graph.</dd><p class="pad"></p>

<dt><a name="Greying_objects"
>Greying objects</a></dt><p class="pad"></p>

<dd>Greying objects is done depth&#45;first. This has much better cache locality then visiting an object again much later. In the picture above this means that grey objects are inserted at the left end of the mark chain immediately to the right of the object that gets blackened.</dd><p class="pad"></p>

<dt><a name="big_aggregates"
>big aggregates</a></dt><p class="pad"></p>

<dd>Greying has to be done in increments. Big aggregates can&#39;t have a mark vtable that could run arbitrarily long. This means that the DOD system must know the layout of arrays, hashes, and objects. This is currently true for arrays and objects but not for hashes. But the latter need some refactoring of internals anyway.</dd><p class="pad"></p>

<dd>To avoid visiting all aggregate elements, it could be better to track the graph of old aggregates by using a write barrier for all writes into the array. This would basically create a generational collector. The old generation (the aggregate) isn&#39;t scanned. But changes to this &#34;old generation&#34; are tracked and reflected in the collectors graph of objects.</dd><p class="pad"></p>

<dt><a name="timely_destruction"
>timely destruction</a></dt><p class="pad"></p>

<dd>The interpreter arena has a count of currently active objects that need timely destruction. When during scope exit an high priority sweep is triggered, we have basically two cases:</dd><p class="pad"></p>

<dd>1) all of these objects were already seen by this DOD run &#45; the scope exit can continue.</dd><p class="pad"></p>

<dd>2) Not all objects were seen &#45; they might be alive or not. This means that the DOD cycle must run to the end to decide, if these objects are alive (or again until all are found alive).</dd><p class="pad"></p>

<dd>To increase performance its likely that we need some additional information that keeps track of the location of such objects and just try to mark paths to objects that need timely destruction.</dd><p class="pad"></p>

<dt><a name="concurrent_or_parallel_collection"
>concurrent or parallel collection</a></dt><p class="pad"></p>

<dd>As the described algorithm is already incremental its well&#45;suited for parallel collection in a multi&#45;threaded Parrot. The work of greying objects can be done in parallel by atomically handling a bunch of objects to another thread. After doing some increments of marking, these objects then get returned to the shared to&#45;space. The parallel collection is finished when the last object is blackened and all threads have reached the thread barrier rendezvous point. (Please note the very different meaning of barrier here).</dd><p class="pad"></p>

<dd>But also a single&#45;threaded Parrot can vastly take advantage by running increments of the collection during waiting for I/O completion or during a sleep opcode.</dd><p class="pad"></p>
</dl>

<h1><a name="FUNCTIONS"
>FUNCTIONS <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>*/</p>

<p>#include &#34;parrot/parrot.h&#34; #include &#34;parrot/dod.h&#34; #include &#60;assert.h&#62;</p>

<p>/* HEADERIZER HFILE: include/parrot/dod.h */</p>

<p>/* HEADERIZER BEGIN: static */</p>

<p>static int collect_cb( PARROT_INTERP, NOTNULL(Small_Object_Pool *pool), int flag, NOTNULL(void *arg) ) __attribute__nonnull__(1) __attribute__nonnull__(2) __attribute__nonnull__(4);</p>

<p>static void gc_ims_add_free_object( PARROT_INTERP, NOTNULL(Small_Object_Pool *pool), NOTNULL(void *to_add) ) __attribute__nonnull__(1) __attribute__nonnull__(2) __attribute__nonnull__(3);</p>

<p>static void gc_ims_alloc_objects( PARROT_INTERP, NOTNULL(Small_Object_Pool *pool) ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>static void * gc_ims_get_free_object( PARROT_INTERP, NOTNULL(Small_Object_Pool *pool) ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>static void gc_ims_pool_init( SHIM_INTERP, NOTNULL(Small_Object_Pool *pool) ) __attribute__nonnull__(2);</p>

<p>static int parrot_gc_ims_collect( PARROT_INTERP, int check_only ) __attribute__nonnull__(1);</p>

<p>static void parrot_gc_ims_deinit( PARROT_INTERP ) __attribute__nonnull__(1);</p>

<p>static void parrot_gc_ims_mark( PARROT_INTERP ) __attribute__nonnull__(1);</p>

<p>static void parrot_gc_ims_reinit( PARROT_INTERP ) __attribute__nonnull__(1);</p>

<p>static void parrot_gc_ims_run( PARROT_INTERP, int flags ) __attribute__nonnull__(1);</p>

<p>static void parrot_gc_ims_run_increment( PARROT_INTERP ) __attribute__nonnull__(1);</p>

<p>static void parrot_gc_ims_sweep( PARROT_INTERP ) __attribute__nonnull__(1);</p>

<p>static int sweep_cb( PARROT_INTERP, NOTNULL(Small_Object_Pool *pool), int flag, NOTNULL(void *arg) ) __attribute__nonnull__(1) __attribute__nonnull__(2) __attribute__nonnull__(4);</p>

<p>/* HEADERIZER END: static */</p>

<p>/* * size of one arena */ #define ALLOCATION_BLOCK_SIZE 8192</p>

<p>/* * each ALLOCATIONS_INIT allocations of any object an incremental * step is triggered */ #define ALLOCATIONS_INIT 1024*4</p>

<p>/* * a mark step does allocations * throttle work */ #define THROTTLE 1.3</p>

<p>/* * if we have at the end total * refill free objects * we just do nothing */ #define REFILL_FACTOR 0.5</p>

<p>/* * we run the copying collector, if memory pool statistics indicate * that this amount of the total size could be freed * * This factor also depends on the allocation color of buffer headers, * which is set to black now. So we are always one DOD cycle behind * and the statistics are rather wrong. */ #define MEM_POOL_RECLAIM 0.2</p>

<p>#if 0 # define IMS_DEBUG(x) fprintf x #else # define IMS_DEBUG(x) #endif</p>

<p>typedef enum { /* these states have to be in execution order */ GC_IMS_INITIAL, /* memory subsystem setup */ GC_IMS_STARTING, /* wait for DOD_block to clear */ GC_IMS_RE_INIT, /* start of normal operation &#45; mark root */ GC_IMS_MARKING, /* mark children */ GC_IMS_START_SWEEP, /* mark finished, start sweep buffers */ GC_IMS_SWEEP, /* sweep buffers */ GC_IMS_COLLECT, /* collect buffer memory */ GC_IMS_FINISHED, /* update statistics */ GC_IMS_CONSUMING, /* when we have plenty of free objects */ GC_IMS_DEAD /* gc is already shutdown */</p>

<p>} gc_ims_state_enum;</p>

<p>typedef struct Gc_ims_private { gc_ims_state_enum state; size_t allocations; /* get_free_object count */ size_t alloc_trigger; /* after this number of allocations a gc increment is triggered */ double throttle; /* throttle * allocations per increment work */ size_t increments; /* increment count */ int lazy; /* timely destruction run */ size_t n_objects; /* live count of prev run */ size_t n_extended_PMCs;/* PMCs found during mark_special */ } Gc_ims_private;</p>

<p>/*</p>

<p>FUNCDOC: gc_ims_add_free_object</p>

<p>Add object <code lang='und' xml:lang='und'>to_add</code> to the free_list in the given pool. <code lang='und' xml:lang='und'>pool&#45;</code>num_free_objects&#62; has to be updated by the caller.</p>

<p>FUNCDOC: gc_ims_get_free_object</p>

<p>Get a new object off the free_list in the given pool.</p>

<p>FUNCDOC: gc_ims_alloc_objects</p>

<p>Allocate new objects for the given pool.</p>

<p>*/</p>

<p>static void gc_ims_add_free_object(PARROT_INTERP, NOTNULL(Small_Object_Pool *pool), NOTNULL(void *to_add)) { *(void **)to_add = pool&#45;&#62;free_list; pool&#45;&#62;free_list = to_add; #if DISABLE_GC_DEBUG UNUSED(interp); #else if (GC_DEBUG(interp)) { if (pool == interp&#45;&#62;arena_base&#45;&#62;pmc_pool) { PMC * const p = (PMC *)to_add; p&#45;&#62;vtable = interp&#45;&#62;vtables[enum_class_Null]; } } #endif }</p>

<p>static void * gc_ims_get_free_object(PARROT_INTERP, NOTNULL(Small_Object_Pool *pool)) { PObj *ptr; Arenas * const arena_base = interp&#45;&#62;arena_base; Gc_ims_private * const g_ims = (Gc_ims_private *)arena_base&#45;&#62;gc_private;</p>

<pre lang='und' xml:lang='und'>    if (++g_ims&#45;&#62;allocations &#62;= g_ims&#45;&#62;alloc_trigger) {
        g_ims&#45;&#62;allocations = 0;
        parrot_gc_ims_run_increment(interp);
    }
    /* if we don&#39;t have any objects */
    if (!pool&#45;&#62;free_list)
        (*pool&#45;&#62;alloc_objects) (interp, pool);
    ptr             = (PObj *)pool&#45;&#62;free_list;
    pool&#45;&#62;free_list = *(void **)ptr;
    /*
     * buffers are born black, PMCs not yet?
     * XXX this does not solve the problem of storing keys in hashes
     *     in the next DOD cycle (if the key isn&#39;t marked elsewhere ?)
     */
    PObj_flags_SETTO(ptr, pool == arena_base&#45;&#62;pmc_pool ? 0 : PObj_live_FLAG);
    &#45;&#45;pool&#45;&#62;num_free_objects;
    return ptr;
}</pre>

<p>static void gc_ims_alloc_objects(PARROT_INTERP, NOTNULL(Small_Object_Pool *pool)) { Small_Object_Arena *new_arena; size_t size; UINTVAL start, end;</p>

<pre lang='und' xml:lang='und'>    pool&#45;&#62;objects_per_alloc  = ALLOCATION_BLOCK_SIZE / pool&#45;&#62;object_size;

    /* Setup memory for the new objects */
    new_arena                = mem_allocate_typed(Small_Object_Arena);
    size                     = ALLOCATION_BLOCK_SIZE;
    new_arena&#45;&#62;start_objects = mem_sys_allocate(size);

    Parrot_append_arena_in_pool(interp, pool, new_arena, size);

    start = 0;
    end = pool&#45;&#62;objects_per_alloc;
    Parrot_add_to_free_list(interp, pool, new_arena, start, end);
}</pre>

<p>static void gc_ims_pool_init(SHIM_INTERP, NOTNULL(Small_Object_Pool *pool)) { pool&#45;&#62;add_free_object = gc_ims_add_free_object; pool&#45;&#62;get_free_object = gc_ims_get_free_object; pool&#45;&#62;alloc_objects = gc_ims_alloc_objects; pool&#45;&#62;more_objects = pool&#45;&#62;alloc_objects; }</p>

<p>static void parrot_gc_ims_deinit(PARROT_INTERP) { Arenas * const arena_base = interp&#45;&#62;arena_base;</p>

<pre lang='und' xml:lang='und'>    mem_sys_free(arena_base&#45;&#62;gc_private);
    arena_base&#45;&#62;gc_private = NULL;
}</pre>

<p>/*</p>

<p>FUNCDOC: Parrot_gc_ims_init</p>

<p>Initialize the state structures of the gc system. Called immediately before creation of memory pools. This function must set the function pointers for <code lang='und' xml:lang='und'>add_free_object_fn</code>, <code lang='und' xml:lang='und'>get_free_object_fn</code>, <code lang='und' xml:lang='und'>alloc_objects_fn</code>, and <code lang='und' xml:lang='und'>more_objects_fn</code>.</p>

<p>*/</p>

<p>PARROT_API void Parrot_gc_ims_init(PARROT_INTERP) { Arenas * const arena_base = interp&#45;&#62;arena_base;</p>

<pre lang='und' xml:lang='und'>    arena_base&#45;&#62;gc_private = mem_sys_allocate_zeroed(sizeof (Gc_ims_private));
    /*
     * set function hooks according to pdd09
     */
    arena_base&#45;&#62;do_dod_run = parrot_gc_ims_run;
    arena_base&#45;&#62;de_init_gc_system = parrot_gc_ims_deinit;
    arena_base&#45;&#62;init_pool = gc_ims_pool_init;

    /*
     * run init state
     */
    parrot_gc_ims_run_increment(interp);
}</pre>

<p>/*</p>

<p>FUNCDOC: parrot_gc_ims_reinit</p>

<p>Reinitialize the collector for the next collection cycle.</p>

<p>*/</p>

<p>static void parrot_gc_ims_reinit(PARROT_INTERP) { Gc_ims_private *g_ims; Arenas * const arena_base = interp&#45;&#62;arena_base;</p>

<pre lang='und' xml:lang='und'>    arena_base&#45;&#62;lazy_dod = 0;
    Parrot_dod_ms_run_init(interp);
    /*
     * trace root set w/o system areas
     * TODO also skip volatile roots
     */
    Parrot_dod_trace_root(interp, 0);

    g_ims        = (Gc_ims_private *)arena_base&#45;&#62;gc_private;
    g_ims&#45;&#62;state = GC_IMS_MARKING;</pre>

<p>}</p>

<p>/*</p>

<p>FUNCDOC: parrot_gc_ims_mark</p>

<p>Mark a bunch of children.</p>

<p>The work depends on item counts with and without a next_for_GC field. The former are marked immediately, only the latter need real work here.</p>

<p>*/</p>

<p>static void parrot_gc_ims_mark(PARROT_INTERP) { size_t todo; double work_factor; PMC *next;</p>

<pre lang='und' xml:lang='und'>    Arenas * const arena_base    = (Arenas *)interp&#45;&#62;arena_base;
    Gc_ims_private * const g_ims = (Gc_ims_private *)arena_base&#45;&#62;gc_private;
    /*
     * use statistics from the previous run
     */
    if (g_ims&#45;&#62;n_objects) {
        work_factor = (double)g_ims&#45;&#62;n_extended_PMCs / g_ims&#45;&#62;n_objects;
    }
    else
        work_factor = 1.0;
    todo = (size_t)(g_ims&#45;&#62;alloc_trigger * g_ims&#45;&#62;throttle * work_factor);
    assert(arena_base&#45;&#62;lazy_dod == 0);
    Parrot_dod_trace_children(interp, todo);
    /*
     * check if we are finished with marking &#45; the end is
     * self&#45;referential
     */
    next = arena_base&#45;&#62;dod_mark_start;
    if (next == PMC_next_for_GC(next)) {
        g_ims&#45;&#62;state = GC_IMS_START_SWEEP;
    }
}</pre>

<p>/*</p>

<p>FUNCDOC: parrot_gc_ims_sweep</p>

<p>Free unused objects in all header pools.</p>

<p>TODO split work per pool.</p>

<p>*/</p>

<p>static int sweep_cb(PARROT_INTERP, NOTNULL(Small_Object_Pool *pool), int flag, NOTNULL(void *arg)) { int * const n_obj = (int *) arg;</p>

<pre lang='und' xml:lang='und'>    Parrot_dod_sweep(interp, pool);
    if (interp&#45;&#62;profile &#38;&#38; (flag &#38; POOL_PMC))
        Parrot_dod_profile_end(interp, PARROT_PROF_DOD_cp);
    *n_obj += pool&#45;&#62;total_objects &#45; pool&#45;&#62;num_free_objects;
    return 0;
}</pre>

<p>static void parrot_gc_ims_sweep(PARROT_INTERP) { Arenas * const arena_base = interp&#45;&#62;arena_base; Gc_ims_private *g_ims; size_t n_objects;</p>

<pre lang='und' xml:lang='und'>    IMS_DEBUG((stderr, &#34;\nSWEEP\n&#34;));
    g_ims = (Gc_ims_private *)arena_base&#45;&#62;gc_private;
    /*
     * as we are now gonna kill objects, make sure that we
     * have traced the current stack
     * except for a lazy run, which is invoked from the run loop
     */
    /* TODO mark volatile roots */
    Parrot_dod_trace_root(interp, g_ims&#45;&#62;lazy ? 0 : DOD_trace_stack_FLAG);
    /*
     * mark (again) rest of children
     */
    Parrot_dod_trace_children(interp, (size_t) &#45;1);
    /*
     * now sweep all
     */
    n_objects = 0;
    Parrot_forall_header_pools(interp, POOL_BUFFER | POOL_PMC,
            (void*)&#38;n_objects, sweep_cb);
    if (interp&#45;&#62;profile)
        Parrot_dod_profile_end(interp, PARROT_PROF_DOD_cb);
    g_ims&#45;&#62;state = GC_IMS_COLLECT;
    g_ims&#45;&#62;n_objects = n_objects;
    g_ims&#45;&#62;n_extended_PMCs = arena_base&#45;&#62;num_extended_PMCs;
}</pre>

<p>/*</p>

<p>FUNCDOC: parrot_gc_ims_collect</p>

<p>Run the copying collector in memory pools, if it could yield some free memory.</p>

<p>*/</p>

<p>#if !GC_IS_MALLOC static int collect_cb(PARROT_INTERP, NOTNULL(Small_Object_Pool *pool), int flag, NOTNULL(void *arg)) { const int check_only = (int)(INTVAL)arg; Memory_Pool *mem_pool; /* * check if there is an associated memory pool */ mem_pool = pool&#45;&#62;mem_pool; if (!mem_pool) return 0; /* * and if the memory pool supports compaction */ if (!mem_pool&#45;&#62;compact) return 0; /* * several header pools can share one memory pool * if that pool is already compacted, the following is zero */ if (!mem_pool&#45;&#62;guaranteed_reclaimable) return 0; /* * check used size */ if ((mem_pool&#45;&#62;possibly_reclaimable * mem_pool&#45;&#62;reclaim_factor + mem_pool&#45;&#62;guaranteed_reclaimable) &#62;= mem_pool&#45;&#62;total_allocated * MEM_POOL_RECLAIM) { IMS_DEBUG((stderr, &#34;COMPACT\n&#34;)); if (check_only) return 1; mem_pool&#45;&#62;compact(interp, mem_pool); } return 0; } #endif</p>

<p>static int parrot_gc_ims_collect(PARROT_INTERP, int check_only) { #if GC_IS_MALLOC UNUSED(interp); UNUSED(check_only); #else Arenas * const arena_base = interp&#45;&#62;arena_base; Gc_ims_private *g_ims; int ret;</p>

<pre lang='und' xml:lang='und'>    if (!check_only &#38;&#38; interp&#45;&#62;profile)
        Parrot_dod_profile_start(interp);
    g_ims = (Gc_ims_private *)arena_base&#45;&#62;gc_private;
    ret   = Parrot_forall_header_pools(interp, POOL_BUFFER,
            (void*)check_only, collect_cb);
    if (ret)
        return ret;
    if (check_only)
        return 0;
    if (interp&#45;&#62;profile)
        Parrot_dod_profile_end(interp, PARROT_PROF_GC);
    g_ims&#45;&#62;state = GC_IMS_FINISHED;
#endif
    return 0;
}</pre>

<p>/*</p>

<p>FUNCDOC: parrot_gc_ims_run_increment</p>

<p>Run one increment of collection. This function is triggered by object allocation.</p>

<p>*/</p>

<p>static void parrot_gc_ims_run_increment(PARROT_INTERP) { Arenas * const arena_base = interp&#45;&#62;arena_base; Gc_ims_private * const g_ims = (Gc_ims_private *)arena_base&#45;&#62;gc_private;</p>

<pre lang='und' xml:lang='und'>    if (arena_base&#45;&#62;DOD_block_level || g_ims&#45;&#62;state == GC_IMS_DEAD) {
        return;
    }
    ++g_ims&#45;&#62;increments;
    IMS_DEBUG((stderr, &#34;state = %d =&#62; &#34;, g_ims&#45;&#62;state));

    switch (g_ims&#45;&#62;state) {
        case GC_IMS_INITIAL:
            g_ims&#45;&#62;state = GC_IMS_STARTING;
            g_ims&#45;&#62;alloc_trigger = ALLOCATIONS_INIT;
            g_ims&#45;&#62;throttle = THROTTLE;
            break;
        case GC_IMS_STARTING:
            /*  fall through and start */
        case GC_IMS_RE_INIT:
            parrot_gc_ims_reinit(interp);
            break;

        case GC_IMS_MARKING:
            parrot_gc_ims_mark(interp);
            break;

        case GC_IMS_START_SWEEP:
            g_ims&#45;&#62;state = GC_IMS_SWEEP;
            /* fall through */
        case GC_IMS_SWEEP:
            parrot_gc_ims_sweep(interp);
            /* fall through */
        case GC_IMS_COLLECT:
            (void)parrot_gc_ims_collect(interp, 0);
            break;
        case GC_IMS_FINISHED:
            ++arena_base&#45;&#62;dod_runs;
            g_ims&#45;&#62;state = GC_IMS_CONSUMING;
            /* fall through */
        case GC_IMS_CONSUMING:
            /*
             * This currently looks only at PMCs and string_headers.
             * There shouldn&#39;t be other pools that could run out of
             * headers independent of PMCs
             */
            if (arena_base&#45;&#62;pmc_pool&#45;&#62;num_free_objects &#60;
                    arena_base&#45;&#62;pmc_pool&#45;&#62;total_objects * REFILL_FACTOR) {
                g_ims&#45;&#62;state = GC_IMS_STARTING;
            }
            else if (arena_base&#45;&#62;string_header_pool&#45;&#62;num_free_objects &#60;
                    arena_base&#45;&#62;string_header_pool&#45;&#62;total_objects *
                    REFILL_FACTOR) {
                g_ims&#45;&#62;state = GC_IMS_STARTING;
            }
            break;
        default:
            PANIC(interp, &#34;Unknown state in gc_ims&#34;);
    }
    IMS_DEBUG((stderr, &#34;%d\n&#34;, g_ims&#45;&#62;state));
}</pre>

<p>/*</p>

<p>FUNCDOC: parrot_gc_ims_run</p>

<p>Interface to <code lang='und' xml:lang='und'>Parrot_do_dod_run</code>. <code lang='und' xml:lang='und'>flags</code> is one of:</p>

<pre lang='und' xml:lang='und'>  DOD_lazy_FLAG   ... timely destruction
  DOD_finish_FLAG ... run until live bits are clear</pre>

<p>*/</p>

<p>static void parrot_gc_ims_run(PARROT_INTERP, int flags) { int lazy; Arenas * const arena_base = interp&#45;&#62;arena_base; Gc_ims_private * const g_ims = (Gc_ims_private *)arena_base&#45;&#62;gc_private;</p>

<pre lang='und' xml:lang='und'>    if (arena_base&#45;&#62;DOD_block_level || g_ims&#45;&#62;state == GC_IMS_DEAD) {
        return;
    }

    if (flags &#38; DOD_finish_FLAG) {
        /*
         * called from really_destroy. This interpreter is gonna die.
         * The destruction includes a sweep over PMCs, so that
         * destructors/finalizers are called.
         *
         * Be sure live bits are clear.
         */
        if (g_ims&#45;&#62;state &#62;= GC_IMS_RE_INIT || g_ims&#45;&#62;state &#60; GC_IMS_FINISHED)
            Parrot_dod_clear_live_bits(interp);
        Parrot_dod_sweep(interp, interp&#45;&#62;arena_base&#45;&#62;pmc_pool);
        g_ims&#45;&#62;state = GC_IMS_DEAD;
        return;
    }
    /* make the test happy that checks the count ;) */
    arena_base&#45;&#62;dod_runs++;
    lazy = flags &#38; DOD_lazy_FLAG;
    if (!lazy) {
        /* run a full cycle
         * TODO if we are called from mem_allocate() in src/resources.c:
         *   * pass needed size
         *   * test   examples/benchmarks/gc_header_new.pasm
         */
        if (!parrot_gc_ims_collect(interp, 1)) {
            parrot_gc_ims_run_increment(interp);
            return;
        }
        if (g_ims&#45;&#62;state &#62;= GC_IMS_FINISHED)
            g_ims&#45;&#62;state = GC_IMS_STARTING;
        while (1) {
            parrot_gc_ims_run_increment(interp);
            if (g_ims&#45;&#62;state &#62; GC_IMS_COLLECT)
                break;
        }
        return;
    }
    /*
     * lazy DOD handling
     */
    IMS_DEBUG((stderr, &#34;\nLAZY state = %d\n&#34;, g_ims&#45;&#62;state));
    g_ims&#45;&#62;lazy = lazy;
    if (g_ims&#45;&#62;state &#62;= GC_IMS_COLLECT) {
        /* we are beyond sweep, timely destruction is done */
        if (arena_base&#45;&#62;num_early_PMCs_seen &#62;= arena_base&#45;&#62;num_early_DOD_PMCs)
            return;
        /* when not all seen, start a fresh cycle */
        g_ims&#45;&#62;state = GC_IMS_RE_INIT;
        /* run init, which clears lazy seen counter */
        parrot_gc_ims_run_increment(interp);
    }
    /*
     *  run through all steps until we see enough PMCs that need timely
     *  destruction or we finished sweeping
     */
    while (arena_base&#45;&#62;num_early_PMCs_seen &#60; arena_base&#45;&#62;num_early_DOD_PMCs) {
        parrot_gc_ims_run_increment(interp);
        if (g_ims&#45;&#62;state &#62;= GC_IMS_COLLECT)
            break;
    }
    /*
     * if we stopped early, the lazy run was successful
     */
    if (g_ims&#45;&#62;state &#60; GC_IMS_COLLECT)
        ++arena_base&#45;&#62;lazy_dod_runs;
    g_ims&#45;&#62;lazy = 0;
}</pre>

<p>/*</p>

<p>FUNCDOC: Parrot_dod_ims_wb</p>

<p>Write barrier called by the DOD_WRITE_BARRIER macro. Always when storing a white object into a black aggregate, either the object must be greyed or the aggregate must be rescanned &#45; by greying it.</p>

<p>*/</p>

<p>#define DOD_IMS_GREY_NEW 1</p>

<p>PARROT_API void Parrot_dod_ims_wb(PARROT_INTERP, NOTNULL(PMC *agg), NOTNULL(PMC *_new)) { #if DOD_IMS_GREY_NEW IMS_DEBUG((stderr, &#34;%d agg %p mark %p\n&#34;, ((Gc_ims_private *)interp&#45;&#62;arena_base&#45;&#62; gc_private)&#45;&#62;state, agg, _new)); pobject_lives(interp, (PObj*)_new); #else PObj_get_FLAGS(agg) &#38;= ~ (PObj_live_FLAG|PObj_custom_GC_FLAG); pobject_lives(interp, (PObj*)agg); #endif }</p>

<p>/*</p>

<h1><a name="SEE_ALSO"
>SEE ALSO <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p><em lang='und' xml:lang='und'>src/dod.c</em>, <em lang='und' xml:lang='und'>include/parrot/dod.h</em>, <em lang='und' xml:lang='und'>include/parrot/pobj.h</em>,</p>

<h1><a name="HISTORY"
>HISTORY <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Initial version by leo (2004.08.12 &#45; 2004.08.15)</p>

<p>*/</p>

<p>/* * Local variables: * c&#45;file&#45;style: &#34;parrot&#34; * End: * vim: expandtab shiftwidth=4: */</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
