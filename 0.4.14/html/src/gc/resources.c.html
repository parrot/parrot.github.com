<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Allocate and deallocate tracked resources</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Allocate and deallocate tracked resources</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../html/index.html">Contents</a> | <a href="../../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>src/resources.c &#45; Allocate and deallocate tracked resources</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<h2><a name="Parrot_Memory_Management_Code"
>Parrot Memory Management Code <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>*/</p>

<p>#include &#60;assert.h&#62; #include &#34;parrot/parrot.h&#34; #include &#34;parrot/resources.h&#34;</p>

<p>#define RECLAMATION_FACTOR 0.20 #define WE_WANT_EVER_GROWING_ALLOCATIONS 0</p>

<p>/* show allocated blocks on stderr */ #define RESOURCE_DEBUG 0 #define RESOURCE_DEBUG_SIZE 1000000</p>

<p>#define POOL_SIZE 65536 * 2</p>

<p>typedef void (*compact_f) (Interp *,
Memory_Pool *);</p>

<p>/* HEADERIZER HFILE: include/parrot/resources.h */</p>

<p>/* HEADERIZER BEGIN: static */</p>

<p>static char * aligned_mem( NOTNULL(const Buffer *buffer),
NOTNULL(char *mem) ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>PARROT_PURE_FUNCTION PARROT_WARN_UNUSED_RESULT static size_t aligned_size( NOTNULL(const Buffer *buffer),
size_t len ) __attribute__nonnull__(1);</p>

<p>PARROT_CONST_FUNCTION PARROT_WARN_UNUSED_RESULT static size_t aligned_string_size( size_t len );</p>

<p>static void * alloc_new_block( PARROT_INTERP,
size_t size,
NOTNULL(Memory_Pool *pool),
NOTNULL(const char *why) ) __attribute__nonnull__(1) __attribute__nonnull__(3) __attribute__nonnull__(4);</p>

<p>static const char* buffer_location( PARROT_INTERP,
NOTNULL(const PObj *b) ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>static void compact_pool( PARROT_INTERP,
NOTNULL(Memory_Pool *pool) ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>static void debug_print_buf( PARROT_INTERP,
NOTNULL(const PObj *b) ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>PARROT_MALLOC static void * mem_allocate( PARROT_INTERP,
size_t size,
NOTNULL(Memory_Pool *pool) ) __attribute__nonnull__(1) __attribute__nonnull__(3);</p>

<p>static void merge_pools( NOTNULL(Memory_Pool *dest),
NOTNULL(Memory_Pool *source) ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>PARROT_MALLOC static Memory_Pool * new_memory_pool( size_t min_block,
NULLOK(compact_f compact) );</p>

<p>/* HEADERIZER END: static */</p>

<p>/*</p>

<p>Allocate a new memory block.
We allocate the larger of the requested size or the default size.
The given text is used for debugging.</p>

<p>*/</p>

<p>static void * alloc_new_block(PARROT_INTERP,
size_t size,
NOTNULL(Memory_Pool *pool),
NOTNULL(const char *why)) { Memory_Block *new_block;</p>

<pre lang='und' xml:lang='und'>    const size_t alloc_size = (size &#62; pool&#45;&#62;minimum_block_size)
            ? size : pool&#45;&#62;minimum_block_size;</pre>

<p>#if RESOURCE_DEBUG fprintf(stderr, &#34;new_block (%s) size %u &#45;&#62; %u\n&#34;, why, size, alloc_size); #else UNUSED(why) #endif</p>

<pre lang='und' xml:lang='und'>    /* Allocate a new block. Header info&#39;s on the front */
    new_block = (Memory_Block *)mem_internal_allocate_zeroed(
        sizeof (Memory_Block) + alloc_size);

    if (!new_block) {
        fprintf(stderr, &#34;out of mem allocsize = %d\n&#34;, (int)alloc_size);
        exit(EXIT_FAILURE);
    }

    new_block&#45;&#62;free  = alloc_size;
    new_block&#45;&#62;size  = alloc_size;

    new_block&#45;&#62;next = NULL;
    new_block&#45;&#62;start = (char *)new_block + sizeof (Memory_Block);
    new_block&#45;&#62;top   = new_block&#45;&#62;start;

    /* Note that we&#39;ve allocated it */
    interp&#45;&#62;arena_base&#45;&#62;memory_allocated += alloc_size;

    /* If this is for a public pool, add it to the list */
    new_block&#45;&#62;prev = pool&#45;&#62;top_block;

    /* If we&#39;re not first, then tack us on the list */
    if (pool&#45;&#62;top_block)
        pool&#45;&#62;top_block&#45;&#62;next = new_block;

    pool&#45;&#62;top_block        = new_block;
    pool&#45;&#62;total_allocated += alloc_size;

    return new_block;
}</pre>

<p>/*</p>

<p>FUNCDOC: mem_allocate</p>

<p>Allocates memory for headers.</p>

<p>Alignment problems history:</p>

<p>See <a href='http://archive.develooper.com/perl6&#45;internals%40perl.org/msg12310.html'><a href="http://archive.develooper.com/perl6&#45;internals%40perl.org/msg12310.html">http://archive.develooper.com/perl6&#45;internals%40perl.org/msg12310.html</a></a> for details.</p>

<p>&#45; return aligned pointer *if needed* &#45; return strings et al at unaligned i.e. void* boundaries &#45; remember alignment in a buffer header bit use this in compaction code &#45; reduce alignment to a reasonable value i.e. MALLOC_ALIGNMENT aka 2*sizeof (size_t) or just 8 (TODO make a config hint)</p>

<p>Buffer memory layout:</p>

<pre lang='und' xml:lang='und'>                    +&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;+
                    |  ref_count   |f |    # GC header
  obj&#45;&#62;bufstart  &#45;&#62; +&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;+
                    |  data           |
                    v                 v

 * if PObj_is_COWable is set, then we have
   &#45; a ref_count, {inc,dec}remented by 2 always
   &#45; the lo bit &#39;f&#39; means &#39;is being forwarded&#34; &#45; what TAIL_flag was

 * if PObj_align_FLAG is set, obj&#45;&#62;bufstart is aligned like discussed above
 * obj&#45;&#62;buflen is the usable length excluding the optional GC part.</pre>

<p>*/</p>

<p>PARROT_MALLOC static void * mem_allocate(PARROT_INTERP, size_t size, NOTNULL(Memory_Pool *pool)) { void *return_val;</p>

<pre lang='und' xml:lang='und'>    /* we always should have one block at least */
    assert(pool&#45;&#62;top_block);

    /* If not enough room, try to find some */
    if (pool&#45;&#62;top_block&#45;&#62;free &#60; size) {
        /*
         * force a DOD run to get live flags set
         * for incremental M&#38;S collection is run from there
         * TODO pass required allocation size to the DOD system,
         *      so that collection can be skipped if needed
         */
        if (!interp&#45;&#62;arena_base&#45;&#62;DOD_block_level) {
            Parrot_do_dod_run(interp, DOD_trace_stack_FLAG);
#if !PARROT_GC_IMS
            /* Compact the pool if allowed and worthwhile */
            if (pool&#45;&#62;compact) {
                /* don&#39;t bother reclaiming if it&#39;s just chicken feed */
                if ((pool&#45;&#62;possibly_reclaimable * pool&#45;&#62;reclaim_factor +
                            pool&#45;&#62;guaranteed_reclaimable) &#62; size) {
                    (*pool&#45;&#62;compact) (interp, pool);
                }

            }
#endif
        }
        if (pool&#45;&#62;top_block&#45;&#62;free &#60; size) {
            if (pool&#45;&#62;minimum_block_size &#60; 65536 * 16)
                pool&#45;&#62;minimum_block_size *= 2;
            /*
             * TODO &#45; Big blocks
             *
             * Mark the block as big block (it has just one item)
             * And don&#39;t set big blocks as the top_block.
             */
            alloc_new_block(interp, size, pool, &#34;compact failed&#34;);

            interp&#45;&#62;arena_base&#45;&#62;mem_allocs_since_last_collect++;

            if (pool&#45;&#62;top_block&#45;&#62;free &#60; size) {
                fprintf(stderr, &#34;out of mem\n&#34;);
                exit(EXIT_FAILURE);
            }
        }
    }

    /* TODO inline the fast path */
    return_val             = pool&#45;&#62;top_block&#45;&#62;top;
    pool&#45;&#62;top_block&#45;&#62;top  += size;
    pool&#45;&#62;top_block&#45;&#62;free &#45;= size;

    return return_val;
}</pre>

<p>#if RESOURCE_DEBUG static const char* buffer_location(PARROT_INTERP, NOTNULL(const PObj *b)) { int i; static char reg[10];</p>

<pre lang='und' xml:lang='und'>    parrot_context_t* const ctx = CONTEXT(interp&#45;&#62;ctx);

    for (i = 0; i &#60; ctx&#45;&#62;n_regs_used[REGNO_STR]; ++i) {
        PObj * const obj = (PObj *) CTX_REG_STR(interp, ctx, i);
        if (obj == b) {
            sprintf(reg, &#34;S%d&#34;, i);
            return reg;
        }
    }

    return &#34;???&#34;;
}</pre>

<p>static void debug_print_buf(PARROT_INTERP, NOTNULL(const PObj *b)) { fprintf(stderr, &#34;found %p, len %d, flags 0x%08x at %s\n&#34;, b, (int)PObj_buflen(b), (uint)PObj_get_FLAGS(b), buffer_location(interp, b)); } #endif</p>

<p>/*</p>

<h2><a name="Compaction_Code"
>Compaction Code <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>FUNCDOC: compact_pool</p>

<p>Compact the buffer pool.</p>

<p>*/</p>

<p>static void compact_pool(PARROT_INTERP, NOTNULL(Memory_Pool *pool)) { INTVAL j; UINTVAL object_size; UINTVAL total_size;</p>

<pre lang='und' xml:lang='und'>    Memory_Block *new_block;     /* A pointer to our working block */
    char         *cur_spot;      /* Where we&#39;re currently copying to */

    Small_Object_Arena *cur_buffer_arena;
    INTVAL             *ref_count  = NULL;
    Arenas * const      arena_base = interp&#45;&#62;arena_base;

    /* Bail if we&#39;re blocked */
    if (arena_base&#45;&#62;GC_block_level)
        return;

    ++arena_base&#45;&#62;GC_block_level;

    if (interp&#45;&#62;profile)
        Parrot_dod_profile_start(interp);

    /* We&#39;re collecting */
    arena_base&#45;&#62;mem_allocs_since_last_collect    = 0;
    arena_base&#45;&#62;header_allocs_since_last_collect = 0;
    arena_base&#45;&#62;collect_runs++;

    /* total &#45; reclaimable == currently used. Add a minimum block to the
     * current amount, so we can avoid having to allocate it in the future. */
    {
        Memory_Block *cur_block;

        total_size = 0;
        cur_block  = pool&#45;&#62;top_block;

        while (cur_block) {
            /*
             * TODO &#45; Big blocks
             *
             * Currently all available blocks are compacted into on new
             * block with total_size. This is more than suboptimal, if
             * the block has just one live item from a big allocation.
             *
             * But currently it&#39;s unknown if the buffer memory is alive
             * as the live bits are in Buffer headers. We have to run the
             * compaction loop below to check liveness. OTOH if this
             * compaction is running through all the buffer headers, there
             * is no relation to the block.
             *
             *
             * Moving the life bit into the buffer thus also solves this
             * problem easily.
             */
            total_size += cur_block&#45;&#62;size &#45; cur_block&#45;&#62;free;
            cur_block   = cur_block&#45;&#62;prev;
        }
    }
    /*
     * XXX for some reason the guarantee isn&#39;t correct
     *     TODO check why
     */

    /* total_size &#45;= pool&#45;&#62;guaranteed_reclaimable; */

    /* this makes for ever increasing allocations but fewer collect runs */
#if WE_WANT_EVER_GROWING_ALLOCATIONS
    total_size += pool&#45;&#62;minimum_block_size;
#endif

    /* Snag a block big enough for everything */
    new_block = (Memory_Block *)alloc_new_block(interp, total_size, pool,
            &#34;inside compact&#34;);

    /* Start at the beginning */
    cur_spot  = new_block&#45;&#62;start;

    /* Run through all the Buffer header pools and copy */
    for (j = 0; j &#60; (INTVAL)arena_base&#45;&#62;num_sized; j++) {
        Small_Object_Pool * const header_pool = arena_base&#45;&#62;sized_header_pools[j];

        if (header_pool == NULL)
            continue;

        object_size = header_pool&#45;&#62;object_size;

        for (cur_buffer_arena = header_pool&#45;&#62;last_Arena;
                NULL != cur_buffer_arena;
                cur_buffer_arena = cur_buffer_arena&#45;&#62;prev) {
            Buffer *b;
            UINTVAL i;

            b = (Buffer *)ARENA_to_PObj(cur_buffer_arena&#45;&#62;start_objects);

            for (i = 0; i &#60; cur_buffer_arena&#45;&#62;used; i++) {
                /* ! (on_free_list | constant | external | sysmem) */
                if (PObj_buflen(b) &#38;&#38; PObj_is_movable_TESTALL(b)) {
                    ptrdiff_t offset = 0;
#if RESOURCE_DEBUG
                    if (PObj_buflen(b) &#62;= RESOURCE_DEBUG_SIZE)
                        debug_print_buf(interp, b);
#endif

                    /* we can&#39;t perform the math all the time, because
                     * strstart might be in unallocated memory */
                    if (PObj_is_COWable_TEST(b)) {
                        ref_count = ((INTVAL*) PObj_bufstart(b)) &#45; 1;

                        if (PObj_is_string_TEST(b)) {
                            offset = (ptrdiff_t)((STRING *)b)&#45;&#62;strstart &#45;
                                (ptrdiff_t)PObj_bufstart(b);
                        }
                    }

                    /* buffer has already been moved; just change the header */
                    if (PObj_COW_TEST(b) &#38;&#38; *ref_count &#38; Buffer_moved_FLAG) {
                        /* Find out who else references our data */
                        Buffer * const hdr = *(Buffer **)(PObj_bufstart(b));

                        assert(PObj_is_COWable_TEST(b));

                        /* Make sure they know that we own it too */
                        PObj_COW_SET(hdr);

                        /* TODO incr ref_count, after fixing string too
                         * Now make sure we point to where the other guy does */
                        PObj_bufstart(b) = PObj_bufstart(hdr);

                        /* And if we&#39;re a string, update strstart */
                        /* Somewhat of a hack, but if we get per&#45;pool
                         * collections, it should help ease the pain */
                        if (PObj_is_string_TEST(b)) {
                            ((STRING *)b)&#45;&#62;strstart = (char *)PObj_bufstart(b) +
                                    offset;
                        }
                    }
                    else {
                        cur_spot = aligned_mem(b, cur_spot);

                        if (PObj_is_COWable_TEST(b)) {
                            INTVAL * const new_ref_count = ((INTVAL*) cur_spot) &#45; 1;
                            *new_ref_count        = 2;
                        }

                        /* Copy our memory to the new pool */
                        memcpy(cur_spot, PObj_bufstart(b), PObj_buflen(b));

                        /* If we&#39;re COW */
                        if (PObj_COW_TEST(b)) {
                            assert(PObj_is_COWable_TEST(b));

                            /* Let the old buffer know how to find us */
                            *(Buffer **)(PObj_bufstart(b)) = b;

                            /* No guarantees that our data is still COW, so
                             * assume not, and let the above code fix&#45;up */
                            PObj_COW_CLEAR(b);

                            /* Finally, let the tail know that we&#39;ve moved, so
                             * that any other references can know to look for
                             * us and not re&#45;copy */
                            *ref_count |= Buffer_moved_FLAG;
                        }
                        PObj_bufstart(b) = cur_spot;
                        if (PObj_is_string_TEST(b)) {
                            ((STRING *)b)&#45;&#62;strstart = (char *)PObj_bufstart(b) +
                                    offset;
                        }
                        cur_spot += PObj_buflen(b);
                    }
                }
                b = (Buffer *)((char *)b + object_size);
            }
        }
    }

    /* Okay, we&#39;re done with the copy. Set the bits in the pool struct */
    /* First, where we allocate next */
    new_block&#45;&#62;top = cur_spot;

    assert(new_block&#45;&#62;size &#62;= (size_t)new_block&#45;&#62;top &#45;
            (size_t)new_block&#45;&#62;start);

    /* How much is free. That&#39;s the total size minus the amount we used */
    new_block&#45;&#62;free = new_block&#45;&#62;size &#45; (new_block&#45;&#62;top &#45; new_block&#45;&#62;start);

    arena_base&#45;&#62;memory_collected += (new_block&#45;&#62;top &#45; new_block&#45;&#62;start);

    /* Now we&#39;re done. We&#39;re already on the pool&#39;s free list, so let us be the
     * only one on the free list and free the rest */
    {
        Memory_Block *cur_block;

        assert(new_block == pool&#45;&#62;top_block);
        cur_block = new_block&#45;&#62;prev;
        while (cur_block) {
            Memory_Block * const next_block = cur_block&#45;&#62;prev;
            /* Note that we don&#39;t have it any more */
            arena_base&#45;&#62;memory_allocated &#45;= cur_block&#45;&#62;size;
            /* We know the pool body and pool header are a single chunk, so
             * this is enough to get rid of &#39;em both */
            mem_internal_free(cur_block);
            cur_block = next_block;
        }

        /* Set our new pool as the only pool */
        new_block&#45;&#62;prev = NULL;
        pool&#45;&#62;total_allocated = total_size;
    }

    pool&#45;&#62;guaranteed_reclaimable = 0;
    pool&#45;&#62;possibly_reclaimable = 0;
    if (interp&#45;&#62;profile)
        Parrot_dod_profile_end(interp, PARROT_PROF_GC);
    &#45;&#45;arena_base&#45;&#62;GC_block_level;
}</pre>

<p>/*</p>

<p>FUNCDOC: Go do a GC run. This only scans the string pools and compacts them, it doesn&#39;t check for string liveness.</p>

<p>*/</p>

<p>void Parrot_go_collect(PARROT_INTERP) { compact_pool(interp, interp&#45;&#62;arena_base&#45;&#62;memory_pool); }</p>

<p>PARROT_PURE_FUNCTION PARROT_WARN_UNUSED_RESULT static size_t aligned_size(NOTNULL(const Buffer *buffer), size_t len) { if (PObj_is_COWable_TEST(buffer)) len += sizeof (void*); if (PObj_aligned_TEST(buffer)) { len = (len + BUFFER_ALIGN_1) &#38; BUFFER_ALIGN_MASK; } else { len = (len + WORD_ALIGN_1) &#38; WORD_ALIGN_MASK; } return len; }</p>

<p>static char * aligned_mem(NOTNULL(const Buffer *buffer), NOTNULL(char *mem)) { if (PObj_is_COWable_TEST(buffer)) mem += sizeof (void*); if (PObj_aligned_TEST(buffer)) { mem = (char*)(((unsigned long)(mem + BUFFER_ALIGN_1)) &#38; BUFFER_ALIGN_MASK); } else { mem = (char*)(((unsigned long)(mem + WORD_ALIGN_1)) &#38; WORD_ALIGN_MASK); } return mem; }</p>

<p>PARROT_CONST_FUNCTION PARROT_WARN_UNUSED_RESULT static size_t aligned_string_size(size_t len) /* XXX Looks like we can lose buffer here */ { len += sizeof (void*); len = (len + WORD_ALIGN_1) &#38; WORD_ALIGN_MASK; return len; }</p>

<p>PARROT_WARN_UNUSED_RESULT int Parrot_in_memory_pool(PARROT_INTERP, NOTNULL(void *bufstart)) { Memory_Pool * const pool = interp&#45;&#62;arena_base&#45;&#62;memory_pool; Memory_Block * cur_block = pool&#45;&#62;top_block;</p>

<pre lang='und' xml:lang='und'>    while (cur_block) {
        if ((char *)bufstart &#62;= cur_block&#45;&#62;start &#38;&#38;
            (char *) bufstart &#60; cur_block&#45;&#62;start + cur_block&#45;&#62;size) {
            return 1;
        }
        cur_block = cur_block&#45;&#62;prev;
    }
    return 0;
}</pre>

<p>/*</p>

<h2><a name="Parrot_Re/Allocate_Code"
>Parrot Re/Allocate Code <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>FUNCDOC: Parrot_reallocate</p>

<p>Reallocate the Buffer&#39;s buffer memory to the given size. The allocated buffer will not shrink. If the buffer was allocated with <a href='TODO'>Parrot_allocate_aligned</a> the new buffer will also be aligned. As with all reallocation, the new buffer might have moved and the additional memory is not cleared.</p>

<p>*/</p>

<p>void Parrot_reallocate(PARROT_INTERP, NOTNULL(Buffer *buffer), size_t tosize) { size_t copysize; char *mem; Memory_Pool * const pool = interp&#45;&#62;arena_base&#45;&#62;memory_pool; size_t new_size, needed, old_size;</p>

<pre lang='und' xml:lang='und'>    /*
     * we don&#39;t shrink buffers
     */
    if (tosize &#60;= PObj_buflen(buffer))
        return;

    /*
     * same as below but barely used and tested &#45; only 3 list related
     * tests do use true reallocation
     *
     * list.c, which does _reallocate, has 2 reallocations
     * normally, which play ping pong with buffers.
     * The normal case is therefore always to allocate a new block
     */
    new_size = aligned_size(buffer, tosize);
    old_size = aligned_size(buffer, PObj_buflen(buffer));
    needed = new_size &#45; old_size;
    if ( (pool&#45;&#62;top_block&#45;&#62;free &#62;= needed) &#38;&#38;
            (pool&#45;&#62;top_block&#45;&#62;top == (char*)PObj_bufstart(buffer) + old_size) ) {
        pool&#45;&#62;top_block&#45;&#62;free &#45;= needed;
        pool&#45;&#62;top_block&#45;&#62;top  += needed;
        PObj_buflen(buffer) = tosize;
        return;
    }
    copysize = PObj_buflen(buffer);
    if (!PObj_COW_TEST(buffer)) {
        pool&#45;&#62;guaranteed_reclaimable += copysize;
    }
    pool&#45;&#62;possibly_reclaimable += copysize;
    mem = (char *)mem_allocate(interp, new_size, pool);
    mem = aligned_mem(buffer, mem);

    /* We shouldn&#39;t ever have a 0 from size, but we do. If we can track down
     * those bugs, this can be removed which would make things cheaper */
    if (copysize) {
        memcpy(mem, PObj_bufstart(buffer), copysize);
    }
    PObj_bufstart(buffer) = mem;
    if (PObj_is_COWable_TEST(buffer))
        new_size &#45;= sizeof (void*);
    PObj_buflen(buffer) = new_size;
}</pre>

<p>/*</p>

<p>FUNCDOC: Parrot_reallocate_string</p>

<p>Reallocate the STRING&#39;s buffer memory to the given size. The allocated buffer will not shrink. This function sets also <code lang='und' xml:lang='und'>str&#45;&#62;strstart</code> to the new buffer location, <code lang='und' xml:lang='und'>str&#45;&#62;bufused</code> is <b>not</b> changed.</p>

<p>*/</p>

<p>void Parrot_reallocate_string(PARROT_INTERP, NOTNULL(STRING *str), size_t tosize) { size_t copysize; char *mem, *oldmem; size_t new_size, needed, old_size;</p>

<pre lang='und' xml:lang='und'>    Memory_Pool * const pool =
        PObj_constant_TEST(str)
            ? interp&#45;&#62;arena_base&#45;&#62;constant_string_pool
            : interp&#45;&#62;arena_base&#45;&#62;memory_pool;
    /*
     * if the requested size is smaller then buflen, we are done
     */
    if (tosize &#60;= PObj_buflen(str))
        return;

    /*
     * first check, if we can reallocate:
     * &#45; if the passed strings buffer is the last string in the pool and
     * &#45; if there is enough size, we can just move the pool&#39;s top pointer
     */
    new_size = aligned_string_size(tosize);
    old_size = aligned_string_size(PObj_buflen(str));
    needed = new_size &#45; old_size;
    if (pool&#45;&#62;top_block&#45;&#62;free &#62;= needed &#38;&#38;
            pool&#45;&#62;top_block&#45;&#62;top == (char*)PObj_bufstart(str) +
            old_size) {
        pool&#45;&#62;top_block&#45;&#62;free &#45;= needed;
        pool&#45;&#62;top_block&#45;&#62;top  += needed;
        PObj_buflen(str) = new_size &#45; sizeof (void*);
        return;
    }
    assert(str&#45;&#62;bufused &#60;= tosize);
    /* only copy used memory, not total string buffer */
    copysize = str&#45;&#62;bufused;

    if (!PObj_COW_TEST(str)) {
        pool&#45;&#62;guaranteed_reclaimable += PObj_buflen(str);
    }
    pool&#45;&#62;possibly_reclaimable += PObj_buflen(str);

    mem = (char *)mem_allocate(interp, new_size, pool);
    mem += sizeof (void*);

    /* copy mem from strstart, *not* bufstart */
    oldmem             = str&#45;&#62;strstart;
    PObj_bufstart(str) = (void *)mem;
    str&#45;&#62;strstart      = mem;
    PObj_buflen(str)   = new_size &#45; sizeof (void*);

    /* We shouldn&#39;t ever have a 0 from size, but we do. If we can track down
     * those bugs, this can be removed which would make things cheaper */
    if (copysize) {
        memcpy(mem, oldmem, copysize);
    }
}</pre>

<p>/*</p>

<p>FUNCDOC: Parrot_allocate</p>

<p>Allocate buffer memory for the given Buffer pointer. The <code lang='und' xml:lang='und'>size</code> has to be a multiple of the word size. <code lang='und' xml:lang='und'>PObj_buflen</code> will be set to exactly the given <code lang='und' xml:lang='und'>size</code>.</p>

<p>*/</p>

<p>void Parrot_allocate(PARROT_INTERP, NOTNULL(Buffer *buffer), size_t size) { PObj_buflen(buffer) = 0; PObj_bufstart(buffer) = NULL; assert((size &#38; WORD_ALIGN_1) == 0); PObj_bufstart(buffer) = mem_allocate(interp, size, interp&#45;&#62;arena_base&#45;&#62;memory_pool); PObj_buflen(buffer) = size; }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_allocate_aligned</p>

<p>Like above, except the <code lang='und' xml:lang='und'>size</code> will be rounded up and the address of the buffer will have the same alignment as a pointer returned by malloc(3) suitable to hold e.g. a <code lang='und' xml:lang='und'>FLOATVAL</code> array.</p>

<p>*/</p>

<p>void Parrot_allocate_aligned(PARROT_INTERP, NOTNULL(Buffer *buffer), size_t size) { size_t new_size; char *mem;</p>

<pre lang='und' xml:lang='und'>    PObj_buflen(buffer) = 0;
    PObj_bufstart(buffer) = NULL;
    new_size = aligned_size(buffer, size);
    mem = (char *)mem_allocate(interp, new_size,
        interp&#45;&#62;arena_base&#45;&#62;memory_pool);
    mem = aligned_mem(buffer, mem);
    PObj_bufstart(buffer) = mem;
    if (PObj_is_COWable_TEST(buffer))
        new_size &#45;= sizeof (void*);
    PObj_buflen(buffer) = new_size;
}</pre>

<p>/*</p>

<p>FUNCDOC: Parrot_allocate_string</p>

<p>Allocate the STRING&#39;s buffer memory to the given size. The allocated buffer maybe slightly bigger than the given <code lang='und' xml:lang='und'>size</code>. This function sets also <code lang='und' xml:lang='und'>str&#45;&#62;strstart</code> to the new buffer location, <code lang='und' xml:lang='und'>str&#45;&#62;bufused</code> is <b>not</b> changed.</p>

<p>*/</p>

<p>void Parrot_allocate_string(PARROT_INTERP, NOTNULL(STRING *str), size_t size) { size_t new_size; Memory_Pool *pool; char *mem;</p>

<pre lang='und' xml:lang='und'>    PObj_buflen(str)   = 0;
    PObj_bufstart(str) = NULL;

    /* there&#39;s no sense in allocating zero memory, when the overhead of
     * allocating a string is one pointer; this can fill the pools in an
     * uncompactable way.  See RT #42320.
     */
    if (size == 0)
        return;

    pool     = PObj_constant_TEST(str)
                ? interp&#45;&#62;arena_base&#45;&#62;constant_string_pool
                : interp&#45;&#62;arena_base&#45;&#62;memory_pool;

    new_size = aligned_string_size(size);
    mem      = (char *)mem_allocate(interp, new_size, pool);
    mem     += sizeof (void*);

    PObj_bufstart(str) =  str&#45;&#62;strstart = mem;
    PObj_buflen(str)   = new_size &#45; sizeof (void*);
}</pre>

<p>/*</p>

<p>FUNCDOC: new_memory_pool</p>

<p>Create a new memory pool.</p>

<p>*/</p>

<p>PARROT_MALLOC static Memory_Pool * new_memory_pool(size_t min_block, NULLOK(compact_f compact)) { Memory_Pool * const pool = mem_internal_allocate_typed(Memory_Pool);</p>

<pre lang='und' xml:lang='und'>    if (pool) {
        pool&#45;&#62;top_block              = NULL;
        pool&#45;&#62;compact                = compact;
        pool&#45;&#62;minimum_block_size     = min_block;
        pool&#45;&#62;total_allocated        = 0;
        pool&#45;&#62;guaranteed_reclaimable = 0;
        pool&#45;&#62;possibly_reclaimable   = 0;
        pool&#45;&#62;reclaim_factor         = RECLAMATION_FACTOR;
    }

    return pool;
}</pre>

<p>/*</p>

<p>FUNCDOC: Parrot_initialize_memory_pools</p>

<p>Initialize the managed memory pools.</p>

<p>*/</p>

<p>void Parrot_initialize_memory_pools(PARROT_INTERP) { Arenas * const arena_base = interp&#45;&#62;arena_base;</p>

<pre lang='und' xml:lang='und'>    arena_base&#45;&#62;memory_pool   = new_memory_pool(POOL_SIZE, &#38;compact_pool);
    alloc_new_block(interp, POOL_SIZE, arena_base&#45;&#62;memory_pool, &#34;init&#34;);

    /* Constant strings &#45; not compacted */
    arena_base&#45;&#62;constant_string_pool = new_memory_pool(POOL_SIZE, NULL);

    alloc_new_block(interp, POOL_SIZE,
                    arena_base&#45;&#62;constant_string_pool, &#34;init&#34;);
}</pre>

<p>/*</p>

<p>FUNCDOC: Parrot_destroy_memory_pools</p>

<p>Destroys the memory pools.</p>

<p>*/</p>

<p>void Parrot_destroy_memory_pools(PARROT_INTERP) { int i;</p>

<pre lang='und' xml:lang='und'>    for (i = 0; i &#60; 2; i++) {
        Memory_Pool * const pool = i ?
                interp&#45;&#62;arena_base&#45;&#62;constant_string_pool :
                interp&#45;&#62;arena_base&#45;&#62;memory_pool;
        Memory_Block *cur_block;

        cur_block = pool&#45;&#62;top_block;

        while (cur_block) {
            Memory_Block * const next_block = cur_block&#45;&#62;prev;
            mem_internal_free(cur_block);
            cur_block = next_block;
        }

        mem_internal_free(pool);
    }
}</pre>

<p>static void merge_pools(NOTNULL(Memory_Pool *dest), NOTNULL(Memory_Pool *source)) { Memory_Block *cur_block;</p>

<pre lang='und' xml:lang='und'>    cur_block = source&#45;&#62;top_block;

    while (cur_block) {
        Memory_Block * const next_block = cur_block&#45;&#62;prev;

        if (cur_block&#45;&#62;free == cur_block&#45;&#62;size) {
            mem_internal_free(cur_block);
        }
        else {
            cur_block&#45;&#62;next        = NULL;
            cur_block&#45;&#62;prev        = dest&#45;&#62;top_block;

            dest&#45;&#62;top_block        = cur_block;
            dest&#45;&#62;total_allocated += cur_block&#45;&#62;size;
        }
        cur_block = next_block;
    }

    dest&#45;&#62;guaranteed_reclaimable += source&#45;&#62;guaranteed_reclaimable;
    dest&#45;&#62;possibly_reclaimable   += dest&#45;&#62;possibly_reclaimable;

    source&#45;&#62;top_block              = NULL;
    source&#45;&#62;total_allocated        = 0;
    source&#45;&#62;possibly_reclaimable   = 0;
    source&#45;&#62;guaranteed_reclaimable = 0;
}</pre>

<p>/*</p>

<p>FUNCDOC: Parrot_merge_memory_pools</p>

<p>Merge the memory pools of <code lang='und' xml:lang='und'>source_interp</code> into <code lang='und' xml:lang='und'>dest_interp</code>.</p>

<p>*/</p>

<p>void Parrot_merge_memory_pools(NOTNULL(Interp *dest_interp), NOTNULL(Interp *source_interp)) { merge_pools(dest_interp&#45;&#62;arena_base&#45;&#62;constant_string_pool, source_interp&#45;&#62;arena_base&#45;&#62;constant_string_pool);</p>

<pre lang='und' xml:lang='und'>    merge_pools(dest_interp&#45;&#62;arena_base&#45;&#62;memory_pool,
                source_interp&#45;&#62;arena_base&#45;&#62;memory_pool);
}</pre>

<p>/*</p>

<h1><a name="SEE_ALSO"
>SEE ALSO <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p><em lang='und' xml:lang='und'>include/parrot/resources.h</em>, <em lang='und' xml:lang='und'>src/memory.c</em>.</p>

<h1><a name="HISTORY"
>HISTORY <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Initial version by Dan on 2001.10.2.</p>

<p>*/</p>

<p>/* * Local variables: * c&#45;file&#45;style: &#34;parrot&#34; * End: * vim: expandtab shiftwidth=4: */</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
