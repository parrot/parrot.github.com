<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Generic IO</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Generic IO</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../html/index.html">Contents</a> | <a href="../../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>src/io/io.c &#45; Generic IO</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>The Parrot IO subsystem uses a per&#45;interpreter stack to provide a layer&#45;based approach to IO.
Each layer implements a subset of the <code lang='und' xml:lang='und'>ParrotIOLayerAPI</code> vtable.
To find an IO function,
Parrot searches the layer stack downwards until it finds a non&#45;<code lang='und' xml:lang='und'>NULL</code> function pointer for that particular slot.</p>

<p>This file implements the generic functionality.
Specific layers are in separate files: <em lang='und' xml:lang='und'><a href="io_buf.c.html">src/io/io_buf.c</a></em>,
<em lang='und' xml:lang='und'><a href="io_stdio.c.html">src/io/io_stdio.c</a></em>,
<em lang='und' xml:lang='und'><a href="io_unix.c.html">src/io/io_unix.c</a></em>,
<em lang='und' xml:lang='und'><a href="io_win32.c.html">src/io/io_win32.c</a></em>,
and <em lang='und' xml:lang='und'><a href="io_layers.c.html">src/io/io_layers.c</a></em>.</p>

<p>The <code lang='und' xml:lang='und'>ParrotIO</code> PMC provides the class&#45;based interface that is used in Parrot ops.
The <code lang='und' xml:lang='und'>ParrotIO struct</code> is defined in <em lang='und' xml:lang='und'><a href="io_private.h.html">src/io/io_private.h</a></em>.</p>

<h2><a name="Resource_Functions"
>Resource Functions <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>*/</p>

<p>#include &#34;parrot/parrot.h&#34; #include &#34;io_private.h&#34;</p>

<p>#include &#60;stdarg.h&#62; #include &#60;assert.h&#62;</p>

<p>/* HEADERIZER HFILE: include/parrot/io.h */</p>

<p>/* This is list of valid layers */ ParrotIOLayer **pio_registered_layers = NULL;</p>

<p>/* This is the default stack used for IO.
Copy this to each new interp */ /* ParrotIOLayer * pio_default_stack; */</p>

<p>/* The standard streams are:</p>

<pre lang='und' xml:lang='und'>                interp&#45;&#62;piodata&#45;&#62;table[PIO_STD*_FILENO].
*/</pre>

<p>PIOOFF_T piooffsetzero;</p>

<p>/*</p>

<p>FUNCDOC: new_io_pmc</p>

<p>Creates and returns a new <code lang='und' xml:lang='und'>ParrotIO</code> PMC.</p>

<p>*/</p>

<p>PARROT_API PMC * new_io_pmc(PARROT_INTERP, NULLOK(ParrotIO *io)) { PMC * const new_pmc = pmc_new(interp, enum_class_ParrotIO); PMC_data(new_pmc) = io; PMC_struct_val(new_pmc) = io ? io&#45;&#62;stack : NULL; return new_pmc; }</p>

<p>/*</p>

<p>FUNCDOC: PIO_make_io_string</p>

<p>Creates a STRING* suitable for returning results from IO read functions. The passed in <code lang='und' xml:lang='und'>buf</code> parameter can:</p>

<ol>
<li>Point to a NULL STRING</li><p class="pad"></p>

<li>Point to a real STRING</li><p class="pad"></p>

<li>Point to a fake STRING with (strstart, bufused) holding the *buffer information.</li><p class="pad"></p>
</ol>

<p>In the third case, the buffer or STRING must be able to hold the required amount of data. For cases 1 and 2, a NULL <code lang='und' xml:lang='und'>strstart</code> tells this function to allocate the STRING memory.</p>

<p>*/</p>

<p>PARROT_WARN_UNUSED_RESULT STRING * PIO_make_io_string(PARROT_INTERP, NOTNULL(STRING **buf), size_t len) { STRING *s; /* * when we get a NULL string, we read a default len */ if (*buf == NULL) { *buf = string_make_empty(interp, enum_stringrep_one, len); return *buf; } s = *buf; if (s&#45;&#62;bufused &#60; len) Parrot_allocate_string(interp, s, len); return s; }</p>

<p>/*</p>

<p>FUNCDOC: PIO_new</p>

<p>Creates a new IO stream.</p>

<p>The values of <code lang='und' xml:lang='und'>flags</code> and <code lang='und' xml:lang='und'>mode</code> are set in the returned <code lang='und' xml:lang='und'>ParrotIO</code>.</p>

<p>Currently <code lang='und' xml:lang='und'>iotype</code> is unused.</p>

<p>*/</p>

<p>PARROT_API PARROT_WARN_UNUSED_RESULT ParrotIO * PIO_new(PARROT_INTERP, SHIM(INTVAL iotype), INTVAL flags, INTVAL mode) { ParrotIO * const new_io = (ParrotIO *)mem_sys_allocate(sizeof (ParrotIO));</p>

<pre lang='und' xml:lang='und'>    new_io&#45;&#62;fpos = new_io&#45;&#62;lpos = piooffsetzero;
    new_io&#45;&#62;flags = flags;
    new_io&#45;&#62;mode = mode;
    new_io&#45;&#62;stack = interp&#45;&#62;piodata&#45;&#62;default_stack;
    new_io&#45;&#62;b.flags = 0;
    new_io&#45;&#62;b.size = 0;
    new_io&#45;&#62;b.startb = NULL;
    new_io&#45;&#62;b.endb = NULL;
    new_io&#45;&#62;b.next = NULL;
    return new_io;
}</pre>

<p>/*</p>

<p>FUNCDOC: PIO_destroy</p>

<p>Destroys the IO stream. At the moment, this only frees the memory and removes the pointers from the PMC.</p>

<p>*/</p>

<p>PARROT_API void PIO_destroy(SHIM_INTERP, NOTNULL(PMC *pmc)) { ParrotIO * const io = (ParrotIO *)PMC_data0(pmc);</p>

<pre lang='und' xml:lang='und'>    if (!io)
        return;
    if (io&#45;&#62;b.startb &#38;&#38; (io&#45;&#62;b.flags &#38; PIO_BF_MALLOC)) {
        mem_sys_free(io&#45;&#62;b.startb);
        io&#45;&#62;b.startb = 0;
    }
#if 0
    /*
     * PIO_destroy is called by PIO_close
     * XXX can&#39;t munmap now
     */
    if (io&#45;&#62;b.startb &#38;&#38; (io&#45;&#62;b.flags &#38; PIO_BF_MMAP)) {
#  ifdef PARROT_HAS_HEADER_SYSMMAN
        munmap((void*)io&#45;&#62;b.startb, io&#45;&#62;b.size);
#  endif
        io&#45;&#62;b.startb = io&#45;&#62;b.endb = NULL;
        io&#45;&#62;b.size = 0;
    }
#endif
    if ((io&#45;&#62;stack&#45;&#62;flags &#38; PIO_L_LAYER_COPIED)) {
        ParrotIOLayer *p;
        for (p = io&#45;&#62;stack; p;) {
            ParrotIOLayer *down;
            /* if top got copied, all have to be malloced */
            assert(p&#45;&#62;flags &#38; PIO_L_LAYER_COPIED);
            down = p&#45;&#62;down;
            if (p&#45;&#62;api&#45;&#62;Delete)
                (*p&#45;&#62;api&#45;&#62;Delete) (p);
            p = down;
        }
    }
    mem_sys_free(io);
    PMC_data(pmc) = NULL;
    PMC_struct_val(pmc) = NULL;
}</pre>

<p>/*</p>

<p>FUNCDOC: PIO_init</p>

<p>Sets up the interpreter&#39;s layer stack and creates the <code lang='und' xml:lang='und'>STD*</code> handles.</p>

<p>Called when creating an interpreter.</p>

<p>*/</p>

<p>PARROT_API void PIO_init(PARROT_INTERP) { /* Has interp been initialized already? */ if (interp&#45;&#62;piodata) { /* memsub system is up and running: */ /* Init IO stacks and handles for interp instance. */ if (PIO_init_stacks(interp) != 0) { real_exception(interp, NULL, PIO_ERROR, &#34;PIO init stacks failed.&#34;); }</p>

<pre lang='und' xml:lang='und'>        /*
         * see also #36677
         *
         */
        if (!_PIO_STDIN(interp)) {
            _PIO_STDIN(interp) = pmc_new(interp, enum_class_Undef);
        }
        if (!_PIO_STDOUT(interp)) {
            _PIO_STDOUT(interp) = pmc_new(interp, enum_class_Undef);
        }
        if (!_PIO_STDERR(interp)) {
            _PIO_STDERR(interp) = pmc_new(interp, enum_class_Undef);
        }

        if (Interp_debug_TEST(interp, PARROT_START_DEBUG_FLAG)) {
            PIO_eprintf(NULL, &#34;PIO: IO system initialized.\n&#34;);
        }

        return;
    }


    interp&#45;&#62;piodata = mem_allocate_typed(ParrotIOData);
    if (interp&#45;&#62;piodata == NULL)
        real_exception(interp, NULL, PIO_ERROR, &#34;PIO alloc piodata failure.&#34;);
    interp&#45;&#62;piodata&#45;&#62;default_stack = NULL;
    interp&#45;&#62;piodata&#45;&#62;table = mem_sys_allocate_zeroed(PIO_NR_OPEN * sizeof(ParrotIO *));
    if (interp&#45;&#62;piodata&#45;&#62;table == NULL)
        real_exception(interp, NULL, PIO_ERROR, &#34;PIO alloc table failure.&#34;);</pre>

<p>}</p>

<p>/*</p>

<p>FUNCDOC: PIO_finish</p>

<p>Closes the interpreter&#39;s IO resourses. Called during its interpreter destruction.</p>

<p>*/</p>

<p>PARROT_API void PIO_finish(PARROT_INTERP) { ParrotIOLayer *layer; #if 0 PMC *pmc; ParrotIO *io; int i;</p>

<pre lang='und' xml:lang='und'>    /* When here, the PMC arena is already destroyed, these PMCs
     * aren&#39;t usable any more.
     * But ParrotIO::destroy should have flushed/closed all PIOs
     * already. If that&#39;s not quite true, we have to separate IO subsys
     * destruction into two parts (again).
     */
    for (i = 0 ; i &#60; PIO_NR_OPEN; i++) {
        if ((pmc = interp&#45;&#62;piodata&#45;&#62;table[i])) {
            layer = PMC_struct_val(pmc);
            io = PMC_data(pmc);
            PIO_close_down(interp, layer, io);
        }
    }
#endif
    /*
     * TODO free IO of std&#45;handles
     */
    for (layer = interp&#45;&#62;piodata&#45;&#62;default_stack; layer;) {
        ParrotIOLayer * const down = layer&#45;&#62;down;
        if (layer&#45;&#62;api&#45;&#62;Delete)
            (*layer&#45;&#62;api&#45;&#62;Delete) (layer);
        layer = down;
    }
    mem_sys_free(interp&#45;&#62;piodata&#45;&#62;table);
    interp&#45;&#62;piodata&#45;&#62;table = NULL;
    mem_sys_free(interp&#45;&#62;piodata);
    interp&#45;&#62;piodata = NULL;</pre>

<p>}</p>

<p>/*</p>

<p>FUNCDOC: PIO_internal_shutdown</p>

<p>IO system destructor, called on destruction of the last interpreter.</p>

<p>*/</p>

<p>PARROT_API void PIO_internal_shutdown(SHIM_INTERP) { mem_sys_free(pio_registered_layers); pio_registered_layers = NULL; }</p>

<p>/*</p>

<p>FUNCDOC: PIO_init_stacks</p>

<p>Initializes the interpreter&#39;s default IO stack by pushing on the IO layers (OS&#45;specific first).</p>

<p>*/</p>

<p>PARROT_API INTVAL PIO_init_stacks(PARROT_INTERP) { ParrotIOLayer *p, *bottom = NULL; int fill, n, i;</p>

<pre lang='und' xml:lang='und'>    /* First push the platform specific OS layer */
    /* Optimize this to keep a default stack and just
     * call copy stack.
     */
#ifdef PIO_OS_UNIX
    PIO_push_layer(interp, PMCNULL, PIO_base_new_layer(&#38;pio_unix_layer));
#endif
#ifdef PIO_OS_WIN32
    PIO_push_layer(interp, PMCNULL, PIO_base_new_layer(&#38;pio_win32_layer));
#endif
#ifdef PIO_OS_STDIO
    PIO_push_layer(interp, PMCNULL, PIO_base_new_layer(&#38;pio_stdio_layer));
#endif
    PIO_push_layer(interp, PMCNULL, PIO_base_new_layer(&#38;pio_buf_layer));

    fill = 0;
    if (!pio_registered_layers) {
        n = 5;  /* 2 default layers for now + utf8, mmap, string */
        pio_registered_layers = (ParrotIOLayer **)mem_sys_allocate(
                sizeof (ParrotIOLayer *) * (n + 1));
        fill = 1;
    }

    /* Note: All layer pushes should be done before init calls */
    for (i = 0, p = interp&#45;&#62;piodata&#45;&#62;default_stack; p; p = p&#45;&#62;down) {
        bottom = p;
        if (fill) {
            assert(i &#60; n); /* XXX n can be undefined at this point. */
            pio_registered_layers[i++] = p;
            pio_registered_layers[i] = NULL;
        }
    }
    /*
     * Init calls where done top down, which seem quite wrong  &#45; lower
     * levels need first to open e.g. STD*. Then the buffered layer can
     * set linebuffering or such
     */
    for (p = bottom; p; p = p&#45;&#62;up) {
        if (p&#45;&#62;api&#45;&#62;Init) {
            if ((*p&#45;&#62;api&#45;&#62;Init) (interp, p) != 0) {
                /* ignore err
                 * see also #36677
                char buf[1024];
                sprintf(buf, &#34;Parrot IO: Failed init layer(%s).\n&#34;, p&#45;&#62;name);
                real_exception(interp, NULL, PIO_ERROR, buf);
                */
                ;
            }
        }
    }
    if (fill) {
        assert(i == 2);
        assert(pio_registered_layers[2] == NULL);
        pio_registered_layers[2] = PIO_utf8_register_layer();
        pio_registered_layers[3] = PIO_mmap_register_layer();
        pio_registered_layers[4] = PIO_string_register_layer();
        pio_registered_layers[5] = NULL;
    }

    return 0;
}</pre>

<p>/*</p>

<p>FUNCDOC: PIO_base_init</p>

<p>Init routine called once for each layer at interpreter creation time. This is similar to a Perl module <code lang='und' xml:lang='und'>INIT {}</code> block.</p>

<p>This default implementation does nothing and returns <code lang='und' xml:lang='und'>0</code>.</p>

<p>*/</p>

<p>PARROT_API INTVAL PIO_base_init(SHIM_INTERP, SHIM(ParrotIOLayer *l)) { return 0; }</p>

<p>/*</p>

<h2><a name="Generic_top&#45;level_ParrotIO_interface"
>Generic top&#45;level <code lang='und' xml:lang='und'>ParrotIO</code> interface <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>FUNCDOC: PIO_parse_open_flags</p>

<p>Parses <code lang='und' xml:lang='und'>*flagstr</code> for Perl&#45;style file open mode flags (<code lang='und' xml:lang='und'>&#60;</code>, <code lang='und' xml:lang='und'>&#62;</code>, <code lang='und' xml:lang='und'>&#62;&#62;</code>, <code lang='und' xml:lang='und'>+&#60;</code>, <code lang='und' xml:lang='und'>+&#62;</code>) and returns the combined generic bit flags.</p>

<p>The low level OS layers may then interpret the generic bits differently depending on platform.</p>

<p>XXX BD Should this be static?</p>

<p>*/</p>

<p>PARROT_API PARROT_WARN_UNUSED_RESULT INTVAL PIO_parse_open_flags(NULLOK(const char *flagstr)) { INTVAL flags; const char *s;</p>

<pre lang='und' xml:lang='und'>    if (!flagstr || !(*flagstr))
        return 0;
    flags = 0;
    s = flagstr;
    /* Set mode flags &#45; &#60;, &#62;, &#62;&#62;, +&#60;, +&#62; */
    switch (*s++) {
        case &#39;+&#39;:
            flags |= (PIO_F_WRITE | PIO_F_READ);
            switch (*s++) {
                case &#39;&#60;&#39;:
                    break;
                case &#39;&#62;&#39;:
                    flags |= PIO_F_TRUNC;
                    break;
                default:
                    return 0;
            }
            break;
        case &#39;&#60;&#39;:
            flags |= PIO_F_READ;
            break;
        case &#39;&#62;&#39;:
            flags |= PIO_F_WRITE;
            if (*s == &#39;&#62;&#39;) {
                flags |= PIO_F_APPEND;
                s++;
            }
            else {
                flags |= PIO_F_TRUNC;
            }
            break;
        case &#39;&#45;&#39;:       /* &#45;| read from pipe */
            if (*s == &#39;|&#39;) {
                flags |= PIO_F_PIPE | PIO_F_READ;
                s++;
            }
            break;
        case &#39;|&#39;:       /* |&#45; write to pipe */
            if (*s == &#39;&#45;&#39;) {
                flags |= PIO_F_PIPE | PIO_F_WRITE;
                s++;
            }
            break;
        default:
            return 0;
    }

    /* TODO: add ? and ! for block/non&#45;block */
    switch (*s++) {
        case &#39;\0&#39;:
            /* No extra arguments */
            break;
        default:
            return 0;
    }

    return flags;
}</pre>

<p>/*</p>

<p>FUNCDOC: PIO_peek</p>

<p>Iterates down the stack to the first layer implementing &#34;Peek&#34; API.</p>

<p>*/</p>

<p>PARROT_API INTVAL PIO_peek(PARROT_INTERP, NOTNULL(PMC *pmc), NOTNULL(STRING **buffer)) { ParrotIOLayer * const l = (ParrotIOLayer *)PMC_struct_val(pmc); ParrotIO * const io = (ParrotIO *)PMC_data0(pmc); if (!io) return &#45;1; return PIO_peek_down(interp, l, io, buffer); }</p>

<p>/*</p>

<p>FUNCDOC: PIO_pioctl</p>

<p>General purpose interface for manipulating IO objects and layer attributes.</p>

<p>Refer to the <code lang='und' xml:lang='und'>PIOCTL*</code> values in <em lang='und' xml:lang='und'>include/parrot/io.h</em>.</p>

<p>All <code lang='und' xml:lang='und'>set</code> operations return <code lang='und' xml:lang='und'>0</code> on success and a negative value on error. <code lang='und' xml:lang='und'>get</code> operations use the return value as the value requested, but should always be <code lang='und' xml:lang='und'>&#62;= 0</code>. A negative value indicates an error. This may be too limited, but we will see. &#45;&#45;Melvin</p>

<p>*/</p>

<p>PARROT_API INTVAL PIO_pioctl(PARROT_INTERP, NOTNULL(PMC *pmc), INTVAL cmd, INTVAL arg) {</p>

<pre lang='und' xml:lang='und'>    ParrotIO * const io = (ParrotIO *)PMC_data0(pmc);
    ParrotIOBuf * b;
    if (!io)
        return &#45;1;
    b = &#38;io&#45;&#62;b;

    switch (cmd) {
       case PIOCTL_CMDSETRECSEP: io&#45;&#62;recsep = arg;

       case PIOCTL_CMDGETRECSEP: return io&#45;&#62;recsep;

       case PIOCTL_CMDSETBUFTYPE:
            if (arg == PIOCTL_NONBUF)
               return PIO_setbuf(interp, pmc, 0);
            else if (arg == PIOCTL_LINEBUF)
               return PIO_setlinebuf(interp, pmc);
            else if (arg == PIOCTL_BLKBUF)
               return PIO_setbuf(interp, pmc, PIO_UNBOUND);
            else return &#45;1;

       case PIOCTL_CMDGETBUFTYPE:
            if (io&#45;&#62;flags &#38; PIO_F_LINEBUF) return PIOCTL_LINEBUF;
            if (io&#45;&#62;flags &#38; PIO_F_BLKBUF) return PIOCTL_BLKBUF;
            return PIOCTL_NONBUF;

       case PIOCTL_CMDSETBUFSIZE:
            return PIO_setbuf(interp, pmc, arg);

       case PIOCTL_CMDGETBUFSIZE:
             if (b) return b&#45;&#62;size;
             else return &#45;1;
       default: return &#45;1;
    }

    return 0;
}</pre>

<p>/*</p>

<p>FUNCDOC: PIO_setbuf</p>

<p>Sets the buffer size for <code lang='und' xml:lang='und'>*pmc</code> to <code lang='und' xml:lang='und'>bufsize</code>. Returns <code lang='und' xml:lang='und'>0</code> if the buffering was enabled.</p>

<p>*/</p>

<p>PARROT_API INTVAL PIO_setbuf(PARROT_INTERP, NOTNULL(PMC *pmc), size_t bufsize) { ParrotIOLayer * const layer = (ParrotIOLayer *)PMC_struct_val(pmc); ParrotIO * const io = (ParrotIO *)PMC_data0(pmc); if (!io) return &#45;1; PIO_flush(interp, pmc); return PIO_setbuf_down(interp, layer, io, bufsize); }</p>

<p>/*</p>

<p>FUNCDOC: PIO_setlinebuf</p>

<p>Enables line buffering for <code lang='und' xml:lang='und'>*pmc</code>. Returns <code lang='und' xml:lang='und'>0</code> if line buffering was successfully set, or already enabled.</p>

<p>*/</p>

<p>PARROT_API INTVAL PIO_setlinebuf(PARROT_INTERP, NOTNULL(PMC *pmc)) { ParrotIOLayer * const l = (ParrotIOLayer *)PMC_struct_val(pmc); ParrotIO * const io = (ParrotIO *)PMC_data0(pmc); if (!io) return &#45;1;</p>

<pre lang='und' xml:lang='und'>    return PIO_setlinebuf_down(interp, l, io);
}</pre>

<p>/*</p>

<p>FUNCDOC: PIO_open</p>

<p>Creates and returns a <code lang='und' xml:lang='und'>ParrotIO</code> PMC for <code lang='und' xml:lang='und'>*spath</code>.</p>

<p>*/</p>

<p>PARROT_API PARROT_WARN_UNUSED_RESULT PMC * PIO_open(PARROT_INTERP, NULLOK(ParrotIOLayer *layer), NOTNULL(const char *spath), NOTNULL(const char *sflags)) { ParrotIO *io; const INTVAL flags = PIO_parse_open_flags(sflags);</p>

<pre lang='und' xml:lang='und'>    if (!layer) {
        layer = interp&#45;&#62;piodata&#45;&#62;default_stack;
    }

    io = PIO_open_down(interp, layer, spath, flags);
    /* io could be null here but we still have to
     * to create a PMC for the caller, no PMCNULL here
     * as that would cause an exception upon access.
     */
    if (io) {
        io&#45;&#62;stack = layer;
    }

    return new_io_pmc(interp, io);
}</pre>

<p>/*</p>

<p>FUNCDOC: PIO_fdopen</p>

<p>Creates and returns a <code lang='und' xml:lang='und'>ParrotIO</code> PMC for <code lang='und' xml:lang='und'>*spath</code> on an existing, open file descriptor.</p>

<p>This is used particularly to initialize the <code lang='und' xml:lang='und'>STD*</code> IO handles onto the OS IO handles (0,1,2).</p>

<p>*/</p>

<p>PARROT_API PARROT_WARN_UNUSED_RESULT PMC * PIO_fdopen(PARROT_INTERP, NULLOK(ParrotIOLayer *layer), PIOHANDLE fd, NOTNULL(const char *sflags)) { ParrotIO *io; INTVAL flags;</p>

<pre lang='und' xml:lang='und'>    if (!layer) {
        layer = interp&#45;&#62;piodata&#45;&#62;default_stack;
    }

    flags = PIO_parse_open_flags(sflags);
    if (!flags)
        return NULL;

    io = PIO_fdopen_down(interp, layer, fd, flags);
    /* io could be null here but we still have to
     * to create a PMC for the caller, no PMCNULL here
     * as that would cause an exception upon access.
     */
    if (io) {
        io&#45;&#62;stack = layer;
    }

    return new_io_pmc(interp, io);
}</pre>

<p>/*</p>

<p>FUNCDOC: PIO_close</p>

<p>Flushes, closes, and destroys the <code lang='und' xml:lang='und'>ParrotIO</code> PMC <code lang='und' xml:lang='und'>*pmc</code>.</p>

<p>*/</p>

<p>PARROT_API INTVAL PIO_close(PARROT_INTERP, NULLOK(PMC *pmc)) { INTVAL res; ParrotIOLayer * const l = (ParrotIOLayer *)PMC_struct_val(pmc); ParrotIO * const io = (ParrotIO *)PMC_data0(pmc); if (!io) return &#45;1; PIO_flush(interp, pmc); /* XXX boe: is this neccessary here? */ res = PIO_close_down(interp, l, io); PIO_destroy(interp, pmc);</p>

<pre lang='und' xml:lang='und'>    return res;
}</pre>

<p>/*</p>

<p>FUNCDOC: PIO_flush</p>

<p>Flushes the <code lang='und' xml:lang='und'>ParrotIO</code> PMC <code lang='und' xml:lang='und'>*pmc</code>.</p>

<p>*/</p>

<p>PARROT_API void PIO_flush(PARROT_INTERP, NOTNULL(PMC *pmc)) { ParrotIOLayer * const l = (ParrotIOLayer *)PMC_struct_val(pmc); ParrotIO * const io = (ParrotIO *)PMC_data0(pmc); if (!io) return;</p>

<pre lang='und' xml:lang='und'>    PIO_flush_down(interp, l, io);
}</pre>

<p>/*</p>

<p>FUNCDOC: PIO_reads</p>

<p>Return a new <code lang='und' xml:lang='und'>STRING*</code> holding up to <code lang='und' xml:lang='und'>len</code> bytes.</p>

<p>FUNCDOC: PIO_read</p>

<p>Reads up to <code lang='und' xml:lang='und'>len</code> bytes from <code lang='und' xml:lang='und'>*pmc</code> and copies them into <code lang='und' xml:lang='und'>*buffer</code>.</p>

<p>*/</p>

<p>PARROT_API PARROT_WARN_UNUSED_RESULT STRING * PIO_reads(PARROT_INTERP, NOTNULL(PMC *pmc), size_t len) { STRING *res; ParrotIOLayer * const l = (ParrotIOLayer *)PMC_struct_val(pmc); ParrotIO * const io = (ParrotIO *)PMC_data0(pmc);</p>

<pre lang='und' xml:lang='und'>    if (!io)
        return new_string_header(interp, 0);

    if (io&#45;&#62;b.flags &#38; PIO_BF_MMAP) {
        res = new_string_header(interp, 0);
        res&#45;&#62;charset = Parrot_iso_8859_1_charset_ptr;   /* XXX binary */
        res&#45;&#62;encoding = Parrot_fixed_8_encoding_ptr;
    }
    else {
        res = NULL;
        res = PIO_make_io_string(interp, &#38;res, len);
    }

    res&#45;&#62;bufused = len;
    PIO_read_down(interp, l, io, &#38;res);

    return res;
}</pre>

<p>PARROT_API PARROT_WARN_UNUSED_RESULT INTVAL PIO_read(PARROT_INTERP, NOTNULL(PMC *pmc), NOTNULL(char *buffer), size_t len) { ParrotIOLayer * const l = (ParrotIOLayer *)PMC_struct_val(pmc); ParrotIO * const io = (ParrotIO *)PMC_data0(pmc); STRING *res = new_string_header(interp, 0); if (!io) return &#45;1;</p>

<pre lang='und' xml:lang='und'>    res&#45;&#62;strstart = buffer;
    res&#45;&#62;bufused = len;
    return PIO_read_down(interp, l, io, &#38;res);
}</pre>

<p>/*</p>

<p>FUNCDOC: PIO_write</p>

<p>Writes <code lang='und' xml:lang='und'>len</code> bytes from <code lang='und' xml:lang='und'>*buffer</code> to <code lang='und' xml:lang='und'>*pmc</code>.</p>

<p>*/</p>

<p>PARROT_API PARROT_WARN_UNUSED_RESULT INTVAL PIO_write(PARROT_INTERP, NOTNULL(PMC *pmc), NOTNULL(const void *buffer), size_t len) { ParrotIOLayer * const l = (ParrotIOLayer *)PMC_struct_val(pmc); ParrotIO * const io = (ParrotIO *)PMC_data0(pmc); DECL_CONST_CAST;</p>

<pre lang='und' xml:lang='und'>    if (!io)
        return &#45;1;

    if (io&#45;&#62;flags &#38; PIO_F_WRITE) {
        STRING fake;
        /* TODO skip utf8 translation layers if any */
        fake.strstart = (char *)const_cast(buffer);
        fake.strlen = fake.bufused = len;
        fake.charset = Parrot_default_charset_ptr;
        fake.encoding = Parrot_default_encoding_ptr;
        return PIO_write_down(interp, l, io, &#38;fake);
    }
    else
        return 0;
}</pre>

<p>/*</p>

<p>FUNCDOC: PIO_seek</p>

<p>Moves the read/write position of <code lang='und' xml:lang='und'>*pmc</code> to offset <code lang='und' xml:lang='und'>bytes</code> from the position indicated by <code lang='und' xml:lang='und'>w</code>. Typically <code lang='und' xml:lang='und'>w</code> will be <code lang='und' xml:lang='und'>0</code> for the start of the file, <code lang='und' xml:lang='und'>1</code> for the current position, and <code lang='und' xml:lang='und'>2</code> for the end.</p>

<p>*/</p>

<p>PARROT_API PARROT_WARN_UNUSED_RESULT PIOOFF_T PIO_seek(PARROT_INTERP, NOTNULL(PMC *pmc), PIOOFF_T offset, INTVAL w) { ParrotIOLayer * const l = (ParrotIOLayer *)PMC_struct_val(pmc); ParrotIO * const io = (ParrotIO *)PMC_data0(pmc); if (!io) return &#45;1;</p>

<pre lang='und' xml:lang='und'>    return PIO_seek_down(interp, l, io, offset, w);
}</pre>

<p>/*</p>

<p>FUNCDOC: PIO_tell</p>

<p>Returns the current read/write position of <code lang='und' xml:lang='und'>*pmc</code>.</p>

<p>*/</p>

<p>PARROT_API PARROT_WARN_UNUSED_RESULT PIOOFF_T PIO_tell(PARROT_INTERP, NOTNULL(PMC *pmc)) { ParrotIOLayer * const l = (ParrotIOLayer *)PMC_struct_val(pmc); ParrotIO * const io = (ParrotIO *)PMC_data0(pmc); if (!io) return &#45;1;</p>

<pre lang='und' xml:lang='und'>    return PIO_tell_down(interp, l, io);
}</pre>

<p>/*</p>

<p>FUNCDOC: PIO_eof</p>

<p>Returns a boolean value indication whether <code lang='und' xml:lang='und'>*pmc</code>&#39;s current read/write position is <code lang='und' xml:lang='und'>EOF</code>.</p>

<p>*/</p>

<p>PARROT_API PARROT_WARN_UNUSED_RESULT INTVAL PIO_eof(SHIM_INTERP, NOTNULL(PMC *pmc)) { ParrotIO * const io = (ParrotIO *)PMC_data0(pmc);</p>

<pre lang='und' xml:lang='und'>    /* io could be null here, but rather than return a negative error
     * we just fake EOF since eof test is usually in a boolean context.
     */
    if (io) {
        return (io&#45;&#62;flags &#38; (PIO_F_EOF)) ? 1 : 0;
    }
    return 1;
}</pre>

<p>/*</p>

<p>FUNCDOC: PIO_puts</p>

<p>Writes <code lang='und' xml:lang='und'>*s</code> tp <code lang='und' xml:lang='und'>*pmc</code>. C string version.</p>

<p>*/</p>

<p>PARROT_API INTVAL PIO_puts(PARROT_INTERP, NOTNULL(PMC *pmc), NOTNULL(const char *s)) { return PIO_write(interp, pmc, s, strlen(s)); }</p>

<p>/*</p>

<p>FUNCDOC: PIO_putps</p>

<p>Writes <code lang='und' xml:lang='und'>*s</code> to <code lang='und' xml:lang='und'>*pmc</code>. Parrot string version.</p>

<p>*/</p>

<p>PARROT_API INTVAL PIO_putps(PARROT_INTERP, NOTNULL(PMC *pmc), NULLOK(STRING *s)) { ParrotIOLayer * const l = (ParrotIOLayer *)PMC_struct_val(pmc); ParrotIO * const io = (ParrotIO *)PMC_data0(pmc); assert((unsigned long)l != 0xdeadbeefUL); assert(io != 0);</p>

<pre lang='und' xml:lang='und'>    if (!s)
        return 0;
#if ! DISABLE_GC_DEBUG
    /* trigger GC for debug &#45; but not during tests */
    if (0 &#38;&#38; GC_DEBUG(interp))
        Parrot_do_dod_run(interp, DOD_trace_stack_FLAG);
#endif
    return PIO_write_down(interp, l, io, s);
}</pre>

<p>/*</p>

<p>FUNCDOC: PIO_fprintf</p>

<p>Writes a C string format with varargs to <code lang='und' xml:lang='und'>*pmc</code>.</p>

<p>*/</p>

<p>PARROT_API INTVAL PIO_fprintf(PARROT_INTERP, NOTNULL(PMC *pmc), NOTNULL(const char *s), ...) { va_list args; INTVAL ret;</p>

<pre lang='und' xml:lang='und'>    va_start(args, s);

    ret=PIO_putps(interp, pmc, Parrot_vsprintf_c(interp, s, args));

    va_end(args);

    return ret;
}</pre>

<p>/*</p>

<p>FUNCDOC: PIO_printf</p>

<p>Writes a C string format with varargs to <code lang='und' xml:lang='und'>stdout</code>.</p>

<p>*/</p>

<p>PARROT_API INTVAL PIO_printf(PARROT_INTERP, NOTNULL(const char *s), ...) { va_list args; INTVAL ret;</p>

<pre lang='und' xml:lang='und'>    va_start(args, s);

    if (interp) {
        STRING * const str = Parrot_vsprintf_c(interp, s, args);
        ret=PIO_putps(interp, _PIO_STDOUT(interp), str);
    }
    else {
        /* Be nice about this...
         **   XXX BD Should this use the default PIO_STDOUT or something?
         */
        ret=vfprintf(stdout, s, args);
    }

    va_end(args);

    return ret;
}</pre>

<p>/*</p>

<p>FUNCDOC: PIO_eprintf</p>

<p>Writes a C string format with varargs to <code lang='und' xml:lang='und'>stderr</code>.</p>

<p>*/</p>

<p>PARROT_API INTVAL PIO_eprintf(NULLOK(PARROT_INTERP), NOTNULL(const char *s), ...) { va_list args; INTVAL ret;</p>

<pre lang='und' xml:lang='und'>    va_start(args, s);

    if (interp) {
        STRING * const str = Parrot_vsprintf_c(interp, s, args);

        ret=PIO_putps(interp, _PIO_STDERR(interp), str);
    }
    else {
        /* Be nice about this...
        **   XXX BD Should this use the default PIO_STDERR or something?
        */
        ret=vfprintf(stderr, s, args);
    }

    va_end(args);

    return ret;
}</pre>

<p>/*</p>

<p>FUNCDOC: PIO_getfd</p>

<p>Returns <code lang='und' xml:lang='und'>*pmc</code>&#39;s file descriptor, or <code lang='und' xml:lang='und'>0</code> if it is not defined.</p>

<p>*/</p>

<p>PARROT_API PARROT_WARN_UNUSED_RESULT PIOHANDLE PIO_getfd(SHIM_INTERP, NOTNULL(PMC *pmc)) { ParrotIO * const io = (ParrotIO *)PMC_data0(pmc);</p>

<pre lang='und' xml:lang='und'>    if (io)
        return io&#45;&#62;fd;

    return (PIOHANDLE)0;        /* XXX that&#39;s plain wrong &#45;&#45;leo */
}</pre>

<p>/*</p>

<h2><a name="PIO_STD*_Functions"
><code lang='und' xml:lang='und'>PIO_STD*</code> Functions <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>*/</p>

<p>/*</p>

<p>FUNCDOC: PIO_STDIN</p>

<p>Returns the <code lang='und' xml:lang='und'>ParrotIO</code> PMC for <code lang='und' xml:lang='und'>stdin</code>.</p>

<p>*/</p>

<p>PARROT_API PMC * PIO_STDIN(PARROT_INTERP) { return _PIO_STDIN(interp); }</p>

<p>/*</p>

<p>FUNCDOC: PIO_STDOUT</p>

<p>Returns the <code lang='und' xml:lang='und'>ParrotIO</code> PMC for <code lang='und' xml:lang='und'>stdout</code>.</p>

<p>*/</p>

<p>PARROT_API PMC * PIO_STDOUT(PARROT_INTERP) { return _PIO_STDOUT(interp); }</p>

<p>/*</p>

<p>FUNCDOC: PIO_STDERR</p>

<p>Returns the <code lang='und' xml:lang='und'>ParrotIO</code> PMC for <code lang='und' xml:lang='und'>stderr</code>.</p>

<p>*/</p>

<p>PARROT_API PMC * PIO_STDERR(PARROT_INTERP) { return _PIO_STDERR(interp); }</p>

<p>/*</p>

<h2><a name="DOD&#45;related_Functions"
>DOD&#45;related Functions <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>FUNCDOC: Parrot_IOData_mark</p>

<p>Called from <code lang='und' xml:lang='und'>trace_active_PMCs()</code> to mark the IO data live.</p>

<p>*/</p>

<p>PARROT_API void Parrot_IOData_mark(PARROT_INTERP, NOTNULL(ParrotIOData *piodata)) { INTVAL i; ParrotIOTable table = piodata&#45;&#62;table;</p>

<pre lang='und' xml:lang='und'>    /* this was i &#60; PIO_NR_OPEN, but only standard handles 0..2 need
     * to be kept alive AFAIK &#45;leo
     */
    for (i = 0; i &#60; 3; i++) {
        if (table[i]) {
            pobject_lives(interp, (PObj *)table[i]);
        }
    }
}</pre>

<p>/*</p>

<h2><a name="Offset_Functions"
>Offset Functions <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>These are used to create offsets for the <code lang='und' xml:lang='und'>seek</code> op.</p>

<p>FUNCDOC: PIO_make_offset</p>

<p>Returns <code lang='und' xml:lang='und'>offset</code>.</p>

<p>*/</p>

<p>PIOOFF_T PIO_make_offset(INTVAL offset) { return offset; }</p>

<p>/*</p>

<p>FUNCDOC: PIO_make_offset32</p>

<p><code lang='und' xml:lang='und'>hi</code> is shifted 32 bytes to the left and <code lang='und' xml:lang='und'>or</code>ed together with <code lang='und' xml:lang='und'>lo</code>. This allows 64&#45;bit seeks with only 32&#45;bit <code lang='und' xml:lang='und'>INTVALS</code>.</p>

<p>*/</p>

<p>PIOOFF_T PIO_make_offset32(INTVAL hi, INTVAL lo) { return ((PIOOFF_T)hi &#60;&#60; 31) | lo; }</p>

<p>/*</p>

<p>FUNCDOC: PIO_make_offset_pmc</p>

<p>Returns the return value of the <code lang='und' xml:lang='und'>get_integer</code> vtable method on <code lang='und' xml:lang='und'>*pmc</code>.</p>

<p>*/</p>

<p>PIOOFF_T PIO_make_offset_pmc(PARROT_INTERP, PMC *pmc) { /* XXX: Maybe use bignums here */ return VTABLE_get_integer(interp, pmc); }</p>

<p>/*</p>

<h2><a name="Networking_Functions"
>Networking Functions <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>FUNCDOC: PIO_poll</p>

<p>Polls <code lang='und' xml:lang='und'>*pmc</code> for the events in <code lang='und' xml:lang='und'>which</code> every <code lang='und' xml:lang='und'>sec</code> seconds + <code lang='und' xml:lang='und'>usec</code> microseconds.</p>

<p>*/</p>

<p>PARROT_API INTVAL PIO_poll(PARROT_INTERP, NOTNULL(PMC *pmc), INTVAL which, INTVAL sec, INTVAL usec) { ParrotIOLayer *l; ParrotIO *io;</p>

<pre lang='und' xml:lang='und'>    if ( PMC_IS_NULL(pmc) ) {
        real_exception(interp, NULL, E_ValueError, &#34;Can&#39;t poll NULL pmc&#34;);
    }

    l = (ParrotIOLayer *)PMC_struct_val(pmc);
    io = (ParrotIO *)PMC_data0(pmc);
    return PIO_poll_down(interp, l, io, which, sec, usec);
}</pre>

<p>/*</p>

<p>FUNCDOC: PIO_socket</p>

<p>Creates and returns a socket using the specified address family, socket type, and protocol number. Check the returned PMC with a boolean test to see whether the socket was successfully created.</p>

<p>*/</p>

<p>PARROT_API PMC * PIO_socket(PARROT_INTERP, INTVAL fam, INTVAL type, INTVAL proto) { ParrotIOLayer * const l = interp&#45;&#62;piodata&#45;&#62;default_stack; ParrotIO * const io = PIO_socket_down(interp, l, fam, type, proto); /* We have to create a PMC here even if the IO handle * didn&#39;t create because caller has to be able to * check with a bool test. Can&#39;t use a NULL PMC in a bool * test as that will cause an exception. */ return new_io_pmc(interp, io); }</p>

<p>/*</p>

<p>FUNCDOC: PIO_recv</p>

<p>Receives a message from the connected socket <code lang='und' xml:lang='und'>*pmc</code> in <code lang='und' xml:lang='und'>*buf</code>. Returns <code lang='und' xml:lang='und'>&#45;1</code> if it fails.</p>

<p>*/</p>

<p>PARROT_API INTVAL PIO_recv(PARROT_INTERP, NOTNULL(PMC *pmc), NOTNULL(STRING **buf)) { ParrotIOLayer * const l = (ParrotIOLayer *)PMC_struct_val(pmc); ParrotIO * const io = (ParrotIO *)PMC_data(pmc); if (!io) return &#45;1;</p>

<pre lang='und' xml:lang='und'>    return PIO_recv_down(interp, l, io, buf);
}</pre>

<p>/*</p>

<p>FUNCDOC: PIO_send</p>

<p>Sends the message <code lang='und' xml:lang='und'>*buf</code> to the connected socket <code lang='und' xml:lang='und'>*pmc</code>. Returns <code lang='und' xml:lang='und'>&#45;1</code> if it cannot send the message.</p>

<p>*/</p>

<p>PARROT_API PARROT_WARN_UNUSED_RESULT INTVAL PIO_send(PARROT_INTERP, NOTNULL(PMC *pmc), NOTNULL(STRING *buf)) { ParrotIOLayer * const l = (ParrotIOLayer *)PMC_struct_val(pmc); ParrotIO * const io = (ParrotIO *)PMC_data(pmc); if (!io) return &#45;1;</p>

<pre lang='und' xml:lang='und'>    return PIO_send_down(interp, l, io, buf);
}</pre>

<p>/*</p>

<p>FUNCDOC: PIO_connect</p>

<p>Connects <code lang='und' xml:lang='und'>*pmc</code> to <code lang='und' xml:lang='und'>*address</code>. Returns <code lang='und' xml:lang='und'>&#45;1</code> on failure.</p>

<p>*/</p>

<p>PARROT_API INTVAL PIO_connect(PARROT_INTERP, NOTNULL(PMC *pmc), NOTNULL(STRING *address)) { ParrotIOLayer * const l = (ParrotIOLayer *)PMC_struct_val(pmc); ParrotIO * const io = (ParrotIO *)PMC_data(pmc); if (!io) return &#45;1;</p>

<pre lang='und' xml:lang='und'>    return PIO_connect_down(interp, l, io, address);
}</pre>

<p>/*</p>

<p>FUNCDOC: PIO_bind</p>

<p>Binds <code lang='und' xml:lang='und'>*pmc</code>&#39;s socket to the local address and port specified by <code lang='und' xml:lang='und'>*address</code>. Returns <code lang='und' xml:lang='und'>&#45;1</code> on failure.</p>

<p>*/</p>

<p>PARROT_API INTVAL PIO_bind(PARROT_INTERP, NOTNULL(PMC *pmc), NOTNULL(STRING *address)) { ParrotIOLayer * const l = (ParrotIOLayer *)PMC_struct_val(pmc); ParrotIO * const io = (ParrotIO *)PMC_data(pmc); if (!io) return &#45;1;</p>

<pre lang='und' xml:lang='und'>    return PIO_bind_down(interp, l, io, address);
}</pre>

<p>/*</p>

<p>FUNCDOC: PIO_listen</p>

<p>Listens for new connections on socket <code lang='und' xml:lang='und'>*pmc</code>. Returns <code lang='und' xml:lang='und'>&#45;1</code> on failure.</p>

<p>*/</p>

<p>PARROT_API PARROT_WARN_UNUSED_RESULT INTVAL PIO_listen(PARROT_INTERP, NOTNULL(PMC *pmc), INTVAL backlog) { ParrotIOLayer * const l = (ParrotIOLayer *)PMC_struct_val(pmc); ParrotIO * const io = (ParrotIO *)PMC_data(pmc); if (!io) return &#45;1;</p>

<pre lang='und' xml:lang='und'>    return PIO_listen_down(interp, l, io, backlog);
}</pre>

<p>/*</p>

<p>FUNCDOC: PIO_accept</p>

<p>Accepts a new connection and returns a newly created <code lang='und' xml:lang='und'>ParrotIO</code> socket. Returns <code lang='und' xml:lang='und'>NULL</code> on failure.</p>

<p>*/</p>

<p>PARROT_API PMC * PIO_accept(PARROT_INTERP, NOTNULL(PMC *pmc)) { ParrotIO *io2; ParrotIOLayer * const l = (ParrotIOLayer *)PMC_struct_val(pmc); ParrotIO * const io = (ParrotIO *)PMC_data(pmc);</p>

<pre lang='und' xml:lang='und'>    /* XXX &#45; return NULL or &#45;1 &#45;&#45; c (02 July 2006) */
    if (!io)
        return NULL;

    io2 = PIO_accept_down(interp, l, io);
    return new_io_pmc(interp, io2);
}</pre>

<p>/*</p>

<p>FUNCDOC: PIO_isatty</p>

<p>Returns a boolean value indicating whether <code lang='und' xml:lang='und'>*pmc</code> is a console/tty.</p>

<p>*/</p>

<p>PARROT_API PARROT_WARN_UNUSED_RESULT INTVAL PIO_isatty(SHIM_INTERP, NOTNULL(PMC *pmc)) { ParrotIO * const io = (ParrotIO *)PMC_data(pmc);</p>

<pre lang='und' xml:lang='und'>    if (!io)
        return 0;

    return (io&#45;&#62;flags &#38; PIO_F_CONSOLE) ? 1 : 0;
}</pre>

<p>/*</p>

<h1><a name="SEE_ALSO"
>SEE ALSO <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p><em lang='und' xml:lang='und'>io/io_buf.c</em>, <em lang='und' xml:lang='und'>io/io_passdown.c</em>, <em lang='und' xml:lang='und'>io/io_stdio.c</em>, <em lang='und' xml:lang='und'>io/io_unix.c</em>, <em lang='und' xml:lang='und'>io/io_win32.c</em>, <em lang='und' xml:lang='und'>io/io_private.h</em>.</p>

<h1><a name="HISTORY"
>HISTORY <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Initially written by Melvin Smith.</p>

<p>Some ideas and goals from Perl 5.7 and Nick Ing&#45;Simmons&#39; work.</p>

<h1><a name="TODO"
>TODO <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Rework to use copy&#45;on&#45;write IO stacks rather than creating a new stack for each IO stream.</p>

<p>Add support for loadable layers in Parrot bytecode.</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
