<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Event handling stuff</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Event handling stuff</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../html/index.html">Contents</a> | <a href="../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>src/events.c &#45; Event handling stuff</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>An event_thread handles async events for all interpreters.
When events are due,
they are placed in per interpreter task_queues,
where they are handled then by the <code lang='und' xml:lang='und'>check_event*</code> opcodes.</p>

<p>IO events and signals are caught in the io_thread,
which again dispatches these to one or all interpreters.</p>

<p>*/</p>

<p>#include &#34;parrot/parrot.h&#34; #include &#34;parrot/events.h&#34; #include &#60;assert.h&#62;</p>

<p>/* HEADERIZER HFILE: include/parrot/events.h */ /* HEADERIZER NONE: static */</p>

<p>/* * event debugging stuff &#45; turn it off before running tests */ #define EVENT_DEBUG 0 /* * not yet &#45; need to sort out platform code and fix exceptions first * TODO get some config for POSIX compliant * TODO create API for extenders like ponie &#45; events disabled for now */ #if defined(linux) || defined(darwin) # define INSTALL_EVENT_HANDLER 0 #else # define INSTALL_EVENT_HANDLER 0 #endif</p>

<p>#if EVENT_DEBUG # define edebug(x) fprintf x static const char *ev_names[] = { &#34;EVENT_TYPE_NONE&#34;,
&#34;EVENT_TYPE_EVENT&#34;,
&#34;EVENT_TYPE_IO&#34;,
&#34;EVENT_TYPE_MSG&#34;,
&#34;EVENT_TYPE_TIMER&#34;,
&#34;EVENT_TYPE_CALL_BACK&#34;,
&#34;EVENT_TYPE_SLEEP&#34;,
&#34;EVENT_TYPE_TERMINATE&#34;,
&#34;EVENT_TYPE_EVENT_TERMINATE&#34;,
&#34;EVENT_TYPE_CLASS_CHANGED&#34;,
&#34;EVENT_TYPE_SIGNAL&#34;,
&#34;EVENT_TYPE_SUSPEND_FOR_GC&#34; }; static const char* et(const parrot_event* const e) { return ev_names[e&#45;&#62;type]; }</p>

<p>#else # define edebug(x) #endif</p>

<p>/* forward defs */ static void* event_thread(void *data); static void* io_thread(void *data); static opcode_t * do_event(Parrot_Interp,
parrot_event *,
opcode_t *); static void stop_io_thread(void); static void schedule_signal_event(int signum); static QUEUE_ENTRY* dup_entry(const QUEUE_ENTRY *entry);</p>

<p>/* * we have exactly one global event_queue * TODO task prio handling */ static QUEUE *event_queue; #define TASK_PRIO 10</p>

<p>/* * user accessible signals like SIGINT */ #ifndef SIGINT # define SIGINT &#45;4711 #endif #ifndef SIGHUP # define SIGHUP &#45;4712 #endif</p>

<p>/* * XXX need a configure test * should be sig_atomic_t */ static int sig_int,
sig_hup;</p>

<p>/* * a pipe is used to send messages to the IO thread */ static int pipe_fds[2]; #define PIPE_READ_FD pipe_fds[0] #define PIPE_WRITE_FD pipe_fds[1]</p>

<p>/* * a structure to communicate with the io_thread */ typedef struct io_thread_msg { INTVAL command; parrot_event *ev; } io_thread_msg;</p>

<p>/*</p>

<h2><a name="Signal_Handling"
>Signal Handling <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>FUNCDOC: sig_handler</p>

<p>Handle signal <code lang='und' xml:lang='und'>signum</code>.</p>

<p>TODO &#45; Only <code lang='und' xml:lang='und'>SIGHUP</code> is handled at the moment for testing</p>

<p>*/</p>

<p>static void sig_handler(int signum) { switch (signum) { case SIGINT: sig_int = 1; break; case SIGHUP: sig_hup = 1; break; } }</p>

<p>#if PARROT_HAS_SIGACTION /*</p>

<p>FUNCDOC: Parrot_sigaction</p>

<p>Signal handlers are common to all threads,
signal block masks are specific,
so we install one handler then block that signal and unblock it in the thread,
that will receive that signal.</p>

<p>*/</p>

<p>static void Parrot_sigaction(int sig,
void (*handler)(int)) { struct sigaction action; sigset_t block_mask;</p>

<pre lang='und' xml:lang='und'>    /* install handler */
    action.sa_handler = handler;
    sigemptyset(&#38;action.sa_mask);
    action.sa_flags = 0;
    sigaction(sig, &#38;action, NULL);

    /* block that signal */
    sigemptyset(&#38;block_mask);
    sigaddset(&#38;block_mask, sig);
    sigprocmask(SIG_BLOCK, &#38;block_mask, NULL);
}</pre>

<p>/* * unblock a signal */ static void Parrot_unblock_signal(int sig) { sigset_t block_mask;</p>

<pre lang='und' xml:lang='und'>    sigemptyset(&#38;block_mask);
    sigaddset(&#38;block_mask, sig);
    sigprocmask(SIG_UNBLOCK, &#38;block_mask, NULL);
}</pre>

<p>#else static void Parrot_sigaction(int sig, void (*handler)(int)) { }</p>

<p>static void Parrot_unblock_signal(int sig) { } #endif</p>

<p>PARROT_API void Parrot_init_signals(void) { /* * SIGFPE is architecture specific &#45; some signal an error, * some don&#39;t, so we have to use direct checks if we are dividing * by zero. */ Parrot_sigaction(SIGHUP, sig_handler); }</p>

<p>/*</p>

<h2><a name="Initialization"
>Initialization <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>FUNCDOC: init_events_first</p>

<p>Init event system for first interpreter.</p>

<p>*/</p>

<p>static void init_events_first(PARROT_INTERP) { Parrot_thread ev_handle; #ifndef WIN32 Parrot_thread io_handle; #endif</p>

<pre lang='und' xml:lang='und'>    /*
     * be sure all init is done only once
     * we could use pthread_once for that too
     */
    if (event_queue)
        PANIC(interp, &#34;event queue already exists &#45; missing parent_interp?&#34;);
    /*
     * create event queue
     */
    event_queue = queue_init(TASK_PRIO);
    /*
     * we use a message pipe to send IO related stuff to the
     * IO thread
     */
#ifndef WIN32
    /*
     * pipes on WIN32 don&#39;t support select
     * s. p6i: &#34;event.c &#45; of signals and pipes&#34;
     */
    if (pipe(pipe_fds))
        internal_exception(1, &#34;Couldn&#39;t create message pipe&#34;);
#endif
    /*
     * now set some sig handlers before any thread is started, so
     * that all threads inherit the signal block mask
     */
#if INSTALL_EVENT_HANDLER
    Parrot_init_signals();
#endif
    /*
     * we start an event_handler thread
     */
    THREAD_CREATE_DETACHED(ev_handle, event_thread, event_queue);
    /*
     * and a signal and IO handler thread
     */
#ifndef WIN32
    THREAD_CREATE_DETACHED(io_handle, io_thread, event_queue);
#endif
}</pre>

<p>/*</p>

<p>FUNCDOC: init_events_all</p>

<p>Init events for all interpreters.</p>

<p>*/</p>

<p>static void init_events_all(PARROT_INTERP) { /* * create per interpreter task queue */ interp&#45;&#62;task_queue = queue_init(0); }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_init_events</p>

<p>Initialize the event system.</p>

<p>*/</p>

<p>PARROT_API void Parrot_init_events(PARROT_INTERP) { if (!interp&#45;&#62;parent_interpreter) { /* add the very first interpreter to the list of interps. */ pt_add_to_interpreters(interp, NULL); init_events_first(interp); } init_events_all(interp); }</p>

<p>/*</p>

<h2><a name="Event_Handler_Functions"
>Event Handler Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>FUNCDOC: Parrot_schedule_event</p>

<p>Create queue entry and insert event into task queue.</p>

<p>*/</p>

<p>PARROT_API void Parrot_schedule_event(PARROT_INTERP, NOTNULL(parrot_event* ev)) { QUEUE_ENTRY* const entry = mem_allocate_typed(QUEUE_ENTRY); entry&#45;&#62;next = NULL; ev&#45;&#62;interp = interp; entry&#45;&#62;data = ev; switch (ev&#45;&#62;type) { case EVENT_TYPE_TIMER: case EVENT_TYPE_SLEEP: entry&#45;&#62;type = QUEUE_ENTRY_TYPE_TIMED_EVENT; insert_entry(event_queue, entry); break; case EVENT_TYPE_CALL_BACK: case EVENT_TYPE_SIGNAL: case EVENT_TYPE_IO: entry&#45;&#62;type = QUEUE_ENTRY_TYPE_EVENT; unshift_entry(event_queue, entry); break; default: entry&#45;&#62;type = QUEUE_ENTRY_TYPE_EVENT; push_entry(event_queue, entry); break; } }</p>

<p>/* * create and schedule a signal event */ static void schedule_signal_event(int signum) { parrot_event* const ev = mem_allocate_typed(parrot_event); QUEUE_ENTRY * const entry = mem_allocate_typed(QUEUE_ENTRY);</p>

<pre lang='und' xml:lang='und'>    entry&#45;&#62;next = NULL;
    entry&#45;&#62;type = QUEUE_ENTRY_TYPE_EVENT;
    ev&#45;&#62;type = EVENT_TYPE_SIGNAL;
    ev&#45;&#62;u.signal = signum;
    entry&#45;&#62;data = ev;
    /*
     * deliver to all interpreters
     */
    Parrot_schedule_broadcast_qentry(entry);
}</pre>

<p>/*</p>

<p>FUNCDOC: Parrot_new_timer_event</p>

<p>Create a new timer event due at <code lang='und' xml:lang='und'>diff</code> from now, repeated at <code lang='und' xml:lang='und'>interval</code> and running the passed <code lang='und' xml:lang='und'>sub</code>.</p>

<p>*/</p>

<p>PARROT_API void Parrot_new_timer_event(PARROT_INTERP, PMC *timer, FLOATVAL diff, FLOATVAL interval, int repeat, PMC *sub, parrot_event_type_enum typ) { parrot_event* const ev = mem_allocate_typed(parrot_event); FLOATVAL now = Parrot_floatval_time(); ev&#45;&#62;type = typ; ev&#45;&#62;u.timer_event.timer = timer; ev&#45;&#62;u.timer_event.abs_time = now + diff; ev&#45;&#62;u.timer_event.interval = interval; ev&#45;&#62;u.timer_event.repeat = repeat; if (repeat &#38;&#38; !interval) ev&#45;&#62;u.timer_event.interval = diff; ev&#45;&#62;u.timer_event.sub = sub; Parrot_schedule_event(interp, ev); }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_new_cb_event</p>

<p>Prepare and schedule a callback event.</p>

<p>*/</p>

<p>PARROT_API void Parrot_new_cb_event(PARROT_INTERP, PMC *cbi, char *ext) { parrot_event* const ev = mem_allocate_typed(parrot_event); QUEUE_ENTRY* const entry = mem_allocate_typed(QUEUE_ENTRY);</p>

<pre lang='und' xml:lang='und'>    entry&#45;&#62;next = NULL;
    entry&#45;&#62;data = ev;
    ev&#45;&#62;interp = interp;
    ev&#45;&#62;type = EVENT_TYPE_CALL_BACK;
    ev&#45;&#62;u.call_back.cbi = cbi;
    ev&#45;&#62;u.call_back.external_data = ext;
    Parrot_schedule_interp_qentry(interp, entry);
}</pre>

<p>/*</p>

<p>FUNCDOC: Parrot_del_timer_event</p>

<p>Deactivate the timer identified by <code lang='und' xml:lang='und'>timer</code>.</p>

<p>*/</p>

<p>PARROT_API void Parrot_del_timer_event(PARROT_INTERP, PMC *timer) { QUEUE_ENTRY *entry;</p>

<pre lang='und' xml:lang='und'>    LOCK(event_queue&#45;&#62;queue_mutex);

    for (entry = event_queue&#45;&#62;head; entry; entry = entry&#45;&#62;next) {
        if (entry&#45;&#62;type == QUEUE_ENTRY_TYPE_TIMED_EVENT) {

            parrot_event * const event = (parrot_event *)entry&#45;&#62;data;

            if (event&#45;&#62;interp == interp
                    &#38;&#38; event&#45;&#62;u.timer_event.timer == timer) {
                event&#45;&#62;u.timer_event.interval = 0.0;
                event&#45;&#62;type = EVENT_TYPE_NONE;
                break;
            }
        }
    }
    UNLOCK(event_queue&#45;&#62;queue_mutex);
}</pre>

<p>/*</p>

<p>FUNCDOC: Parrot_new_terminate_event</p>

<p>Create a terminate event, interpreter will leave the run&#45;loop when this event arrives.</p>

<p>*/</p>

<p>PARROT_API void Parrot_new_terminate_event(PARROT_INTERP) { parrot_event* const ev = mem_allocate_typed(parrot_event); ev&#45;&#62;type = EVENT_TYPE_TERMINATE; Parrot_schedule_event(interp, ev); }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_new_suspend_for_gc_event</p>

<p>Create a suspend&#45;for&#45;GC event, interpreter will wait on a condition variable for GC to finish when the event arrives.</p>

<p>*/</p>

<p>PARROT_API void Parrot_new_suspend_for_gc_event(PARROT_INTERP) { QUEUE_ENTRY *qe; parrot_event* const ev = mem_allocate_typed(parrot_event); ev&#45;&#62;type = EVENT_TYPE_SUSPEND_FOR_GC; qe = mem_allocate_typed(QUEUE_ENTRY); qe&#45;&#62;next = NULL; qe&#45;&#62;data = ev; qe&#45;&#62;type = QUEUE_ENTRY_TYPE_EVENT; /* we don&#39;t use schedule_event because we must modify its * task queue immediately */ Parrot_schedule_interp_qentry(interp, qe); }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_kill_event_loop</p>

<p>Schedule event&#45;loop terminate event. This shuts down the event thread.</p>

<p>*/</p>

<p>PARROT_API void Parrot_kill_event_loop(void) { parrot_event* const ev = mem_allocate_typed(parrot_event); ev&#45;&#62;type = EVENT_TYPE_EVENT_TERMINATE; Parrot_schedule_event(NULL, ev); }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_schedule_interp_qentry</p>

<p>Put a queue entry into the interpreters task queue and enable event checking for the interpreter.</p>

<p>*/</p>

<p>PARROT_API void Parrot_schedule_interp_qentry(PARROT_INTERP, NOTNULL(struct QUEUE_ENTRY *entry)) { parrot_event * const event = (parrot_event *)entry&#45;&#62;data; /* * sleep checks events when it awakes */ edebug((stderr, &#34;got entry &#45; schedule_inter_qentry %s\n&#34;, et(event))); if (event&#45;&#62;type != EVENT_TYPE_SLEEP) enable_event_checking(interp); /* * do push_entry last &#45; this signales the queue condition so the * interpreter might starting process that event immediately * * we should better use a priority for placing the event * in front or at the end of the queue */ switch (event&#45;&#62;type) { case EVENT_TYPE_CALL_BACK: case EVENT_TYPE_SIGNAL: unshift_entry(interp&#45;&#62;task_queue, entry); break; default: push_entry(interp&#45;&#62;task_queue, entry); break; } }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_schedule_broadcast_qentry</p>

<p>Broadcast an event.</p>

<p>*/</p>

<p>void Parrot_schedule_broadcast_qentry(struct QUEUE_ENTRY *entry) { parrot_event * const event = (parrot_event *)entry&#45;&#62;data;</p>

<pre lang='und' xml:lang='und'>    switch (event&#45;&#62;type) {
        case EVENT_TYPE_SIGNAL:
            edebug((stderr, &#34;broadcast signal\n&#34;));
            /*
             * we don&#39;t have special signal handlers in usercode yet
             * e.g.:
             * install handler like exception handler *and*
             * set a interpreter flag, that a handler exists
             * we then could examine that flag (after LOCKing it)
             * and dispatch the exception to all interpreters that
             * handle it
             * Finally, we send the first (main) interpreter that signal
             *
             * For now just send to all.
             *
             */
            switch (event&#45;&#62;u.signal) {
                case SIGHUP:
                case SIGINT:
                    {
                    if (n_interpreters) {
                        size_t i;
                        LOCK(interpreter_array_mutex);
                        for (i = 1; i &#60; n_interpreters; ++i) {
                            Interp *interp;
                            edebug((stderr, &#34;deliver SIGINT to %d\n&#34;, i));
                            interp = interpreter_array[i];
                            if (interp)
                                Parrot_schedule_interp_qentry(interp,
                                        dup_entry(entry));
                        }
                        UNLOCK(interpreter_array_mutex);
                    }
                    Parrot_schedule_interp_qentry(interpreter_array[0], entry);
                    edebug((stderr, &#34;deliver SIGINT to 0\n&#34;));
                    }
                    break;
                default:
                    mem_sys_free(entry);
                    mem_sys_free(event);
            }
            break;
        default:
            mem_sys_free(entry);
            mem_sys_free(event);
            internal_exception(1, &#34;Unknown event to broadcast&#34;);
            break;
    }
}</pre>

<p>/*</p>

<h2><a name="IO_Thread_Handling"
>IO Thread Handling <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>FUNCDOC: io_thread</p>

<p>The IO thread uses select/poll to handle IO events and signals.</p>

<p>It waits on input from the message pipe to insert file descriptors in the wait sets.</p>

<p>*/</p>

<p>#ifndef WIN32 typedef struct pending_io_events { int n; int alloced; parrot_event **events; } pending_io_events;</p>

<p>static void store_io_event(pending_io_events *ios, parrot_event *ev) { if (!ios&#45;&#62;alloced) { ios&#45;&#62;events = (parrot_event **)mem_sys_allocate(16 * sizeof (ev)); ios&#45;&#62;alloced = 16; } else if (ios&#45;&#62;n == ios&#45;&#62;alloced &#45; 1) { ios&#45;&#62;alloced &#60;&#60;= 1; ios&#45;&#62;events = (parrot_event **)mem_sys_realloc(ios&#45;&#62;events, (ios&#45;&#62;alloced * sizeof (ev))); } ios&#45;&#62;events[ios&#45;&#62;n++] = ev; }</p>

<p>static void io_thread_ready_rd(pending_io_events *ios, int ready_rd) { int i;</p>

<pre lang='und' xml:lang='und'>    for (i = 0; i &#60; ios&#45;&#62;n; ++i) {
        parrot_event * const ev = ios&#45;&#62;events[i];
        PMC * const pio = ev&#45;&#62;u.io_event.pio;
        const int fd = PIO_getfd(NULL, pio);
        if (fd == ready_rd) {
            /* remove from event list */
            &#45;&#45;ios&#45;&#62;n;
            for (; i &#60; ios&#45;&#62;n; ++i)
                ios&#45;&#62;events[i] = ios&#45;&#62;events[i+1];
            Parrot_schedule_event(ev&#45;&#62;interp, ev);
            break;
        }
    }
}</pre>

<p>PARROT_CAN_RETURN_NULL static void* io_thread(SHIM(void *data)) { fd_set act_rfds, act_wfds; int n_highest, i; int running = 1; pending_io_events ios;</p>

<pre lang='und' xml:lang='und'>    ios.n       = 0;
    ios.alloced = 0;
    ios.events  = 0;
    /* remember pending io events */

    FD_ZERO(&#38;act_rfds);
    FD_ZERO(&#38;act_wfds);
    /*
     * Watch the reader end of the pipe for messages
     */
    FD_SET(PIPE_READ_FD, &#38;act_rfds);
    n_highest = PIPE_READ_FD + 1;
    /*
     * all signals that we shall handle here have to be unblocked
     * in this and only in this thread
     */
    Parrot_unblock_signal(SIGHUP);
    while (running) {
        fd_set rfds = act_rfds;
        fd_set wfds = act_wfds;
        const int retval = select(n_highest, &#38;rfds, &#38;wfds, NULL, NULL);

        switch (retval) {
            case &#45;1:
                if (errno == EINTR) {
                    edebug((stderr, &#34;select EINTR\n&#34;));
                    if (sig_int) {
                        edebug((stderr, &#34;int arrived\n&#34;));
                        sig_int = 0;
                        /*
                         * signal the event thread
                         */
                        schedule_signal_event(SIGINT);
                    }
                    if (sig_hup) {
                        edebug((stderr, &#34;int arrived\n&#34;));
                        sig_hup = 0;
                        /*
                         * signal the event thread
                         */
                        schedule_signal_event(SIGHUP);
                    }

                }
                break;
            case 0:     /* timeout &#45; can&#39;t happen */
                break;
            default:
                edebug((stderr, &#34;IO ready\n&#34;));
                for (i = 0; i &#60; n_highest; ++i) {
                    if (FD_ISSET(i, &#38;rfds)) {
                        if (i == PIPE_READ_FD) {
                            io_thread_msg buf;
                            /*
                             * a command arrived
                             */
                            edebug((stderr, &#34;msg arrived\n&#34;));
                            if (read(PIPE_READ_FD, &#38;buf, sizeof(buf)) != sizeof(buf))
                                internal_exception(1,
                                        &#34;read error from msg pipe&#34;);
                            switch (buf.command) {
                                case IO_THR_MSG_TERMINATE:
                                    running = 0;
                                    break;
                                case IO_THR_MSG_ADD_SELECT_RD:
                                    {
                                        PMC * const pio = buf.ev&#45;&#62;u.io_event.pio;
                                        const int fd = PIO_getfd(NULL, pio);
                                        if (FD_ISSET(fd, &#38;act_rfds)) {
                                            mem_sys_free(buf.ev);
                                            break;
                                        }
                                        FD_SET(fd, &#38;act_rfds);
                                        if (fd &#62;= n_highest)
                                            n_highest = fd + 1;
                                        store_io_event(&#38;ios, buf.ev);
                                    }
                                    break;
                                    /* TODO */
                                default:
                                    internal_exception(1,
                                            &#34;unhandled msg in pipe&#34;);
                                    break;
                            }

                        }
                        else {
                            /*
                             * one of the io_event fds is ready
                             * remove from active set, as we don&#39;t
                             * want to fire again during io_handler
                             * invocation
                             */
                            FD_CLR(i, &#38;act_rfds);
                            io_thread_ready_rd(&#38;ios, i);
                        }
                    }
                }
                /* TODO check fds */
                break;
        }
    }
    edebug((stderr, &#34;IO thread terminated\n&#34;));
    close(PIPE_READ_FD);
    close(PIPE_WRITE_FD);
    return NULL;
}
#endif</pre>

<p>/*</p>

<p>FUNCDOC: stop_io_thread</p>

<p>Tell the IO thread to stop.</p>

<p>*/</p>

<p>static void stop_io_thread(void) { #ifndef WIN32 io_thread_msg buf; /* * tell IO thread to stop */ memset(&#38;buf, 0, sizeof(buf)); buf.command = IO_THR_MSG_TERMINATE; if (write(PIPE_WRITE_FD, &#38;buf, sizeof(buf)) != sizeof(buf)) internal_exception(1, &#34;msg pipe write failed&#34;); #endif }</p>

<p>PARROT_API void Parrot_event_add_io_event(PARROT_INTERP, PMC *pio, PMC *sub, PMC *data, INTVAL which) { io_thread_msg buf; parrot_event * const event = mem_allocate_typed(parrot_event);</p>

<pre lang='und' xml:lang='und'>    event&#45;&#62;type        = EVENT_TYPE_IO;
    event&#45;&#62;interp      = interp;
    /*
     * TODO dod_register these PMCs as long as the event system
     *      owns these 3
     *      unregister, when event is passed to interp again
     */
    event&#45;&#62;u.io_event.pio       = pio;
    event&#45;&#62;u.io_event.handler   = sub;
    event&#45;&#62;u.io_event.user_data = data;

    buf.command = which;
    buf.ev      = event;
#ifndef WIN32
    if (write(PIPE_WRITE_FD, &#38;buf, sizeof(buf)) != sizeof(buf))
        internal_exception(1, &#34;msg pipe write failed&#34;);
#endif
}</pre>

<p>/*</p>

<h2><a name="Event_Handler_Thread_Functions"
>Event Handler Thread Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>FUNCDOC: dup_entry</p>

<p>Duplicate queue entry.</p>

<p>*/</p>

<p>PARROT_MALLOC static QUEUE_ENTRY* dup_entry(NOTNULL(const QUEUE_ENTRY *entry)) { QUEUE_ENTRY * const new_entry = mem_allocate_typed(QUEUE_ENTRY);</p>

<pre lang='und' xml:lang='und'>    new_entry&#45;&#62;next = NULL;
    new_entry&#45;&#62;type = entry&#45;&#62;type;
    new_entry&#45;&#62;data = mem_allocate_typed(parrot_event);

    mem_sys_memcopy(new_entry&#45;&#62;data, entry&#45;&#62;data, sizeof (parrot_event));
    return new_entry;
}</pre>

<p>/*</p>

<p>FUNCDOC: dup_entry_interval</p>

<p>Duplicate timed entry and add interval to <code lang='und' xml:lang='und'>abs_time</code>.</p>

<p>*/</p>

<p>static QUEUE_ENTRY* dup_entry_interval(QUEUE_ENTRY *entry, FLOATVAL now) { QUEUE_ENTRY * const new_entry = dup_entry(entry); parrot_event * const event = (parrot_event *)new_entry&#45;&#62;data;</p>

<pre lang='und' xml:lang='und'>    event&#45;&#62;u.timer_event.abs_time = now + event&#45;&#62;u.timer_event.interval;

    return new_entry;
}</pre>

<p>/*</p>

<p>FUNCDOC: process_events</p>

<p>Do something, when an event arrived caller has locked the mutex returns 0 if event thread terminates.</p>

<p>*/</p>

<p>static int process_events(QUEUE *event_q) { FLOATVAL now; QUEUE_ENTRY *entry;</p>

<pre lang='und' xml:lang='und'>    while ((entry = peek_entry(event_q)) != NULL) {
        /*
         * one or more entries arrived &#45; we hold the mutex again
         * so we have to use the nonsyc_pop_entry to pop off event entries
         */
        parrot_event *event = NULL;

        switch (entry&#45;&#62;type) {
            case QUEUE_ENTRY_TYPE_EVENT:
                entry = nosync_pop_entry(event_q);
                event = (parrot_event *)entry&#45;&#62;data;
                break;

            case QUEUE_ENTRY_TYPE_TIMED_EVENT:
                event = (parrot_event *)entry&#45;&#62;data;
                now   = Parrot_floatval_time();

                /*
                 * if the timer_event isn&#39;t due yet, ignore the event
                 * (we were signalled on insert of the event)
                 * wait until we get at it again when time has elapsed
                 */
                if (now &#60; event&#45;&#62;u.timer_event.abs_time)
                    return 1;
                entry = nosync_pop_entry(event_q);
                /*
                 * if event is repeated dup and reinsert it
                 */
                if (event&#45;&#62;u.timer_event.interval) {
                    if (event&#45;&#62;u.timer_event.repeat) {
                        if (event&#45;&#62;u.timer_event.repeat != &#45;1)
                            event&#45;&#62;u.timer_event.repeat&#45;&#45;;
                        nosync_insert_entry(event_q,
                                dup_entry_interval(entry, now));
                    }
                }
                break;
            default:
                internal_exception(1, &#34;Unknown queue entry&#34;);
        }
        assert(event);
        if (event&#45;&#62;type == EVENT_TYPE_NONE) {
            mem_sys_free(entry);
            mem_sys_free(event);
            continue;
        }
        else if (event&#45;&#62;type == EVENT_TYPE_EVENT_TERMINATE) {
            mem_sys_free(entry);
            mem_sys_free(event);

            return 0;
        }
        /*
         * now insert entry in interpreter task queue
         */
        if (event&#45;&#62;interp) {
            Parrot_schedule_interp_qentry(event&#45;&#62;interp, entry);
        }
        else {
            Parrot_schedule_broadcast_qentry(entry);
        }
    } /* while events */
    return 1;
}</pre>

<p>/*</p>

<p>FUNCDOC: event_thread</p>

<p>The event thread is started by the first interpreter. It handles all events for all interpreters.</p>

<p>*/</p>

<p>static void* event_thread(void *data) { QUEUE * const event_q = (QUEUE *) data; int running = 1;</p>

<pre lang='und' xml:lang='und'>    LOCK(event_q&#45;&#62;queue_mutex);
    /*
     * we might already have an event in the queue
     */
    if (peek_entry(event_q))
        running = process_events(event_q);
    while (running) {
        QUEUE_ENTRY * const entry = peek_entry(event_q);

        if (!entry) {
            /* wait infinite until entry arrives */
            queue_wait(event_q);
        }
        else if (entry&#45;&#62;type == QUEUE_ENTRY_TYPE_TIMED_EVENT) {
            /* do a_timedwait for entry */
            struct timespec abs_time;
            parrot_event * const event = (parrot_event*)entry&#45;&#62;data;
            const FLOATVAL when = event&#45;&#62;u.timer_event.abs_time;

            abs_time.tv_sec = (time_t) when;
            abs_time.tv_nsec = (long)((when &#45; abs_time.tv_sec)*1000.0f)
                *1000L*1000L;
            queue_timedwait(event_q, &#38;abs_time);
        }
        else {
            /* we shouldn&#39;t get here probably
             */
            internal_exception(1, &#34;Spurious event&#34;);

        }
        /*
         * one or more entries arrived &#45; we hold the mutex again
         * so we have to use the nonsync_pop_entry to pop off event entries
         */
        running = process_events(event_q);
    } /* event loop */
    /*
     * the main interpreter is dying
     * TODO empty the queue
     */
    UNLOCK(event_q&#45;&#62;queue_mutex);
    queue_destroy(event_q);
    stop_io_thread();
    edebug((stderr, &#34;event thread stopped\n&#34;));
    return NULL;
}</pre>

<p>/*</p>

<h2><a name="Sleep_Handling"
>Sleep Handling <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>FUNCDOC: wait_for_wakeup</p>

<p>Sleep on the event queue condition. If an event arrives, the event is processed. Terminate the loop if sleeping is finished.</p>

<p>*/</p>

<p>static opcode_t * wait_for_wakeup(PARROT_INTERP, opcode_t *next) { QUEUE * const tq = interp&#45;&#62;task_queue;</p>

<pre lang='und' xml:lang='und'>    interp&#45;&#62;sleeping = 1;

    /*
     * event handler like callbacks or timers are run as normal code
     * so inside such an event handler function, another event might get
     * handled, which is good (higher priority events can interrupt
     * other event handler).  OTOH we must ensure that all state changes
     * are done in do_event and we should probably suspend nested
     * event handlers sometimes
     *
     * FIXME: the same is true for the *next param:
     *        get rid of that, instead mangle the resume flags
     *        and offset to stop the runloop
     *
     */

    while (interp&#45;&#62;sleeping) {
        QUEUE_ENTRY * const entry = wait_for_entry(tq);
        parrot_event * const event = (parrot_event*)entry&#45;&#62;data;

        mem_sys_free(entry);
        edebug((stderr, &#34;got ev %s head : %p\n&#34;, et(event), tq&#45;&#62;head));
        next  = do_event(interp, event, next);
    }

    edebug((stderr, &#34;woke up\n&#34;));
    return next;
}</pre>

<p>/*</p>

<p>FUNCDOC: Parrot_sleep_on_event</p>

<p>Go to sleep. This is called from the <code lang='und' xml:lang='und'>sleep</code> opcode.</p>

<p>*/</p>

<p>PARROT_API opcode_t * Parrot_sleep_on_event(PARROT_INTERP, FLOATVAL t, opcode_t *next) { #if PARROT_HAS_THREADS</p>

<pre lang='und' xml:lang='und'>    if (interp&#45;&#62;sleeping)
        fprintf(stderr, &#34;nested sleep might not work\n&#34;);
    /*
     * place the opcode_t* next arg in the event data, so that
     * we can identify this event in wakeup
     */
    Parrot_new_timer_event(interp, (PMC *) next, t,
            0, 0, NULL, EVENT_TYPE_SLEEP);
    next = wait_for_wakeup(interp, next);
#else
    /*
     * TODO check for nanosleep or such
     */
    Parrot_sleep((UINTVAL) ceil(t));
#endif
    return next;
}</pre>

<p>/*</p>

<h2><a name="Event_Handling_for_Run&#45;Loops"
>Event Handling for Run&#45;Loops <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>FUNCDOC: Parrot_do_check_events</p>

<p>Explicitly <code lang='und' xml:lang='und'>sync</code> called by the check_event opcode from run loops.</p>

<p>*/</p>

<p>PARROT_API opcode_t * Parrot_do_check_events(PARROT_INTERP, opcode_t *next) { if (peek_entry(interp&#45;&#62;task_queue)) return Parrot_do_handle_events(interp, 0, next);</p>

<pre lang='und' xml:lang='und'>    return next;
}</pre>

<p>/*</p>

<p>FUNCDOC: event_to_exception</p>

<p>Convert event to exception and throw it.</p>

<p>*/</p>

<p>static void event_to_exception(PARROT_INTERP, NOTNULL(const parrot_event* event)) { const int exit_code = &#45;event&#45;&#62;u.signal;</p>

<pre lang='und' xml:lang='und'>    switch (event&#45;&#62;u.signal) {
        case SIGINT:
        case SIGHUP:
            /*
             * SIGINT is silent, if no exception handler is
             * installed: set severity to EXCEPT_exit
             */
            do_exception(interp, EXCEPT_exit, exit_code);
            break;
        default:
            do_exception(interp, EXCEPT_error, exit_code);
            break;
    }
}</pre>

<p>/*</p>

<p>FUNCDOC: do_event</p>

<p>Run user code or such.</p>

<p>*/</p>

<p>static opcode_t * do_event(PARROT_INTERP, NOTNULL(parrot_event* event), opcode_t *next) { edebug((stderr, &#34;do_event %s\n&#34;, et(event))); switch (event&#45;&#62;type) { case EVENT_TYPE_TERMINATE: next = NULL; /* this will terminate the run loop */ break; case EVENT_TYPE_SIGNAL: interp&#45;&#62;sleeping = 0; /* generate exception */ event_to_exception(interp, event); /* not reached &#45; will longjmp */ break; case EVENT_TYPE_TIMER: /* run ops, save registers */ Parrot_runops_fromc_args_event(interp, event&#45;&#62;u.timer_event.sub, &#34;v&#34;); break; case EVENT_TYPE_CALL_BACK: edebug((stderr, &#34;starting user cb\n&#34;)); Parrot_run_callback(interp, event&#45;&#62;u.call_back.cbi, event&#45;&#62;u.call_back.external_data); break; case EVENT_TYPE_IO: edebug((stderr, &#34;starting io handler\n&#34;)); Parrot_runops_fromc_args_event(interp, event&#45;&#62;u.io_event.handler, &#34;vPP&#34;, event&#45;&#62;u.io_event.pio, event&#45;&#62;u.io_event.user_data); break; case EVENT_TYPE_SLEEP: interp&#45;&#62;sleeping = 0; break; case EVENT_TYPE_SUSPEND_FOR_GC: edebug((stderr, &#34;suspend for gc\n&#34;)); pt_suspend_self_for_gc(interp); break; default: fprintf(stderr, &#34;Unhandled event type %d\n&#34;, event&#45;&#62;type); break; } mem_sys_free(event); return next; }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_do_handle_events</p>

<p>Called by the <code lang='und' xml:lang='und'>check_event__</code> opcode from run loops or from above. When called from the <code lang='und' xml:lang='und'>check_events__</code> opcode, we have to restore the <code lang='und' xml:lang='und'>op_func_table</code>.</p>

<p>*/</p>

<p>PARROT_API opcode_t * Parrot_do_handle_events(PARROT_INTERP, int restore, opcode_t *next) { QUEUE * const tq = interp&#45;&#62;task_queue;</p>

<pre lang='und' xml:lang='und'>    if (restore)
        disable_event_checking(interp);

    if (!peek_entry(tq))
        return next;

    while (peek_entry(tq)) {
        QUEUE_ENTRY * const  entry = pop_entry(tq);
        parrot_event * const event = (parrot_event*)entry&#45;&#62;data;

        mem_sys_free(entry);
        next  = do_event(interp, event, next);
    }

    return next;
}</pre>

<p>/*</p>

<h1><a name="SEE_ALSO"
>SEE ALSO <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p><em lang='und' xml:lang='und'>include/parrot/events.h</em> and <em lang='und' xml:lang='und'><a href="../docs/dev/events.pod.html">docs/dev/events.pod</a></em>.</p>

<p>*/</p>

<p>/* * Local variables: * c&#45;file&#45;style: &#34;parrot&#34; * End: * vim: expandtab shiftwidth=4: */</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
