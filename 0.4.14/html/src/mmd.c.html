<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Multimethod dispatch for binary opcode functions</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Multimethod dispatch for binary opcode functions</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../html/index.html">Contents</a> | <a href="../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>src/mmd.c &#45; Multimethod dispatch for binary opcode functions</p>

<h1><a name="SYNOPSIS"
>SYNOPSIS <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>This system is set up to handle type&#45;based dispatching for binary (i.e.
two&#45;arg) functions.
This includes,
though isn&#39;t necessarily limited to,
binary operators such as addition or subtraction.</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>The MMD system is straightforward,
and currently must be explicitly invoked,
for example by a vtable function.
(We may reserve the right to use MMD in all circumstances,
but currently do not).</p>

<h2><a name="API"
>API <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>For the purposes of the API,
each MMD&#45;able function is assigned a unique number which is used to find the correct function table.
This is the <code lang='und' xml:lang='und'>func_num</code> parameter in the following functions.
While Parrot isn&#39;t restricted to a predefined set of functions,
it <i>does</i> set things up so that all the binary vtable functions have a MMD table preinstalled for them,
with default behaviour.</p>

<h2><a name="Remarks"
>Remarks <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p><code lang='und' xml:lang='und'>binop_mmd_funcs&#45;&#62;x</code> and <code lang='und' xml:lang='und'>&#45;&#62;y</code> are table sizes not highest type in table.</p>

<h2><a name="Functions"
>Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>*/</p>

<p>#include &#34;parrot/compiler.h&#34; #include &#34;parrot/parrot.h&#34; #include &#34;parrot/mmd.h&#34; #include &#34;parrot/oplib/ops.h&#34; #include &#34;mmd.str&#34; #include &#60;assert.h&#62;</p>

<p>/* HEADERIZER HFILE: include/parrot/mmd.h */</p>

<p>/* HEADERIZER BEGIN: static */</p>

<p>static INTVAL distance_cmp( SHIM_INTERP,
INTVAL a,
INTVAL b ); static void dump_mmd( PARROT_INTERP,
INTVAL function ) __attribute__nonnull__(1);</p>

<p>static funcptr_t get_mmd_dispatcher( PARROT_INTERP,
NOTNULL(PMC *left),
NOTNULL(PMC *right),
INTVAL function,
NOTNULL(int *is_pmc) ) __attribute__nonnull__(1) __attribute__nonnull__(2) __attribute__nonnull__(3) __attribute__nonnull__(5);</p>

<p>static PMC* mmd_arg_tuple_func( PARROT_INTERP ) __attribute__nonnull__(1);</p>

<p>static PMC* mmd_arg_tuple_inline( PARROT_INTERP,
NOTNULL(STRING *signature),
va_list args ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>static void mmd_create_builtin_multi_meth( PARROT_INTERP,
NOTNULL(PMC *ns),
INTVAL type,
NOTNULL(const MMD_init *entry) ) __attribute__nonnull__(1) __attribute__nonnull__(2) __attribute__nonnull__(4);</p>

<p>static void mmd_create_builtin_multi_meth_2( PARROT_INTERP,
NOTNULL(PMC *ns),
INTVAL func_nr,
INTVAL type,
INTVAL right,
funcptr_t func_ptr ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>static PMC * mmd_create_builtin_multi_stub( PARROT_INTERP,
NOTNULL(PMC* ns),
INTVAL func_nr ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>static PMC* mmd_cvt_to_types( PARROT_INTERP,
NOTNULL(PMC *multi_sig) ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>static PMC * mmd_deref( PARROT_INTERP,
NOTNULL(PMC *value) ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>static UINTVAL mmd_distance( PARROT_INTERP,
NOTNULL(PMC *pmc),
NOTNULL(PMC *arg_tuple) ) __attribute__nonnull__(1) __attribute__nonnull__(2) __attribute__nonnull__(3);</p>

<p>static void mmd_ensure_writable( PARROT_INTERP,
INTVAL function,
NULLOK(PMC *pmc) ) __attribute__nonnull__(1);</p>

<p>static void mmd_expand_x( PARROT_INTERP,
INTVAL func_nr,
INTVAL new_x ) __attribute__nonnull__(1);</p>

<p>static void mmd_expand_y( PARROT_INTERP,
INTVAL func_nr,
INTVAL new_y ) __attribute__nonnull__(1);</p>

<p>static PMC* mmd_get_ns( PARROT_INTERP ) __attribute__nonnull__(1);</p>

<p>static int mmd_is_hidden( PARROT_INTERP,
NOTNULL(PMC *multi),
NOTNULL(PMC *cl) ) __attribute__nonnull__(1) __attribute__nonnull__(2) __attribute__nonnull__(3);</p>

<p>static PMC* mmd_make_ns( PARROT_INTERP ) __attribute__nonnull__(1);</p>

<p>static int mmd_maybe_candidate( PARROT_INTERP,
NOTNULL(PMC *pmc),
NOTNULL(PMC *cl) ) __attribute__nonnull__(1) __attribute__nonnull__(2) __attribute__nonnull__(3);</p>

<p>static void mmd_search_builtin( PARROT_INTERP,
NOTNULL(STRING *meth),
NOTNULL(PMC *cl) ) __attribute__nonnull__(1) __attribute__nonnull__(2) __attribute__nonnull__(3);</p>

<p>static void mmd_search_classes( PARROT_INTERP,
NOTNULL(STRING *meth),
NOTNULL(PMC *arg_tuple),
NOTNULL(PMC *cl),
INTVAL start_at_parent ) __attribute__nonnull__(1) __attribute__nonnull__(2) __attribute__nonnull__(3) __attribute__nonnull__(4);</p>

<p>static int mmd_search_cur_namespace( PARROT_INTERP,
NOTNULL(STRING *meth),
NOTNULL(PMC *cl) ) __attribute__nonnull__(1) __attribute__nonnull__(2) __attribute__nonnull__(3);</p>

<p>static PMC* mmd_search_default( PARROT_INTERP,
NOTNULL(STRING *meth),
NOTNULL(PMC *arg_tuple) ) __attribute__nonnull__(1) __attribute__nonnull__(2) __attribute__nonnull__(3);</p>

<p>static PMC* mmd_search_scopes( PARROT_INTERP,
NOTNULL(STRING *meth) ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>static void mmd_sort_candidates( PARROT_INTERP,
NOTNULL(PMC *arg_tuple),
NOTNULL(PMC *cl) ) __attribute__nonnull__(1) __attribute__nonnull__(2) __attribute__nonnull__(3);</p>

<p>/* HEADERIZER END: static */</p>

<p>#define MMD_DEBUG 0</p>

<p>#ifndef NDEBUG static void dump_mmd(PARROT_INTERP,
INTVAL function) { UINTVAL x,
y; UINTVAL offset,
x_funcs,
y_funcs; MMD_table * const table = interp&#45;&#62;binop_mmd_funcs + function; funcptr_t func,
def; /* XXX Looks like def is never defined */</p>

<pre lang='und' xml:lang='und'>    x_funcs = table&#45;&#62;x;
    y_funcs = table&#45;&#62;y;
    printf(&#34;    &#34;);
    for (x = 0; x &#60; x_funcs; ++x) {
        if (! (x % 10))
            printf(&#34;%d&#34;, (int) x / 10);
        else
            printf(&#34; &#34;);
    }
    printf(&#34;\n&#34;);
    for (y = 0; y &#60; y_funcs; ++y) {
        printf(&#34;%3d &#34;, (int)y);
        for (x = 0; x &#60; x_funcs; ++x) {
            offset = x_funcs * y + x;
            func = table&#45;&#62;mmd_funcs[offset];
            printf(&#34;%c&#34;,
                    func == def ?  &#39;.&#39; :
                    (UINTVAL)func &#38; 1 ?  &#39;P&#39; :
                    !func  ? &#39;0&#39; : &#39;F&#39;);
        }
        printf(&#34;\n&#34;);
    }
    for (y = 0; y &#60; y_funcs; ++y) {
        for (x = 0; x &#60; x_funcs; ++x) {
            offset = x_funcs * y + x;
            func = table&#45;&#62;mmd_funcs[offset];
            if (func &#38;&#38; func != def &#38;&#38; !((UINTVAL) func &#38; 1))
                printf(&#34;%3d %3d: %p\n&#34;, (int)x, (int)y, (void*) func);
        }
    }
}
#endif</pre>

<p>PARROT_API PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL funcptr_t get_mmd_dispatch_type(PARROT_INTERP, INTVAL func_nr, INTVAL left_type, INTVAL right_type, NOTNULL(int *is_pmc)) { funcptr_t func, func_; INTVAL r; MMD_table * const table = interp&#45;&#62;binop_mmd_funcs + func_nr; const UINTVAL x_funcs = table&#45;&#62;x; const UINTVAL y_funcs = table&#45;&#62;y;</p>

<p>#if MMD_DEBUG fprintf(stderr, &#34;running function %d with left type=%u, right type=%u\n&#34;, (int) func_nr, (unsigned) left_type, (unsigned) right_type); #endif</p>

<pre lang='und' xml:lang='und'>    func = NULL;
    assert(left_type &#62;= 0);
    assert(right_type &#62;=0 ||
            (right_type &#62;= enum_type_INTVAL &#38;&#38; right_type &#60;= enum_type_PMC));
    r = right_type;
    if (right_type &#60; 0)
        right_type &#45;= enum_type_INTVAL;
    else
        right_type += 4;
    if ((UINTVAL)left_type &#60; x_funcs &#38;&#38; (UINTVAL)right_type &#60; y_funcs) {
            const UINTVAL offset = x_funcs * right_type + left_type;
            func = table&#45;&#62;mmd_funcs[offset];
    }
    if (!func) {
        const char * const meth_c = Parrot_MMD_method_name(interp, func_nr);
        STRING * const meth_s = const_string(interp, meth_c);
        PMC * const method = Parrot_MMD_search_default_infix(interp,
                meth_s, left_type, r);
        if (!method)
            real_exception(interp, 0, 1, &#34;MMD function %s not found &#34;
                    &#34;for types (%d, %d)&#34;, meth_c, left_type, r);
        if (method&#45;&#62;vtable&#45;&#62;base_type == enum_class_NCI) {
            /* C function is at struct_val */
            func = D2FPTR(PMC_struct_val(method));
            *is_pmc = 0;
            mmd_register(interp, func_nr, left_type, r,
                    (funcptr_t)PMC_struct_val(method));
        }
        else {
            *is_pmc = 1;
            func = D2FPTR(method);
            mmd_register_sub(interp, func_nr, left_type, r, method);
        }
        return func;
    }
    *is_pmc = (UINTVAL)func &#38; 3;
    func_ = (funcptr_t)((UINTVAL)func &#38; ~3);
#ifndef PARROT_HAS_ALIGNED_FUNCPTR
    if (!*is_pmc) {
        return func;
    }
    else if (!is_pmc_ptr(interp, F2DPTR(func_))) {
        *is_pmc = 0;
        return func;
    }
#endif
    return func_;
}</pre>

<p>static funcptr_t get_mmd_dispatcher(PARROT_INTERP, NOTNULL(PMC *left), NOTNULL(PMC *right), INTVAL function, NOTNULL(int *is_pmc)) { const UINTVAL left_type = VTABLE_type(interp, left); const UINTVAL right_type = VTABLE_type(interp, right); return get_mmd_dispatch_type(interp, function, left_type, right_type, is_pmc); }</p>

<p>/*</p>

<p>FUNCDOC: If <code lang='und' xml:lang='und'>value</code> is a reference&#45;like PMC, dereference it so we can make an MMD call on the &#39;real&#39; value.</p>

<p>*/</p>

<p>static PMC * mmd_deref(PARROT_INTERP, NOTNULL(PMC *value)) { if (VTABLE_type(interp, value) != value&#45;&#62;vtable&#45;&#62;base_type) return VTABLE_get_pmc(interp, value); else return value; }</p>

<p>/*</p>

<p>FUNCDOC: Make sure <code lang='und' xml:lang='und'>pmc</code> is writable enough for <code lang='und' xml:lang='und'>function</code>.</p>

<p>*/</p>

<p>static void mmd_ensure_writable(PARROT_INTERP, INTVAL function, NULLOK(PMC *pmc)) { if (!PMC_IS_NULL(pmc) &#38;&#38; (pmc&#45;&#62;vtable&#45;&#62;flags &#38; VTABLE_IS_READONLY_FLAG)) real_exception(interp, 0, 1, &#34;%s applied to read&#45;only argument&#34;, Parrot_MMD_method_name(interp, function)); }</p>

<p>/*</p>

<p>FUNCDOC: mmd_dispatch_p_ppp</p>

<p>Dispatch to a multimethod that returns a PMC. <code lang='und' xml:lang='und'>left</code>, <code lang='und' xml:lang='und'>right</code>, and <code lang='und' xml:lang='und'>dest</code> are all PMC pointers, while <code lang='und' xml:lang='und'>func_num</code> is the MMD table that should be used to do the dispatching. If the <code lang='und' xml:lang='und'>dest</code> pointer is NULL, it dispatches two a two&#45;argument function that returns a new <code lang='und' xml:lang='und'>dest</code> always.</p>

<p>The MMD system will figure out which function should be called based on the types of <code lang='und' xml:lang='und'>left</code> and <code lang='und' xml:lang='und'>right</code> and call it, passing in <code lang='und' xml:lang='und'>left</code>, <code lang='und' xml:lang='und'>right</code>, and possibly <code lang='und' xml:lang='und'>dest</code> like any other binary vtable function.</p>

<p>FUNCDOC: mmd_dispatch_p_pip</p>

<p>Like above, right argument is a native INTVAL.</p>

<p>FUNCDOC: mmd_dispatch_p_pnp</p>

<p>Like above, right argument is a native FLOATVAL.</p>

<p>FUNCDOC: mmd_dispatch_p_psp</p>

<p>Like above, right argument is a native STRING *.</p>

<p>FUNCDOC: mmd_dispatch_v_pp</p>

<p>FUNCDOC: mmd_dispatch_v_pi</p>

<p>FUNCDOC: mmd_dispatch_v_pn</p>

<p>FUNCDOC: mmd_dispatch_v_ps</p>

<p>Inplace dispatch functions for <code lang='und' xml:lang='und'>left &#60;op=&#62; right</code>.</p>

<p>*/</p>

<p>PARROT_API PMC* mmd_dispatch_p_ppp(PARROT_INTERP, NOTNULL(PMC *left), NOTNULL(PMC *right), NULLOK(PMC *dest), INTVAL func_nr) { mmd_f_p_ppp real_function; int is_pmc;</p>

<pre lang='und' xml:lang='und'>    left = mmd_deref(interp, left);
    right = mmd_deref(interp, right);

    real_function = (mmd_f_p_ppp)get_mmd_dispatcher(interp,
            left, right, func_nr, &#38;is_pmc);

    if (is_pmc) {
        PMC * const sub = (PMC*)real_function;
        if (dest)
            return Parrot_runops_fromc_args(interp, sub, &#34;PPPP&#34;,
                    left, right, dest);
        else
            return Parrot_runops_fromc_args(interp, sub, &#34;PPP&#34;,
                    left, right);
    }
    else {
        return (*real_function)(interp, left, right, dest);
    }
}</pre>

<p>PARROT_API PMC* mmd_dispatch_p_pip(PARROT_INTERP, NOTNULL(PMC *left), INTVAL right, NULLOK(PMC *dest), INTVAL func_nr) { int is_pmc;</p>

<pre lang='und' xml:lang='und'>    UINTVAL left_type;
    mmd_f_p_pip real_function;

    left = mmd_deref(interp, left);

    left_type = left&#45;&#62;vtable&#45;&#62;base_type;

    real_function =
        (mmd_f_p_pip)get_mmd_dispatch_type(interp, func_nr,
                                           left_type, enum_type_INTVAL,
                                           &#38;is_pmc);

    if (is_pmc) {
        PMC * const sub = (PMC*)real_function;
        if (dest)
            return Parrot_runops_fromc_args(interp, sub, &#34;PPIP&#34;,
                    left, right, dest);
        else
            return Parrot_runops_fromc_args(interp, sub, &#34;PPI&#34;,
                    left, right);
    }
    else {
        return (*real_function)(interp, left, right, dest);
    }
}</pre>

<p>PARROT_API PMC* mmd_dispatch_p_pnp(PARROT_INTERP, NOTNULL(PMC *left), FLOATVAL right, NULLOK(PMC *dest), INTVAL func_nr) { mmd_f_p_pnp real_function; int is_pmc; UINTVAL left_type;</p>

<pre lang='und' xml:lang='und'>    left = mmd_deref(interp, left);

    left_type = left&#45;&#62;vtable&#45;&#62;base_type;
    real_function = (mmd_f_p_pnp)get_mmd_dispatch_type(interp,
            func_nr, left_type, enum_type_FLOATVAL, &#38;is_pmc);
    if (is_pmc) {
        PMC * const sub = (PMC*)real_function;
        if (dest)
            return Parrot_runops_fromc_args(interp, sub, &#34;PPNP&#34;,
                    left, right, dest);
        else
            return Parrot_runops_fromc_args(interp, sub, &#34;PPN&#34;,
                    left, right);
    }
    else {
        return (*real_function)(interp, left, right, dest);
    }
}</pre>

<p>PARROT_API PMC* mmd_dispatch_p_psp(PARROT_INTERP, NOTNULL(PMC *left), NOTNULL(STRING *right), NULLOK(PMC *dest), INTVAL func_nr) { mmd_f_p_psp real_function; int is_pmc; const UINTVAL left_type = left&#45;&#62;vtable&#45;&#62;base_type;</p>

<pre lang='und' xml:lang='und'>    real_function = (mmd_f_p_psp)get_mmd_dispatch_type(interp,
            func_nr, left_type, enum_type_STRING, &#38;is_pmc);
    if (is_pmc) {
        PMC * const sub = (PMC*)real_function;
        if (dest)
            return Parrot_runops_fromc_args(interp, sub, &#34;PPSP&#34;,
                    left, right, dest);
        else
            return Parrot_runops_fromc_args(interp, sub, &#34;PPS&#34;,
                    left, right);
    }
    else {
        return (*real_function)(interp, left, right, dest);
    }
}</pre>

<p>/* * inplace variants */ PARROT_API void mmd_dispatch_v_pp(PARROT_INTERP, NOTNULL(PMC *left), NOTNULL(PMC *right), INTVAL func_nr) { mmd_f_v_pp real_function; int is_pmc;</p>

<pre lang='und' xml:lang='und'>    left = mmd_deref(interp, left);
    right = mmd_deref(interp, right);

    mmd_ensure_writable(interp, func_nr, left);

    real_function = (mmd_f_v_pp)get_mmd_dispatcher(interp,
            left, right, func_nr, &#38;is_pmc);

    if (is_pmc) {
        PMC * const sub = (PMC*)real_function;
        Parrot_runops_fromc_args(interp, sub, &#34;vPP&#34;, left, right);
    }
    else {
        (*real_function)(interp, left, right);
    }
}</pre>

<p>void mmd_dispatch_v_pi(PARROT_INTERP, NOTNULL(PMC *left), INTVAL right, INTVAL func_nr) { mmd_f_v_pi real_function; int is_pmc; UINTVAL left_type;</p>

<pre lang='und' xml:lang='und'>    left = mmd_deref(interp, left);
    mmd_ensure_writable(interp, func_nr, left);

    left_type = left&#45;&#62;vtable&#45;&#62;base_type;
    real_function = (mmd_f_v_pi)get_mmd_dispatch_type(interp,
            func_nr, left_type, enum_type_INTVAL, &#38;is_pmc);
    if (is_pmc) {
        PMC * const sub = (PMC*)real_function;
        Parrot_runops_fromc_args(interp, sub, &#34;vPI&#34;, left, right);
    }
    else {
        (*real_function)(interp, left, right);
    }
}</pre>

<p>PARROT_API void mmd_dispatch_v_pn(PARROT_INTERP, NOTNULL(PMC *left), FLOATVAL right, INTVAL func_nr) { mmd_f_v_pn real_function; int is_pmc; UINTVAL left_type;</p>

<pre lang='und' xml:lang='und'>    left = mmd_deref(interp, left);
    mmd_ensure_writable(interp, func_nr, left);

    left_type = left&#45;&#62;vtable&#45;&#62;base_type;
    real_function = (mmd_f_v_pn)get_mmd_dispatch_type(interp,
            func_nr, left_type, enum_type_FLOATVAL, &#38;is_pmc);
    if (is_pmc) {
        PMC * const sub = (PMC*)real_function;
        Parrot_runops_fromc_args(interp, sub, &#34;vPN&#34;, left, right);
    }
    else {
        (*real_function)(interp, left, right);
    }
}</pre>

<p>PARROT_API void mmd_dispatch_v_ps(PARROT_INTERP, NOTNULL(PMC *left), STRING *right, INTVAL func_nr) { mmd_f_v_ps real_function; int is_pmc; UINTVAL left_type;</p>

<pre lang='und' xml:lang='und'>    left = mmd_deref(interp, left);
    mmd_ensure_writable(interp, func_nr, left);

    left_type = VTABLE_type(interp, left);
    real_function = (mmd_f_v_ps)get_mmd_dispatch_type(interp,
            func_nr, left_type, enum_type_STRING, &#38;is_pmc);
    if (is_pmc) {
        PMC * const sub = (PMC*)real_function;
        Parrot_runops_fromc_args(interp, sub, &#34;vPS&#34;, left, right);
    }
    else {
        (*real_function)(interp, left, right);
    }
}</pre>

<p>/*</p>

<p>FUNCDOC: Like <code lang='und' xml:lang='und'>mmd_dispatch_p_ppp()</code>, only it returns an <code lang='und' xml:lang='und'>INTVAL</code>. This is used by MMD compare functions.</p>

<p>*/</p>

<p>PARROT_API INTVAL mmd_dispatch_i_pp(PARROT_INTERP, NOTNULL(PMC *left), NOTNULL(PMC *right), INTVAL func_nr) { mmd_f_i_pp real_function; int is_pmc; INTVAL ret;</p>

<pre lang='und' xml:lang='und'>    left = mmd_deref(interp, left);
    right = mmd_deref(interp, right);

    real_function = (mmd_f_i_pp)get_mmd_dispatcher(interp,
            left, right, func_nr, &#38;is_pmc);

    if (is_pmc) {
        PMC * const sub = (PMC*)real_function;
        ret = Parrot_runops_fromc_args_reti(interp, sub, &#34;IPP&#34;,
                left, right);
    }
    else {
        ret = (*real_function)(interp, left, right);
    }
    return ret;
}</pre>

<p>/*</p>

<p>FUNCDOC: Add a new binary MMD function to the list of functions the MMD system knows of. <code lang='und' xml:lang='und'>func_num</code> is the number of the new function. <code lang='und' xml:lang='und'>function</code> is ignored.</p>

<p>TODO change this to a MMD register interface that takes a function *name*.</p>

<p>*/</p>

<p>PARROT_API void mmd_add_function(PARROT_INTERP, INTVAL func_nr, SHIM(funcptr_t function)) { if (func_nr &#62;= (INTVAL)interp&#45;&#62;n_binop_mmd_funcs) { INTVAL i;</p>

<pre lang='und' xml:lang='und'>        if (interp&#45;&#62;binop_mmd_funcs) {
            interp&#45;&#62;binop_mmd_funcs =
                (MMD_table *)mem_sys_realloc(interp&#45;&#62;binop_mmd_funcs,
                                (func_nr + 1) * sizeof (MMD_table));
        }
        else {
            interp&#45;&#62;binop_mmd_funcs =
                (MMD_table *)mem_sys_allocate((func_nr + 1) * sizeof (MMD_table));
        }

        for (i = interp&#45;&#62;n_binop_mmd_funcs; i &#60;= func_nr; ++i)  {
            MMD_table * const table = interp&#45;&#62;binop_mmd_funcs + i;
            table&#45;&#62;x = 0;
            table&#45;&#62;y = 0;
            table&#45;&#62;mmd_funcs = NULL;
        }
        interp&#45;&#62;n_binop_mmd_funcs = func_nr + 1;
    }</pre>

<p>}</p>

<p>/*</p>

<p>FUNCDOC: Expands the function table in the X dimension to include <code lang='und' xml:lang='und'>new_x</code>.</p>

<p>*/</p>

<p>static void mmd_expand_x(PARROT_INTERP, INTVAL func_nr, INTVAL new_x) { funcptr_t *new_table; UINTVAL x; UINTVAL y; UINTVAL i; MMD_table * const table = interp&#45;&#62;binop_mmd_funcs + func_nr; char *src_ptr, *dest_ptr; size_t old_dp, new_dp;</p>

<pre lang='und' xml:lang='und'>    /* Is the Y 0? If so, nothing to expand, so just set the X for
       later use */
    if (table&#45;&#62;y == 0) {
        table&#45;&#62;x = new_x;
        return;
    }

    /* The Y is not zero. Bleah. This means we have to expand the
       table in an unpleasant way. */

    x = table&#45;&#62;x;
    y = table&#45;&#62;y;

    /* First, fill in the whole new table with the default function
       pointer. We only really need to do the new part, but... */
    new_table = (funcptr_t *)mem_sys_allocate_zeroed(sizeof (funcptr_t) *
                                                     y * new_x);

    /* Then copy the old table over. We have to do this row by row,
       because the rows in the old and new tables are different
       lengths */
    src_ptr = (char*) table&#45;&#62;mmd_funcs;
    dest_ptr = (char*) new_table;
    old_dp = sizeof (funcptr_t) * x;
    new_dp = sizeof (funcptr_t) * new_x;
    for (i = 0; i &#60; y; i++) {
        STRUCT_COPY_N(dest_ptr, src_ptr, x);
        src_ptr  += old_dp;
        dest_ptr += new_dp;
    }
    if (table&#45;&#62;mmd_funcs)
        mem_sys_free(table&#45;&#62;mmd_funcs);
    table&#45;&#62;x = new_x;
    /* Set the old table to point to the new table */
    table&#45;&#62;mmd_funcs = new_table;
}</pre>

<p>/*</p>

<p>FUNCDOC: Expands the function table in the Y direction.</p>

<p>*/</p>

<p>static void mmd_expand_y(PARROT_INTERP, INTVAL func_nr, INTVAL new_y) { UINTVAL new_size, old_size; MMD_table * const table = interp&#45;&#62;binop_mmd_funcs + func_nr;</p>

<pre lang='und' xml:lang='und'>    assert(table&#45;&#62;x);

    old_size = sizeof (funcptr_t) * table&#45;&#62;x * table&#45;&#62;y;
    new_size = sizeof (funcptr_t) * table&#45;&#62;x * new_y;

    if (table&#45;&#62;mmd_funcs)
        table&#45;&#62;mmd_funcs = (funcptr_t *)mem_sys_realloc_zeroed(
            table&#45;&#62;mmd_funcs, new_size, old_size);
    else
        table&#45;&#62;mmd_funcs = (funcptr_t *)mem_sys_allocate_zeroed(new_size);

    table&#45;&#62;y = new_y;
}</pre>

<p>/*</p>

<p>FUNCDOC: Add a function to the MMD table by class name, rather than class number. Handles the case where the named class isn&#39;t loaded yet.</p>

<p>Adds a new MMD function <code lang='und' xml:lang='und'>funcptr</code> to the <code lang='und' xml:lang='und'>func_num</code> function table that will be invoked when the left parameter is of class <code lang='und' xml:lang='und'>left_class</code> and the right parameter is of class <code lang='und' xml:lang='und'>right_class</code>. Both classes are <code lang='und' xml:lang='und'>STRING *</code>s that hold the PMC class names for the left and right sides. If either class isn&#39;t yet loaded, Parrot will cache the information such that the function will be installed if at some point in the future both classes are available.</p>

<p>Currently this is done by just assigning class numbers to the classes, which the classes will pick up and use if they&#39;re later loaded, but we may later put the functions into a deferred table that we scan when PMC classes are loaded. Either way, the function will be guaranteed to be installed when it&#39;s needed.</p>

<p>The function table must exist, but if it is too small, it will automatically be expanded.</p>

<p>*/</p>

<p>PARROT_API void mmd_add_by_class(PARROT_INTERP, INTVAL functype, NOTNULL(STRING *left_class), NOTNULL(STRING *right_class), NULLOK(funcptr_t funcptr)) { INTVAL left_type = pmc_type(interp, left_class); INTVAL right_type = pmc_type(interp, right_class);</p>

<pre lang='und' xml:lang='und'>    if (left_type == enum_type_undef) {
        left_type = pmc_register(interp, left_class);
    }
    if (right_type == enum_type_undef) {
        right_type = pmc_register(interp, right_class);
    }

    mmd_register(interp, functype, left_type, right_type, funcptr);</pre>

<p>}</p>

<p>/*</p>

<p>FUNCDOC: Register a function <code lang='und' xml:lang='und'>funcptr</code> for MMD function table <code lang='und' xml:lang='und'>func_num</code> for classes <code lang='und' xml:lang='und'>left_type</code> and <code lang='und' xml:lang='und'>right_type</code>. The left and right types are <code lang='und' xml:lang='und'>INTVAL</code>s that represent the class ID numbers.</p>

<p>The function table must exist, but if it is too small, it will automatically be expanded.</p>

<p>Adding a new function to the table can be interestingly non&#45;trivial, so we get to be tricky.</p>

<p>If the left or right types are larger than anything we&#39;ve seen so far, it means that we have to expand the table. Making Y larger is simple &#45;&#45; just realloc with some more rows. Making X larger is less simple. In either case, we punt to other functions.</p>

<p>TODO &#45; Currently the MMD system doesn&#39;t handle inheritance and best match searching, as it assumes that all PMC types have no parent type. This can be considered a bug, and will be resolved at some point in the future.</p>

<p>*/</p>

<p>PARROT_API void mmd_register(PARROT_INTERP, INTVAL func_nr, INTVAL left_type, INTVAL right_type, NULLOK(funcptr_t funcptr)) {</p>

<pre lang='und' xml:lang='und'>    INTVAL offset;
    MMD_table *table;

    assert(func_nr &#60; (INTVAL)interp&#45;&#62;n_binop_mmd_funcs);
    assert(left_type &#62;= 0);
    assert(right_type &#62;=0 ||
            (right_type &#62;= enum_type_INTVAL &#38;&#38; right_type &#60;= enum_type_PMC));
    if (right_type &#60; 0)
        right_type &#45;= enum_type_INTVAL;
    else
        right_type += 4;
    table = interp&#45;&#62;binop_mmd_funcs + func_nr;
    if ((INTVAL)table&#45;&#62;x &#60;= left_type) {
        mmd_expand_x(interp, func_nr, left_type + 1);
    }

    if ((INTVAL)table&#45;&#62;y &#60;= right_type) {
        mmd_expand_y(interp, func_nr, right_type + 1);
    }

    offset = table&#45;&#62;x * right_type + left_type;
    table&#45;&#62;mmd_funcs[offset] = funcptr;
}</pre>

<p>PARROT_API void mmd_register_sub(PARROT_INTERP, INTVAL func_nr, INTVAL left_type, INTVAL right_type, NOTNULL(PMC *sub)) { if (sub&#45;&#62;vtable&#45;&#62;base_type == enum_class_NCI) { /* returned from mmdvt_find */ mmd_register(interp, func_nr, left_type, right_type, D2FPTR(PMC_struct_val(sub))); } else { PMC * const fake = (PMC*)((UINTVAL) sub | 1); mmd_register(interp, func_nr, left_type, right_type, D2FPTR(fake)); } }</p>

<p>/*</p>

<p>FUNCDOC: Frees all the memory allocated used the MMD subsystem.</p>

<p>*/</p>

<p>PARROT_API void mmd_destroy(PARROT_INTERP) { if (interp&#45;&#62;n_binop_mmd_funcs) { UINTVAL i; for (i = 0; i &#60;interp&#45;&#62;n_binop_mmd_funcs; ++i) { if (interp&#45;&#62;binop_mmd_funcs[i].mmd_funcs) { mem_sys_free(interp&#45;&#62;binop_mmd_funcs[i].mmd_funcs); interp&#45;&#62;binop_mmd_funcs[i].mmd_funcs = NULL; } } } mem_sys_free(interp&#45;&#62;binop_mmd_funcs); interp&#45;&#62;binop_mmd_funcs = NULL; }</p>

<p>/*</p>

<p>FUNCDOC: Return an MMD PMC function for the given data types. The return result is either a Sub PMC (for PASM MMD functions) or a NCI PMC holding the C function pointer in PMC_struct_val.</p>

<p>*/</p>

<p>PARROT_API PARROT_WARN_UNUSED_RESULT PMC * mmd_vtfind(PARROT_INTERP, INTVAL func_nr, INTVAL left, INTVAL right) { int is_pmc; PMC *f; const funcptr_t func = get_mmd_dispatch_type(interp, func_nr, left, right, &#38;is_pmc); if (func &#38;&#38; is_pmc) { /* TODO if is_pmc == 2 a Bound_NCI is returned, which actually * should be filled with one of the wrapper functions */ return (PMC*)F2DPTR(func); } f = pmc_new(interp, enum_class_NCI); PMC_struct_val(f) = F2DPTR(func); return f; }</p>

<p>PARROT_API PMC * Parrot_MMD_search_default_infix(PARROT_INTERP, STRING *meth, INTVAL left_type, INTVAL right_type) { PMC* const arg_tuple = pmc_new(interp, enum_class_FixedIntegerArray);</p>

<pre lang='und' xml:lang='und'>    VTABLE_set_integer_native(interp, arg_tuple, 2);
    VTABLE_set_integer_keyed_int(interp, arg_tuple, 0, left_type);
    VTABLE_set_integer_keyed_int(interp, arg_tuple, 1, right_type);
    return mmd_search_default(interp, meth, arg_tuple);
}</pre>

<p>/*</p>

<p>FUNCDOC: Parrot_mmd_sort_candidate_list</p>

<p>Given an array PMC (usually a MultiSub) sort the mmd candidates by their manhatten distance to the current args.</p>

<p>*/</p>

<p>PARROT_API PMC * Parrot_mmd_sort_candidate_list(PARROT_INTERP, PMC *candidates) { PMC *arg_tuple; INTVAL n;</p>

<pre lang='und' xml:lang='und'>    n = VTABLE_elements(interp, candidates);
    if (!n)
        return PMCNULL;

    arg_tuple  = mmd_arg_tuple_func(interp);
    candidates = VTABLE_clone(interp, candidates);
    mmd_sort_candidates(interp, arg_tuple, candidates);

    /* if there aren&#39;t any variants that match the current args, we could end
       up with an empty list */
    n = VTABLE_elements(interp, candidates);
    if (!n)
        return PMCNULL;

    return candidates;
}</pre>

<p>/*</p>

<p>FUNCDOC: mmd_arg_tuple_inline</p>

<p>Return a list of argument types. PMC arguments are specified as function arguments.</p>

<p>FUNCDOC: mmd_arg_tuple_func</p>

<p>Return a list of argument types. PMC arguments are take from registers according to calling conventions.</p>

<p>*/</p>

<p>static PMC* mmd_arg_tuple_inline(PARROT_INTERP, NOTNULL(STRING *signature), va_list args) { INTVAL i; PMC *arg;</p>

<pre lang='und' xml:lang='und'>    PMC * const arg_tuple = pmc_new(interp, enum_class_FixedIntegerArray);
    const INTVAL sig_len = string_length(interp, signature);

    if (!sig_len)
        return arg_tuple;
    VTABLE_set_integer_native(interp, arg_tuple, sig_len);
    for (i = 0; i &#60; sig_len; ++i) {
        INTVAL type = string_index(interp, signature, i);
        switch (type) {
            case &#39;I&#39;:
                VTABLE_set_integer_keyed_int(interp, arg_tuple,
                        i, enum_type_INTVAL);
                break;
            case &#39;N&#39;:
                VTABLE_set_integer_keyed_int(interp, arg_tuple,
                        i, enum_type_FLOATVAL);
                break;
            case &#39;S&#39;:
                VTABLE_set_integer_keyed_int(interp, arg_tuple,
                        i, enum_type_STRING);
                break;
            case &#39;O&#39;:
            case &#39;P&#39;:
                arg = va_arg(args, PMC *);
                type = VTABLE_type(interp, arg);
                VTABLE_set_integer_keyed_int(interp, arg_tuple,
                        i, type);
                break;
            default:
                real_exception(interp, NULL, 1,
                        &#34;Unknown signature type %d in mmd_arg_tuple&#34;, type);
                break;
        }

    }
    return arg_tuple;
}</pre>

<p>static PMC* mmd_arg_tuple_func(PARROT_INTERP) { INTVAL sig_len, i, type, idx; PMC* arg; PMC* args_array; /* from recent set_args opcode */ opcode_t *args_op; PackFile_Constant **constants;</p>

<pre lang='und' xml:lang='und'>    /*
     * if there is no signature e.g. because of
     *      m = getattribute l, &#34;__add&#34;
     * &#45; we have to return the MultiSub
     * &#45; create a BoundMulti
     * &#45; dispatch in invoke &#45; yeah ugly
     */

    PMC * const arg_tuple = pmc_new(interp, enum_class_ResizableIntegerArray);

    args_op = interp&#45;&#62;current_args;
    if (!args_op)
        return arg_tuple;
    assert(*args_op == PARROT_OP_set_args_pc);
    constants = interp&#45;&#62;code&#45;&#62;const_table&#45;&#62;constants;
    ++args_op;
    args_array = constants[*args_op]&#45;&#62;u.key;
    ASSERT_SIG_PMC(args_array);
    sig_len = SIG_ELEMS(args_array);
    if (!sig_len)
        return arg_tuple;
    ++args_op;

    for (i = 0; i &#60; sig_len; ++i, ++args_op) {
        type = SIG_ITEM(args_array, i);
        /* named don&#39;t MMD */
        if (type &#38; PARROT_ARG_NAME)
            break;
        switch (type &#38; (PARROT_ARG_TYPE_MASK | PARROT_ARG_FLATTEN)) {
            case PARROT_ARG_INTVAL:
                VTABLE_push_integer(interp, arg_tuple, enum_type_INTVAL);
                break;
            case PARROT_ARG_FLOATVAL:
                VTABLE_push_integer(interp, arg_tuple, enum_type_FLOATVAL);
                break;
            case PARROT_ARG_STRING:
                VTABLE_push_integer(interp, arg_tuple, enum_type_STRING);
                break;
            case PARROT_ARG_PMC:
                idx = *args_op;
                if ((type &#38; PARROT_ARG_CONSTANT))
                    arg = constants[idx]&#45;&#62;u.key;
                else
                    arg = REG_PMC(interp, idx);
                type = VTABLE_type(interp, arg);
                VTABLE_push_integer(interp, arg_tuple, type);
                break;
            case PARROT_ARG_FLATTEN | PARROT_ARG_PMC:  {
                /* expand flattening args */
                int j, n;

                idx = *args_op;
                arg = REG_PMC(interp, idx);
                n = VTABLE_elements(interp, arg);
                for (j = 0; j &#60; n; ++j)  {
                    PMC * const elem = VTABLE_get_pmc_keyed_int(interp, arg, j);
                    type = VTABLE_type(interp, elem);
                    VTABLE_push_integer(interp, arg_tuple, type);
                }
                break;
            }
            default:
                real_exception(interp, NULL, 1,
                        &#34;Unknown signature type %d in mmd_arg_tuple&#34;, type);
                break;
        }

    }
    return arg_tuple;
}</pre>

<p>/*</p>

<p>FUNCDOC: mmd_search_default</p>

<p>Default implementation of MMD search. Search scopes for candidates, walk the class hierarchy, sort all candidates by their Manhattan distance, and return result</p>

<p>*/</p>

<p>static PMC* mmd_search_default(PARROT_INTERP, NOTNULL(STRING *meth), NOTNULL(PMC *arg_tuple)) { INTVAL n;</p>

<pre lang='und' xml:lang='und'>    /*
     * 2) create a list of matching functions
     */
    PMC * const candidate_list = mmd_search_scopes(interp, meth);
    /*
     * 3) if list is empty fail
     *    if the first found function is a plain Sub: finito
     */
    n = VTABLE_elements(interp, candidate_list);
    if (n == 1) {
        PMC * const pmc = VTABLE_get_pmc_keyed_int(interp, candidate_list, 0);
        STRING * const _sub = CONST_STRING(interp, &#34;Sub&#34;);

        if (VTABLE_isa(interp, pmc, _sub)) {
            return pmc;
        }
    }
    /*
     * 4) first was a MultiSub &#45; go through all found MultiSubs and check
     *    the first arguments MRO, add all MultiSubs and plain methods,
     *    where the first argument matches
     */
    mmd_search_classes(interp, meth, arg_tuple, candidate_list, 0);
    n = VTABLE_elements(interp, candidate_list);
    if (!n)
        return NULL;
    /*
     * 5) sort the list
     */
    if (n &#62; 1)
        mmd_sort_candidates(interp, arg_tuple, candidate_list);
    n = VTABLE_elements(interp, candidate_list);
    if (!n)
        return NULL;
    /*
     * 6) Uff, return first one
     */
    return VTABLE_get_pmc_keyed_int(interp, candidate_list, 0);
}</pre>

<p>/*</p>

<p>FUNCDOC: mmd_search_classes</p>

<p>Search all the classes in all MultiSubs of the candidates <code lang='und' xml:lang='und'>cl</code> and return a list of all candidates. <code lang='und' xml:lang='und'>start_at_parent</code> is 0 to start at the class itself or 1 to search from the first parent class.</p>

<p>*/</p>

<p>static void mmd_search_classes(PARROT_INTERP, NOTNULL(STRING *meth), NOTNULL(PMC *arg_tuple), NOTNULL(PMC *cl), INTVAL start_at_parent) { INTVAL type1;</p>

<pre lang='und' xml:lang='und'>    /*
     * get the class of the first argument
     */
    if (!VTABLE_elements(interp, arg_tuple))
        return;
    type1 = VTABLE_get_integer_keyed_int(interp, arg_tuple, 0);
    if (type1 &#60; 0) {
        return;
        real_exception(interp, NULL, 1, &#34;unimplemented native MMD type&#34;);
        /* TODO create some class namespace */
    }
    else {
        PMC * const mro = interp&#45;&#62;vtables[type1]&#45;&#62;mro;
        const INTVAL n = VTABLE_elements(interp, mro);
        INTVAL i;

        for (i = start_at_parent; i &#60; n; ++i) {
            PMC * const _class = VTABLE_get_pmc_keyed_int(interp, mro, i);
            PMC * const pmc = Parrot_find_method_with_cache(interp, _class, meth);
            if (!PMC_IS_NULL(pmc)) {
                /*
                 * mmd_is_hidden would consider all previous candidates
                 * XXX pass current n so that only candidates from this
                 *     mro are used?
                 */
                if (mmd_maybe_candidate(interp, pmc, cl))
                    break;
            }
        }
    }
}</pre>

<p>static INTVAL distance_cmp(SHIM_INTERP, INTVAL a, INTVAL b) { short da = (short)(a &#38; 0xffff); short db = (short)(b &#38; 0xffff); /* sort first by distance */ if (da &#62; db) return 1; if (da &#60; db) return &#45;1; /* end then by index in candidate list */ da = (short)(a &#62;&#62; 16); db = (short)(b &#62;&#62; 16); return da &#62; db ? 1 : da &#60; db ? &#45;1 : 0; }</p>

<p>extern void Parrot_FixedPMCArray_nci_sort(Interp* , PMC* pmc, PMC *cmp_func);</p>

<p>/*</p>

<p>mmd_distance</p>

<p>Create Manhattan Distance of sub <code lang='und' xml:lang='und'>pmc</code> against given argument types. 0xffff is the maximum distance</p>

<p>*/</p>

<p>static PMC* mmd_cvt_to_types(PARROT_INTERP, NOTNULL(PMC *multi_sig)) { const INTVAL n = VTABLE_elements(interp, multi_sig); INTVAL i;</p>

<pre lang='und' xml:lang='und'>    PMC * const ar = pmc_new(interp, enum_class_FixedIntegerArray);
    VTABLE_set_integer_native(interp, ar, n);
    for (i = 0; i &#60; n; ++i) {
        PMC * const sig_elem = VTABLE_get_pmc_keyed_int(interp, multi_sig, i);
        INTVAL type;

        if (sig_elem&#45;&#62;vtable&#45;&#62;base_type == enum_class_String) {
            STRING * const sig = VTABLE_get_string(interp, sig_elem);
            if (memcmp(sig&#45;&#62;strstart, &#34;__VOID&#34;, 6) == 0) {
                PMC_int_val(ar)&#45;&#45;;  /* XXX */
                break;
            }
            type = pmc_type(interp, sig);
        }
        else {
            type = pmc_type_p(interp, sig_elem);
        }
        VTABLE_set_integer_keyed_int(interp, ar, i, type);
    }
    return ar;
}</pre>

<p>#define MMD_BIG_DISTANCE 0x7fff</p>

<p>static UINTVAL mmd_distance(PARROT_INTERP, NOTNULL(PMC *pmc), NOTNULL(PMC *arg_tuple)) { PMC *multi_sig, *mro; INTVAL i, n, args, dist, j, m;</p>

<pre lang='und' xml:lang='und'>    if (pmc&#45;&#62;vtable&#45;&#62;base_type == enum_class_NCI) {
        /* has to be a builtin multi method */
        multi_sig = PMC_pmc_val(pmc);
    }
    else if (pmc&#45;&#62;vtable&#45;&#62;base_type == enum_class_Sub ||
             pmc&#45;&#62;vtable&#45;&#62;base_type == enum_class_Closure) {
        multi_sig = PMC_sub(pmc)&#45;&#62;multi_signature;
        if (!multi_sig) {
            /* some method */
            return 0;
        }
        if (multi_sig&#45;&#62;vtable&#45;&#62;base_type == enum_class_FixedPMCArray) {
            multi_sig = PMC_sub(pmc)&#45;&#62;multi_signature =
                mmd_cvt_to_types(interp, multi_sig);
        }
    }
    else
        return MMD_BIG_DISTANCE;
    n = VTABLE_elements(interp, multi_sig);
    args = VTABLE_elements(interp, arg_tuple);
    /*
     * arg_tuple may have more arguments &#45; only the
     * n multi_sig invocants are counted
     */
    if (args &#60; n)
        return MMD_BIG_DISTANCE;
    dist = 0;
    if (args &#62; n)
        dist = 1000;   /* XXX arbitrary &#62; max_class_depth * n */
    /*
     * now go through args
     */
    for (i = 0; i &#60; n; ++i) {
        const INTVAL type_sig  = VTABLE_get_integer_keyed_int(interp, multi_sig, i);
        const INTVAL type_call = VTABLE_get_integer_keyed_int(interp, arg_tuple, i);
        if (type_sig == type_call)
            continue;
        /*
         * different native types are very different, except a PMC
         * which matches any PMC
         */
        if (type_call &#60;= 0 &#38;&#38; type_sig == enum_type_PMC) {
            dist++;
            continue;
        }
        if ((type_sig &#60;= 0 &#38;&#38; type_sig != enum_type_PMC) || type_call &#60;= 0) {
            dist = MMD_BIG_DISTANCE;
            break;
        }
        /*
         * now consider MRO of types the signature type has to be somewhere
         * in the MRO of the type_call
         */
        mro = interp&#45;&#62;vtables[type_call]&#45;&#62;mro;
        m = VTABLE_elements(interp, mro);
        for (j = 0; j &#60; m; ++j) {
            const PMC * const cl = VTABLE_get_pmc_keyed_int(interp, mro, j);
            if (cl&#45;&#62;vtable&#45;&#62;base_type == type_sig)
                break;
            ++dist;
        }
        /*
         * if the type wasn&#39;t in MRO check, if any PMC matches
         * in that case use the distance + 1 (of an any PMC parent)
         */
        if (j == m &#38;&#38; type_sig != enum_type_PMC) {
            dist = MMD_BIG_DISTANCE;
            break;
        }
        ++dist;
#if MMD_DEBUG
        {
            STRING *s1, *s2;
            if (type_sig &#60; 0)
                s1 = Parrot_get_datatype_name(interp, type_sig);
            else {
                s1 = interp&#45;&#62;vtables[type_sig]&#45;&#62;whoami;
            }
            if (type_call &#60; 0)
                s2 = Parrot_get_datatype_name(interp, type_call);
            else {
                s2 = interp&#45;&#62;vtables[type_call]&#45;&#62;whoami;
            }
            PIO_eprintf(interp, &#34;arg %d: dist %d sig %Ss arg %Ss\n&#34;,
                i, dist, s1, s2);
        }
#endif
    }
    return dist;
}</pre>

<p>/*</p>

<p>FUNCDOC: mmd_sort_candidates</p>

<p>Sort the candidate list <code lang='und' xml:lang='und'>cl</code> by Manhattan Distance</p>

<p>*/</p>

<p>static void mmd_sort_candidates(PARROT_INTERP, NOTNULL(PMC *arg_tuple), NOTNULL(PMC *cl)) { INTVAL i; PMC *nci; INTVAL *helper; PMC **data;</p>

<pre lang='und' xml:lang='und'>    const INTVAL n = VTABLE_elements(interp, cl);
    /*
     * create a helper structure:
     * bits 0..15  = distance
     * bits 16..31 = idx in candidate list
     *
     * TODO use half of available INTVAL bits
     */
    PMC * const sort = pmc_new(interp, enum_class_FixedIntegerArray);
    VTABLE_set_integer_native(interp, sort, n);
    helper = (INTVAL *)PMC_data(sort);
    for (i = 0; i &#60; n; ++i) {
        PMC * const pmc = VTABLE_get_pmc_keyed_int(interp, cl, i);
        const INTVAL d = mmd_distance(interp, pmc, arg_tuple);
        helper[i] = i &#60;&#60; 16 | (d &#38; 0xffff);
    }
    /*
     * need an NCI function pointer
     */
    nci = pmc_new(interp, enum_class_NCI);
    PMC_struct_val(nci) = F2DPTR(distance_cmp);
    /*
     * sort it
     */
    Parrot_FixedPMCArray_nci_sort(interp, sort, nci);
    /*
     * now helper has a sorted list of indices in the upper 16 bits
     * fill helper with sorted candidates
     */
    data = (PMC **)PMC_data(cl);
    for (i = 0; i &#60; n; ++i) {
        const INTVAL idx = helper[i] &#62;&#62; 16;
        /*
         * if the distance is big stop
         */
        if ((helper[i] &#38; 0xffff) == MMD_BIG_DISTANCE) {
            PMC_int_val(cl) = i;
            break;
        }
        helper[i] = (INTVAL)data[idx];
    }
    /*
     * use helper structure
     */
    PMC_data(cl) = helper;
    PMC_data(sort) = data;
}</pre>

<p>/*</p>

<p>FUNCDOC: mmd_search_scopes</p>

<p>Search all scopes for MMD candidates matching the arguments given in <code lang='und' xml:lang='und'>arg_tuple</code>.</p>

<p>*/</p>

<p>static PMC* mmd_search_scopes(PARROT_INTERP, NOTNULL(STRING *meth)) { PMC * const candidate_list = pmc_new(interp, enum_class_ResizablePMCArray);</p>

<pre lang='und' xml:lang='und'>    const int stop = mmd_search_cur_namespace(interp, meth, candidate_list);
    if (stop)
        return candidate_list;
    mmd_search_builtin(interp, meth, candidate_list);
    return candidate_list;
}</pre>

<p>/*</p>

<p>FUNCDOC: mmd_is_hidden</p>

<p>Check if the given multi sub is hidden by any inner multi sub (already in the candidate list <code lang='und' xml:lang='und'>cl</code>.</p>

<p>*/</p>

<p>static int mmd_is_hidden(PARROT_INTERP, NOTNULL(PMC *multi), NOTNULL(PMC *cl)) { /* * if the candidate list already has the a sub with the same * signature (long name), the outer multi is hidden * * TODO */ UNUSED(interp); UNUSED(multi); UNUSED(cl); return 0; }</p>

<p>/*</p>

<p>FUNCDOC: mmd_maybe_candidate</p>

<p>If the candidate <code lang='und' xml:lang='und'>pmc</code> is a Sub PMC, push it on the candidate list and return TRUE to stop further search.</p>

<p>If the candidate is a MultiSub remember all matching Subs and return FALSE to continue searching outer scopes.</p>

<p>*/</p>

<p>static int mmd_maybe_candidate(PARROT_INTERP, NOTNULL(PMC *pmc), NOTNULL(PMC *cl)) { INTVAL i, n;</p>

<pre lang='und' xml:lang='und'>    STRING * const _sub = CONST_STRING(interp, &#34;Sub&#34;);
    STRING * const _multi_sub = CONST_STRING(interp, &#34;MultiSub&#34;);

    if (VTABLE_isa(interp, pmc, _sub)) {
        /* a plain sub stops outer searches */
        /* TODO check arity of sub */

        VTABLE_push_pmc(interp, cl, pmc);
        return 1;
    }
    if (!VTABLE_isa(interp, pmc, _multi_sub)) {
        /* not a Sub or MultiSub &#45; ignore */
        return 0;
    }
    /*
     * ok we have a multi sub pmc, which is an array of candidates
     */
    n = VTABLE_elements(interp, pmc);
    for (i = 0; i &#60; n; ++i) {
        PMC * const multi_sub = VTABLE_get_pmc_keyed_int(interp, pmc, i);

        if (!mmd_is_hidden(interp, multi_sub, cl))
            VTABLE_push_pmc(interp, cl, multi_sub);
    }
    return 0;
}</pre>

<p>/*</p>

<p>FUNCDOC: mmd_search_cur_namespace</p>

<p>Search the current package namespace for matching candidates. Return TRUE if the MMD search should stop.</p>

<p>*/</p>

<p>static int mmd_search_cur_namespace(PARROT_INTERP, NOTNULL(STRING *meth), NOTNULL(PMC *cl)) { PMC * const pmc = Parrot_find_global_cur(interp, meth);</p>

<pre lang='und' xml:lang='und'>    return pmc &#38;&#38; mmd_maybe_candidate(interp, pmc, cl);
}</pre>

<p>static PMC* mmd_get_ns(PARROT_INTERP) { STRING * const ns_name = CONST_STRING(interp, &#34;__parrot_core&#34;); PMC * const ns = Parrot_get_namespace_keyed_str(interp, interp&#45;&#62;root_namespace, ns_name); return ns; }</p>

<p>static PMC* mmd_make_ns(PARROT_INTERP) { STRING * const ns_name = CONST_STRING(interp, &#34;__parrot_core&#34;); PMC * const ns = Parrot_make_namespace_keyed_str(interp, interp&#45;&#62;root_namespace, ns_name); return ns; }</p>

<p>/*</p>

<p>FUNCDOC: mmd_search_builtin</p>

<p>Search the builtin namespace for matching candidates. This is the last search in all the namespaces.</p>

<p>*/</p>

<p>static void mmd_search_builtin(PARROT_INTERP, NOTNULL(STRING *meth), NOTNULL(PMC *cl)) { PMC * const ns = mmd_get_ns(interp); PMC * const pmc = Parrot_find_global_n(interp, ns, meth); if (pmc) mmd_maybe_candidate(interp, pmc, cl); }</p>

<p>static PMC * mmd_create_builtin_multi_stub(PARROT_INTERP, NOTNULL(PMC* ns), INTVAL func_nr) { const char * name = Parrot_MMD_method_name(interp, func_nr); /* create in constant pool */ STRING * const s = const_string(interp, name); PMC * multi = constant_pmc_new(interp, enum_class_MultiSub);</p>

<pre lang='und' xml:lang='und'>    VTABLE_set_pmc_keyed_str(interp, ns, s, multi);
    return ns;
}</pre>

<p>static void mmd_create_builtin_multi_meth_2(PARROT_INTERP, NOTNULL(PMC *ns), INTVAL func_nr, INTVAL type, INTVAL right, funcptr_t func_ptr) { const char *short_name; char signature[6], val_sig; STRING *meth_name; PMC *method, *multi, *_class, *multi_sig;</p>

<pre lang='und' xml:lang='und'>    assert(type != enum_class_Null &#38;&#38; type != enum_class_delegate &#38;&#38;
            type != enum_class_Ref  &#38;&#38; type != enum_class_SharedRef &#38;&#38;
            type != enum_class_deleg_pmc &#38;&#38; type != enum_class_ParrotClass &#38;&#38;
            type != enum_class_ParrotObject);
    short_name = Parrot_MMD_method_name(interp, func_nr);
    /*
     * _int, _float, _str are just native variants of the base
     * multi
     */
    val_sig = &#39;P&#39;;
    if (right == enum_type_INTVAL)
        val_sig = &#39;I&#39;;
    else if (right == enum_type_STRING)
        val_sig = &#39;S&#39;;
    else if (right == enum_type_FLOATVAL)
        val_sig = &#39;N&#39;;

    /*
     * create NCI method in left class
     */
    strcpy(signature, &#34;PJP.P&#34;);
    signature[3] = val_sig;
    if (func_nr &#62;= MMD_EQ &#38;&#38; func_nr &#60;= MMD_STRCMP) {
        signature[0] = &#39;I&#39;;
        signature[4] = &#39;\0&#39;;
    }
    /* implace infix like __i_add don&#39;t return a result */
    if (memcmp(short_name, &#34;__i_&#34;, 4) == 0)
        signature[0] = &#39;v&#39;;
    meth_name = const_string(interp, short_name);
    _class = interp&#45;&#62;vtables[type]&#45;&#62;pmc_class;
    method = Parrot_find_method_direct(interp, _class, meth_name);
    if (PMC_IS_NULL(method)) {
        /* first method */
        method = constant_pmc_new(interp, enum_class_NCI);
        VTABLE_set_pointer_keyed_str(interp, method,
                const_string(interp, signature),
                F2DPTR(func_ptr));
        VTABLE_add_method(interp, _class, meth_name, method);
    }
    else {
        /* multiple methods with that same name */
        if (method&#45;&#62;vtable&#45;&#62;base_type == enum_class_NCI) {
            /* convert first to a multi */
            multi = constant_pmc_new(interp, enum_class_MultiSub);
            VTABLE_add_method(interp, _class, meth_name, multi);
            VTABLE_push_pmc(interp, multi, method);
        }
        else {
            assert(method&#45;&#62;vtable&#45;&#62;base_type == enum_class_MultiSub);
            multi = method;
        }
        method = constant_pmc_new(interp, enum_class_NCI);
        VTABLE_set_pointer_keyed_str(interp, method,
                const_string(interp, signature),
                F2DPTR(func_ptr));
        VTABLE_push_pmc(interp, multi, method);
    }
    /* mark MMD */
    PObj_get_FLAGS(method) |= PObj_private0_FLAG;
    /*
     * attach the multi_signature array to PMC_pmc_val
     */
    multi_sig = constant_pmc_new(interp, enum_class_FixedIntegerArray);
    VTABLE_set_integer_native(interp, multi_sig, 2);
    VTABLE_set_integer_keyed_int(interp, multi_sig, 0, type);
    VTABLE_set_integer_keyed_int(interp, multi_sig, 1, right);
    PMC_pmc_val(method) = multi_sig;

    /*
     * push method onto core multi_sub
     * TODO cache the namespace
     */
    multi = Parrot_find_global_n(interp, ns,
                                 const_string(interp, short_name));
    assert(multi);
    VTABLE_push_pmc(interp, multi, method);
}</pre>

<p>static void mmd_create_builtin_multi_meth(PARROT_INTERP, NOTNULL(PMC *ns), INTVAL type, NOTNULL(const MMD_init *entry)) { mmd_create_builtin_multi_meth_2(interp, ns, entry&#45;&#62;func_nr, type, entry&#45;&#62;right, entry&#45;&#62;func_ptr); }</p>

<p>/*</p>

<p>FUNCDOC: Register MMD functions for this PMC type.</p>

<p>*/</p>

<p>PARROT_API void Parrot_mmd_register_table(PARROT_INTERP, INTVAL type, NOTNULL(const MMD_init *mmd_table), INTVAL n) { MMD_table * const table = interp&#45;&#62;binop_mmd_funcs; PMC * const ns = mmd_make_ns(interp); INTVAL i;</p>

<pre lang='und' xml:lang='und'>    if ((INTVAL)table&#45;&#62;x &#60; type &#38;&#38; type &#60; enum_class_core_max) {
        /*
         * pre&#45;allocate the function table
         */
        for (i = 0; i &#60; MMD_USER_FIRST; ++i) {
            mmd_register(interp, i, enum_class_core_max &#45; 1,
                    enum_class_core_max &#45; 1, NULL);
            /*
             * create a MultiSub stub
             */
            mmd_create_builtin_multi_stub(interp, ns, i);
        }
    }
    /*
     * register default mmds for this type
     */
    for (i = 0; i &#60; n; ++i) {
        /* The following always fails for Intel C++ for unknown reasons,
         * but I&#39;m assuming it&#39;s optimizer related.
         */
#ifndef __INTEL_COMPILER
        assert((PTR2UINTVAL(mmd_table[i].func_ptr) &#38; 3) == 0);
#endif
        mmd_register(interp,
                mmd_table[i].func_nr, type,
                mmd_table[i].right, mmd_table[i].func_ptr);
        mmd_create_builtin_multi_meth(interp, ns, type, mmd_table + i);
    }
}</pre>

<p>/*</p>

<p>FUNCDOC: Parrot_mmd_rebuild_table</p>

<p>Rebuild the static MMD_table for the given class type and MMD function number. If <code lang='und' xml:lang='und'>type</code> is negative all classes are rebuilt. If <code lang='und' xml:lang='und'>func_nr</code> is negative all MMD functions are rebuilt.</p>

<p>*/</p>

<p>PARROT_API void Parrot_mmd_rebuild_table(PARROT_INTERP, INTVAL type, INTVAL func_nr) { MMD_table *table; UINTVAL i;</p>

<pre lang='und' xml:lang='und'>    UNUSED(type);

    if (!interp&#45;&#62;binop_mmd_funcs)
        return;
    table = interp&#45;&#62;binop_mmd_funcs + func_nr;
    if (!table)
        return;

    /* TODO specific parts of table
     * the type and it&#39;s mro and
     * all classes that inherit from type
     */
    for (i = 0; i &#60; table&#45;&#62;x * table&#45;&#62;y; ++i)
        table&#45;&#62;mmd_funcs[i] = NULL;
}</pre>

<p>/*</p>

<h1><a name="SEE_ALSO"
>SEE ALSO <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p><em lang='und' xml:lang='und'>include/parrot/mmd.h</em>, <em lang='und' xml:lang='und'>http://svn.perl.org/perl6/doc/trunk/design/apo/A12.pod</em>, <em lang='und' xml:lang='und'>http://svn.perl.org/perl6/doc/trunk/design/syn/S12.pod</em></p>

<p>*/</p>

<p>/* * Local variables: * c&#45;file&#45;style: &#34;parrot&#34; * End: * vim: expandtab shiftwidth=4: */</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
