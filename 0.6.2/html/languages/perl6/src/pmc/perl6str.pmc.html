<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
    <HEAD>
        <TITLE>Perl 6 Strings</TITLE>
        <LINK REL="stylesheet" TYPE="text/css"
            HREF="../../../../../resources/perl.css"
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY>
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Perl 6 Strings</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../../../html/index.html">Contents</a> | <a href="../../../../../html/languages.html">Language Implementations</a> | <a href="../../../../../html/perl6.html">Perl6</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../../../resources/up.gif'></a></a></h1>

<p>src/pmc/perl6str.pmc &#45; Perl 6 Strings</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../../../resources/up.gif'></a></a></h1>

<p><code lang='und' xml:lang='und'>Perl6Str</code> extends <code lang='und' xml:lang='und'>String</code> to provide Perl 6&#45;specific string numifying behavior.</p>

<h2><a name="Methods"
>Methods <a href='#_top'><img alt='^' border=0 src='../../../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="INTVAL_get_integer()"
><b><code lang='und' xml:lang='und'>INTVAL get_integer()</b></code></a></dt><p class="pad"></p>

<dd>Returns the value of a Perl 6 string as an integer.
For now we just call <code lang='und' xml:lang='und'>get_number()</code> and return that as an integer.</dd><p class="pad"></p>

<dt><a name="FLOATVAL_get_number()"
><b><code lang='und' xml:lang='und'>FLOATVAL get_number()</b></code></a></dt><p class="pad"></p>

<dd>Returns the value of a Perl 6 string as a number.
Currently this routine understands the &#34;0x&#34;,
&#34;0d&#34;,
&#34;0o&#34;,
and &#34;0b&#34; radix forms,
as well as exponents and underscores between pairs of digits.</dd><p class="pad"></p>

<dt><a name="void_increment()"
><b><code lang='und' xml:lang='und'>void increment()</b></code></a></dt><p class="pad"></p>

<dt><a name="void_decrement()"
><b><code lang='und' xml:lang='und'>void decrement()</b></code></a></dt><p class="pad"></p>

<dd>Increment/decrement the string magically according to S03 rules.</dd><p class="pad"></p>

<dd>These implementations are very ASCII oriented.
They assume that the alphabet is contiguous and that there aren&#39;t any other characters on either side of the letters or digits that return true for <code lang='und' xml:lang='und'>isalpha()</code> or <code lang='und' xml:lang='und'>isdigit()</code> respectively.</dd><p class="pad"></p>

<dd>*/</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    VTABLE void increment() {
        STRING            *str   = Parrot_unCOW_string(interp, PMC_str_val(SELF));
        char              *start = str&#45;&#62;strstart;
        const char * const end   = start + string_length(INTERP, str);

        /* pointer to the substring we&#39;re going to increment */
        char       *substr;

        /* length of the substring */
        INTVAL      len;

        INTVAL i, carry;

        /* start of the current incrementable substring */
        char *s = start;

        /* end of the current incrementable substring */
        char *e = start;

        /* start of the previous incrementable substring */
        char *ps = 0;

        /* end of the previous incrementable substring */
        const char *pe = 0;

        /* find the portion of the string to increment */
        while (s &#60; end) {
            while (!isalnum((unsigned char)*s) &#38;&#38; s &#60; end)
                s++;

            e = s;

            while (isalnum((unsigned char)*e) &#38;&#38; e &#60; end)
                e++;

            if (!(e &#60; end))
                break;

            ps = s;
            pe = e;
            s = e;
        }

        if (ps == 0 || *pe != &#39;.&#39;) {
            len    = e &#45; s;
            substr = s;
        }
        else {
            len    = pe &#45; ps;
            substr = ps;
        }

        /* Actual increment */
        for (i = len &#45; 1, carry = 1; i &#62;= 0 &#38;&#38; carry; i&#45;&#45;) {
            if (isdigit((unsigned char)substr[i])) {

                if (++substr[i] &#60;= &#39;9&#39;) {
                    carry = 0;
                }
                else {
                    substr[i] = &#39;0&#39;;
                    carry     = 1;
                }
            }
            else {
                if (isalpha((unsigned char)++substr[i])) {
                    carry = 0;
                }
                else {
                    substr[i] &#45;= &#39;z&#39; &#45; &#39;a&#39; + 1;
                    carry      = 1;
                }
            }
        }

        /* If there&#39;s a carry, extend the string */
        if (carry &#38;&#38; len &#62; 0) {
            /* start index of incrementable portion */
            INTVAL a = substr &#45; start;

            /* length to end of string */
            INTVAL b = str&#45;&#62;strlen &#45; a;

            STRING *rep = string_substr(INTERP, str, a, b, NULL, 0);
            INTVAL  c   = &#39;1&#39;;

            if (isalpha((unsigned char)start[a]))
                c = start[a];

            string_replace(INTERP, str, a + 1, b, rep, 0);
            string_replace(INTERP, str, a, 1, string_chr(INTERP, c), 0);
        }
    }


    VTABLE void decrement() {
        STRING      *str   = Parrot_unCOW_string(interp, PMC_str_val(SELF));
        char        *start = str&#45;&#62;strstart;
        char * const end   = start + string_length(INTERP, str);

        /* pointer to the substring we&#39;re going to decrement */
        char *substr;

        /* length of the substring */
        INTVAL len;

        INTVAL i, steal;

        /* start of the current decrementable substring */
        char *s = start;

        /* end of the current decrementable substring */
        char *e = start;

        /* start of the previous decrementable substring */
        char *ps = 0;

        /* end of the previous decrementable substring */
        const char *pe = 0;

        /* Find the portion of the string to decrement */
        while (s &#60; end) {
            while (!isalnum((unsigned char)*s) &#38;&#38; s &#60; end)
                s++;

            e = s;

            while (isalnum((unsigned char)*e) &#38;&#38; e &#60; end)
                e++;

            if (!(e &#60; end))
                break;

            ps = s;
            pe = e;
            s = e;
        }

        if (ps == 0 || *pe != &#39;.&#39;) {
            len    = e &#45; s;
            substr = s;
        }
        else {
            len    = pe &#45; ps;
            substr = ps;
        }

        /* Check if we&#39;ve bottomed out on decrementing */
        for (i = 0; i &#60; len; i++) {
            if (substr[i] != &#39;a&#39; &#38;&#38; substr[i] != &#39;A&#39; &#38;&#38; substr[i] != &#39;0&#39;)
                break;
        }

        if (i == len)
            return;

        /* Actual decrement */
        for (i = len &#45; 1, steal = 1; i &#62;= 0 &#38;&#38; steal; i&#45;&#45;) {
            if (isdigit((unsigned char)substr[i])) {
                if (&#45;&#45;substr[i] &#62;= &#39;0&#39;) {
                    steal = 0;
                }
                else {
                    substr[i] = &#39;9&#39;;
                    steal     = 1;
                }
            }
            else {
                if (isalpha((unsigned char)&#45;&#45;substr[i])) {
                    steal = 0;
                }
                else {
                    substr[i] += &#39;z&#39; &#45; &#39;a&#39; + 1;
                    steal      = 1;
                }
            }
        }
    }</pre>

<dd>}</dd><p class="pad"></p>

<dd>/*</dd><p class="pad"></p>
</dl>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../../../resources/parrot_small.png"
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
