<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
    <HEAD>
        <TITLE>Garbage Collection Subsystems</TITLE>
        <LINK REL="stylesheet" TYPE="text/css"
            HREF="../../../resources/perl.css"
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY>
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Garbage Collection Subsystems</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../html/index.html">Contents</a> | <a href="../../../html/docs.html">Documentation</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>docs/pdds/pdd09_gc.pod &#45; Garbage Collection Subsystems</p>

<h1><a name="ABSTRACT"
>ABSTRACT <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>This PDD specifies Parrot&#39;s garbage collection subsystems.</p>

<h1><a name="VERSION"
>VERSION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>$Revision$</p>

<h1><a name="DEFINITIONS"
>DEFINITIONS <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<h2><a name="Garbage_collection_(GC)"
>Garbage collection (GC) <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Garbage collection is a process of freeing up memory that is no longer used by the interpreter,
by determining which objects will not be referenced again and can be reclaimed.</p>

<h2><a name="Simple_mark"
>Simple mark <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>All reachable objects are marked as alive,
first marking a root set,
and then recursively marking objects reachable from other reachable objects.
Objects not reached are considered dead.
After collection,
all objects are reset to unmarked,
and the process starts again.</p>

<h2><a name="Tri&#45;color_mark"
>Tri&#45;color mark <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Instead of a simple separation of marked (as live) and unmarked (dead),
the object set is divided into three parts: white,
gray,
and black.
The white objects are presumed dead.
The gray objects have been marked as live by some other object,
but haven&#39;t yet marked the objects they refer to.
The black objects are live,
and have marked all objects they directly refer to.</p>

<p>In the initial run,
all objects start as white and the root set is marked gray.
The marking process changes white objects to gray (marking them from another gray object),
and gray objects to black (when all objects they refer to are marked).
When the gray set is empty,
all live objects have been marked and the white set can be collected.
After a collection run,
all black objects are reset to white,
the root set to gray,
and the process begins again.</p>

<p>The advantage of a tri&#45;color mark over a simple mark is that it can be broken into smaller stages.</p>

<h2><a name="Mark&#45;and&#45;sweep"
>Mark&#45;and&#45;sweep <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>In this GC scheme,
after all reachable objects are marked as live,
a sweep through the object arenas collects all unmarked objects.</p>

<h2><a name="Mark&#45;and&#45;don&#39;t&#45;sweep"
>Mark&#45;and&#45;don&#39;t&#45;sweep <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>In this scheme,
all objects are marked black (live) when created.
White objects are free memory available for allocation.
When no white objects remain (out of memory),
the black objects are all changed to white,
and a marking process runs to mark all reachable objects as live.
Any unreachable objects are left white,
and available for allocation.</p>

<p>In some implementations,
the change from black to white is made by simply changing the interpretation of the mark bit,
for example,
from 1 == black to 1 == white.</p>

<h2><a name="Copying_collection"
>Copying collection <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>In this scheme,
live objects are copied into a new memory region.
The entire old memory region can then be reclaimed.</p>

<h2><a name="Compacting_collection"
>Compacting collection <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>In this scheme,
live objects are moved closer together,
eliminating fragments of free space between live objects.
This compaction makes later allocation of new objects faster,
since the allocator doesn&#39;t have to scan for fragments of free space.</p>

<h2><a name="Reference_counting"
>Reference counting <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>In this scheme,
all objects have a count of how often they are referred to by other objects.
If that count reaches zero,
the object&#39;s memory can be reclaimed.
This scheme doesn&#39;t cope well with reference loops&#45;&#45;loops of dead objects,
all referencing one another but not reachable from elsewhere,
never get collected.</p>

<h2><a name="Stop&#45;the&#45;world"
>Stop&#45;the&#45;world <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>A common disadvantage of a simple mark implemenation is that the entire system (including all threads that use the same memory pools) must be suspended while the whole memory set is examined during marking and collection.
Normal operation continues only after the whole GC cycle is performed.
This can lead to arbitrarily long pauses during program execution.</p>

<h2><a name="Incremental"
>Incremental <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Rather than suspending the system for marking and collection,
GC is done in small increments intermittent with normal program operation.
Some implementations perform the marking as part of ordinary object access.</p>

<h2><a name="Real&#45;time"
>Real&#45;time <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>The pauses caused by GC don&#39;t exceed a certain limit.</p>

<h2><a name="Generational"
>Generational <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>The object space is divided between a young generation (short&#45;lived temporaries) and one or more old generations.
Only young generations are reset to white (presumed dead).
Avoiding scanning the old generations repeatedly can considerably speed up GC.</p>

<p>Generational collection does not guarantee that all unreachable objects will be reclaimed,
so in large systems it is sometimes combined with a mark&#45;and&#45;sweep or copying collection scheme,
one for light collection runs performed frequently,
and the other for more complete runs performed rarely.</p>

<h2><a name="Concurrent"
>Concurrent <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>GC marking and collection runs as a separate thread,
sometimes with multiple threads participating in GC.
On a multi&#45;processor machine,
concurrent GC may be truly parallel.</p>

<h1><a name="SYNOPSIS"
>SYNOPSIS <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Not applicable.</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<dl>
<dt><a
>&#45; Parrot provides swappable garbage collection schemes.
The GC scheme can be selected at configure/compile time.
The GC scheme cannot be changed on&#45;the&#45;fly at runtime,
but in the future may be selected with a command&#45;line option at execution time.</a></dt><p class="pad"></p>

<dt><a name="&#45;_All_live_PMCs_must_be_reachable_from_the_root_set_of_objects_in_the_interpreter."
>&#45; All live PMCs must be reachable from the root set of objects in the interpreter.</a></dt><p class="pad"></p>

<dt><a name="&#45;_Garbage_collection_must_be_safe_for_objects_shared_across_multiple_interpreters/threads."
>&#45; Garbage collection must be safe for objects shared across multiple interpreters/threads.</a></dt><p class="pad"></p>

<dt><a name="&#45;_The_phrase_&#34;dead_object_detection&#34;_and_abbreviation_&#34;DOD&#34;_are_deprecated."
>&#45; The phrase &#34;dead object detection&#34; and abbreviation &#34;DOD&#34; are deprecated.</a></dt><p class="pad"></p>
</dl>

<h1><a name="IMPLEMENTATION"
>IMPLEMENTATION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Parrot supports pluggable garbage collection cores,
so ultimately any garbage collection model devised can run on it.
However,
different GC models are more or less appropriate for different application areas.
The current default stop&#45;the&#45;world mark&#45;and&#45;sweep model is not well suited for concurrent/parallel execution.
We will keep the simple mark&#45;and&#45;sweep implementation,
but it will no longer be primary.</p>

<p>Parrot really has two independent GC models,
one used for objects (PMCs) and the other used for buffers (including strings).
The core difference is that buffers cannot contain other buffers,
so incremental marking is unnecessary.
Currently,
PMCs are not allowed to move after creation,
so the GC model used there is not copying nor compacting.</p>

<p>The primary GC model for PMCs,
at least for the 1.0 release,
will use a tri&#45;color incremental marking scheme,
combined with a concurrent sweep scheme.</p>

<h2><a name="Initial_Marking"
>Initial Marking <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Each PMC has a <code lang='und' xml:lang='und'>flags</code> member which,
among other things,
facilitates garbage collection.
At the beginning of the mark phase,
the <code lang='und' xml:lang='und'>PObj_is_live_FLAG</code> and <code lang='und' xml:lang='und'>PObj_is_fully_marked_FLAG</code> are both unset,
which flags the PMC as presumed dead (white).
The initial mark phase of the collection cycle goes through each PMC in the root set and sets the <code lang='und' xml:lang='und'>PObj_is_live_FLAG</code> bit in the <code lang='und' xml:lang='und'>flags</code> member (the PMC is gray).
It does not set the <code lang='und' xml:lang='und'>PObj_is_fully_marked_FLAG</code> bit (changing the PMC to black),
because in the initial mark,
the PMCs or buffers contained by a PMC are not marked.
It also appends the PMC to the end of a list used for further marking.
However,
if the PMC has already been marked as black,
the current end of list is returned (instead of appending the already processed PMC) to prevent endless looping.</p>

<p>The fourth combination of the two flags,
where <code lang='und' xml:lang='und'>PObj_is_live_FLAG</code> is unset and <code lang='und' xml:lang='und'>PObj_is_fully_marked_FLAG</code> is set,
is reserved for PMCs of an older generation not actively participating in the GC run.</p>

<p>The root set for the initial marking phase includes the following core storage locations:</p>

<dl>
<dt><a name="Global_stash"
>Global stash</a></dt><p class="pad"></p>

<dt><a name="System_stack"
>System stack</a></dt><p class="pad"></p>

<dt><a name="Current_PMC_register_set"
>Current PMC register set</a></dt><p class="pad"></p>

<dt><a name="Stashes"
>Stashes</a></dt><p class="pad"></p>

<dt><a name="PMC_register_stack"
>PMC register stack</a></dt><p class="pad"></p>

<dt><a name="General/User_stack"
>General/User stack</a></dt><p class="pad"></p>
</dl>

<h2><a name="Incremental_Marking"
>Incremental Marking <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>After the root set of PMCs have been marked,
a series of incremental mark runs are performed.
These may be performed frequently,
between other operations.
The incremental mark runs work to move gray PMCs to black.
They take a PMC from the list for further marking,
mark any PMCs or buffers it contains as gray (the <code lang='und' xml:lang='und'>PObj_is_live_FLAG</code> is set and the <code lang='und' xml:lang='und'>PObj_is_fully_marked_FLAG</code> is left unset),
and add the contained PMCs or buffers to the list for further marking.
If the PMC has a custom mark function in its vtable,
it is called at this point.</p>

<p>After all contained PMCs or buffers have been marked,
the PMC itself is marked as black (the <code lang='und' xml:lang='und'>PObj_is_live_FLAG</code> and <code lang='und' xml:lang='und'>PObj_is_fully_marked_FLAG</code> are both set).
A limit may be placed on the number of PMCs handled in each incremental mark run.</p>

<h2><a name="Buffer_Marking"
>Buffer Marking <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>The initial marking phase also marks the root set of buffers.
Because buffers cannot contain other buffers,
they are immediately marked as black and not added to the list for further marking.
Because PMCs may contain buffers,
the buffer collection phase can&#39;t run until the incremental marking of PMCs is completed.</p>

<p>The root set for buffers includes the following locations:</p>

<dl>
<dt><a name="Current_String_register_set"
>Current String register set</a></dt><p class="pad"></p>

<dt><a name="String_register_set_stack"
>String register set stack</a></dt><p class="pad"></p>

<dt><a name="General/User_stack"
>General/User stack</a></dt><p class="pad"></p>

<dt><a name="Control_stack"
>Control stack</a></dt><p class="pad"></p>
</dl>

<p>Once a buffer is found to be live,
the <code lang='und' xml:lang='und'>flags</code> member of the buffer structure has the <code lang='und' xml:lang='und'>PObj_live_FLAG</code> and <code lang='und' xml:lang='und'>PObj_is_fully_marked_FLAG</code> bits set.</p>

<h2><a name="Collection"
>Collection <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>When the list for further marking is empty (all gray PMCs have changed to black),
the collection stage is started.
First,
PMCs are collected,
followed by buffers.
In both cases (PMC and buffer),
the &#34;live&#34; and &#34;fully_marked&#34; flags are reset after examination for reclamation.</p>

<h3><a name="Collecting_PMCs"
>Collecting PMCs</a></h3>

<p>To collect PMCs,
each PMC arena is examined from the most recently created backwards.
Each PMC is examined to see if it is live,
already on the free list,
or constant.
If it is not,
then it is added to the free list and marked as being on the free list with the <code lang='und' xml:lang='und'>PObj_on_free_list_FLAG</code>.</p>

<h3><a name="Collecting_buffers"
>Collecting buffers</a></h3>

<p>To collect buffers,
each Buffer arena is examined from the most recently created backwards.
If the buffer is not live,
not already on the free list and it is not a constant or copy on write,
then it is added to the free pool for reuse and marked with the <code lang='und' xml:lang='und'>PObj_on_free_list_FLAG</code>.</p>

<h3><a name="Concurrent_collection"
>Concurrent collection</a></h3>

<p>For the most part,
the variable sets between concurrent tasks don&#39;t interact.
They have independent root sets and don&#39;t require information on memory usage from other tasks before performing a collection phase.
In Parrot,
tasks tend to be short&#45;lived,
and their variables can be considered young generations from a generational GC perspective.
Because of this,
a full heavyweight task will maintain its own small memory pools,
quickly born and quickly dying.</p>

<p>Shared variables,
on the other hand,
do require information from multiple concurrent tasks before they can be collected.
Because of this,
they live in the parent interpreter&#39;s global pools,
and can only be collected after all concurrent tasks have completed a full mark phase without marking the shared variable as live.
Because GC in the concurrent tasks happens incrementally between operations,
a full collection of the shared variables can happen lazily,
and does not require a stop&#45;the&#45;world sweep through all concurrent tasks simultaneously.</p>

<h2><a name="Internal_Structures"
>Internal Structures <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>The different GC cores are independent,
but they share some code and resources.
The arena structures and arena creation routines are common across most GC cores,
and some GC cores also share mark routines.</p>

<p>The main interpreter structure has an arena_base member,
which is a pointer to an Arenas struct.</p>

<h3><a name="The_Arenas_structure"
>The Arenas structure</a></h3>

<p>The Arenas structure contains pointers to a variety of memory pools,
each used for a specific purpose.
Two are Memory_Pool pointers (memory_pool,
constant_string_pool),
and six are Small_Object_Pool structures (pmc_pool,
pmc_ext_pool,
constant_pmc_pool,
buffer_header_pool,
constant_string_header_pool).</p>

<p>The Arenas structure holds function pointers for the core defined interface of the currently active GC subsystem: <code lang='und' xml:lang='und'>init_pool</code>,
<code lang='und' xml:lang='und'>do_gc_mark</code>,
<code lang='und' xml:lang='und'>finalize_gc_system</code>.
It holds various accounting information for the GC subsystem,
including how many GC runs have been completed,
amount of memory allocated since the last run,
and total memory allocated.
This accounting information is updated by the GC system.
The current block level for GC mark and sweep phases is stored in the Arenas structure.
(See <a href='#Blocking_GC'>&#34;Blocking GC&#34;</a>.)</p>

<p>The pointer <code lang='und' xml:lang='und'>void *gc_private</code> is reserved for use by the currently active GC subsystem (with freedom for variation between GC implementations).</p>

<h3><a name="The_Memory_Pool_structure"
>The Memory_Pool structure</a></h3>

<p>The Memory_Pool structure is a simple memory pool.
It contains a pointer to the top block of the allocated pool,
the total allocated size of the pool,
the block size,
and some details on the reclamation characteristics of the pool.</p>

<h3><a name="The_Small_Object_Pool_structure"
>The Small_Object_Pool structure</a></h3>

<p>The Small_Object_Pool structure is a richer memory pool for object allocation.
It tracks details like the number of allocated and free objects in the pool,
a list of free objects,
and for the generational GC implementation maintains linked lists of white,
black,
and gray PMCs.
It contains a pointer to a simple Memory_Pool (the base storage of the pool).
It holds function pointers for adding and retrieving free objects in the pool,
and for allocating objects.</p>

<h2><a name="Internal_API"
>Internal API <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Currently only one GC system is active at a time,
selected at configure or compile time.
Future versions will support switching GC systems at execution&#45;time to accommodate different work loads.</p>

<p>Each GC core provides a standard interface for interaction with the core.</p>

<h3><a name="Initialization"
>Initialization</a></h3>

<p>Each GC core declares an initialization routine,
which is called from <em lang='und' xml:lang='und'>src/memory.c:mem_setup_allocator()</em> after creating <code lang='und' xml:lang='und'>arena_base</code> in the interpreter struct.</p>

<dl>
<dt><a name="void_Parrot_gc_XXX_init(Interp_*)"
><b><code lang='und' xml:lang='und'>void Parrot_gc_XXX_init(Interp *)</b></code></a></dt><p class="pad"></p>

<dd>A routine to initialize the GC system named <code lang='und' xml:lang='und'>XXX</code>.</dd><p class="pad"></p>

<dd>The initialization code is responsible for the creation of the header pools and fills the function pointer slots in the interpreter&#39;s <code lang='und' xml:lang='und'>arena_base</code> member.</dd><p class="pad"></p>
</dl>

<h3><a name="Arenas_structure_function_pointers"
>Arenas structure function pointers</a></h3>

<p>Each GC system declares 3 function pointers,
stored in the Arenas structure.</p>

<dl>
<dt><a name="void_(*do_gc_mark)_(Interp_*,_int_flags)"
><b><code lang='und' xml:lang='und'>void (*do_gc_mark) (Interp *, int flags)</b></code></a></dt><p class="pad"></p>

<dd>Trigger or perform a GC run.
With an incremental GC core,
this may only start/continue a partial mark phase,
rather than marking the entire tree of live objects.</dd><p class="pad"></p>

<dd>{{DEPRECATION NOTE: do_gc_mark used to be do_dod_run.}}.</dd><p class="pad"></p>

<dd>Flags is one of:</dd><p class="pad"></p>

<dl>
<dt><a name="GC_trace_normal_|_GC_trace_stack_FLAG"
>GC_trace_normal | GC_trace_stack_FLAG</a></dt><p class="pad"></p>

<dd>Run a normal GC cycle.
This is normally called by resource shortage in the buffer memory pools before a collection is run.
The bit named <code lang='und' xml:lang='und'>GC_trace_stack_FLAG</code> indicates that the C&#45;stack (and other system areas like the processor registers) have to be traced too.</dd><p class="pad"></p>

<dd>The implementation might or might not actually run a full GC cycle.
If an incremental GC system just finished the mark phase,
it would do nothing.
OTOH if no objects are currently marked live,
the implementation should run the mark phase,
so that copying of dead objects is avoided.</dd><p class="pad"></p>

<dd>{{DEPRECATION NOTE: GC_trace_normal used to be DOD_trace_normal.
GC_trace_stack_FLAG used to be DOD_trace_stack_FLAG.}}</dd><p class="pad"></p>

<dt><a name="GC_lazy_FLAG"
>GC_lazy_FLAG</a></dt><p class="pad"></p>

<dd>Do a timely destruction run.
The goal is either to detect all objects that need timely destruction or to do a full collection.
In the former case the collection can be interrupted or postponed.
This is called from the Parrot run&#45;loop.
No system areas have to be traced.</dd><p class="pad"></p>

<dd>{{DEPRECATION NOTE: GC_lazy_FLAG used to be DOD_lazy_FLAG.}}</dd><p class="pad"></p>

<dt><a name="GC_finish_FLAG"
>GC_finish_FLAG</a></dt><p class="pad"></p>

<dd>Called during interpreter destruction.
The GC subsystem must clear the live state of all objects and perform a sweep in the PMC header pool,
so that destructors and finalizers get called.</dd><p class="pad"></p>

<dd>{{DEPRECATION NOTE: GC_finish_FLAG used to be DOD_finish_FLAG.}}</dd><p class="pad"></p>

<dt><a name="GC_no_trace_volatile_roots"
>GC_no_trace_volatile_roots</a></dt><p class="pad"></p>

<dd>Trace root set except volatile roots.
That is skip e.g.
registers.</dd><p class="pad"></p>

<dd>{{DEPRECATION NOTE: GC_no_trace_volatile_roots used to be DOD_no_trace_volatile_roots.}}</dd><p class="pad"></p>
</dl>

<dt><a name="void_(*finalize_gc_system)_(Interp_*)"
><b><code lang='und' xml:lang='und'>void (*finalize_gc_system) (Interp *)</b></code></a></dt><p class="pad"></p>

<dd>Called during interpreter destruction.
Free used resources and memory pools.</dd><p class="pad"></p>

<dd>{{DEPRECATION NOTE: finalize_gc_system used to be de_init_gc_system.}}</dd><p class="pad"></p>

<dt><a name="void_(*init_pool)_(Interp_*,_struct_Small_Object_Pool_*)"
><b><code lang='und' xml:lang='und'>void (*init_pool) (Interp *, struct Small_Object_Pool *)</b></code></a></dt><p class="pad"></p>

<dd>A function to initialize the given pool.
This function should set the following object allocation functions for the given pool.</dd><p class="pad"></p>
</dl>

<h3><a name="Small_Object_Pool_function_pointers"
>Small_Object_Pool function pointers</a></h3>

<p>Each GC core defines 4 function pointers stored in the Small_Object_Pool structures.</p>

<dl>
<dt><a name="PObj_*_(*get_free_object)_(Interp_*,_struct_Small_Object_Pool*)"
><b><code lang='und' xml:lang='und'>PObj * (*get_free_object) (Interp *, struct Small_Object_Pool*)</b></code></a></dt><p class="pad"></p>

<dd>Each header pool provides one function pointer to get a new object from that pool.
It should return one free object from the given pool (removing it from the pool&#39;s free list).
Object flags are returned clear,
except flags that are used by the garbage collector itself.
If the pool is a buffer header pool,
all other object memory is zeroed.</dd><p class="pad"></p>

<dt><a name="void_(*add_free_object)_(Interp_*,_struct_Small_Object_Pool_*,_PObj_*);"
><b><code lang='und' xml:lang='und'>void (*add_free_object) (Interp *, struct Small_Object_Pool *, PObj *);</b></code></a></dt><p class="pad"></p>

<dd>Add a freed object to the pool&#39;s free list.</dd><p class="pad"></p>

<dt><a name="void_(*alloc_objects)_(Interp_*,_struct_Small_Object_Pool_*);"
><b><code lang='und' xml:lang='und'>void (*alloc_objects) (Interp *, struct Small_Object_Pool *);</b></code></a></dt><p class="pad"></p>

<dd>Initial allocation of objects for the pool.</dd><p class="pad"></p>

<dt><a name="void_(*more_objects)_(Interp_*,_struct_Small_Object_Pool_*);"
><b><code lang='und' xml:lang='und'>void (*more_objects) (Interp *, struct Small_Object_Pool *);</b></code></a></dt><p class="pad"></p>

<dd>Reallocation for additional objects.
It has the same signature as <code lang='und' xml:lang='und'>alloc_objects</code>,
and in some GC cores the same function pointer is used for both.
In some GC cores,
<code lang='und' xml:lang='und'>more_objects</code> may do a GC run.</dd><p class="pad"></p>
</dl>

<h3><a name="Write_Barrier"
>Write Barrier</a></h3>

<p>Each GC core has to provide these (possibly empty) macros:</p>

<dl>
<dt><a name="GC_WRITE_BARRIER(Interp_*,_PMC_*agg,_PMC_*old,_PMC_*new)"
><b><code lang='und' xml:lang='und'>GC_WRITE_BARRIER(Interp *, PMC *agg, PMC *old, PMC *new)</b></code></a></dt><p class="pad"></p>

<dd>This macro is invoked when in aggregate <code lang='und' xml:lang='und'>agg</code> the element <code lang='und' xml:lang='und'>old</code> is getting overritten by <code lang='und' xml:lang='und'>new</code>.
Both <code lang='und' xml:lang='und'>old</code> and <code lang='und' xml:lang='und'>new</code> may be NULL.</dd><p class="pad"></p>

<dd>{{DEPRECATION NOTE: used to be DOD_WRITE_BARRIER.}}</dd><p class="pad"></p>

<dt><a name="GC_WRITE_BARRIER_KEY(Interp_*,_PMC_*agg,_PMC_*old,_PObj_*old_key,_PMC_*new,_PObj_*new_key)"
><b><code lang='und' xml:lang='und'>GC_WRITE_BARRIER_KEY(Interp *, PMC *agg, PMC *old, PObj *old_key, PMC *new, PObj *new_key)</b></code></a></dt><p class="pad"></p>

<dd>Like above.
Invoked when a hash key is inserted,
possibly replacing an old key.</dd><p class="pad"></p>

<dd>{{DEPRECATION NOTE: used to be DOD_WRITE_BARRIER_KEY.}}</dd><p class="pad"></p>
</dl>

<h2><a name="Blocking_GC"
>Blocking GC <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Being able to block GC is important,
so newly allocated Buffers or PMCs won&#39;t be collected before they&#39;re attached to the live tree.
The following routines control GC:</p>

<dl>
<dt><a name="Parrot_block_GC_mark(Interp_*interpreter)"
>Parrot_block_GC_mark(Interp *interpreter)</a></dt><p class="pad"></p>

<dd>Block the GC mark phase for the passed interpreter.
(But not the sweep phase)</dd><p class="pad"></p>

<dd>{{DEPRECATION NOTE: used to be Parrot_block_DOD.}}</dd><p class="pad"></p>

<dt><a name="Parrot_block_GC_sweep(Interp_*interpreter)"
>Parrot_block_GC_sweep(Interp *interpreter)</a></dt><p class="pad"></p>

<dd>Block the GC sweep phase for the passed interpreter.
(But not the mark phase)</dd><p class="pad"></p>

<dd>{{DEPRECATION NOTE: used to be Parrot_block_GC.}}</dd><p class="pad"></p>

<dt><a name="Parrot_unblock_GC_mark(Interp_*interpreter)"
>Parrot_unblock_GC_mark(Interp *interpreter)</a></dt><p class="pad"></p>

<dd>Unblock the GC mark phase for the passed interpreter.
(But not the sweep phase)</dd><p class="pad"></p>

<dd>{{DEPRECATION NOTE: used to be Parrot_unblock_DOD.}}</dd><p class="pad"></p>

<dt><a name="Parrot_unblock_GC_sweep(Interp_*interpreter)"
>Parrot_unblock_GC_sweep(Interp *interpreter)</a></dt><p class="pad"></p>

<dd>Unblock the GC sweep phase for the passed interpreter.
(But not the mark phase)</dd><p class="pad"></p>

<dd>{{DEPRECATION NOTE: used to be Parrot_unblock_GC.}}</dd><p class="pad"></p>
</dl>

<p>Note that the blocking is recursive&#45;&#45;if you call Parrot_block_GC_sweep() three times in succession,
you need to call Parrot_unblock_GC_sweep() three times to re&#45;enable the GC sweep phase.</p>

<h2><a name="PMC/Buffer_API"
>PMC/Buffer API <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<h3><a name="Flags"
>Flags</a></h3>

<p>For PMCs and Buffers to be collected properly,
you must set the appropriate flags on them.</p>

<p>Directly manipulating these flags is not recommended.
Always use the macros defined in <em lang='und' xml:lang='und'>include/parrot/pobj.h</em>.</p>

<dl>
<dt><a name="PObj_active_destroy_FLAG"
>PObj_active_destroy_FLAG</a></dt><p class="pad"></p>

<dd>The PMC has some sort of active destructor,
and will have that destructor called when the PMC is destroyed.</dd><p class="pad"></p>

<dt><a name="PObj_custom_mark_FLAG"
>PObj_custom_mark_FLAG</a></dt><p class="pad"></p>

<dd>The <code lang='und' xml:lang='und'>mark</code> vtable slot will be called during the GC mark phase.
The mark function must call <code lang='und' xml:lang='und'>pobject_lives</code> for all non&#45;NULL objects (Buffers and PMCs) that PMC refers to.</dd><p class="pad"></p>

<dd>Please note that <code lang='und' xml:lang='und'>pobject_lives</code> may be a macro.</dd><p class="pad"></p>

<dt><a name="PObj_data_is_PMC_array_FLAG"
>PObj_data_is_PMC_array_FLAG</a></dt><p class="pad"></p>

<dd>Set if the data pointer points to an array of objects.
The length of the array is <code lang='und' xml:lang='und'>PMC_int_val(SELF)</code>.</dd><p class="pad"></p>

<dt><a name="PObj_external_FLAG"
>PObj_external_FLAG</a></dt><p class="pad"></p>

<dd>Set if the buffer points to memory that came from outside Parrot&#39;s memory system.</dd><p class="pad"></p>

<dt><a name="PObj_sysmem_FLAG"
>PObj_sysmem_FLAG</a></dt><p class="pad"></p>

<dd>Set if the memory came from the system malloc.
When the buffer is considered dead,
the memory will be freed back to the system.</dd><p class="pad"></p>

<dt><a name="PObj_COW_FLAG"
>PObj_COW_FLAG</a></dt><p class="pad"></p>

<dd>The buffer&#39;s memory is copy on write.
Any changes to the buffer must first have the buffer&#39;s memory copied.
The COW flag should then be removed.</dd><p class="pad"></p>
</dl>

<p>The following flags can be used by the GC subsystem:</p>

<dl>
<dt><a name="PObj_live_FLAG"
>PObj_live_FLAG</a></dt><p class="pad"></p>

<dd>The system considers the object to be alive for collection purposes.</dd><p class="pad"></p>

<dt><a name="PObj_on_free_list_FLAG"
>PObj_on_free_list_FLAG</a></dt><p class="pad"></p>

<dd>The object is unused,
and on the free list for later allocation.</dd><p class="pad"></p>

<dt><a name="PObj_custom_GC_FLAG"
>PObj_custom_GC_FLAG</a></dt><p class="pad"></p>

<dd>Mark the buffer as needing GC.</dd><p class="pad"></p>
</dl>

<h1><a name="ATTACHMENTS"
>ATTACHMENTS <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>None.</p>

<h1><a name="FOOTNOTES"
>FOOTNOTES <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>None.</p>

<h1><a name="REFERENCES"
>REFERENCES <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>&#34;A unified theory of garbage collection&#34;: <a href="http://portal.acm.org/citation.cfm?id=1028982">http://portal.acm.org/citation.cfm?id=1028982</a></p>

<p>&#34;Scalable Locality&#45;Conscious Multithreaded Memory Allocation&#34;: <a href="http://people.cs.vt.edu/~scschnei/papers/ismm06.pdf">http://people.cs.vt.edu/~scschnei/papers/ismm06.pdf</a></p>

<p>&#34;Parallel and concurrent garbage collectors&#34;: <a href="http://chaoticjava.com/posts/parallel&#45;and&#45;concurrent&#45;garbage&#45;collectors/">http://chaoticjava.com/posts/parallel&#45;and&#45;concurrent&#45;garbage&#45;collectors/</a></p>

<p>&#34;Region&#45;Based Memory Management&#34;: <a href="http://www.irisa.fr/prive/talpin/papers/ic97.pdf">http://www.irisa.fr/prive/talpin/papers/ic97.pdf</a></p>

<p>Dan&#39;s first musings on the GC subsystem: <a href="http://www.mail&#45;archive.com/perl6&#45;all@perl.org/msg14072.html">http://www.mail&#45;archive.com/perl6&#45;all@perl.org/msg14072.html</a></p>

<p>Semi&#45;timely and ordered destruction: <a href="http://www.sidhe.org/~dan/blog/archives/000199.html">http://www.sidhe.org/~dan/blog/archives/000199.html</a></p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../resources/parrot_small.png"
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
