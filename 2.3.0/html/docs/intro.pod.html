<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>Parrot  - The Parrot Primer</title>
        <link rel="stylesheet" type="text/css"
            href="../../resources/parrot.css"
            media="all">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    </head>
    <body>
        <div id="wrapper">
            <div id="header">

                <a href="http://www.parrot.org">
                <img border=0 src="../../resources/parrot_logo.png" id="logo" alt="parrot">
                </a>
            </div> <!-- "header" -->
            <div id="divider"></div>
            <div id="mainbody">
                <div id="breadcrumb">
                    <a href="../../html/index.html">Home</a> &raquo; The Parrot Primer
                </div>

<h1><a name="NAME"
>NAME</a></h1>

<p>docs/intro.pod &#45; The Parrot Primer</p>

<h1><a name="Welcome_to_Parrot"
>Welcome to Parrot</a></h1>

<p>This document provides a gentle introduction to the Parrot virtual machine for anyone considering writing code for Parrot by hand,
writing a compiler that targets Parrot,
getting involved with Parrot development or simply wondering what on earth Parrot is.</p>

<h1><a name="What_is_Parrot?"
>What is Parrot?</a></h1>

<h2><a name="Virtual_Machines"
>Virtual Machines</a></h2>

<p>Parrot is a virtual machine.
To understand what a virtual machine is,
consider what happens when you write a program in a language such as Perl,
then run it with the applicable interpreter (in the case of Perl,
the perl executable).
First,
the program you have written in a high level language is turned into simple instructions,
for example <i>fetch the value of the variable named x</i>,
<i>add 2 to this value</i>,
<i>store this value in the variable named y</i>,
etc.
A single line of code in a high level language may be converted into tens of these simple instructions.
This stage is called <i>compilation</i>.</p>

<p>The second stage involves executing these simple instructions.
Some languages (for example,
C) are often compiled to instructions that are understood by the CPU and as such can be executed by the hardware.
Other languages,
such as Perl,
Python and Java,
are usually compiled to CPU&#45;independent instructions.
A <i>virtual machine</i> (sometimes known as an <i>interpreter</i>) is required to execute those instructions.</p>

<p>While the central role of a virtual machine is to efficiently execute instructions,
it also performs a number of other functions.
One of these is to abstract away the details of the hardware and operating system that a program is running on.
Once a program has been compiled to run on a virtual machine,
it will run on any platform that the VM has been implemented on.
VMs may also provide security by allowing more fine&#45;grained limitations to be placed on a program,
memory management functionality and support for high level language features (such as objects,
data structures,
types,
subroutines,
etc).</p>

<h2><a name="Design_goals"
>Design goals</a></h2>

<p>Parrot is designed with the needs of dynamically typed languages (such as Perl and Python) in mind,
and should be able to run programs written in these languages more efficiently than VMs developed with static languages in mind (JVM,
.NET).
Parrot is also designed to provide interoperability between languages that compile to it.
In theory,
you will be able to write a class in Perl,
subclass it in Python and then instantiate and use that subclass in a Tcl program.</p>

<p>Historically,
Parrot started out as the runtime for Perl 6.
Unlike Perl 5,
the Perl 6 compiler and runtime (VM) are to be much more clearly separated.
The name <i>Parrot</i> was chosen after the 2001 April Fool&#39;s Joke which had Perl and Python collaborating on the next version of their languages.
The name reflects the intention to build a VM to run not just Perl 6,
but also many other languages.</p>

<h1><a name="Parrot_concepts_and_jargon"
>Parrot concepts and jargon</a></h1>

<h2><a name="Instruction_formats"
>Instruction formats</a></h2>

<p>Parrot can currently accept instructions to execute in four forms.
PIR (Parrot Intermediate Representation) is designed to be written by people and generated by compilers.
It hides away some low&#45;level details,
such as the way parameters are passed to functions.
PASM (Parrot Assembly) is a level below PIR &#45; it is still human readable/writable and can be generated by a compiler,
but the author has to take care of details such as calling conventions and register allocation.
PAST (Parrot Abstract Syntax Tree) enables Parrot to accept an abstract syntax tree style input &#45; useful for those writing compilers.</p>

<p>All of the above forms of input are automatically converted inside Parrot to PBC (Parrot Bytecode).
This is much like machine code,
but understood by the Parrot interpreter.
It is not intended to be human&#45;readable or human&#45;writable,
but unlike the other forms execution can start immediately,
without the need for an assembly phase.
Parrot bytecode is platform independent.</p>

<h2><a name="The_instruction_set"
>The instruction set</a></h2>

<p>The Parrot instruction set includes arithmetic and logical operators,
compare and branch/jump (for implementing loops,
if...then constructs,
etc),
finding and storing global and lexical variables,
working with classes and objects,
calling subroutines and methods along with their parameters,
I/O,
threads and more.</p>

<h2><a name="Registers_and_fundamental_data_types"
>Registers and fundamental data types</a></h2>

<p>The Parrot VM is register based.
This means that,
like a hardware CPU,
it has a number of fast&#45;access units of storage called registers.
There are 4 types of register in Parrot: integers (I),
numbers (N),
strings (S) and PMCs (P).
There are N of each of these,
named I0,I1,..N0..,
etc.
Integer registers are the same size as a word on the machine Parrot is running on and number registers also map to a native floating point type.
The amount of registers needed is determined per subroutine at compile&#45;time.</p>

<h2><a name="PMCs"
>PMCs</a></h2>

<p>PMC stands for Polymorphic Container.
PMCs represent any complex data structure or type,
including aggregate data types (arrays,
hash tables,
etc).
A PMC can implement its own behavior for arithmetic,
logical and string operations performed on it,
allowing for language&#45;specific behavior to be introduced.
PMCs can be built in to the Parrot executable or dynamically loaded when they are needed.</p>

<h2><a name="Garbage_Collection"
>Garbage Collection</a></h2>

<p>Parrot provides garbage collection,
meaning that Parrot programs do not need to free memory explicitly; it will be freed when it is no longer in use (that is,
no longer referenced) whenever the garbage collector runs.</p>

<h1><a name="Obtaining,_building_and_testing_Parrot"
>Obtaining,
building and testing Parrot</a></h1>

<h2><a name="Where_to_get_Parrot"
>Where to get Parrot</a></h2>

<p>See <a href='http://www.parrot.org/download'><a href="http://www.parrot.org/download">http://www.parrot.org/download</a></a> for several ways to get a recent version of parrot.</p>

<h2><a name="Building_Parrot"
>Building Parrot</a></h2>

<p>The first step to building Parrot is to run the <em><a href="../Configure.pl.html">Configure.pl</a></em> program,
which looks at your platform and decides how Parrot should be built.
This is done by typing:</p>

<pre>  perl Configure.pl</pre>

<p>Once this is complete, run the <code>make</code> program <code>Configure.pl</code> prompts you with. When this completes, you will have a working <code>parrot</code> executable.</p>

<p>Please report any problems that you encounter while building Parrot so the developers can fix them. You can do this by creating a login and opening a new ticket at <a href='https://trac.parrot.org'>https://trac.parrot.org</a>. Please include the <em>myconfig</em> file that was generated as part of the build process and any errors that you observed.</p>

<h2><a name="The_Parrot_test_suite"
>The Parrot test suite</a></h2>

<p>Parrot has an extensive regression test suite. This can be run by typing:</p>

<pre>  make test</pre>

<p>Substituting make for the name of the make program on your platform. The output will look something like this:</p>

<pre> C:\Perl\bin\perl.exe t\harness &#45;&#45;gc&#45;debug 
   t\library\*.t  t\op\*.t  t\pmc\*.t  t\run\*.t  t\native_pbc\*.t
   imcc\t\*\*.t  t\dynpmc\*.t  t\p6rules\*.t t\src\*.t t\perl\*.t
 t\library\dumper...............ok
 t\library\getopt_long..........ok
 ...
 All tests successful, 4 test and 71 subtests skipped.
 Files=163, Tests=2719, 192 wallclock secs ( 0.00 cusr +  0.00 csys =  0.00 CPU)</pre>

<p>It is possible that a number of tests may fail. If this is a small number, then it is probably little to worry about, especially if you have the latest Parrot sources from the SVN repository. However, please do not let this discourage you from reporting test failures, using the same method as described for reporting build problems.</p>

<h1><a name="Some_simple_Parrot_programs"
>Some simple Parrot programs</a></h1>

<h2><a name="Hello_world!"
>Hello world!</a></h2>

<p>Create a file called <em>hello.pir</em> that contains the following code.</p>
<pre>  .sub main
      say "Hello world!"
  .end
</pre>
<p>Then run it by typing:</p>

<pre>  parrot hello.pir</pre>

<p>As expected, this will display the text <code>Hello world!</code> on the console, followed by a new line.</p>

<p>Let&#39;s take the program apart. <code>.sub main</code> states that the instructions that follow make up a subroutine named <code>main</code>, until a <code>.end</code> is encountered. The second line contains the <code>print</code> instruction. In this case, we are calling the variant of the instruction that accepts a constant string. The assembler takes care of deciding which variant of the instruction to use for us.</p>

<h2><a name="Using_registers"
>Using registers</a></h2>

<p>We can modify hello.pir to first store the string <code>Hello world!</code> in a register and then use that register with the print instruction.</p>
<pre>  .sub main
      $S0 = "Hello world!"
      say $S0
  .end
</pre>
<p>PIR does not allow us to set a register directly. We need to prefix the register name with <code>$</code> when referring to a register. The compiler will map $S0 to one of the available string registers, for example S0, and set the value. This example also uses the syntactic sugar provided by the <code>=</code> operator. <code>=</code> is simply a more readable way of using the <code>set</code> opcode.</p>

<p>To make PIR even more readable, named registers can be used. These are later mapped to real numbered registers.</p>
<pre>  .sub main
      .local string hello
      hello = "Hello world!"
      say hello
  .end
</pre>
<p>The <code>.local</code> directive indicates that the named register is only needed inside the current subroutine (that is, between <code>.sub</code> and <code>.end</code>). Following <code>.local</code> is a type. This can be <code>int</code> (for I registers), <code>float</code> (for N registers), <code>string</code> (for S registers), <code>pmc</code> (for P registers) or the name of a PMC type.</p>

<h2><a name="PIR_vs._PASM"
>PIR vs. PASM</a></h2>

<p>PASM does not handle register allocation or provide support for named registers. It also does not have the <code>.sub</code> and <code>.end</code> directives, instead replacing them with a label at the start of the instructions.</p>

<h2><a name="Summing_squares"
>Summing squares</a></h2>

<p>This example introduces some more instructions and PIR syntax. Lines starting with a <code>#</code> are comments.</p>
<pre>  .sub main
      # State the number of squares to sum.
      .local int maxnum
      maxnum = 10

      # We'll use some named registers. Note that we can declare many
      # registers of the same type on one line.
      .local int i, total, temp
      total = 0

      # Loop to do the sum.
      i = 1
  loop:
      temp = i * i
      total += temp
      inc i
      if i <= maxnum goto loop

      # Output result.
      print "The sum of the first "
      print maxnum
      print " squares is "
      print total
      print ".\n"
  .end
</pre>
<p>PIR provides a bit of syntactic sugar that makes it look more high level than assembly. For example:</p>
<pre>  .local pmc temp, i
  temp = i * i
</pre>
<p>Is just another way of writing the more assembly&#45;ish:</p>
<pre>  .local pmc temp, i
  mul temp, i, i
</pre>
<p>And:</p>
<pre>  .local pmc i, maxnum
  if i <= maxnum goto loop
  # ...
  loop:
</pre>
<p>Is the same as:</p>
<pre>  .local pmc i, maxnum
  le i, maxnum, loop
  # ...
  loop:
</pre>
<p>And:</p>
<pre>  .local pmc temp, total
  total += temp
</pre>
<p>Is the same as:</p>
<pre>  .local pmc  temp, total
  add total, temp
</pre>
<p>As a rule, whenever a Parrot instruction modifies the contents of a register, that will be the first register when writing the instruction in assembly form.</p>

<p>As is usual in assembly languages, loops and selection are implemented in terms of conditional branch statements and labels, as shown above. Assembly programming is one place where using goto is not bad form!</p>

<h2><a name="Recursively_computing_factorial"
>Recursively computing factorial</a></h2>

<p>In this example we define a factorial function and recursively call it to compute factorial.</p>
<pre>  .sub factorial
      # Get input parameter.
      .param int n

      # return (n > 1 ? n * factorial(n - 1) : 1)
      .local int result

      if n > 1 goto recurse
      result = 1
      goto return

  recurse:
      $I0 = n - 1
      result = factorial($I0)
      result *= n

  return:
      .return (result)
  .end


  .sub main :main
      .local int f, i

      # We'll do factorial 0 to 10.
      i = 0
  loop:
      f = factorial(i)

      print "Factorial of "
      print i
      print " is "
      print f
      print ".\n"

      inc i
      if i <= 10 goto loop
  .end
</pre>
<p>The first line, <code>.param int n</code>, specifies that this subroutine takes one integer parameter and that we&#39;d like to refer to the register it was passed in by the name <code>n</code> for the rest of the sub.</p>

<p>Much of what follows has been seen in previous examples, apart from the line reading:</p>
<pre>  .local int result
  result = factorial($I0)
</pre>
<p>The last line of PIR actually represents a few lines of PASM. The assembler builds a PMC that describes the signature, including which register the arguments are held in. A similar process happens for providing the registers that the return values should be placed in. Finally, the <code>factorial</code> sub is invoked.</p>

<p>Right before the <code>.end</code> of the <code>factorial</code> sub, a <code>.return</code> directive is used to specify that the value held in the register named <code>result</code> is to be copied to the register that the caller is expecting the return value in.</p>

<p>The call to <code>factorial</code> in main works in just the same was as the recursive call to <code>factorial</code> within the sub <code>factorial</code> itself. The only remaining bit of new syntax is the <code>:main</code>, written after <code>.sub main</code>. By default, PIR assumes that execution begins with the first sub in the file. This behavior can be changed by marking the sub to start in with <code>:main</code>.</p>

<h2><a name="Compiling_to_PBC"
>Compiling to PBC</a></h2>

<p>To compile PIR to bytecode, use the <code>&#45;o</code> flag and specify an output file with the extension <em>.pbc</em>.</p>

<pre>  parrot &#45;o factorial.pbc factorial.pir</pre>

<h1><a name="Where_next?"
>Where next?</a></h1>

<h2><a name="Documentation"
>Documentation</a></h2>

<p>What documentation you read next depends upon what you are looking to do with Parrot. The opcodes reference and built&#45;in PMCs reference are useful to dip into for pretty much everyone. If you intend to write or compile to PIR then there are a number of documents about PIR that are worth a read. For compiler writers, the Compiler FAQ is essential reading. If you want to get involved with Parrot development, the PDDs (Parrot Design Documents) contain some details of the internals of Parrot; a few other documents fill in the gaps. One way of helping Parrot development is to write tests, and there is a document entitled <i>Testing Parrot</i> that will help with this.</p>

<h2><a name="The_Parrot_Mailing_List"
>The Parrot Mailing List</a></h2>

<p>Much Parrot development and discussion takes place on the parrot&#45;dev mailing list. You can subscribe by filling out the form at <a href='http://lists.parrot.org/mailman/listinfo/parrot&#45;dev'><a href="http://lists.parrot.org/mailman/listinfo/parrot&#45;dev">http://lists.parrot.org/mailman/listinfo/parrot&#45;dev</a></a> or read the NNTP archive at <a href='http://groups.google.com/group/parrot&#45;dev/'><a href="http://groups.google.com/group/parrot&#45;dev/">http://groups.google.com/group/parrot&#45;dev/</a></a>.</p>

<h2><a name="IRC"
>IRC</a></h2>

<p>The Parrot IRC channel is hosted on irc.parrot.org and is named <code>#parrot</code>. Alternative IRC servers are at irc.pobox.com and irc.rhizomatic.net.</p>
            </div> <!-- "mainbody" -->
            <div id="divider"></div>
            <div id="footer">
	        Copyright &copy; 2002-2009, Parrot Foundation.
            </div>
        </div> <!-- "wrapper" -->
    </body>
</html>
