<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>The Parrot Primer</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">The Parrot Primer</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../html/index.html">Contents</a> | <a href="../../html/docs.html">Documentation</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>docs/intro.pod &#45; The Parrot Primer</p>

<h1><a name="Welcome_to_Parrot"
>Welcome to Parrot <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>This is an update to the article &#39;Parrot: Some Assembly Required&#39; which appeared on <a href="http://www.perl.com">http://www.perl.com</a> for the 0.0.2 release of Parrot.
It&#39;s intended as being the best way for the newcomer to Parrot to learn what Parrot is and how to use it.</p>

<h1><a name="What_is_Parrot?"
>What is Parrot? <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>First,
though,
what is Parrot,
and why are we making such a fuss about it?
Well,
if you haven&#39;t been living in a box for the past years,
you&#39;ll know that the Perl community has embarked on the design and implementation of a new version of Perl,
both the language and the interpreter.</p>

<p>Parrot is related to Perl 6,
but it is not Perl 6.
To find out what it actually is,
we need to know a little about how Perl works.
When you feed your program into <code lang='und' xml:lang='und'>perl</code>,
it is first compiled into an internal representation,
or bytecode; then this bytecode is fed to an almost separate subsystem inside <code lang='und' xml:lang='und'>perl</code> to be interpreted.
So there are two distinct phases of <code lang='und' xml:lang='und'>perl</code>&#39;s operation &#45; compilation to bytecode,
and interpretation of bytecode.
This is not unique to Perl; other languages following this design include Python,
Ruby,
Tcl and,
believe it or not,
even Java.</p>

<p>In previous versions of Perl,
this arrangement has been pretty <i>ad hoc</i>: there hasn&#39;t been any overarching design to the interpreter or the compiler,
and the interpreter has ended up being pretty reliant on certain features of the compiler.
Nevertheless,
the interpreter (some languages call it a Virtual Machine) can be thought of as a software CPU &#45; the compiler produces &#34;machine code&#34; instructions for the virtual machine,
which it then executes,
much like a C compiler produces machine code to be run on a real CPU.</p>

<p>Perl 6 plans to separate out the design of the compiler and the interpreter.
This is why we&#39;ve come up with a subproject,
which we&#39;ve called Parrot,
which has a certain,
limited amount of independence from Perl 6.
Parrot is destined to be the Perl 6 Virtual Machine,
the software CPU on which we will run Perl 6 bytecode.
We&#39;re working on Parrot before we work on the Perl 6 compiler because it&#39;s much easier to write a compiler once you&#39;ve got a target to compile to!</p>

<p>The name &#34;Parrot&#34; was chosen after the 2001 April Fool&#39;s Joke which had Perl and Python collaborating on the next version of their interpreters.
This is meant to reflect the idea that we&#39;d eventually like other languages to use Parrot as their VM; in a sense,
we&#39;d like Parrot to become a &#34;common language runtime&#34; for dynamic languages.</p>

<h2><a name="Where_we&#39;re_at"
>Where we&#39;re at <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>It should be stressed we&#39;re still in the early stages of development.</p>

<p>But don&#39;t let that put you off!
Parrot is still very much usable; we&#39;ve already a lot of languages (in different state of completeness) which compile down to Parrot bytecode.
Please have a look at the <em lang='und' xml:lang='und'>languages/</em> subdirectory.</p>

<p>At the moment,
it&#39;s possible to write simple programs in Parrot assembly language,
use an assembler to convert them to machine code and then execute them on a test interpreter.
We have support for a wide variety of ordinary and transcendental mathematical operations,
some rudimentary string support,
and some conditional operators.</p>

<h2><a name="How_to_get_it"
>How to get it <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>So let&#39;s get ourselves a copy of Parrot,
so that we can start investigating how to program in the Parrot assembler.</p>

<p>Periodic,
numbered releases will appear on CPAN (we&#39;re currently on version 0.2.0),
but at this stage of the project an awful lot is changing between releases.
To really keep up to date with Parrot,
we should get our copy from the SVN repository.
Here&#39;s how we do that:</p>

<pre lang='und' xml:lang='und'>  svn co https://svn.perl.org/parrot/trunk parrot</pre>

<p>You can find more instructions at: <a href="http://www.parrotcode.org/source.html">http://www.parrotcode.org/source.html</a></p>

<p>Now we have downloaded Parrot, we need to build it; so:</p>

<pre lang='und' xml:lang='und'> % cd parrot
 % perl Configure.pl
 Parrot Configure
 Copyright (C) 2001&#45;2003 The Perl Foundation.  All Rights Reserved.

 Since you&#39;re running this script, you obviously have
 Perl 5&#45;&#45;I&#39;ll be pulling some defaults from its configuration.
 ...</pre>

<p>The Configure script will then attempt to discover your local configuration automatically; you can supply the &#45;&#45;ask switch if you wish to configure the build manually. You might also have a look at:</p>

<pre lang='und' xml:lang='und'> % perl Configure.pl &#45;&#45;help</pre>

<p>Once Configure has finished successfully, type <code lang='und' xml:lang='und'>make</code> (or the name of your local <code lang='und' xml:lang='und'>make</code> program). With any luck, Parrot will successfully build. (If it doesn&#39;t, the address to complain to is at the end of this introduction...)</p>

<h2><a name="The_test_suite"
>The test suite <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Now we should run some tests; so type <code lang='und' xml:lang='und'>make test</code> and you should see a readout like the following:</p>

<pre lang='und' xml:lang='und'> perl t/harness &#45;&#45;gc&#45;debug &#45;&#45;running&#45;make&#45;test  &#45;b t/op/*.t t/pmc/*.t \
      t/native_pbc/*.t imcc/t/*/*.t t/src/*.t
 t/op/00ff&#45;dos...........ok
 t/op/00ff&#45;unix..........ok
 ...
 All tests successful, 40 subtests skipped.
 Files=95, Tests=1386, 125 wallclock secs (56.96 cusr + 23.71 csys = 80.67 CPU)</pre>

<p>(Of course, there might be more tests than this, but you get the idea; tests may be skipped &#45; for one reason or another &#45; but none of them should fail!)</p>

<h2><a name="Reporting_Problems"
>Reporting Problems <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>If you have problems with parrot, please send a message to bugs&#45;parrot@bugs6.perl.org with a description of your problem. Please include the myconfig file that was generated as part of the build process.</p>

<h1><a name="Parrot_Concepts"
>Parrot Concepts <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>Before we dive into programming Parrot assembly, let&#39;s take a brief look at some of the concepts involved.</p>

<h2><a name="Types"
>Types <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>The Parrot CPU has four basic data types:</p>

<dl>
<dt><a name="INTVAL"
><b><code lang='und' xml:lang='und'>INTVAL</b></code></a></dt><p class="pad"></p>

<dd>An integer type; guaranteed to be wide enough to hold a pointer.</dd><p class="pad"></p>

<dt><a name="FLOATVAL"
><b><code lang='und' xml:lang='und'>FLOATVAL</b></code></a></dt><p class="pad"></p>

<dd>An architecture&#45;independent floating point type.</dd><p class="pad"></p>

<dt><a name="STRING"
><b><code lang='und' xml:lang='und'>STRING</b></code></a></dt><p class="pad"></p>

<dd>An abstracted, encoding&#45;independent string type.</dd><p class="pad"></p>

<dt><a name="PMC"
><b><code lang='und' xml:lang='und'>PMC</b></code></a></dt><p class="pad"></p>

<dd>Other types like a (perl) scalar or an array.</dd><p class="pad"></p>
</dl>

<p>The first three types are pretty much self&#45;explanatory; the final type, Parrot Magic Cookies, are slightly more difficult to understand. But that&#39;s OK! We&#39;ll talk more about PMCs at the end of the article.</p>

<h2><a name="Registers"
>Registers <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>The current Perl 5 virtual machine is a stack machine &#45; it communicates values between operations by keeping them on a stack. Operations load values onto the stack, do whatever they need to do, and put the result back onto the stack. This is very easy to work with, but it&#39;s very slow: to add two numbers together, you need to perform three stack pushes and two stack pops. Worse, the stack has to grow at runtime, and that means allocating memory just when you don&#39;t want to be allocating it.</p>

<p>So Parrot&#39;s going to break with the established tradition for virtual machines, and use a register architecture, more akin to the architecture of a real hardware CPU. This has another advantage: we can use all the existing literature on how to write compilers and optimizers for register&#45;based CPUs for our software CPU!</p>

<p>Parrot has specialist registers for each type: 32 INTVAL registers, 32 FLOATVAL registers, 32 string registers and 32 PMC registers. In Parrot assembler, these are named <code lang='und' xml:lang='und'>I0</code>...<code lang='und' xml:lang='und'>I31</code>, <code lang='und' xml:lang='und'>N0</code>...<code lang='und' xml:lang='und'>N31</code>, <code lang='und' xml:lang='und'>S0</code>...<code lang='und' xml:lang='und'>S31</code>, <code lang='und' xml:lang='und'>P0</code>...<code lang='und' xml:lang='und'>P31</code>.</p>

<p>Now let&#39;s look at some assembler. We can set these registers with the <code lang='und' xml:lang='und'>set</code> operator:</p>

<pre lang='und' xml:lang='und'>    set I1, 10
    set N1, 3.1415
    set S1, &#34;Hello, Parrot&#34;</pre>

<p>All Parrot ops have the same format: the name of the operator, the destination register, and then the operands.</p>

<h2><a name="Operations"
>Operations <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>There are a variety of operations you can perform: the file <em lang='und' xml:lang='und'>docs/core_ops.pod</em> documents them, along with a little more about the assembler syntax. For instance, we can print out the contents of a register, or a constant:</p>

<pre lang='und' xml:lang='und'>    print &#34;The contents of register I1 is: &#34;
    print I1
    print &#34;\n&#34;</pre>

<p>Or we can perform mathematical functions on registers:</p>

<pre lang='und' xml:lang='und'>    add I1, I1, I2  # Add the contents of I2 to the contents of I1
    mul I3, I2, I4  # Multiply I2 by I4 and store in I3
    inc I1          # Increment I1 by one
    dec N3, 1.5     # Decrement N3 by 1.5</pre>

<p>We can even perform some simple string manipulation:</p>

<pre lang='und' xml:lang='und'>    set S1, &#34;fish&#34;
    set S2, &#34;bone&#34;
    concat S1, S2             # S1 is now &#34;fishbone&#34;
    substr S4, S1, 0, 1, &#34;w&#34;  # S1 is now &#34;wishbone&#34;
    length I1, S1             # I1 is 8
    end</pre>

<h2><a name="Branches"
>Branches <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Code gets a little boring without flow control; for starters, Parrot knows about branching and labels. The <code lang='und' xml:lang='und'>branch</code> op is equivalent to Perl&#39;s <code lang='und' xml:lang='und'>goto</code>:</p>

<pre lang='und' xml:lang='und'>          branch TERRY
 JOHN:    print &#34;fjords\n&#34;
          branch END
 MICHAEL: print &#34; pining&#34;
          branch GRAHAM
 TERRY:   print &#34;It&#39;s&#34;
          branch MICHAEL
 GRAHAM:  print &#34; for the &#34;
          branch JOHN
 END:     end</pre>

<p>It can also do simple tests for whether or not a register contains a true value:</p>

<pre lang='und' xml:lang='und'>          set I1, 12
          set I2, 5
          mod I3, I1, I2
          if I3, REMAIND
          print &#34;5 is an integer divisor of 12&#34;
          branch DONE
 REMAIND: print &#34;5 divides 12 with remainder &#34;
          print I3
 DONE:    print &#34;\n&#34;
          end</pre>

<p>Note that <code lang='und' xml:lang='und'>if</code> branches to <code lang='und' xml:lang='und'>REMAIND</code> if <code lang='und' xml:lang='und'>I3</code> contains a true (i.e. non&#45;zero) value; if <code lang='und' xml:lang='und'>I3</code> is zero, execution falls through to the next statement. Here&#39;s what that would look like in Perl, for comparison:</p>

<pre lang='und' xml:lang='und'>    $i1 = 12;
    $i2 = 5;
    $i3 = $i1 % $i2;
    if ($i3) {
      print &#34;5 divides 12 with remainder &#34;;
      print $i3;
    } else {
      print &#34;5 is an integer divisor of 12&#34;;
    }
    print &#34;\n&#34;;
    exit;</pre>

<p>And speaking of comparison, we have the full range of numeric comparators: <code lang='und' xml:lang='und'>eq</code>, <code lang='und' xml:lang='und'>ne</code>, <code lang='und' xml:lang='und'>lt</code>, <code lang='und' xml:lang='und'>gt</code>, <code lang='und' xml:lang='und'>le</code> and <code lang='und' xml:lang='und'>ge</code>. Note that you can&#39;t use these operators on arguments of disparate types; you may even need to add the suffix <code lang='und' xml:lang='und'>_i</code> or <code lang='und' xml:lang='und'>_n</code> to the op to tell it what type of argument you are using &#45; although the assembler ought to divine this for you, by the time you read this.</p>

<h1><a name="Some_Parrot_Programs"
>Some Parrot Programs <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>Now let&#39;s have a look at a few simple Parrot programs to give you a feel for the language.</p>

<h2><a name="Displaying_the_Time"
>Displaying the Time <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>This little program displays the Unix epoch time every second: (or so)</p>

<pre lang='und' xml:lang='und'>         set I3, 3000000
 REDO:   time I1
         print I1
         print &#34;\n&#34;
         set I2, 0
 SPIN:   inc I2
         le I2, I3, SPIN
         branch REDO
         end</pre>

<p>First, we set integer register 3 to contain 3 million &#45; that&#39;s a completely arbitrary number, due to the fact that Parrot averages a massive six million ops per second on my machine. Then the program consists of two loops: the outer loop stores the current Unix time in integer register 1, prints it out, prints a new line, and resets register 2 to zero. The inner loop increments register 2 until it reaches the 3 million we stored in register 3. When it is no longer less than (or equal to) 3 million, we go back to the <code lang='und' xml:lang='und'>REDO</code> of the outer loop. In essence, we&#39;re just spinning around a busy loop to waste some time.</p>

<p>How do we run this? Copy the assembler to a file <em lang='und' xml:lang='und'>showtime.pasm</em>, and inside your Parrot directory, run:</p>

<pre lang='und' xml:lang='und'>      parrot showtime.pasm</pre>

<p>This will assemble and run the code in <em lang='und' xml:lang='und'>showtime.pasm</em>. You can also create an assembled bytecode from the assembler by running:</p>

<pre lang='und' xml:lang='und'>      parrot &#45;o showtime.pbc showtime.pasm</pre>

<p>(<code lang='und' xml:lang='und'>.pbc</code> is the file extension for Parrot bytecode.)</p>

<p>To run this bytecode type</p>

<pre lang='und' xml:lang='und'>      parrot showtime.pbc</pre>

<h2><a name="Finding_a_Fibonacci_number"
>Finding a Fibonacci number <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>The Fibonacci series is defined like this: take two numbers, 1 and 1. Then repeatedly add together the last two numbers in the series to make the next one: 1, 1, 2, 3, 5, 8, 13, and so on. The Fibonacci number <code lang='und' xml:lang='und'>fib(n)</code> is the n&#39;th number in the series. Here&#39;s a simple Parrot assembler program which finds the first 20 Fibonacci numbers:</p>

<pre lang='und' xml:lang='und'> # Some simple code to print some Fibonacci numbers
 # Leon Brocard &#60;acme@astray.com&#62;

         print   &#34;The first 20 fibonacci numbers are:\n&#34;
         set     I1, 0
         set     I2, 20
         set     I3, 0
         set     I4, 1
 REDO:   set     I5, I4
         add     I4, I3, I4
         set     I3, I5
         print   I3
         print   &#34;\n&#34;
         inc     I1
         lt      I1, I2, REDO
 DONE:   end</pre>

<p>This is the equivalent code in Perl:</p>

<pre lang='und' xml:lang='und'>        print &#34;The first 20 fibonacci numbers are:\n&#34;;
        my $i = 0;
        my $target = 20;
        my $a = 0;
        my $b = 1;
        until ($i == $target) {
           my $num = $b;
           $b += $a;
           $a = $num;
           print $a,&#34;\n&#34;;
           $i++;
        }</pre>

<h2><a name="Further_examples"
>Further examples <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Additional examples of what can be done with Parrot assembler can be found in the <em lang='und' xml:lang='und'>parrot/examples/</em> subdirectory, and on the web at <a href="http://www.parrotcode.org/examples/.">http://www.parrotcode.org/examples/.</a></p>

<h1><a name="Where_Next?"
>Where Next? <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>Parrot is obviously developing very rapidly, and we&#39;ve still got a long way to go before we are ready to a compiler to this platform. This section is for those who are interested in helping us take Parrot further.</p>

<h2><a name="Vtable_datatypes"
>Vtable datatypes <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>PMCs are almost like Perl 5&#39;s SVs and Python&#39;s Objects, only more so. A PMC is an object of some type, which can be instructed to perform various operations. So when we say</p>

<pre lang='und' xml:lang='und'>      inc P1</pre>

<p>to increment the value in PMC register 1, the <code lang='und' xml:lang='und'>increment</code> method is called on the PMC &#45; and it&#39;s up to the PMC how it handles that method.</p>

<p>PMCs are how we plan to make Parrot language&#45;independent &#45; a Perl PMC would have different behavior from a Python PMC or a Tcl PMC. The individual methods are function pointers held in a structure called a <b>vtable</b>, and each PMC has a pointer to the vtable which implements the methods of its &#34;class&#34;. Hence a Perl interpreter would link in a library full of Perl&#45;like classes and its PMCs would have Perl&#45;like behaviour.</p>

<p>The PMC types available are described in <em lang='und' xml:lang='und'>doc/vtables.pod</em>; you can create a new PMC with</p>

<pre lang='und' xml:lang='und'>    new P0, &#60;typename&#62;</pre>

<p>and then use any of the instructions in <em lang='und' xml:lang='und'><a href="../ops/core.ops.html">ops/core.ops</a></em> and <em lang='und' xml:lang='und'><a href="../ops/pmc.ops.html">ops/pmc.ops</a></em> which support PMCs. <em lang='und' xml:lang='und'>doc/vtables.pod</em> also tells you how to implement your own PMC vtable classes.</p>

<h2><a name="Getting_involved"
>Getting involved <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>We&#39;ve got a good number of people working away on Parrot, but we could always use a few more. To help out, you&#39;ll need a subscription to the perl6&#45;internals mailing list, (<code lang='und' xml:lang='und'>perl6&#45;internals@perl.org</code>), where all the development takes place. You should also keep up to date with the SVN version of Parrot; if you want to be alerted to SVN commits, you can subscribe to the cvs&#45;parrot mailing list (<code lang='und' xml:lang='und'>cvs&#45;parrot@perl.org</code>). SVN commit access is given to those who take responsibility for a particular area of Parrot, or who often submit high&#45;quality patches.</p>

<p>The projects home page is <a href='http://www.parrotcode.org'><a href="http://www.parrotcode.org">http://www.parrotcode.org</a></a>.</p>

<p>So don&#39;t delay &#45; pick up a Parrot today!</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
