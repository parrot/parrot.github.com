<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Untitled</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Untitled</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../../html/index.html">Contents</a> | <a href="../../../../html/languages.html">Language Implementations</a> | <a href="../../../../html/tcl.html">TCL</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NOTE"
>NOTE <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>This document is probably no longer current.</p>

<h1><a name="PARSING"
>PARSING <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>This document explains the algorithm used by <code lang='und' xml:lang='und'>parse.imc</code> to parse a hunk of tcl.
This is a from&#45;scratch implementation based on the tcl man page.
This was,
btw,
a heck of a lot easier when I had perl5&#39;s regexps to do things with.
=&#45;)</p>

<p>First,
in <code lang='und' xml:lang='und'>__main</code>,
we read in the input file and shove it in a string.
This then gets passed to the <code lang='und' xml:lang='und'>__parse</code> sub.
(Or we take stdin,
we&#39;re not picky)</p>

<p>Footnotes refer to bullet items in the tcl man page.</p>

<h1><a name="STATE_MACHINE"
>STATE_MACHINE <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>There are several states that our parser can be in:</p>

<h2><a name="BEGIN_SCOPE"
>BEGIN_SCOPE <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Where we begin,
create a lexical scope in which to store variables.</p>

<p>newline/backslash substitution is performed on the string.
[8]</p>

<h2><a name="BEGIN_COMMAND"
>BEGIN_COMMAND <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>We clear out the Array that is holding our command.</p>

<h2><a name="BEGIN_WORD"
>BEGIN_WORD <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>skip any leading whitespace.
If a newline or a ; is found,
goto END_COMMAND [1]</p>

<p>if the first character of the first word is a #,
then it&#39;s a comment: ignore all characters until the next newline,
and go to BEGIN_COMMAND [9]</p>

<p>If the first character of a word is a double&#45;quote,
the word consists of all the characters between the two double quotes.
append it to the command Array and goto BEGIN_WORD [4] (escaped \&#34;&#39;s are ignored.) (any non whitespace/ non command separator character in the stream at this point is an error.)</p>

<p>If the first character of a word is a {,
the word consists of all the characters between the { and the }.
append the word to the command Array and goto begin word.
[5] There must be a matched number of unescaped { and } chars.
(any non whitespace/ non command separator character in the stream at this point is an error.)</p>

<p>If there are no more characters,
goto END_SCOPE</p>

<p>If any other character,
then fall through:</p>

<h2><a name="MIDDLE_WORD"
>MIDDLE_WORD <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>We&#39;re in the middle of getting a word.
Any whitespace indicates END_WORD.
A ; or \n indicates END_COMMAND.</p>

<p>If a [ (unescaped) is present,
then the word extends to at least the next ].
Grab these characters,
goto MIDDLE_WORD</p>

<p>If a ${ appears,
the word extends to at least the next }.
Grab these characters,
goto MIDDLE_WORD</p>

<h2><a name="END_WORD"
>END_WORD <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>We&#39;ve reached the end of a word.
Add it to the array of words.
goto BEGIN_WORD</p>

<h2><a name="END_COMMAND"
>END_COMMAND <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>We&#39;ve reached the end of a command,
append any outstanding word into the command array.</p>

<p>Append the command array to the array of commands.
Goto BEGIN_COMMAND</p>

<h2><a name="END_SCOPE"
>END_SCOPE <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>We now have an array of arrays,
which correspond to the raw text of the words in the code.
Now we need to perform various substitutions on the words.
(In a future version,
this is where we&#39;d compile the code.
For now,
we&#39;ll just interpret it.)</p>

<h2><a name="RUN_COMMAND"
>RUN_COMMAND <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>pop an array off the array of commands.
For each of the words in the command array,
we need to make sure we only process each character of text once &#45; to do this,
we keep a linked list of { state,
start,
len } &#45; Each round of substitution can only happen on raw segments.
Once a substitution occurs,
the list is further segmented,
the raw being broken up into possibly multiple alternating raw/cooked segments.
Substitutions are NOT done on words that were {} words.</p>

<dl>
<dt><a name="Command_substitution"
>Command substitution</a></dt><p class="pad"></p>

<dd>All characters between a [ and ] are considered a tcl script,
and run through a separate invocation of the parser.</dd><p class="pad"></p>

<dt><a name="Variable_substitution"
>Variable substitution</a></dt><p class="pad"></p>

<dd>If there&#39;s a $ ,
then any of the following text is replaced with the corresponding variable value: $name ,
$name(index) and ${name}.
index has command,
variable,
and backslash substitutions performed on it before it&#39;s used to lookup a value.</dd><p class="pad"></p>

<dt><a name="backslash_substitution"
>backslash substitution</a></dt><p class="pad"></p>

<dd>Various \ substitutions,
except for backslash&#45;newline,
which is done before anything else when we first get our script.</dd><p class="pad"></p>
</dl>

<h2><a name="EXECUTE_COMMAND"
>EXECUTE_COMMAND <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>At this point,
each of the words is as cooked as it&#39;s going to be.
Put the list for each word back together into a single string.
Call the command associated with the first cooked word and pass in the rest of the array as the parameters.</p>

<p>Save return value.
(but only the last one)</p>

<p>While there are commands left,
go to RUN_COMMAND</p>

<p>return the last return value saved.
(XXX: what to return if there was no command executed?
empty string?)</p>

<h1><a name="POD_ERRORS"
>POD ERRORS <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>Hey!
<b>The above document had some coding errors,
which are explained below:</b></p>

<dl>
<dt><a name="Around_line_111:"
>Around line 111:</a></dt><p class="pad"></p>

<dd>You forgot a &#39;=back&#39; before &#39;=head2&#39;</dd><p class="pad"></p>
</dl>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
