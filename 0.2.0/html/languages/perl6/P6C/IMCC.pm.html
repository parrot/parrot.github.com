<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Untitled</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Untitled</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../../html/index.html">Contents</a> | <a href="../../../../html/languages.html">Language Implementations</a> | <a href="../../../../html/perl6.html">Perl6</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="P6C::IMCC"
><b>P6C::IMCC</b> <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>IMCC.pm is still a &#34;ball of mud&#34; at the moment,
but context propagation has been moved to Context.pm.
Next for refactoring is symbol handling.</p>

<p>Context should not be propagated during code generation,
as the context propagation pass handles this.
This rule is broken for hyper&#45;operators,
since I can&#39;t think of a good way to handle them using context.</p>

<p>Code is generated by a depth&#45;first recursive traversal of the op tree.
Each node type should define a <code lang='und' xml:lang='und'>val</code> function to be called by its parent node.
This function should gather values from child nodes (by calling their <code lang='und' xml:lang='und'>val</code> functions),
then emit the code for the node&#39;s operation (using <code lang='und' xml:lang='und'>P6C::Compiler::code</code>).
Code is appended to the current function in the order in which it is generated,
so subnodes must be evaluated in the proper order.</p>

<p><code lang='und' xml:lang='und'>val</code> should return one of the following:</p>

<ul>
<li>undef if the node has no rvalue.</li><p class="pad"></p>

<li>a reference to an array of registers if called in tuple context.</li><p class="pad"></p>

<li>the name of a PMC register holding the rvalue otherwise.</li><p class="pad"></p>
</ul>

<p>Node types that can act as lvalues should define an <code lang='und' xml:lang='und'>assign</code> function that takes an unevaluated rvalue tree and a context structure.
This function should return a PMC register or array ref (like <code lang='und' xml:lang='und'>val</code>) if (like an assignment) it serves as both an lvalue and an rvalue.</p>

<h2><a name="External_interface"
>External interface <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>If <code lang='und' xml:lang='und'>P6C::IMCC</code> is imported with the &#34;:external&#34; flag,
it will define the following interface,
used by the driver:</p>

<dl>
<dt><a name="init()"
><b>init()</b></a></dt><p class="pad"></p>

<dd>Initialize or reset compiler state.
This should be called before generating any code.
<code lang='und' xml:lang='und'>init</code> destroys all functions and globals,
resets the current function,
and reinitializes builtins.</dd><p class="pad"></p>

<dt><a name="compile($top)"
><b>compile($top)</b></a></dt><p class="pad"></p>

<dd>Compile a tree based at $top,
but do not emit any code.</dd><p class="pad"></p>

<dt><a name="emit()"
><b>emit()</b></a></dt><p class="pad"></p>

<dd>Emit IMCC code on standard output,
including a header that calls <code lang='und' xml:lang='und'>main</code>,
and the code for any builtin functions (see <code lang='und' xml:lang='und'>P6C::Builtins</code>).
<code lang='und' xml:lang='und'>emit</code> will fail if you have not defined <code lang='und' xml:lang='und'>main</code>.</dd><p class="pad"></p>
</dl>

<h2><a name="Internals"
>Internals <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>If <code lang='und' xml:lang='und'>P6C::IMCC</code> is imported with the &#34;:all&#34; flag,
it exports an internal interface.</p>

<p>The compiler maintains a &#34;current function&#34; (could be generalized to &#34;current scope&#34;) in which code is emitted,
locals are declared,
and symbol lookups begin.
The following functions manipulate the current function context.</p>

<dl>
<dt><a name="code($x)"
><b>code($x)</b></a></dt><p class="pad"></p>

<dd>Append IMCC code <code lang='und' xml:lang='und'>$x</code> to the current function.</dd><p class="pad"></p>

<dt><a name="add_function($name,_[$sub_def])"
><b>add_function($name,
[$sub_def])</b></a></dt><p class="pad"></p>

<dd>Create a new function stub for <code lang='und' xml:lang='und'>$name</code>.
If <code lang='und' xml:lang='und'>$name</code> exists,
it will be overwritten.
In such cases,
a warning will be omitted unless the {&#39;weak&#39;} flag is set.</dd><p class="pad"></p>

<dt><a name="exists_function_def($name)"
><b>exists_function_def($name)</b></a></dt><p class="pad"></p>

<dd>Return true if function <code lang='und' xml:lang='und'>$name</code> is defined (i.e.
not just &#34;declared&#34;).</dd><p class="pad"></p>

<dt><a name="exists_function_decl($name)"
><b>exists_function_decl($name)</b></a></dt><p class="pad"></p>

<dd>Return true if a stub exists for <code lang='und' xml:lang='und'>$name</code>,
even if it has no code.</dd><p class="pad"></p>

<dt><a name="$oldfunc_=_set_function($name)"
><b>$oldfunc = set_function($name)</b></a></dt><p class="pad"></p>

<dd>Set the code insertion point to the end of function <code lang='und' xml:lang='und'>$name</code>,
returning the name of the previously active function.
Function <code lang='und' xml:lang='und'>$name</code> should exist before this is called.</dd><p class="pad"></p>
</dl>

<h2><a name="Name_lookup"
>Name lookup <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>This is a primitive symbol table.
Which is okay,
since Parrot doesn&#39;t have stashes yet.
Hopefully the interface will be useful when things get more complicated.</p>

<dl>
<dt><a name="$name_=_globalvar($var)"
><b>$name = globalvar($var)</b></a></dt><p class="pad"></p>

<dd>Lookup a global variable.</dd><p class="pad"></p>

<dt><a name="add_globalvar($var_[,_$type])"
><b>add_globalvar($var [,
$type])</b></a></dt><p class="pad"></p>

<dd>Declare global variable <code lang='und' xml:lang='und'>$var</code>.
Warns if <code lang='und' xml:lang='und'>$var</code> is already defined.
<code lang='und' xml:lang='und'>$var</code> will be initialized to a new PMC of type <code lang='und' xml:lang='und'>$type</code> (or <code lang='und' xml:lang='und'>PerlUndef</code> if type is not given) before <code lang='und' xml:lang='und'>main</code> is called.</dd><p class="pad"></p>

<dt><a name="$name_=_localvar($var)"
><b>$name = localvar($var)</b></a></dt><p class="pad"></p>

<dd>Find local variable <code lang='und' xml:lang='und'>$var</code>,
returning its IMCC name.</dd><p class="pad"></p>

<dt><a name="add_localvar($var,_$type)"
><b>add_localvar($var,
$type)</b></a></dt><p class="pad"></p>

<dd>Declare local variable <code lang='und' xml:lang='und'>$var</code> of type <code lang='und' xml:lang='und'>$type</code>.
Warns if <code lang='und' xml:lang='und'>$var</code> is already defined.
If <code lang='und' xml:lang='und'>$type</code> is a PMC type,
<code lang='und' xml:lang='und'>$var</code> will automatically be initialized.</dd><p class="pad"></p>

<dt><a name="$name_=_paramvar($var)"
><b>$name = paramvar($var)</b></a></dt><p class="pad"></p>

<dd>Find parameter <code lang='und' xml:lang='und'>$var</code>.</dd><p class="pad"></p>

<dt><a name="$name_=_findvar($var)"
><b>$name = findvar($var)</b></a></dt><p class="pad"></p>

<dt><a name="($name,_$isglobal)_=_findvar($var)"
><b>($name,
$isglobal) = findvar($var)</b></a></dt><p class="pad"></p>

<dd>Find variable <code lang='und' xml:lang='und'>$var</code>,
a <code lang='und' xml:lang='und'>P6C::variable</code>,
returning a PMC register containing its value.
Currently <code lang='und' xml:lang='und'>findvar</code> looks at the active function&#39;s parameters,
then locals,
then globals (which don&#39;t exist,
so it won&#39;t find anything there).
Returns undef if the variable is not found.
<code lang='und' xml:lang='und'>$isglobal</code> is currently unused.</dd><p class="pad"></p>

<dt><a name="push_scope()"
><b>push_scope()</b></a></dt><p class="pad"></p>

<dd>Push a scope within the current function.</dd><p class="pad"></p>

<dt><a name="pop_scope()"
><b>pop_scope()</b></a></dt><p class="pad"></p>

<dd>Pop a scope from the current function.</dd><p class="pad"></p>

<dt><a name="mangled_name($thing)"
><b>mangled_name($thing)</b></a></dt><p class="pad"></p>

<dd>Mangle any kind of variable,
function,
or operator name.</dd><p class="pad"></p>

<dd>Convert names like $foo to _SV_foo.
If the name is prefixed with an equals sign,
then just pass the rest of the string through untouched (so the mangled form of &#34;=$#@!!&#34; is &#34;$#@!!&#34;.</dd><p class="pad"></p>
</dl>

<h2><a name="Labels"
><b>Labels</b> <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Note that the &#34;labels&#34; here aren&#39;t necessarily simple addresses in the code; while this may sometimes be the case,
creating some labels may involve taking a continuation,
and jumping to labels may involve throwing an exception and unwinding the call stack.</p>

<p>XXX: Labels and try/CATCH currently use different mechanisms,
contrary to Apocalypse 4.
Exceptions are implemented with continuations,
and are therefore much more expensive than labels,
which use simple jumps.
Eventually,
either continuations will have to become much lighter&#45;weight,
or the compiler will have to determine when a jump is sufficient,
and when a continuation or exception is required.
This implementation means that you can&#39;t mix gotos and exceptions without Bad Things happening.</p>

<p>The <code lang='und' xml:lang='und'>name</code> argument is a label name,
and may be undefined for typed loop labels (e.g.
&#34;next&#34;).
The <code lang='und' xml:lang='und'>type</code> argument should be one of the following:</p>

<dl>
<dt><a name="next"
><b>next</b></a></dt><p class="pad"></p>

<dt><a name="redo"
><b>redo</b></a></dt><p class="pad"></p>

<dt><a name="last"
><b>last</b></a></dt><p class="pad"></p>

<dt><a name="break"
><b>break</b></a></dt><p class="pad"></p>

<dt><a name="continue"
><b>continue</b></a></dt><p class="pad"></p>

<dt><a name="skip"
><b>skip</b></a></dt><p class="pad"></p>

<dt><a name="return"
><b>return</b></a></dt><p class="pad"></p>
</dl>

<p>Label handling functions:</p>

<dl>
<dt><a name="declare_label(name_=_$name,_type_=&#62;_$type)&#62;"
><b>declare_label(name =</b> $name,
type =&#62; $type)&#62;</a></dt><p class="pad"></p>

<dd>Declare a label in the current scope.
Either <code lang='und' xml:lang='und'>name</code> or <code lang='und' xml:lang='und'>type</code> may be omitted.</dd><p class="pad"></p>

<dt><a name="emit_label(name_=_$name,_type_=&#62;_$type)&#62;"
><b>emit_label(name =</b> $name,
type =&#62; $type)&#62;</a></dt><p class="pad"></p>

<dd>Emit code for a label in the current scope.
Either <code lang='und' xml:lang='und'>name</code> or <code lang='und' xml:lang='und'>type</code> may be omitted.</dd><p class="pad"></p>

<dt><a name="goto_label(name_=_$name,_type_=&#62;_$type)&#62;"
><b>goto_label(name =</b> $name,
type =&#62; $type)&#62;</a></dt><p class="pad"></p>

<dd>Branch to the appropriate version of a label.
Either <code lang='und' xml:lang='und'>name</code> or <code lang='und' xml:lang='und'>type</code> may be omitted.</dd><p class="pad"></p>

<dt><a name="fixup_label(from,to)"
><b>fixup_label(from,to)</b></a></dt><p class="pad"></p>

<dd>Do something intensely interesting that is extremely important for you to understand.</dd><p class="pad"></p>
</dl>

<h2><a name="Topic"
><b>Topic</b> <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="set_topic($x)"
><b>set_topic($x)</b></a></dt><p class="pad"></p>

<dd>Sets the topic to <code lang='und' xml:lang='und'>$x</code> until the next call to <code lang='und' xml:lang='und'>set_topic</code>,
or until the end of the current scope,
whichever is first.
Note that <code lang='und' xml:lang='und'>$x</code> is a <b>variable</b>,
not a value.</dd><p class="pad"></p>

<dt><a name="topic()"
><b>topic()</b></a></dt><p class="pad"></p>

<dd>Get the current topic variable.</dd><p class="pad"></p>
</dl>

<h2><a name="Temporary_names"
>Temporary names <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="gensym([$str])"
><b>gensym([$str])</b></a></dt><p class="pad"></p>

<dd>Generate a unique identifier.
If <code lang='und' xml:lang='und'>$str</code> is given,
include it as part of the identifier.</dd><p class="pad"></p>

<dt><a name="gentmp([$type])"
><b>gentmp([$type])</b></a></dt><p class="pad"></p>

<dd>Generate an uninitialized temporary register.</dd><p class="pad"></p>

<dt><a name="genlocal($type,$name)"
><b>genlocal($type,$name)</b></a></dt><p class="pad"></p>

<dd>Generate an uninitialized local variable with the given type and name.</dd><p class="pad"></p>

<dt><a name="genlabel([$str])"
><b>genlabel([$str])</b></a></dt><p class="pad"></p>

<dd>Generate a unique label containing <code lang='und' xml:lang='und'>$str</code>.</dd><p class="pad"></p>

<dt><a name="newtmp([$type,[$comment]])"
><b>newtmp([$type,[$comment]])</b></a></dt><p class="pad"></p>

<dd>Create a new temporary register to hold a value of type <code lang='und' xml:lang='und'>$type</code>,
which should be &#34;int&#34;,
&#34;num&#34;,
&#34;str&#34;,
or some PMC type.
If <code lang='und' xml:lang='und'>$type</code> is a PMC type,
the register will be initialized with a new value.
If <code lang='und' xml:lang='und'>$type</code> is omitted,
it default to <code lang='und' xml:lang='und'>PerlUndef</code>.</dd><p class="pad"></p>

<dt><a name="newlocal([$type])"
><b>newlocal([$type])</b></a></dt><p class="pad"></p>

<dd>Generate a new local variable initialized with the default value for its type.</dd><p class="pad"></p>
</dl>

<h2><a name="Code_generation_functions"
>Code generation functions <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>The following functions generate useful and common pieces of code.</p>

<dl>
<dt><a name="gen_counted_loop($counter,_$body)"
><b>gen_counted_loop($counter,
$body)</b></a></dt><p class="pad"></p>

<dd>Generate a counted loop using <code lang='und' xml:lang='und'>$counter</code> as the repetition count.
The loop will iterate over values between 0 and $counter &#45; 1,
inclusive.
<code lang='und' xml:lang='und'>$counter</code> will be used as the iteration variable,
so it can be used in indexing expressions in the loop body.</dd><p class="pad"></p>

<dt><a name="scalar_in_context($val,_$ctx)"
><b>scalar_in_context($val,
$ctx)</b></a></dt><p class="pad"></p>

<dd>Emit the code to return a scalar <code lang='und' xml:lang='und'>$val</code> in the right way for context <code lang='und' xml:lang='und'>$ctx</code>.
In array context,
that means create a single&#45;element array containing the scalar.</dd><p class="pad"></p>

<dt><a name="primitive_in_context($val,_$primitive_type,_$ctx)"
><b>primitive_in_context($val,
$primitive_type,
$ctx)</b></a></dt><p class="pad"></p>

<dt><a name="array_in_context($val,_$ctx)"
><b>array_in_context($val,
$ctx)</b></a></dt><p class="pad"></p>

<dd>Convert an array to the appropriate type for the given context.
In tuple context,
pull out as many values as needed from the array.
In scalar context,
return the length of the array.</dd><p class="pad"></p>

<dt><a name="tuple_in_context(\@vals,_$ctx)"
><b>tuple_in_context(\@vals,
$ctx)</b></a></dt><p class="pad"></p>

<dd>Convert a tuple to the appropriate type for the given context.
In tuple context,
pad with PerlUndefs or truncate the array.
In array context,
construct an array out of all of the values in the tuple.
In scalar context,
return the first element in the tuple.</dd><p class="pad"></p>

<dt><a name="undef_in_context($ctx)"
><b>undef_in_context($ctx)</b></a></dt><p class="pad"></p>

<dd>Convert an undefined value to the appropriate type for the given context.
For example,
an undefined value is an empty PerlArray.
For most types,
it is a PerlUndef object.</dd><p class="pad"></p>

<dt><a name="do_flatten_array($vals)"
><b>do_flatten_array($vals)</b></a></dt><p class="pad"></p>

<dd>Emit code to evaluate each item in <code lang='und' xml:lang='und'>@$vals</code>,
which are assumed to be in list context.
The results are concatenated into a single array,
whose name is returned.</dd><p class="pad"></p>

<dt><a name="do_append_array($dest,_$src)"
><b>do_append_array($dest,
$src)</b></a></dt><p class="pad"></p>

<dd>Append one array to another.
I would vastly prefer having an &#39;append&#39; opcode,
but that can wait.</dd><p class="pad"></p>
</dl>

<h2><a name="P6C::rule"
>P6C::rule <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>A node representing a rule.</p>

<dl>
<dt><a name="val()_:_rule_&#45;&#62;_match_obj"
><b>val()</b> : rule &#45;&#62; match obj</a></dt><p class="pad"></p>

<dd>Generate code defining a rule</dd><p class="pad"></p>

<dd>Rules take several arguments: mode &#45; 0 means try to match rule 1 means backtrack into rule rx_pos &#45; position within input string to start matching rx_input &#45; input string rx_stack &#45; backtracking state stack params &#45; rule parameters array</dd><p class="pad"></p>

<dd>and return two values: rx_pos &#45; position after applying rule (to match or backtrack) status &#45; 1 for success,
0 for failure</dd><p class="pad"></p>

<dd>TODO: Rather than returning a status code,
this really ought to just invoke the appropriate continuation.</dd><p class="pad"></p>

<dd>TODO: It would also be nice to have two different entry points rather than the hokey <code lang='und' xml:lang='und'>mode</code> param.</dd><p class="pad"></p>
</dl>

<h1><a name="SEE_ALSO"
>SEE ALSO <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p><a href='TODO'>P6C::IMCC::prefix</a> for prefix operators (function calls,
return statements,
if/for/while/given,
etc.)</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
