<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Freeze and thaw functionality</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Freeze and thaw functionality</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../html/index.html">Contents</a> | <a href="../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>src/pmc_freeze.c &#45; Freeze and thaw functionality</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>Freeze uses the <code lang='und' xml:lang='und'>next_for_GC pointer()</code> to remember seen PMCs.
PMCs are written as IDs (or tags),
which are calculated from their arena address.
This PMC number is multiplied by four.
The 2 low bits indicate a seen PMC or a PMC of the same type as the previous one respectively.</p>

<p>Thawing PMCs uses a list with (maximum) size of the amount of PMCs to keep track of retrieved PMCs.</p>

<p>The individual information of PMCs is frozen/thawed by their vtables.</p>

<p>To avoid recursion,
the whole functionality is driven by <code lang='und' xml:lang='und'>pmc&#45;&#62;vtable&#45;&#62;visit</code>,
which is called for the first PMC initially.
Container PMCs call a &#34;todo&#45;callback&#34; for all contained PMCs.
The individual action vtable (freeze/thaw) is then called for all todo&#45;PMCs.</p>

<p>In the current implementation <code lang='und' xml:lang='und'>IMAGE_IO</code> is a stand&#45;in for some kind of serializer PMC which will eventually be written.
It associates a Parrot <code lang='und' xml:lang='und'>STRING</code> with a vtable.</p>

<h2><a name="Image_Stream_Functions"
>Image Stream Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="static_void_str_append(Parrot_Interp_interpreter,_STRING_*s,_const_void_*b,_size_t_len)"
><b><code lang='und' xml:lang='und'>static void str_append(Parrot_Interp interpreter, STRING *s, const void *b, size_t len)</b></code></a></dt><p class="pad"></p>

<dd>Appends <code lang='und' xml:lang='und'>len</code> bytes from buffer <code lang='und' xml:lang='und'>*b</code> to string <code lang='und' xml:lang='und'>*s</code>.</dd><p class="pad"></p>

<dd>Plain ascii &#45; for testing only:</dd><p class="pad"></p>

<dd>For speed reasons we mess around with the string buffers directly.</dd><p class="pad"></p>

<dd>No encoding of strings,
no transcoding.</dd><p class="pad"></p>

<dt><a name="static_void_push_ascii_integer(Parrot_Interp_interpreter,_IMAGE_IO_*io,_INTVAL_v)"
><b><code lang='und' xml:lang='und'>static void push_ascii_integer(Parrot_Interp interpreter, IMAGE_IO *io, INTVAL v)</b></code></a></dt><p class="pad"></p>

<dd>Pushes an ASCII version of the integer <code lang='und' xml:lang='und'>v</code> onto the end of the <code lang='und' xml:lang='und'>*io</code> &#34;stream&#34;.</dd><p class="pad"></p>

<dt><a name="static_void_push_ascii_number(Parrot_Interp_interpreter,_IMAGE_IO_*io,_FLOATVAL_v)"
><b><code lang='und' xml:lang='und'>static void push_ascii_number(Parrot_Interp interpreter, IMAGE_IO *io, FLOATVAL v)</b></code></a></dt><p class="pad"></p>

<dd>Pushes an ASCII version of the number <code lang='und' xml:lang='und'>v</code> onto the end of the <code lang='und' xml:lang='und'>*io</code> &#34;stream&#34;.</dd><p class="pad"></p>

<dt><a name="static_void_push_ascii_string(Parrot_Interp_interpreter,_IMAGE_IO_*io,_STRING_*s)"
><b><code lang='und' xml:lang='und'>static void push_ascii_string(Parrot_Interp interpreter, IMAGE_IO *io, STRING *s)</b></code></a></dt><p class="pad"></p>

<dd>Pushes an ASCII version of the string <code lang='und' xml:lang='und'>*s</code> onto the end of the <code lang='und' xml:lang='und'>*io</code> &#34;stream&#34;.</dd><p class="pad"></p>

<dd>For testing only &#45; no encodings and such.</dd><p class="pad"></p>

<dd>XXX no string delimiters &#45; so no space allowed.</dd><p class="pad"></p>

<dt><a name="static_void_push_ascii_pmc(Parrot_Interp_interpreter,_IMAGE_IO_*io,_PMC*_v)"
><b><code lang='und' xml:lang='und'>static void push_ascii_pmc(Parrot_Interp interpreter, IMAGE_IO *io, PMC *v)</b></code></a></dt><p class="pad"></p>

<dd>Pushes an ASCII version of the PMC <code lang='und' xml:lang='und'>*v</code> onto the end of the <code lang='und' xml:lang='und'>*io</code> &#34;stream&#34;.</dd><p class="pad"></p>

<dt><a name="static_INTVAL_shift_ascii_integer(Parrot_Interp_interpreter,_IMAGE_IO_*io)"
><b><code lang='und' xml:lang='und'>static INTVAL shift_ascii_integer(Parrot_Interp interpreter, IMAGE_IO *io)</b></code></a></dt><p class="pad"></p>

<dd>Removes and returns an integer from the start of the <code lang='und' xml:lang='und'>*io</code> &#34;stream&#34;.</dd><p class="pad"></p>

<dt><a name="static_FLOATVAL_shift_ascii_number(Parrot_Interp_interpreter,_IMAGE_IO_*io)"
><b><code lang='und' xml:lang='und'>static FLOATVAL shift_ascii_number(Parrot_Interp interpreter, IMAGE_IO *io)</b></code></a></dt><p class="pad"></p>

<dd>Removes and returns an number from the start of the <code lang='und' xml:lang='und'>*io</code> &#34;stream&#34;.</dd><p class="pad"></p>

<dt><a name="static_STRING*_shift_ascii_string(Parrot_Interp_interpreter,_IMAGE_IO_*io)"
><b><code lang='und' xml:lang='und'>static STRING *shift_ascii_string(Parrot_Interp interpreter, IMAGE_IO *io)</b></code></a></dt><p class="pad"></p>

<dd>Removes and returns an string from the start of the <code lang='und' xml:lang='und'>*io</code> &#34;stream&#34;.</dd><p class="pad"></p>

<dt><a name="static_PMC*_shift_ascii_pmc(Parrot_Interp_interpreter,_IMAGE_IO_*io)"
><b><code lang='und' xml:lang='und'>static PMC *shift_ascii_pmc(Parrot_Interp interpreter, IMAGE_IO *io)</b></code></a></dt><p class="pad"></p>

<dd>Removes and returns a PMC from the start of the <code lang='und' xml:lang='und'>*io</code> &#34;stream&#34;.</dd><p class="pad"></p>
</dl>

<h2><a name="opcode_t_IO_Functions"
><code lang='und' xml:lang='und'>opcode_t</code> IO Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="static_PARROT_INLINE_void_op_check_size(Parrot_Interp_interpreter,_STRING_*s,_size_t_len)"
><b><code lang='und' xml:lang='und'>static PARROT_INLINE void op_check_size(Parrot_Interp interpreter, STRING *s, size_t len)</b></code></a></dt><p class="pad"></p>

<dd>Checks the size of the &#34;stream&#34; buffer to see if it can accommodate <code lang='und' xml:lang='und'>len</code> more bytes.
If not then the buffer is expanded.</dd><p class="pad"></p>

<dt><a name="static_void_op_append(Parrot_Interp_interpreter,_STRING_*s,_opcode_t_b,_size_t_len)"
><b><code lang='und' xml:lang='und'>static void op_append(Parrot_Interp interpreter, STRING *s, opcode_t b, size_t len)</b></code></a></dt><p class="pad"></p>

<dd>Appends the opcode <code lang='und' xml:lang='und'>b</code> to the string <code lang='und' xml:lang='und'>*s</code>.</dd><p class="pad"></p>

<dt><a name="static_void_push_opcode_integer(Parrot_Interp_interpreter,_IMAGE_IO_*io,_INTVAL_v)"
><b><code lang='und' xml:lang='und'>static void push_opcode_integer(Parrot_Interp interpreter, IMAGE_IO *io, INTVAL v)</b></code></a></dt><p class="pad"></p>

<dd>Pushes the integer <code lang='und' xml:lang='und'>v</code> onto the end of the <code lang='und' xml:lang='und'>*io</code> &#34;stream&#34;.</dd><p class="pad"></p>

<dd>XXX assumes sizeof(opcode_t) == sizeof(INTVAL).</dd><p class="pad"></p>

<dt><a name="static_void_push_opcode_number(Parrot_Interp_interpreter,_IMAGE_IO_*io,_FLOATVAL_v)"
><b><code lang='und' xml:lang='und'>static void push_opcode_number(Parrot_Interp interpreter, IMAGE_IO *io, FLOATVAL v)</b></code></a></dt><p class="pad"></p>

<dd>Pushes the number <code lang='und' xml:lang='und'>v</code> onto the end of the <code lang='und' xml:lang='und'>*io</code> &#34;stream&#34;.</dd><p class="pad"></p>

<dt><a name="static_void_push_opcode_string(Parrot_Interp_interpreter,_IMAGE_IO_*io,_STRING*_v)"
><b><code lang='und' xml:lang='und'>static void push_opcode_string(Parrot_Interp interpreter, IMAGE_IO *io, STRING *v)</b></code></a></dt><p class="pad"></p>

<dd>Pushes the string <code lang='und' xml:lang='und'>*v</code> onto the end of the <code lang='und' xml:lang='und'>*io</code> &#34;stream&#34;.</dd><p class="pad"></p>

<dt><a name="static_void_push_opcode_pmc(Parrot_Interp_interpreter,_IMAGE_IO_*io,_PMC*_v)"
><b><code lang='und' xml:lang='und'>static void push_opcode_pmc(Parrot_Interp interpreter, IMAGE_IO *io, PMC *v)</b></code></a></dt><p class="pad"></p>

<dd>Pushes the PMC <code lang='und' xml:lang='und'>*v</code> onto the end of the <code lang='und' xml:lang='und'>*io</code> &#34;stream&#34;.</dd><p class="pad"></p>

<dt><a name="static_INTVAL_shift_opcode_integer(Parrot_Interp_interpreter,_IMAGE_IO_*io)"
><b><code lang='und' xml:lang='und'>static INTVAL shift_opcode_integer(Parrot_Interp interpreter, IMAGE_IO *io)</b></code></a></dt><p class="pad"></p>

<dd>Removes and returns an integer from the start of the <code lang='und' xml:lang='und'>*io</code> &#34;stream&#34;.</dd><p class="pad"></p>

<dd>TODO &#45; The shift functions aren&#39;t portable yet.
We need to have a packfile header for wordsize and endianess.</dd><p class="pad"></p>

<dt><a name="static_PMC*_shift_opcode_pmc(Parrot_Interp_interpreter,_IMAGE_IO_*io)"
><b><code lang='und' xml:lang='und'>static PMC *shift_opcode_pmc(Parrot_Interp interpreter, IMAGE_IO *io)</b></code></a></dt><p class="pad"></p>

<dd>Removes and returns an PMC from the start of the <code lang='und' xml:lang='und'>*io</code> &#34;stream&#34;.</dd><p class="pad"></p>

<dd>Note that this actually reads a PMC id,
not a PMC.</dd><p class="pad"></p>

<dt><a name="tatic_FLOATVAL_shift_opcode_number(Parrot_Interp_interpreter,_IMAGE_IO_*io)"
><b><code lang='und' xml:lang='und'>tatic FLOATVAL shift_opcode_number(Parrot_Interp interpreter, IMAGE_IO *io)</b></code></a></dt><p class="pad"></p>

<dd>Removes and returns an number from the start of the <code lang='und' xml:lang='und'>*io</code> &#34;stream&#34;.</dd><p class="pad"></p>

<dt><a name="static_STRING*_shift_opcode_string(Parrot_Interp_interpreter,_IMAGE_IO_*io)"
><b><code lang='und' xml:lang='und'>static STRING *shift_opcode_string(Parrot_Interp interpreter, IMAGE_IO *io)</b></code></a></dt><p class="pad"></p>

<dd>Removes and returns a string from the start of the <code lang='und' xml:lang='und'>*io</code> &#34;stream&#34;.</dd><p class="pad"></p>
</dl>

<h2><a name="Helper_Functions"
>Helper Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="static_size_t_key_hash_int(Interp_*interp,_Hash_*hash,_void_*value)"
><b><code lang='und' xml:lang='und'>static size_t key_hash_int(Interp *interp, Hash *hash, void *value)</b></code></a></dt><p class="pad"></p>

<dt><a name="static_int_int_compare(Parrot_Interp_interp,_void_*a,_void_*b)"
><b><code lang='und' xml:lang='und'>static int int_compare(Parrot_Interp interp, void *a, void *b)</b></code></a></dt><p class="pad"></p>

<dd>Custom <code lang='und' xml:lang='und'>key_hash</code> and <code lang='und' xml:lang='und'>compare</code> functions.</dd><p class="pad"></p>

<dt><a name="static_void_pmc_add_ext(Parrot_Interp_interpreter,_PMC_*pmc)"
><b><code lang='und' xml:lang='und'>static void pmc_add_ext(Parrot_Interp interpreter, PMC *pmc)</b></code></a></dt><p class="pad"></p>

<dd>Adds a <code lang='und' xml:lang='und'>PMC_EXT</code> to <code lang='und' xml:lang='und'>*pmc</code>.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>static void cleanup_next_for_GC_pool(Parrot_Interp interpreter, struct Small_Object_Pool *pool)</b></code></a></dt><p class="pad"></p>

<dd>Sets all the <code lang='und' xml:lang='und'>next_for_GC</code> pointers to <code lang='und' xml:lang='und'>NULL</code>.</dd><p class="pad"></p>

<dt><a name="static_void_cleanup_next_for_GC(Parrot_Interp_interpreter)"
><b><code lang='und' xml:lang='und'>static void cleanup_next_for_GC(Parrot_Interp interpreter)</b></code></a></dt><p class="pad"></p>

<dd>Cleans up the <code lang='und' xml:lang='und'>next_for_GC</code> pointers.</dd><p class="pad"></p>

<dt><a name="static_void_ft_init(Parrot_Interp_interpreter,_visit_info_*info)"
><b><code lang='und' xml:lang='und'>static void ft_init(Parrot_Interp interpreter, visit_info *info)</b></code></a></dt><p class="pad"></p>

<dd>Initializes the freeze/thaw subsystem.</dd><p class="pad"></p>

<dt><a name="static_void_todo_list_init(Parrot_Interp_interpreter,_visit_info_*info)"
><b><code lang='und' xml:lang='und'>static void todo_list_init(Parrot_Interp interpreter, visit_info *info)</b></code></a></dt><p class="pad"></p>

<dd>Initializes the <code lang='und' xml:lang='und'>*info</code> lists.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_INLINE static void freeze_pmc(Parrot_Interp interpreter, PMC *pmc, visit_info *info, int seen, UINTVAL id)</b></code></a></dt><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_INLINE static int thaw_pmc(Parrot_Interp interpreter, visit_info *info, UINTVAL *id, INTVAL *type)</b></code></a></dt><p class="pad"></p>

<dd>Freeze and thaw a PMC (id).</dd><p class="pad"></p>

<dd>For example,
the ASCII representation of the <code lang='und' xml:lang='und'>PerlArray</code></dd><p class="pad"></p>

<dd>P0 = [P1=666,
P2=777,
P0]</dd><p class="pad"></p>

<dd>may look like this:</dd><p class="pad"></p>

<dd>0xdf4 30 3 0xdf8 33 666 0xdf2 777 0xdf5</dd><p class="pad"></p>

<dd>where 30 is <code lang='und' xml:lang='und'>class_enum_PerlArray</code>,
33 is <code lang='und' xml:lang='und'>class_enum_PerlInt</code>,
the type of the second <code lang='und' xml:lang='und'>PerlInt</code> is suppressed,
the repeated P0 has bit 0 set.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_INLINE static void do_action(Parrot_Interp interpreter, PMC *pmc, visit_info *info, int seen, UINTVAL id)</b></code></a></dt><p class="pad"></p>

<dd>Called from <code lang='und' xml:lang='und'>visit_next_for_GC()</code> and <code lang='und' xml:lang='und'>visit_todo_list()</code> to perform the action specified in <code lang='und' xml:lang='und'>info&#45;&#62;what</code>.</dd><p class="pad"></p>

<dd>Currently only <code lang='und' xml:lang='und'>VISIT_FREEZE_NORMAL</code> is implemented.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_INLINE static PMC *thaw_create_pmc(Parrot_Interp interpreter, PMC *pmc, visit_info *info, INTVAL type)</b></code></a></dt><p class="pad"></p>

<dd>Called from <code lang='und' xml:lang='und'>do_thaw()</code> to attach the vtable etc.
to <code lang='und' xml:lang='und'>*pmc</code>.</dd><p class="pad"></p>

<dt><a name="PARROT_INLINE_static_void_do_thaw(Parrot_Interp_interpreter,_PMC*_pmc,_visit_info_*info)"
><b><code lang='und' xml:lang='und'>PARROT_INLINE static void do_thaw(Parrot_Interp interpreter, PMC *pmc, visit_info *info)</b></code></a></dt><p class="pad"></p>

<dd>Called by <code lang='und' xml:lang='und'>visit_todo_list_thaw()</code> to thaw and return a PMC.</dd><p class="pad"></p>

<dd><code lang='und' xml:lang='und'>seen</code> is false if this is the first time the PMC has been encountered.</dd><p class="pad"></p>

<dt><a name="static_UINTVAL_id_from_pmc(Parrot_Interp_interpreter,_PMC*_pmc)"
><b><code lang='und' xml:lang='und'>static UINTVAL id_from_pmc(Parrot_Interp interpreter, PMC *pmc)</b></code></a></dt><p class="pad"></p>

<dd>Creates and returns a unique id (tag) for a PMC.
This is the object number in the PMCs arena(s) shifted left by 2.
Starts at <code lang='und' xml:lang='und'>1&#60;&#60;2</code>.
0 is a <code lang='und' xml:lang='und'>NULLPMC</code>.</dd><p class="pad"></p>

<dt><a name="static_void_add_pmc_next_for_GC(Parrot_Interp_interpreter,_PMC_*pmc,_visit_info_*info)"
><b><code lang='und' xml:lang='und'>static void add_pmc_next_for_GC(Parrot_Interp interpreter, PMC *pmc, visit_info *info)</b></code></a></dt><p class="pad"></p>

<dd>Remembers the PMC for later processing.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_INLINE static int next_for_GC_seen(Parrot_Interp interpreter, PMC *pmc, visit_info *info, UINTVAL *id)</b></code></a></dt><p class="pad"></p>

<dd>Remembers next child to visit via the <code lang='und' xml:lang='und'>next_for_GC pointer</code> generate a unique ID per PMC and freeze the ID (not the PMC address) so thaw the hash&#45;lookup can be replaced by an array lookup then which is a lot faster.</dd><p class="pad"></p>

<dt><a name="static_void_add_pmc_todo_list(Parrot_Interp_interpreter,_PMC_*pmc,_visit_info_*info)"
><b><code lang='und' xml:lang='und'>static void add_pmc_todo_list(Parrot_Interp interpreter, PMC *pmc, visit_info *info)</b></code></a></dt><p class="pad"></p>

<dd>Remembers the PMC to be processed later.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_INLINE static int todo_list_seen(Parrot_Interp interpreter, PMC *pmc, visit_info *info, UINTVAL *id)</b></code></a></dt><p class="pad"></p>

<dd>Returns true if the PMC was seen,
otherwise it put it on the todo list,
generates an ID (tag) for PMC,
offset by 4 as are addresses,
low bits are flags.</dd><p class="pad"></p>

<dt><a name="tatic_void_visit_next_for_GC(Parrot_Interp_interpreter,_PMC*_pmc,_visit_info*_info)"
><b><code lang='und' xml:lang='und'>tatic void visit_next_for_GC(Parrot_Interp interpreter, PMC *pmc, visit_info *info)</b></code></a></dt><p class="pad"></p>

<dd><code lang='und' xml:lang='und'>visit_child</code> callbacks:</dd><p class="pad"></p>

<dd>Checks if the PMC was seen,
generate an ID for it if not,
then do the appropriate action.</dd><p class="pad"></p>

<dt><a name="static_void_visit_todo_list(Parrot_Interp_interpreter,_PMC*_pmc,_visit_info*_info)"
><b><code lang='und' xml:lang='und'>static void visit_todo_list(Parrot_Interp interpreter, PMC *pmc, visit_info *info)</b></code></a></dt><p class="pad"></p>

<dd>Checks the seen PMC via the todo list.</dd><p class="pad"></p>

<dt><a name="static_void_visit_todo_list_thaw(Parrot_Interp_interpreter,_PMC*_old,_visit_info*_info)"
><b><code lang='und' xml:lang='und'>static void visit_todo_list_thaw(Parrot_Interp interpreter, PMC *old, visit_info *info)</b></code></a></dt><p class="pad"></p>

<dd>Callback for thaw &#45; action first.</dd><p class="pad"></p>

<dd>Todo&#45;list and seen handling is all in <code lang='und' xml:lang='und'>do_thaw()</code>.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>static void visit_loop_next_for_GC(Parrot_Interp interpreter, PMC *current, visit_info *info)</b></code></a></dt><p class="pad"></p>

<dd>Put first item on todo list,
then run as long as there are items to be done.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>static PMC *visit_loop_todo_list(Parrot_Interp interpreter, PMC *current, visit_info *info)</b></code></a></dt><p class="pad"></p>

<dd>The thaw loop.</dd><p class="pad"></p>

<dt><a name="static_void_create_image(Parrot_Interp_interpreter,_PMC_*pmc,_visit_info_*info)"
><b><code lang='und' xml:lang='und'>static void create_image(Parrot_Interp interpreter, PMC *pmc, visit_info *info)</b></code></a></dt><p class="pad"></p>

<dd>Allocate image to some estimated size.</dd><p class="pad"></p>

<dt><a name="static_PMC*_run_thaw(Parrot_Interp_interpreter,_STRING*_image,_visit_enum_type_what)"
><b><code lang='und' xml:lang='und'>static PMC *run_thaw(Parrot_Interp interpreter, STRING *image, visit_enum_type what)</b></code></a></dt><p class="pad"></p>

<dd>Performs thawing.
<code lang='und' xml:lang='und'>what</code> indicates what to be thawed.</dd><p class="pad"></p>

<dd>Thaw could use the <code lang='und' xml:lang='und'>next_for_GC</code> pointers as todo&#45;list too,
but this would need 2 runs through the arenas to clean the <code lang='und' xml:lang='und'>next_for_GC</code> pointers.</dd><p class="pad"></p>

<dd>For now it seems cheaper to use a list for remembering contained aggregates.
We could of course decide dynamically,
which strategy to use,
e.g.: given a big image,
the first thawed item is a small aggregate.
This implies,
it probably contains (or some big strings) more nested containers,
for which the <code lang='und' xml:lang='und'>next_for_GC</code> approach could be a win.</dd><p class="pad"></p>
</dl>

<h2><a name="Public_Interface"
>Public Interface <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="STRING*_Parrot_freeze_at_destruct(Parrot_Interp_interpreter,_PMC*_pmc)"
><b><code lang='und' xml:lang='und'>STRING *Parrot_freeze_at_destruct(Parrot_Interp interpreter, PMC *pmc)</b></code></a></dt><p class="pad"></p>

<dd>This function must not consume any resources (except the image itself).
It uses the <code lang='und' xml:lang='und'>next_for_GC</code> pointer,
so its not reentrant and must not be interrupted by a DOD run.</dd><p class="pad"></p>

<dt><a name="STRING*_Parrot_freeze(Parrot_Interp_interpreter,_PMC*_pmc)"
><b><code lang='und' xml:lang='und'>STRING *Parrot_freeze(Parrot_Interp interpreter, PMC *pmc)</b></code></a></dt><p class="pad"></p>

<dd>Freeze using either method.</dd><p class="pad"></p>

<dt><a name="PMC*_Parrot_thaw(Parrot_Interp_interpreter,_STRING*_image)"
><b><code lang='und' xml:lang='und'>PMC *Parrot_thaw(Parrot_Interp interpreter, STRING *image)</b></code></a></dt><p class="pad"></p>

<dd>Thaw a PMC,
called from the <code lang='und' xml:lang='und'>thaw</code> opcode.</dd><p class="pad"></p>

<dt><a name="PMC*_Parrot_thaw_constants(Parrot_Interp_interpreter,_STRING*_image)"
><b><code lang='und' xml:lang='und'>PMC *Parrot_thaw_constants(Parrot_Interp interpreter, STRING *image)</b></code></a></dt><p class="pad"></p>

<dd>Thaw the constants.
This is used by PackFile for unpacking PMC constants.</dd><p class="pad"></p>

<dt><a name="PMC*_Parrot_clone(Parrot_Interp_interpreter,_PMC*_pmc)"
><b><code lang='und' xml:lang='und'>PMC *Parrot_clone(Parrot_Interp interpreter, PMC *pmc)</b></code></a></dt><p class="pad"></p>

<dd>There are for sure shortcuts to clone faster,
e.g.
always thaw the image immediately or use a special callback.
But for now we just thaw a frozen PMC.</dd><p class="pad"></p>
</dl>

<h1><a name="TODO"
>TODO <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>The seen&#45;hash version for freezing might go away sometimes.</p>

<h1><a name="SEE_ALSO"
>SEE ALSO <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>Lot of discussion on p6i and <em lang='und' xml:lang='und'><a href="../docs/dev/pmc_freeze.pod.html">docs/dev/pmc_freeze.pod</a></em>.</p>

<h1><a name="HISTORY"
>HISTORY <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>Initial version by leo 2003.11.03 &#45; 2003.11.07.</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
