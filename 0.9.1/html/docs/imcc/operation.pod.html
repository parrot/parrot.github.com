<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>operation</title>
        <link rel="stylesheet" type="text/css"
            href="../../../resources/parrot.css"
            media="all">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    </head>
    <body>
        <div id="wrapper">
            <div id="header">

                <img border=0 src="../../../resources/parrot_logo.png" id="logo" alt="parrot">
            </div> <!-- "header" -->
            <div id="divider"></div>
            <div id="mainbody">
                <div id="breadcrumb">
                    <a href="../../../html/index.html">Contents</a> &raquo; <a href="../../../html/imcc.html">IMCC</a> &raquo; operation
                </div>

<h1><a name="NAME"
>NAME</a></h1>

<p>IMCC &#45; operation</p>

<h1><a name="VERSION"
>VERSION</a></h1>

<dl>
<dt><a name="0.1_initial"
>0.1 initial</a></dt>

<dt><a name="0.2_uninitialized_warning;_optimizations"
>0.2 uninitialized warning; optimizations</a></dt>

<dt><a name="0.3_merged_parsing.pod_into_this_file."
>0.3 merged parsing.pod into this file.</a></dt>
</dl>

<h1><a name="OVERVIEW"
>OVERVIEW</a></h1>

<p>This document describes the principles of IMCC operation.</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>The main features of imcc are:</p>

<dl>
<dt><a name="Source_file_parsing"
>Source file parsing</a></dt>

<dt><a name="Register_allocation"
>Register allocation</a></dt>

<dt><a name="Optimization"
>Optimization</a></dt>

<dt><a name="Code_generation"
>Code generation</a></dt>

<dt><a name="Running_the_code"
>Running the code</a></dt>
</dl>

<h1><a name="SOURCE_FILE_PARSING"
>SOURCE FILE PARSING</a></h1>

<h2><a name="Overview"
>Overview</a></h2>

<p>IMCC parses and generates code in terms of <i>compilation units</i>.
These are self&#45;contained blocks of code very similar to subroutines.</p>

<p>Code for a compilation unit is created as soon (or not earlier) as the end of the unit is reached.</p>

<p>{{ Is this true?
one sub calling another not&#45;yet compiled sub would not work in that case.
}}</p>

<h2><a name="Symbols,_constants_and_labels"
>Symbols,
constants and labels</a></h2>

<p><i>Compilation units</i> maintain their own symbol table containing local labels and variable symbols.
This symbol table,
<code>hash</code>,
is not visible to code in different units.</p>

<p>If you need global variables,
please use the <b>get_{hll,root}_global</b> opcodes.</p>

<p>Global labels and constants are kept in the global symbol table <code>ghash</code>.
This allows for global constant folding beyond the scope of individual subroutines.</p>

<p>This also means that you currently can&#39;t use the same global symbol (e.g.
subroutine name) in different namespaces.
The following creates invalid code:</p>

<pre>  .sub main
     ...
  .end

   .namespace [&#34;main&#34;]
  .sub main
     ...
  .end</pre>

<p>Local labels in different <i>compilation units</i> with the same name are allowed, though assembling the generated PASM doesn&#39;t work. However, running this code inside imcc is ok. This will probably change in the future so that local labels are mangled to be unique.</p>

<h1><a name="REGISTER_ALLOCATION"
>REGISTER ALLOCATION</a></h1>

<p>Register allocation is done per <i>compilation unit</i>.</p>

<p>IMCC <i>identifiers</i> and <i>temporary variables</i> e.g. $I0 are assigned a physical parrot register depending on the life range of these variables. If the life range of one variable doesn&#39;t overlap the range of another variable, they might get the same parrot register. For instance:</p>

<pre>   $I0 = 10
   $I1 = 20</pre>

<p>will translate to</p>

<pre>   set I0, 10
   set I0, 20</pre>

<p>provided that $I0 is not used after these lines. In this case, the assignment to $I0 is redundant and will be optimized away if IMCC is run with optimization level <b>&#45;O2</b>.</p>

<p><i>PASM registers</i> keep their register. During the usage of a <i>PASM register</i> this register will be not get assigned to. Therefore, they should be used only when absolutely necessary, and you should try to avoid using them within long pieces of code.</p>

<h2><a name="Basic_blocks"
>Basic blocks</a></h2>

<p>To determine the life range of variables, the code gets separated into pieces, called <b>basic block</b>s. A <b>basic block</b> starts at a label, which can get jumped to, and ends at a branch instruction.</p>

<h2><a name="Call_graph"
>Call graph</a></h2>

<p>All connections between the <b>basic block</b>s are calculated. This allows for:</p>

<h2><a name="Loop_detection"
>Loop detection</a></h2>

<p>where the range and depth of loops is calculated.</p>

<h2><a name="Life_analysis"
>Life analysis</a></h2>

<p>Whenever an operand is marked as an <b>OUT</b> argument, this operand starts with a new value. This means that at this point the life range of the symbol ends and a new life range is started, which allows the allocation of a different register to the same variable or the same register to a different variable.</p>

<p>Variables used as <b>IN</b> parameters must keep their parrot register over their usage range.</p>

<p>When <code>imcc</code> detects a register usage, where the first operation is using (reading) a register (and warnings are enabled), <code>imcc</code> emits an appropriate message.</p>

<p>Consider these two code snippets (block numbers are attached):</p>

<pre>  .sub main :main
 0      $I0 = 0     # initialized
 0      if $I0 goto l1
 1      $I1 = 1     # init in block 1
 1      goto l2
 2  l1:
 2      $I1 = 2     # init in block 2
 3  l2:
 3      print $I0
 3      print $I1   # all paths leading here do init
 3      print &#34;\n&#34;
 3      end
  .end</pre>

<p>and:</p>

<pre>  .sub main :main
 0      $I0 = 0     # initialized
 0      if $I0 goto l1  # branch to bb 1 or 2
 1      $I1 = 1     # init only in block 1
 2  l1:
 2      print $I0
 2      print $I1   # no init in code path from block 0
 2      print &#34;\n&#34;
 2      end
  .end</pre>

<p>The latter of these emits the warning:</p>

<pre>  warning:imcc:propagate_need: &#39;$I1&#39; might be used \
  uninitialized in _main:7</pre>

<h2><a name="Interference_graph"
>Interference graph</a></h2>

<p>Once the above information is calculated, the next step is to look at which variables interfere with which others. Non&#45;interfering variables can be given the same parrot register.</p>

<h2><a name="Register_allocation"
>Register allocation</a></h2>

<p><code>imcc</code> then starts allocating registers according to a variable&#39;s score. Variables deeply nested inside loops have the highest score and get a parrot register first. Variables with a long life range (i.e. with many interferences) get allocated last.</p>

<h1><a name="Optimization"
>Optimization</a></h1>

<p>Optimizations are only done when enabled with the <b>&#45;O</b> switch. Please consult <em>t/imcpasm/*.t</em> for examples. They occur between various stages and may be repeatedly done: e.g. after converting a conditional branch to an absolute one, unreachable code will be removed then, which might cause unused labels ...</p>

<h1><a name="OPTIMIZATIONS_WITH_&#45;O1"
>OPTIMIZATIONS WITH &#45;O1</a></h1>

<h2><a name="Constant_substitution"
>Constant substitution</a></h2>

<p>Constant arguments to many ops are evaluated. Conditional branches with constant conditions are converted to unconditional branches. Integer arguments to float operations are converted to float operands.</p>

<h2><a name="If&#45;branch_optimization"
>If&#45;branch optimization</a></h2>

<p>A sequence of code:</p>

<pre>    if cond, L1
    branch L2
 L1:
 ...
 L2:</pre>

<p>will be converted to</p>

<pre>    unless cond, L2
    ...
 L2:</pre>

<p>The same is done for other conditional branches <b>gt</b>, <b>ge</b>, <b>eq</b> and their reverse meanings.</p>

<h2><a name="Branches_to_branches"
>Branches to branches</a></h2>

<p>Unconditional branch sequences get optimized to jumps to the final label.</p>

<h2><a name="Unused_labels"
>Unused labels</a></h2>

<p>Unreferenced labels are deleted.</p>

<h2><a name="Dead_code_removal"
>Dead code removal</a></h2>

<p>Code not reachable after an unconditional branch instruction and basic blocks that are not entered from somewhere get removed.</p>

<h1><a name="OPTIMIZATIONS_WITH_&#45;O2"
>OPTIMIZATIONS WITH &#45;O2</a></h1>

<p>Note: These are currently experimental and might not do the Right Thing.</p>

<h2><a name="Used_LHS_once"
>Used LHS once</a></h2>

<p>For a sequence of code</p>

<pre>   $I0 = 10
   $I1 = 20</pre>

<p>where <b>$I0</b> is not used again, the first assignment will be tossed, resulting in code like:</p>

<pre>   set I0, 20</pre>

<h2><a name="Loop_optimization"
>Loop optimization</a></h2>

<p>Instructions which are invariant to a loop are pulled out of the loop and inserted in front of the loop entry.</p>

<h1><a name="Code_generation"
>Code generation</a></h1>

<p><code>imcc</code> either generates PASM or else directly generates a PBC file for running with parrot.</p>

<h1><a name="Running_code"
>Running code</a></h1>

<p>Additionally the generated code can be run immediately inside imcc. All parrot runtime options like <b>&#45;j</b> or <b>&#45;t</b> are available.</p>

<h1><a name="FILES"
>FILES</a></h1>

<p><em>imc.c</em>, <em>cfg.c</em>, <em>optimizer.c</em>, <em>pbc.c</em></p>

<h1><a name="AUTHOR"
>AUTHOR</a></h1>

<p>Leopold Toetsch &#60;lt@toetsch.at&#62;</p>
            </div> <!-- "mainbody" -->
            <div id="divider"></div>
            <div id="footer">
	        Copyright &copy; 2002-2009, Parrot Foundation.
            </div>
        </div> <!-- "wrapper" -->
    </body>
</html>
