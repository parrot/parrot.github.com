<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>Multimethod dispatch for binary opcode functions</title>
        <link rel="stylesheet" type="text/css"
            href="../../resources/parrot.css"
            media="all">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    </head>
    <body>
        <div id="wrapper">
            <div id="header">

                <img border=0 src="../../resources/parrot_logo.png" id="logo" alt="parrot">
            </div> <!-- "header" -->
            <div id="divider"></div>
            <div id="mainbody">
                <div id="breadcrumb">
                    <a href="../../html/index.html">Contents</a> &raquo; <a href="../../html/docs.html">Documentation</a> &raquo; Multimethod dispatch for binary opcode functions
                </div>

<h1><a name="NAME"
>NAME</a></h1>

<p>docs/mmd.pod &#45; Multimethod dispatch for binary opcode functions</p>

<h1><a name="CAVEATS"
>CAVEATS</a></h1>

<p>XXX &#45; Part or all of this document is outdated.
Especially the &#34;the MMD system doesn&#39;t handle inheritance&#34; bit.
Please refer to PDD03 at this moment while we rewrite or merge this document.
We apologize for the inconvenience.</p>

<h1><a name="SYNOPSIS"
>SYNOPSIS</a></h1>

<p>This system is set up to handle type&#45;based dispatching for binary (i.e.
two&#45;arg) functions.
This includes,
though isn&#39;t necessarily limited to,
binary operators such as addition or subtraction.</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>The MMD system is straightforward,
and currently must be explicitly invoked,
for example by a vtable function.
(We may reserve the right to use MMD in all circumstances,
but currently do not)</p>

<h2><a name="API"
>API</a></h2>

<p>For the purposes of the API,
each MMD&#45;able function is assigned a unique number which is used to find the correct function table.
This is the <code>func_num</code> parameter in the following functions.
While Parrot isn&#39;t restricted to a predefined set of functions,
it <i>does</i> set things up so that all the binary vtable functions have a MMD table preinstalled for them,
with default behavior.</p>

<dl>
<dt><a name="mmd_add_by_class(interp,_func_num,_left_class,_right_class,_funcptr)"
>mmd_add_by_class(interp,
func_num,
left_class,
right_class,
funcptr)</a></dt>
Adds a new MMD function <code>funcptr</code> to the <code>func_num</code> function table that will be invoked when the left parameter is of class <code>left_class</code> and the right parameter is of class <code>right_class</code>.
Both classes are <code>STRING *</code>s that hold the PMC class names for the left and right sides.
If either class isn&#39;t yet loaded,
Parrot will cache the information such that the function will be installed if at some point in the future both classes are available.Currently this is done by just assigning class numbers to the classes,
which the classes will pick up and use if they&#39;re later loaded,
but we may later put the functions into a deferred table that we scan when PMC classes are loaded.
Either way,
the function will be guaranteed to be installed when it&#39;s needed.The function table must exist,
but if it is too small,
it will automatically be expanded.
<dt><a name="mmd_register(interp,_func_num,_left_type,_right_type,_funcptr)"
>mmd_register(interp,
func_num,
left_type,
right_type,
funcptr)</a></dt>
Register a function <code>funcptr</code> for MMD function table <code>func_num</code> for classes <code>left_type</code> and <code>right_type</code>.
The left and right types are <code>INTVAL</code>s that represent the class ID numbers.The function table must exist,
but if it is too small,
it will automatically be expanded.Currently the MMD system doesn&#39;t handle inheritance and best match searching,
as it assumes that all PMC types have no parent type.
This can be considered a bug,
and will be resolved at some point in the future.
<dt><a name="mmd_dispatch_pmc(interp,_left,_right,_dest,_func_num)"
>mmd_dispatch_pmc(interp,
left,
right,
dest,
func_num)</a></dt>
Dispatch to a multimethod that &#34;returns&#34; a PMC.
<code>left</code>,
<code>right</code>,
and <code>dest</code> are all PMC pointers,
while <code>func_num</code> is the MMD table that should be used to do the dispatching.The MMD system will figure out which function should be called based on the types of <code>left</code> and <code>right</code> and call it,
passing in <code>left</code>,
<code>right</code>,
and <code>dest</code> like any other binary vtable function.This function has a void return type,
like all the &#34;take two PMCs,
return a PMC&#34; vtable functions do.
<dt><a name="STRING_*mmd_dispatch_string(interp,_left,_right,_func_num)"
>STRING *mmd_dispatch_string(interp,
left,
right,
func_num)</a></dt>
Dispatch to a multimethod that returns a string.
<code>left</code> and <code>right</code> are PMC pointers,
while <code>func_num</code> is the MMD table that should be used to do the dispatching.
The function is responsible for creating the returned string.
<dt><a name="INTVAL_mmd_dispatch_intval(interp,_left,_right,_func_num)"
>INTVAL mmd_dispatch_intval(interp,
left,
right,
func_num)</a></dt>
Like <code>mmd_dispatch_string</code>,
only it returns an INTVAL.
<dt><a name="FLOATVAL_mmd_dispatch_floatval(interp,_left,_right,_func_num)"
>FLOATVAL mmd_dispatch_floatval(interp,
left,
right,
func_num)</a></dt>
Like <code>mmd_dispatch_string</code>,
only it returns a FLOATVAL.
<dt><a name="mmd_add_function(interp,_func_num,_default_func)"
>mmd_add_function(interp,
func_num,
default_func)</a></dt>
Add a new function table to the list of functions the MMD system knows of.
<code>func_num</code> is the number of the new function,
while <code>default_func</code> is the function to be called when the system doesn&#39;t know which function it should call.
(Because,
for example,
there hasn&#39;t been a function installed that matches the left and right types for a call)</dl>

<h2><a name="Constants"
>Constants</a></h2>

<p>The following constants are defined to identify function tables:</p>

<dl>
<dt><a name="MMD_ADD"
>MMD_ADD</a></dt>
Addition
<dt><a name="MMD_SUBTRACT"
>MMD_SUBTRACT</a></dt>
Subtraction
<dt><a name="MMD_MULTIPLY"
>MMD_MULTIPLY</a></dt>
Multiplication
<dt><a name="MMD_DIVIDE"
>MMD_DIVIDE</a></dt>
Division
<dt><a name="MMD_MOD"
>MMD_MOD</a></dt>
Accurate modulus
<dt><a name="MMD_CMOD"
>MMD_CMOD</a></dt>
C&#45;style modulus
<dt><a name="MMD_BAND"
>MMD_BAND</a></dt>
Binary and
<dt><a name="MMD_BOR"
>MMD_BOR</a></dt>
Binary or
<dt><a name="MMD_BXOR"
>MMD_BXOR</a></dt>
Binary xor
<dt><a name="MMD_BSL"
>MMD_BSL</a></dt>
Bitshift left
<dt><a name="MMD_BSR"
>MMD_BSR</a></dt>
Bitshift right
<dt><a name="MMD_CONCAT"
>MMD_CONCAT</a></dt>
String concatenation
<dt><a name="MMD_LAND"
>MMD_LAND</a></dt>
Short&#45;circuiting logical and
<dt><a name="MMD_LOR"
>MMD_LOR</a></dt>
Short&#45;circuiting logical or
<dt><a name="MMD_LXOR"
>MMD_LXOR</a></dt>
Logical xor (not short&#45;circuiting)
<dt><a name="MMD_REPEAT"
>MMD_REPEAT</a></dt>
String repetition
<dt><a name="MMD_NUMEQ"
>MMD_NUMEQ</a></dt>
Numeric equality
<dt><a name="MMD_STREQ"
>MMD_STREQ</a></dt>
String equality
<dt><a name="MMD_NUMCMP"
>MMD_NUMCMP</a></dt>
Numeric comparison
<dt><a name="MMD_STRCMP"
>MMD_STRCMP</a></dt>
String comparison
<dt><a name="MMD_SOR"
>MMD_SOR</a></dt>
Bitwise or of the string value
<dt><a name="MMD_SAND"
>MMD_SAND</a></dt>
Bitwise and of the string value
<dt><a name="MMD_SXOR"
>MMD_SXOR</a></dt>
Bitwise xor of the string value</dl>

<h2><a name="Defaults"
>Defaults</a></h2>

<p>By default,
functions are installed for all the functions that have constants associated with them.
They are all functions suitable for calling with <code>mmd_dispatch_pmc</code>.</p>

<p>The math functions (add,
subtract,
multiply,
and divide) all work on the float values of the left and right sides.</p>

<p>The cmod function does a plan C&#45;style mod (the C <code>%</code> operator) on the integer value of the left and right sides.</p>

<p>The mod function does an fmod on the float values of the two sides.</p>

<p>The bitwise functions (and,
or,
xor,
left shift,
right shift) work on the integer values of the two sides.</p>

<p>The concat function concatenates the string values of the left and right sides.</p>

<p>The logical functions (and,
or,
xor) use the boolean values of the left and right sides to see whether they should set_pmc the destination to the left or right sides.
The <code>and</code> and <code>or</code> functions short&#45;circuit,
<code>xor</code> does not.</p>

<p>The repeat function gets the string value of the left side and the integer value of the right.</p>

<p>The numeric equal and numeric comparison functions work on the float values of both sides.</p>

<p>The string equal and comparison functions work on the string values of both sides.</p>

<p>The string bitwise ops (and,
or,
xor) take the string values of both sides and do bitwise operations on the resulting bitstring.</p>
            </div> <!-- "mainbody" -->
            <div id="divider"></div>
            <div id="footer">
	        Copyright &copy; 2002-2009, Parrot Foundation.
            </div>
        </div> <!-- "wrapper" -->
    </body>
</html>
