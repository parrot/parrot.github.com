<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>Towers of hanoi</title>
        <link rel="stylesheet" type="text/css"
            href="../../../resources/parrot.css"
            media="all">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    </head>
    <body>
        <div id="wrapper">
            <div id="header">

                <img border=0 src="../../../resources/parrot_logo.png" id="logo" alt="parrot">
            </div> <!-- "header" -->
            <div id="divider"></div>
            <div id="mainbody">
                <div id="breadcrumb">
                    <a href="../../../html/index.html">Contents</a> &raquo; <a href="../../../html/imcc.html">IMCC</a> &raquo; Towers of hanoi
                </div>

<h1><a name="NAME"
>NAME</a></h1>

<p>examples/pir/hanoi.pir &#45; Towers of hanoi</p>

<h1><a name="SYNOPSIS"
>SYNOPSIS</a></h1>

<p>You may pass in the height of the tower:</p>

<pre>    % ./parrot examples/pir/hanoi.pir 5</pre>

<p>The default is 3.</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>Towers of Hanoi (<a href="http://www.cut&#45;the&#45;knot.org/recurrence/hanoi.shtml">http://www.cut&#45;the&#45;knot.org/recurrence/hanoi.shtml</a>) is a combinatorial puzzle. The PIR shows manipulation of arrays of integers.</p>

<h1><a name="Data_Structure"
>Data Structure</a></h1>

<p><code>towers</code> is a <code>FixedPMCArray</code> PMC with three elements. Each element is a <code>ResizableIntegerArray</code> PMC which represents a tower (column) of Hanoi. Each integer element of the array represents a single disk, where the integer value is the size of the disk. The top of the tower is at the highest index; since a larger disk cannot be placed on top of a smaller one, it follows that the tower array must always be sorted in descending order. This lends itself naturally to use of the <code>push</code> and <code>pop</code> operations for moving disks.</p>

<p>So this situation (after the first move)</p>

<pre>           |        |
     ====  |        |
    ====== |        |   ==</pre>

<p>is represented as</p>

<pre>    [[3, 2], [], [1]]</pre>

<p>In pseudocode:</p>

<pre>    sub main() {
        size = argv[0] || 3
        int towers[] = [[size..1], [], []]
        move_stack(size, 0, 2, 1)

        sub move_stack(n_to_move, start, target, storage) {
            if (n_to_move == 1) {
                move_one(start, target)
            }
            else {
                # Move all but the largest disk to storage.
                move_stack(n_to_move&#45;1, start, storage, target)
                # Move the largest disk to the target.
                move_one(start, target)
                # Move all but the largest disk from storage to target.
                move_stack(n_to_move&#45;1, storage, target, start)
            }
        }

        sub move_one(start_col, dest_col) {
            # Do the move
            push(towers[dest_col], pop(towers[start_col]));

            # Print the results
            print(towers);
        }
    }</pre>

<h1><a name="TODO"
>TODO</a></h1>

<p>Replace $I6 etc. with mnemonic register names.</p>

<h1><a name="HISTORY"
>HISTORY</a></h1>

<pre> First version               Tony Payne            2002&#45;15&#45;05
 Converted to PIR            Bernhard Schmalhofer  2005&#45;10&#45;20
 Use PCC instead of bsr/ret  Bob Rogers            2008&#45;04&#45;06</pre>
            </div> <!-- "mainbody" -->
            <div id="divider"></div>
            <div id="footer">
	        Copyright &copy; 2002-2009, Parrot Foundation.
            </div>
        </div> <!-- "wrapper" -->
    </body>
</html>
