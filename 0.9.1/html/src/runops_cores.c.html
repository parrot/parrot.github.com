<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>Untitled</title>
        <link rel="stylesheet" type="text/css"
            href="../../resources/parrot.css"
            media="all">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    </head>
    <body>
        <div id="wrapper">
            <div id="header">

                <img border=0 src="../../resources/parrot_logo.png" id="logo" alt="parrot">
            </div> <!-- "header" -->
            <div id="divider"></div>
            <div id="mainbody">
                <div id="breadcrumb">
                    <a href="../../html/index.html">Contents</a> &raquo; <a href="../../html/c.html">C</a> &raquo; Untitled
                </div>

<h1><a name="Run_Cores"
>Run Cores</a></h1>

<p>During execution,
the runcore is like the heart of Parrot.
The runcore controls calling the various opcodes with the correct data,
and making sure that program flow moves properly.
Some runcores,
such as the <i>precomputed C goto runcore</i> are optimized for speed and don&#39;t perform many tasks beyond finding and dispatching opcodes.
Other runcores,
such as the <i>GC&#45;Debug</i>,
<i>debug</i> and <i>profiling</i> runcores help with typical software maintenance and analysis tasks.
We&#39;ll talk about all of these throughout the chapter.</p>

<p>Runcores must pass execution to each opcode in the incoming bytecode stream.
This is called <i>dispatching</i> the opcodes.
Because the different runcores are structured in different ways,
the opcodes themselves must be formated differently.
The opcode compiler compiles opcodes into a number of separate formats,
depending on what runcores are included in the compiled Parrot.
Because of this,
understanding opcodes first requires an understanding of the Parrot runcores.</p>

<p>Parrot has multiple runcores.
Some are useful for particular maintenance tasks,
some are only available as optimizations in certain compilers,
some are intended for general use,
and some are just interesing flights of fancy with no practical benefits.
Here we list the various runcores,
their uses,
and their benefits.</p>

<h2><a name="Slow_Core"
>Slow Core</a></h2>

<p>The slow core is a basic runcore design that treats each opcode as a separate function at the C level.
Each function is called,
and returns the address of the next opcode to be called by the core.
The slow core performs bounds checking to ensure that the next opcode to be called is properly in bounds,
and not somewhere random in memory.
Because of this modular approach where opcodes are treated as separate executable entities many other runcores,
especially diagnostic and maintenance cores are based on this design.
The program counter <code>pc</code> is the current index into the bytecode stream.
Here is a pseudocode representation for how the slow core works:</p>

<pre>  while(1) {
      pc = NEXT_OPCODE;
      if(pc &#60; LOW_BOUND || pc &#62; HIGH_BOUND)
          throw exception;
      DISPATCH_OPCODE(pc);
      UPDATE_INTERPRETER();
  }</pre>

<h2><a name="Fast_Core"
>Fast Core</a></h2>

<p>The fast core is a bare&#45;bones core that doesn&#39;t do any of the bounds&#45;checking or context updating that the slow core does. The fast core is the way Parrot should run, and is used to find and debug places where execution strays outside of its normal bounds. In pseudocode, the fast core is very much like the slow core except it doesn&#39;t do the bounds checking between each instruction, and doesn&#39;t update the interpreter&#39;s current context for each dispatch.</p>

<pre>  while(1) {
      pc = NEXT_OPCODE;
      DISPATCH_OPCODE(pc);
  }</pre>

<h2><a name="Switch_Core"
>Switch Core</a></h2>

<p>As its name implies, the switch core uses a gigantic C <code>switch / case</code> structure to execute opcodes. Here&#39;s a brief example of how this architecture works:</p>

<pre>  for( ; ; current_opcode++) {
      switch(*current_opcode) {
          case opcode_1:
              ...
          case opcode_2:
              ...
          case opcode_3:
              ...
      }
  }</pre>

<p>This is quite a fast architecture for dispatching opcodes because it all happens within a single function. The only operations performed between opcodes is a jump back to the top of the loop, incrementing the opcode pointer, dereferencing the opcode pointer, and then a jump to the <code>case</code> statement for the next opcode.</p>

<h2><a name="Computed_Goto_Core"
>Computed Goto Core</a></h2>

<p><i>Computed Goto</i> is a feature of some C compilers where a label is treated as a piece of data that can be stored as a <code>void *</code> pointer. Each opcode becomes simply a label in a very large function, and pointers to the labels are stored in a large array. Calling an opcode is as easy as taking that opcode&#39;s number as the index of the label array, and calling the associated label. Sound complicated? It is a little, especially to C programmers who are not used to using labels, much less treating them as first class data items.</p>

<p>Notice that computed goto is a feature only available in some compilers such as GCC, and will not be available in every distribution of Parrot, depending what compilers were used to build it.</p>

<p>As was mentioned earlier, not all compilers support computed goto, which means that this core will not be built on platforms that don&#39;t support it. However, it&#39;s still an interesting topic to study so we will look at it briefly here. For compilers that support it, computed goto labels are <code>void **</code> values. In the computed goto core, all the labels represent different opcodes, so they are stored in an array:</p>

<pre>  void *my_labels[] = {
      &#38;&#38;label1,
      &#38;&#38;label2,
      &#38;&#38;label3
  };

  label1:
      ...
  label2:
      ...
  label3:
      ...</pre>

<p>Jumping to one of these labels is done with a command like this:</p>

<pre>  goto *my_labels[opcode_number];</pre>

<p>Actually, opcodes are pointed to by an <code>opcode_t *</code> pointer, and all opcodes are stored sequentially in memory, so the actual jump in the computed goto core must increment the pointer and then jump to the new version. In C it looks something like this:</p>

<pre>  goto *my_labels[*(current_opcode += 1)];</pre>

<p>Each opcode is an index into the array of labels, and at the end of each opcode an instruction like this is performed to move to the next opcode in series, or else some kind of control flow occurs that moves it to a non&#45;sequential location:</p>

<pre>  goto *my_lables[*(current_opcode = destination)];</pre>

<p>These are simplifications on what really happens in this core, because the actual code has been optimized quite a bit from what has been presented here. However, as we shall see with the precomputed goto core, it isn&#39;t optimized as aggressively as is possible.</p>

<h2><a name="Precomputed_Goto_Core"
>Precomputed Goto Core</a></h2>

<p>The precomputed goto core is an amazingly fast optimized core that uses the same computed goto feature, but performs the array dereferencing before the core even starts. The compiled bytecode is fed into a preprocessor that converts the bytecode instruction numbers into lable pointer values. In the computed goto core, you have this operation to move to the next opcode:</p>

<pre>  goto *my_labels[*(current_opcode += 1)];</pre>

<p>This single line of code is deceptively complex. A number of machine code operations must be performed to complete this step: The value of <code>current_opcode</code> must be incremented to the next value, that value must be dereferenced to find the opcode value. In C, arrays are pointers, so <code>my_labels</code> gets dereferenced and an offset is taken from it to find the stored label reference. That label reference is then dereferenced, and the jump is performed.</p>

<p>That&#39;s a lot of steps to execute before we can jump to the next opcode. What if each opcode value was replaced with the value of the jump label beforehand? If <code>current_opcode</code> points to a label pointer directly, we don&#39;t need to perform an additional dereference on the array at all. We can replace that entire mess above with this line:</p>

<pre>  goto **(current_opcode += 1);</pre>

<p>That&#39;s far fewer machine instructions to execute before we can move to the next opcode, which means faster throughput. Remember that whatever dispatch mechanism is used will be called after every single opcode, and some large programs may have millions of opcodes! Every single machine instruction that can be cut out of the dispatch mechanism could increase the execution speed of Parrot in a significant and noticable way. The dispatch mechanism used by the various runcores is hardly the largest performance bottleneck in Parrot anyway, but we like to use faster cores to shave every little bit of speed out of the system.</p>

<p>The caveat of course is that the predereferenced computed goto core is only available with compilers that support computed goto, such as GCC. Parrot will not have access to this core if it is built with a different compiler.</p>

<h2><a name="Tracing_Core"
>Tracing Core</a></h2>

<h2><a name="Profiling_Core"
>Profiling Core</a></h2>

<p>The profiling core analyzes the performance of Parrot, and helps to determine where bottlenecks and trouble spots are in the programs that run on top of Parrot. When Parrot calls a PIR subroutine it sets up the environment, allocates storage for the passed parameters and the return values, passes the parameters, and calls a new runcore to execute it. To calculate the amount of time that each subroutine takes, we need to measure the amount of time spent in each runcore from the time the core begins to the time the core executes. The profiling core does exactly this, acting very similarly to a slow core but also measuring the amount of time it takes for the core to complete. The tracing core actually keeps track of a few additional values, including the number of GC cycles run while in the subroutine, the number of each opcode called and the number of calls to each subroutine made. All this information is helpfully printed to the STDERR output for later analysis.</p>

<h2><a name="GC_Debug_Core"
>GC Debug Core</a></h2>

<p>Parrot&#39;s garbage collector has been known as a weakness in the system for several years. In fact, the garbage collector and memory management subsystem was one of the last systems to be improved and rewritten before the release of version 1.0. It&#39;s not that garbage collection isn&#39;t important, but instead that it was so hard to do earlier in the project.</p>

<p>Early on when the GC was such a weakness, and later when the GC was under active development, it was useful to have an operational mode that would really exercise the GC and find bugs that otherwise could hide by sheer chance. The GC debug runcore was this tool. The core executes a complete collection iteration between every single opcode. The throughput performance is terrible, but that&#39;s not the point: it&#39;s almost guaranteed to find problems in the memory system if they exist.</p>

<h2><a name="Debug_Core"
>Debug Core</a></h2>

<p>The debug core works like a normal software debugger, such as GDB. The debug core executes each opcode, and then prompts the user to enter a command. These commands can be used to continue execution, step to the next opcode, or examine and manipulate data from the executing program.</p>

<h2><a name="Functions"
>Functions</a></h2>

<dl>
<dt><a name="opcode_t_*_runops_fast_core"
><b><code>opcode_t *runops_fast_core</b></code></a></dt>
Runs the Parrot operations starting at <code>pc</code> until there are no more operations. This performs no bounds checking, profiling, or tracing.
<dt><a name="opcode_t_*_runops_cgoto_core"
><b><code>opcode_t *runops_cgoto_core</b></code></a></dt>
Runs the Parrot operations starting at <code>pc</code> until there are no more operations, using the computed <code>goto</code> core, performing no bounds checking, profiling, or tracing.If computed <code>goto</code> is not available then Parrot exits with exit code 1.
<dt><a name="static_opcode_t_*_runops_trace_core"
><b><code>static opcode_t *runops_trace_core</b></code></a></dt>
Runs the Parrot operations starting at <code>pc</code> until there are no more operations, using the tracing interpreter.
<dt><a name="opcode_t_*_runops_slow_core"
><b><code>opcode_t *runops_slow_core</b></code></a></dt>
Runs the Parrot operations starting at <code>pc</code> until there are no more operations, with tracing and bounds checking enabled.
<dt><a name="opcode_t_*_runops_gc_debug_core"
><b><code>opcode_t *runops_gc_debug_core</b></code></a></dt>
Runs the Parrot operations starting at <code>pc</code> until there are no more operations, performing a full GC run before each op. This is very slow, but it&#39;s also a very quick way to find GC problems.
<dt><a name="opcode_t_*_runops_profile_core"
><b><code>opcode_t *runops_profile_core</b></code></a></dt>
Runs the Parrot operations starting at <code>pc</code> until there are no more operations, with tracing, bounds checking, and profiling enabled.
<dt><a name="opcode_t_*_runops_debugger_core"
><b><code>opcode_t *runops_debugger_core</b></code></a></dt>
Used by the debugger, under construction</dl>

<p>*/</p>

<p>/* * Local variables: * c&#45;file&#45;style: &#34;parrot&#34; * End: * vim: expandtab shiftwidth=4: */</p>

<h1><a name="POD_ERRORS"
>POD ERRORS</a></h1>

<p>Hey! <b>The above document had some coding errors, which are explained below:</b></p>

<dl>
<dt><a name="Around_line_174:"
>Around line 174:</a></dt>
Deleting unknown formatting code N&#60;&#62;</dl>
            </div> <!-- "mainbody" -->
            <div id="divider"></div>
            <div id="footer">
	        Copyright &copy; 2002-2009, Parrot Foundation.
            </div>
        </div> <!-- "wrapper" -->
    </body>
</html>
