<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>Exceptions</title>
        <link rel="stylesheet" type="text/css"
            href="../../resources/parrot.css"
            media="all">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    </head>
    <body>
        <div id="wrapper">
            <div id="header">

                <img border=0 src="../../resources/parrot_logo.png" id="logo" alt="parrot">
            </div> <!-- "header" -->
            <div id="divider"></div>
            <div id="mainbody">
                <div id="breadcrumb">
                    <a href="../../html/index.html">Contents</a> &raquo; <a href="../../html/c.html">C</a> &raquo; Exceptions
                </div>

<h1><a name="NAME"
>NAME</a></h1>

<p>src/exceptions.c &#45; Exceptions</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>Define the the core subsystem for exceptions.</p>

<h2><a name="Exception_Functions"
>Exception Functions</a></h2>

<dl>
<dt><a name="PMC_*_Parrot_ex_build_exception"
><b><code>PMC *Parrot_ex_build_exception</b></code></a></dt>
Constructs a new exception object from the passed in arguments.
<dt><a name="void_die_from_exception"
><b><code>void die_from_exception</b></code></a></dt>
Print a stack trace for <code>exception</code>,
a message if there is one,
and then exit.
<dt><a name="void_Parrot_ex_add_c_handler"
><b><code>void Parrot_ex_add_c_handler</b></code></a></dt>
Adds a new exception handler (defined in C) to the concurrency scheduler.
Since the exception handler is C code,
it stores a runloop jump point to the start of the handler code.
<dt><a name="opcode_t_*_Parrot_ex_throw_from_op"
><b><code>opcode_t *Parrot_ex_throw_from_op</b></code></a></dt>
Runs the exception handler.
<dt><a name="void_Parrot_ex_throw_from_c"
><b><code>void Parrot_ex_throw_from_c</b></code></a></dt>
Throws an exception object.See also <code>exit_fatal()</code>,
which signals fatal errors,
and <code>Parrot_ex_throw_from_op</code>.The &#39;invoke&#39; vtable function doesn&#39;t actually execute a sub/continuation/handler,
it only sets up the environment for invocation and returns the address of the start of the sub&#39;s code.
That address then becomes the next op in the runloop.Exceptions thrown from C and caught by a continuation&#45;based handler are resumable at the level of a C instruction.
When handled,
they return the exception object.
Any values returned from the handler to the C code that threw the exception can be stored in the exception&#39;s payload.
<dt><a name="opcode_t_*_Parrot_ex_throw_from_op_args"
><b><code>opcode_t *Parrot_ex_throw_from_op_args</b></code></a></dt>
Throws an exception from an opcode,
with an error message constructed from a format string and arguments.See also <code>Parrot_ex_throw_from_c</code>,
<code>Parrot_ex_throw_from_op</code>,
and <code>exit_fatal()</code>.
<dt><a name="void_Parrot_ex_throw_from_c_args"
><b><code>void Parrot_ex_throw_from_c_args</b></code></a></dt>
Throws an exception,
with an error message constructed from a format string and arguments.
<code>ret_addr</code> is the address from which to resume,
if some handler decides that is appropriate,
or zero to make the error non&#45;resumable.
<code>exitcode</code> is a <code>exception_type_enum</code> value.See also <code>Parrot_ex_throw_from_c</code>,
<code>Parrot_ex_throw_from_op</code>,
and <code>exit_fatal()</code>.
<dt><a name="opcode_t_*_Parrot_ex_rethrow_from_op"
><b><code>opcode_t *Parrot_ex_rethrow_from_op</b></code></a></dt>
Rethrow the exception.
<dt><a name="void_Parrot_ex_rethrow_from_c"
><b><code>void Parrot_ex_rethrow_from_c</b></code></a></dt>
Return back to runloop,
assumes exception is still in todo (see RT #45915) and that this is called from within a handler setup with <code>new_c_exception</code>.
<dt><a name="void_Parrot_ex_mark_unhandled"
><b><code>void Parrot_ex_mark_unhandled</b></code></a></dt>
Mark an exception as unhandled,
as part of rethrowing it.
<dt><a name="size_t_Parrot_ex_calc_handler_offset"
><b><code>size_t Parrot_ex_calc_handler_offset</b></code></a></dt>
Retrieve an exception from the concurrency scheduler,
prepare a call to the handler,
and return the offset to the handler so it can become the next op in the runloop.</dl>

<h2><a name="Error_Functions"
>Error Functions</a></h2>

<dl>
<dt><a name="void_Parrot_assert"
><b><code>void Parrot_assert</b></code></a></dt>
A better version of assert() that gives a backtrace.
<dt><a name="void_Parrot_confess"
><b><code>void Parrot_confess</b></code></a></dt>
Prints a backtrace and message for a failed assertion.
<dt><a name="void_Parrot_print_backtrace"
><b><code>void Parrot_print_backtrace</b></code></a></dt>
Displays the primrose path to disaster,
(the stack frames leading up to the abort).
Used by <code>Parrot_confess</code>.
<dt><a name="void_exit_fatal"
><b><code>void exit_fatal</b></code></a></dt>
Signal a fatal error condition.
This should only be used with dire errors that cannot throw an exception (because no interpreter is available,
or the nature of the error would interfere with the exception system).This involves printing an error message to stderr,
and calling <code>exit</code> to exit the process with the given exitcode.
It is not possible for Parrot bytecode to intercept a fatal error (for that,
use <code>Parrot_ex_throw_from_c_args</code>).
<code>exit_fatal</code> does not call <code>Parrot_exit</code> to invoke exit handlers (that would require an interpreter).
<dt><a name="void_do_panic"
><b><code>void do_panic</b></code></a></dt>
Panic handler.</dl>

<h1><a name="SEE_ALSO"
>SEE ALSO</a></h1>

<p><em>include/parrot/exceptions.h</em>.</p>
            </div> <!-- "mainbody" -->
            <div id="divider"></div>
            <div id="footer">
	        Copyright &copy; 2002-2009, Parrot Foundation.
            </div>
        </div> <!-- "wrapper" -->
    </body>
</html>
