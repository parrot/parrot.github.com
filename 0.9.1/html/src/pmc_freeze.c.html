<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>Freeze and thaw functionality</title>
        <link rel="stylesheet" type="text/css"
            href="../../resources/parrot.css"
            media="all">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    </head>
    <body>
        <div id="wrapper">
            <div id="header">

                <img border=0 src="../../resources/parrot_logo.png" id="logo" alt="parrot">
            </div> <!-- "header" -->
            <div id="divider"></div>
            <div id="mainbody">
                <div id="breadcrumb">
                    <a href="../../html/index.html">Contents</a> &raquo; <a href="../../html/c.html">C</a> &raquo; Freeze and thaw functionality
                </div>

<h1><a name="NAME"
>NAME</a></h1>

<p>src/pmc_freeze.c &#45; Freeze and thaw functionality</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>Freeze uses the <code>next_for_GC pointer()</code> to remember seen PMCs.
PMCs are written as IDs (or tags),
which are calculated from their arena address.
This PMC number is multiplied by four.
The 2 low bits indicate a seen PMC or a PMC of the same type as the previous one respectively.</p>

<p>Thawing PMCs uses a list with (maximum) size of the amount of PMCs to keep track of retrieved PMCs.</p>

<p>The individual information of PMCs is frozen/thawed by their vtables.</p>

<p>To avoid recursion,
the whole functionality is driven by <code>pmc&#45;&#62;vtable&#45;&#62;visit</code>,
which is called for the first PMC initially.
Container PMCs call a &#34;todo&#45;callback&#34; for all contained PMCs.
The individual action vtable (freeze/thaw) is then called for all todo&#45;PMCs.</p>

<p>In the current implementation <code>IMAGE_IO</code> is a stand&#45;in for some kind of serializer PMC which will eventually be written.
It associates a Parrot <code>STRING</code> with a vtable.</p>

<h2><a name="Image_Stream_Functions"
>Image Stream Functions</a></h2>

<dl>
<dt><a name="static_void_str_append"
><b><code>static void str_append</b></code></a></dt>
Appends <code>len</code> bytes from buffer <code>*b</code> to string <code>*s</code>.Plain ascii &#45; for testing only:For speed reasons we mess around with the string buffers directly.No encoding of strings,
no transcoding.
<dt><a name="static_void_push_ascii_integer"
><b><code>static void push_ascii_integer</b></code></a></dt>
Pushes an ASCII version of the integer <code>v</code> onto the end of the <code>*io</code> &#34;stream&#34;.
<dt><a name="static_void_push_ascii_number"
><b><code>static void push_ascii_number</b></code></a></dt>
Pushes an ASCII version of the number <code>v</code> onto the end of the <code>*io</code> &#34;stream&#34;.
<dt><a name="static_void_push_ascii_string"
><b><code>static void push_ascii_string</b></code></a></dt>
Pushes an ASCII version of the string <code>*s</code> onto the end of the <code>*io</code> &#34;stream&#34;.For testing only &#45; no encodings and such.XXX no string delimiters &#45; so no space allowed.
<dt><a name="static_void_push_ascii_pmc"
><b><code>static void push_ascii_pmc</b></code></a></dt>
Pushes an ASCII version of the PMC <code>*v</code> onto the end of the <code>*io</code> &#34;stream&#34;.
<dt><a name="static_INTVAL_shift_ascii_integer"
><b><code>static INTVAL shift_ascii_integer</b></code></a></dt>
Removes and returns an integer from the start of the <code>*io</code> &#34;stream&#34;.
<dt><a name="static_FLOATVAL_shift_ascii_number"
><b><code>static FLOATVAL shift_ascii_number</b></code></a></dt>
Removes and returns an number from the start of the <code>*io</code> &#34;stream&#34;.
<dt><a name="static_STRING*_shift_ascii_string"
><b><code>static STRING *shift_ascii_string</b></code></a></dt>
Removes and returns an string from the start of the <code>*io</code> &#34;stream&#34;.
<dt><a name="static_PMC*_shift_ascii_pmc"
><b><code>static PMC *shift_ascii_pmc</b></code></a></dt>
Removes and returns a PMC from the start of the <code>*io</code> &#34;stream&#34;.</dl>

<h2><a name="opcode_t_IO_Functions"
><code>opcode_t</code> IO Functions</a></h2>

<dl>
<dt><a name="static_void_op_check_size"
><b><code>static void op_check_size</b></code></a></dt>
Checks the size of the &#34;stream&#34; buffer to see if it can accommodate <code>len</code> more bytes.
If not then the buffer is expanded.
<dt><a name="static_void_op_append"
><b><code>static void op_append</b></code></a></dt>
Appends the opcode <code>b</code> to the string <code>*s</code>.
<dt><a name="static_void_push_opcode_integer"
><b><code>static void push_opcode_integer</b></code></a></dt>
Pushes the integer <code>v</code> onto the end of the <code>*io</code> &#34;stream&#34;.XXX assumes sizeof (opcode_t) == sizeof (INTVAL).
<dt><a name="static_void_push_opcode_number"
><b><code>static void push_opcode_number</b></code></a></dt>
Pushes the number <code>v</code> onto the end of the <code>*io</code> &#34;stream&#34;.
<dt><a name="static_void_push_opcode_string"
><b><code>static void push_opcode_string</b></code></a></dt>
Pushes the string <code>*v</code> onto the end of the <code>*io</code> &#34;stream&#34;.
<dt><a name="static_void_push_opcode_pmc"
><b><code>static void push_opcode_pmc</b></code></a></dt>
Pushes the PMC <code>*v</code> onto the end of the <code>*io</code> &#34;stream&#34;.
<dt><a name="static_INTVAL_shift_opcode_integer"
><b><code>static INTVAL shift_opcode_integer</b></code></a></dt>
Removes and returns an integer from the start of the <code>*io</code> &#34;stream&#34;.TODO &#45; The shift functions aren&#39;t portable yet.
We need to have a packfile header for wordsize and endianess.
<dt><a name="static_PMC*_shift_opcode_pmc"
><b><code>static PMC *shift_opcode_pmc</b></code></a></dt>
Removes and returns an PMC from the start of the <code>*io</code> &#34;stream&#34;.Note that this actually reads a PMC id,
not a PMC.
<dt><a name="static_FLOATVAL_shift_opcode_number"
><b><code>static FLOATVAL shift_opcode_number</b></code></a></dt>
Removes and returns an number from the start of the <code>*io</code> &#34;stream&#34;.
<dt><a name="static_STRING*_shift_opcode_string"
><b><code>static STRING *shift_opcode_string</b></code></a></dt>
Removes and returns a string from the start of the <code>*io</code> &#34;stream&#34;.</dl>

<h2><a name="Helper_Functions"
>Helper Functions</a></h2>

<dl>
<dt><a name="static_void_pmc_add_ext"
><b><code>static void pmc_add_ext</b></code></a></dt>
Adds a <code>PMC_EXT</code> to <code>*pmc</code>.
<dt><a name="static_void_cleanup_next_for_GC_pool"
><b><code>static void cleanup_next_for_GC_pool</b></code></a></dt>
Sets all the <code>next_for_GC</code> pointers to <code>NULL</code>.
<dt><a name="static_void_cleanup_next_for_GC"
><b><code>static void cleanup_next_for_GC</b></code></a></dt>
Cleans up the <code>next_for_GC</code> pointers.
<dt><a name="static_void_ft_init"
><b><code>static void ft_init</b></code></a></dt>
Initializes the freeze/thaw subsystem.
<dt><a name="static_void_todo_list_init"
><b><code>static void todo_list_init</b></code></a></dt>
Initializes the <code>*info</code> lists.
<dt><a name="static_void_freeze_pmc"
><b><code>static void freeze_pmc</b></code></a></dt>
Freeze PMC,
setting type,
seen,
and &#34;same&#45;as&#45;last&#34; indicators as appropriate.
<dt><a name="static_int_thaw_pmc"
><b><code>static int thaw_pmc</b></code></a></dt>
Freeze and thaw a PMC (id).For example,
the ASCII representation of the <code>Array</code>
<pre>    P0 = [P1=666, P2=777, P0]</pre>
may look like this:
<pre>    0xdf4 30 3 0xdf8 33 666 0xdf2 777 0xdf5</pre>
where 30 is <code>class_enum_Array</code>, 33 is <code>class_enum_Integer</code>, the type of the second <code>Integer</code> is suppressed, the repeated P0 has bit 0 set.
<dt><a name="static_void_do_action"
><b><code>static void do_action</b></code></a></dt>
Called from <code>visit_next_for_GC()</code> and <code>visit_todo_list()</code> to perform the action specified in <code>info&#45;&#62;what</code>.Currently only <code>VISIT_FREEZE_NORMAL</code> is implemented.
<dt><a name="static_PMC*_thaw_create_pmc"
><b><code>static PMC *thaw_create_pmc</b></code></a></dt>
Called from <code>do_thaw()</code> to attach the vtable etc. to <code>*pmc</code>.
<dt><a name="static_void_do_thaw"
><b><code>static void do_thaw</b></code></a></dt>
Called by <code>visit_todo_list_thaw()</code> to thaw and return a PMC.<code>seen</code> is false if this is the first time the PMC has been encountered.
<dt><a name="static_UINTVAL_id_from_pmc"
><b><code>static UINTVAL id_from_pmc</b></code></a></dt>
Find a PMC in an arena, and return an id (left&#45;shifted 2 bits), based on its position.If not found, throw an exception.
<dt><a name="static_void_add_pmc_next_for_GC"
><b><code>static void add_pmc_next_for_GC</b></code></a></dt>
Remembers the PMC for later processing.
<dt><a name="static_int_next_for_GC_seen"
><b><code>static int next_for_GC_seen</b></code></a></dt>
Remembers next child to visit via the <code>next_for_GC pointer</code> generate a unique ID per PMC and freeze the ID (not the PMC address) so thaw the hash&#45;lookup can be replaced by an array lookup then which is a lot faster.
<dt><a name="static_void_add_pmc_todo_list"
><b><code>static void add_pmc_todo_list</b></code></a></dt>
Remembers the PMC to be processed later.
<dt><a name="static_int_todo_list_seen"
><b><code>static int todo_list_seen</b></code></a></dt>
Returns true if the PMC was seen, otherwise it put it on the todo list, generates an ID (tag) for PMC, offset by 4 as are addresses, low bits are flags.
<dt><a name="static_void_visit_next_for_GC"
><b><code>static void visit_next_for_GC</b></code></a></dt>
<code>visit_child</code> callbacks:Checks if the PMC was seen, generate an ID for it if not, then do the appropriate action.
<dt><a name="static_void_visit_todo_list"
><b><code>static void visit_todo_list</b></code></a></dt>
Checks the seen PMC via the todo list.
<dt><a name="static_void_visit_todo_list_thaw"
><b><code>static void visit_todo_list_thaw</b></code></a></dt>
Callback for thaw &#45; action first.Todo&#45;list and seen handling is all in <code>do_thaw()</code>.
<dt><a name="static_void_visit_loop_next_for_GC"
><b><code>static void visit_loop_next_for_GC</b></code></a></dt>
Put first item on todo list, then run as long as there are items to be done.
<dt><a name="static_void_visit_loop_todo_list"
><b><code>static void visit_loop_todo_list</b></code></a></dt>
The thaw loop.
<dt><a name="static_void_create_image"
><b><code>static void create_image</b></code></a></dt>
Allocate image to some estimated size.
<dt><a name="static_PMC*_run_thaw"
><b><code>static PMC *run_thaw</b></code></a></dt>
Performs thawing. <code>what</code> indicates what to be thawed.Thaw could use the <code>next_for_GC</code> pointers as todo&#45;list too, but this would need 2 runs through the arenas to clean the <code>next_for_GC</code> pointers.For now it seems cheaper to use a list for remembering contained aggregates. We could of course decide dynamically, which strategy to use, e.g.: given a big image, the first thawed item is a small aggregate. This implies, it probably contains (or some big strings) more nested containers, for which the <code>next_for_GC</code> approach could be a win.</dl>

<h2><a name="Public_Interface"
>Public Interface</a></h2>

<dl>
<dt><a name="STRING*_Parrot_freeze_at_destruct"
><b><code>STRING *Parrot_freeze_at_destruct</b></code></a></dt>
This function must not consume any resources (except the image itself). It uses the <code>next_for_GC</code> pointer, so its not reentrant and must not be interrupted by a GC run.
<dt><a name="STRING*_Parrot_freeze"
><b><code>STRING *Parrot_freeze</b></code></a></dt>
Freeze using either method.
<dt><a name="PMC*_Parrot_thaw"
><b><code>PMC *Parrot_thaw</b></code></a></dt>
Thaw a PMC, called from the <code>thaw</code> opcode.
<dt><a name="PMC*_Parrot_thaw_constants"
><b><code>PMC *Parrot_thaw_constants</b></code></a></dt>
Thaw the constants. This is used by PackFile for unpacking PMC constants.
<dt><a name="PMC*_Parrot_clone"
><b><code>PMC *Parrot_clone</b></code></a></dt>
There are for sure shortcuts to clone faster, e.g. always thaw the image immediately or use a special callback. But for now we just thaw a frozen PMC.</dl>

<h1><a name="TODO"
>TODO</a></h1>

<p>The seen&#45;hash version for freezing might go away sometimes.</p>

<h1><a name="SEE_ALSO"
>SEE ALSO</a></h1>

<p>Lot of discussion on p6i and <em><a href="../docs/dev/pmc_freeze.pod.html">docs/dev/pmc_freeze.pod</a></em>.</p>

<h1><a name="HISTORY"
>HISTORY</a></h1>

<p>Initial version by leo 2003.11.03 &#45; 2003.11.07.</p>
            </div> <!-- "mainbody" -->
            <div id="divider"></div>
            <div id="footer">
	        Copyright &copy; 2002-2009, Parrot Foundation.
            </div>
        </div> <!-- "wrapper" -->
    </body>
</html>
