<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>Some utility functions</title>
        <link rel="stylesheet" type="text/css"
            href="../../resources/parrot.css"
            media="all">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    </head>
    <body>
        <div id="wrapper">
            <div id="header">

                <img border=0 src="../../resources/parrot_logo.png" id="logo" alt="parrot">
            </div> <!-- "header" -->
            <div id="divider"></div>
            <div id="mainbody">
                <div id="breadcrumb">
                    <a href="../../html/index.html">Contents</a> &raquo; <a href="../../html/c.html">C</a> &raquo; Some utility functions
                </div>

<h1><a name="NAME"
>NAME</a></h1>

<p>src/utils.c &#45; Some utility functions</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>Prototypes are in <em>src/misc.h</em>.</p>

<p>Opcode helper functions that don&#39;t really fit elsewhere.</p>

<h2><a name="Functions"
>Functions</a></h2>

<dl>
<dt><a name="INTVAL_intval_mod"
><b><code>INTVAL intval_mod</b></code></a></dt>
NOTE: This &#34;corrected mod&#34; algorithm is based on the C code on page 70 of [1].
Assuming correct behavior of the built&#45;in mod operator (%) with positive arguments,
this algorithm implements a mathematically convenient version of mod,
defined thus:
<pre>    x mod y = x &#45; y * floor(x / y)</pre>
For more information on this definition of mod, see section 3.4 of [2], pages 81&#45;85.References:[1] Donald E. Knuth, *MMIXware: A RISC Computer for the Third Millennium* Springer, 1999.[2] Ronald L. Graham, Donald E. Knuth and Oren Patashnik, *Concrete Mathematics*, Second Edition. Addison&#45;Wesley, 1994.
<dt><a name="FLOATVAL_floatval_mod"
><b><code>FLOATVAL floatval_mod</b></code></a></dt>
Returns <code>n2 mod n3</code>.Includes a workaround for buggy code generation in the <code>lcc</code> compiler.</dl>

<h2><a name="Random_Number_Generator"
>Random Number Generator</a></h2>

<p>Based on the <code>rand48()</code> family of functions.</p>

<dl>
<dt><a name="static_void_next_rand"
><b><code>static void next_rand</b></code></a></dt>
Returns the next random number in <code>X</code>.
<dt><a name="static_FLOATVAL__erand48"
><b><code>static FLOATVAL _erand48</b></code></a></dt>
Returns a <code>double</code> in the interval <code>[0.0, 1.0)</code>.
<dt><a name="static_FLOATVAL__drand48"
><b><code>static FLOATVAL _drand48</b></code></a></dt>
Returns a <code>double</code> in the interval <code>[0.0, 1.0)</code>.
<dt><a name="static_long__jrand48"
><b><code>static long _jrand48</b></code></a></dt>
Returns a <code>long</code> in the interval <code>[&#45;2^31, 2^31)</code>.
<dt><a name="static_long__nrand48"
><b><code>static long _nrand48</b></code></a></dt>
Returns a <code>long</code> in the interval <code>[0, 2^31)</code>.
<dt><a name="static_long__lrand48"
><b><code>static long _lrand48</b></code></a></dt>
Returns a <code>long</code> in the interval <code>[0, 2^31)</code>.
<dt><a name="static_long__mrand48"
><b><code>static long _mrand48</b></code></a></dt>
Returns a <code>long</code> in the interval <code>[&#45;2^31, 2^31)</code>.
<dt><a name="static_void__srand48"
><b><code>static void _srand48</b></code></a></dt>
Sets the high order 32 bits to the argument <code>seed</code>. The low order 16 bits are set to the arbitrary value 0x330e.
<dt><a name="FLOATVAL_Parrot_float_rand"
><b><code>FLOATVAL Parrot_float_rand</b></code></a></dt>
Returns a <code>FLOATVAL</code> in the interval <code>[0.0, 1.0)</code>.<code>how_random</code> is ignored.
<dt><a name="INTVAL_Parrot_uint_rand"
><b><code>INTVAL Parrot_uint_rand</b></code></a></dt>
Returns an <code>INTVAL</code> in the interval <code>[0, 2^31)</code>.<code>how_random</code> is ignored.
<dt><a name="INTVAL_Parrot_int_rand"
><b><code>INTVAL Parrot_int_rand</b></code></a></dt>
Returns an <code>INTVAL</code> in the interval <code>[&#45;2^31, 2^31)</code>.<code>how_random</code> is ignored.
<dt><a name="INTVAL_Parrot_range_rand"
><b><code>INTVAL Parrot_range_rand</b></code></a></dt>
Returns an <code>INTVAL</code> in the range <code>[from, to]</code>.<code>how_random</code> is ignored.
<dt><a name="void_Parrot_srand"
><b><code>void Parrot_srand</b></code></a></dt>
Seeds the random number generator with <code>seed</code>.
<dt><a name="PMC*_tm_to_array"
><b><code>PMC *tm_to_array</b></code></a></dt>
Helper to convert a <b>struct tm *</b> to an Array
<dt><a name="INTVAL_Parrot_byte_index"
><b><code>INTVAL Parrot_byte_index</b></code></a></dt>
Looks for the location of a substring within a longer string. Takes pointers to the strings and the offset within the string at which to start searching as arguments.Returns an offset value if it is found, or &#45;1 if no match.
<dt><a name="INTVAL_Parrot_byte_rindex"
><b><code>INTVAL Parrot_byte_rindex</b></code></a></dt>
Substring search (like Parrot_byte_index), but works backwards, from the rightmost end of the string.Returns offset value or &#45;1 (if no match).
<dt><a name="static_void_rec_climb_back_and_mark"
><b><code>static void rec_climb_back_and_mark</b></code></a></dt>
Recursive function, used by Parrot_register_move to climb back the graph of register moves operations.The node must have a predecessor: it is implicit because if a node has a node_index, it must have a predecessor because the node_index are the index of registers in dest_regs[] array, so by definition they have a corrsponding src_regs register.Then it emits the move operation with its predecessor, or its backup if already used/visited.Then continues the climbing if the predecessor was not modified, anf in that case marks it, and set node_index as its backup.
<pre>  node_index  ... the index of a destination (i.e. with a pred.) register
  c           ... the graph and all the needed params : the context</pre>

<dt><a name="static_void_process_cycle_without_exit"
><b><code>static void process_cycle_without_exit</b></code></a></dt>
Recursive function, used by Parrot_register_move to handle the case of cycles without exits, that are cycles of move ops between registers where each register has exactly one predecessor and one successorFor instance: 1&#45;&#45;&#62;2, 2&#45;&#45;&#62;3, 3&#45;&#45;&#62;1
<pre>  node_index  ... the index of a destination (i.e. with a pred.) register
  c           ... the graph and all the needed params : the context</pre>

<dt><a name="void_Parrot_register_move"
><b><code>void Parrot_register_move</b></code></a></dt>
Move <code>n_regs</code> from the given register list <code>src_regs</code> to <code>dest_regs</code>.
<pre>  n_regs    ... amount of registers to move
  dest_regs ... list of register numbers 0..255
  src_regs  ... list of register numbers 0..255
  temp_reg  ... a register number not in one of these lists
  mov       ... a register move function to be called to move one register
  mov_alt   ... a register move function to be called to move one register
                which triese fetching from an alternate src (or NULLfunc):

    (void)  (mov)(interp, dest, src, info);
    moved = (mov_alt)(interp, dest, src, info);</pre>
Some <code>dest_regs</code> might be the same as <code>src_regs</code>, which makes this a bit non&#45;trivial, because if the destination is already clobbered, using it later as source doesn&#34;t work. E.g.
<pre>  0 &#60;&#45; 1
  1 &#60;&#45; 0     # register 0 already clobbered</pre>
or
<pre>  2 &#60;&#45; 0
  0 &#60;&#45; 1
  3 &#60;&#45; 2      # register 2 already clobbered &#45; reorder moves</pre>
To handle such cases, we do:
<pre>  a) rearrange the order of moves (not possible in the first case)
     and/or if that failed:
  b) if an alternate move function is available, it may fetch the
     source from a different (non&#45;clobbered) location &#45; call it.
     if the function returns 0 also use c)
  c) if no alternate move function is available, use the temp reg</pre>
The amount of register moves should of course be minimal.TODO The current implementation will not work for following casesTalked to Leo and he said those cases are not likely (Vishal Soni). 1. I0&#45;&#62;I1 I1&#45;&#62;I0 I0&#45;&#62;I3 2. I1&#45;&#62;I2 I3&#45;&#62;I2TODO: Add tests for the above conditions.</dl>

<h1><a name="HISTORY"
>HISTORY</a></h1>

<p>Initial version by leo 2003.09.09.</p>
            </div> <!-- "mainbody" -->
            <div id="divider"></div>
            <div id="footer">
	        Copyright &copy; 2002-2009, Parrot Foundation.
            </div>
        </div> <!-- "wrapper" -->
    </body>
</html>
