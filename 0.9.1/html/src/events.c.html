<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>Event handling stuff</title>
        <link rel="stylesheet" type="text/css"
            href="../../resources/parrot.css"
            media="all">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    </head>
    <body>
        <div id="wrapper">
            <div id="header">

                <img border=0 src="../../resources/parrot_logo.png" id="logo" alt="parrot">
            </div> <!-- "header" -->
            <div id="divider"></div>
            <div id="mainbody">
                <div id="breadcrumb">
                    <a href="../../html/index.html">Contents</a> &raquo; <a href="../../html/c.html">C</a> &raquo; Event handling stuff
                </div>

<h1><a name="NAME"
>NAME</a></h1>

<p>src/events.c &#45; Event handling stuff</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>An event_thread handles async events for all interpreters.
When events are due,
they are placed in per interpreter task_queues,
where they are handled then by the <code>check_event*</code> opcodes.</p>

<p>IO events and signals are caught in the io_thread,
which again dispatches these to one or all interpreters.</p>

<h2><a name="Signal_Handling"
>Signal Handling</a></h2>

<dl>
<dt><a name="static_void_sig_handler"
><b><code>static void sig_handler</b></code></a></dt>
Handle signal <code>signum</code>.TODO &#45; Only <code>SIGHUP</code> is handled at the moment for testing
<dt><a name="static_void_Parrot_sigaction"
><b><code>static void Parrot_sigaction</b></code></a></dt>
Signal handlers are common to all threads,
signal block masks are specific,
so we install one handler then block that signal and unblock it in the thread,
that will receive that signal.
<dt><a name="static_void_Parrot_unblock_signal"
><b><code>static void Parrot_unblock_signal</b></code></a></dt>
unblock a signal
<dt><a name="void_Parrot_init_signals"
><b><code>void Parrot_init_signals</b></code></a></dt>
Set up actions to handle signals.
Only SIGHUP handled at the moment.</dl>

<h2><a name="Initialization"
>Initialization</a></h2>

<dl>
<dt><a name="static_void_init_events_first"
><b><code>static void init_events_first</b></code></a></dt>
Init event system for first interpreter.
<dt><a name="static_void_init_events_all"
><b><code>static void init_events_all</b></code></a></dt>
Init events for all interpreters.
<dt><a name="void_Parrot_init_events"
><b><code>void Parrot_init_events</b></code></a></dt>
Initialize the event system.</dl>

<h2><a name="Event_Handler_Functions"
>Event Handler Functions</a></h2>

<dl>
<dt><a name="void_Parrot_schedule_event"
><b><code>void Parrot_schedule_event</b></code></a></dt>
Create queue entry and insert event into task queue.
<dt><a name="static_void_schedule_signal_event"
><b><code>static void schedule_signal_event</b></code></a></dt>
create and schedule a signal event
<dt><a name="void_Parrot_new_timer_event"
><b><code>void Parrot_new_timer_event</b></code></a></dt>
Create a new timer event due at <code>diff</code> from now,
repeated at <code>interval</code> and running the passed <code>sub</code>.
<dt><a name="void_Parrot_new_cb_event"
><b><code>void Parrot_new_cb_event</b></code></a></dt>
Prepare and schedule a callback event.
<dt><a name="void_Parrot_del_timer_event"
><b><code>void Parrot_del_timer_event</b></code></a></dt>
Deactivate the timer identified by <code>timer</code>.
<dt><a name="void_Parrot_new_terminate_event"
><b><code>void Parrot_new_terminate_event</b></code></a></dt>
Create a terminate event,
interpreter will leave the run&#45;loop when this event arrives.
<dt><a name="void_Parrot_new_suspend_for_gc_event"
><b><code>void Parrot_new_suspend_for_gc_event</b></code></a></dt>
Create a suspend&#45;for&#45;GC event,
interpreter will wait on a condition variable for GC to finish when the event arrives.
<dt><a name="void_Parrot_kill_event_loop"
><b><code>void Parrot_kill_event_loop</b></code></a></dt>
Schedule event&#45;loop terminate event.
This shuts down the event thread.
<dt><a name="void_Parrot_schedule_interp_qentry"
><b><code>void Parrot_schedule_interp_qentry</b></code></a></dt>
Put a queue entry into the interpreters task queue and enable event checking for the interpreter.
<dt><a name="void_Parrot_schedule_broadcast_qentry"
><b><code>void Parrot_schedule_broadcast_qentry</b></code></a></dt>
Broadcast an event.</dl>

<h2><a name="IO_Thread_Handling"
>IO Thread Handling</a></h2>

<dl>
<dt><a name="static_void_store_io_event"
><b><code>static void store_io_event</b></code></a></dt>
Stores an event in the event stack.
Allocates memory if necessary.
<dt><a name="static_void_io_thread_ready_rd"
><b><code>static void io_thread_ready_rd</b></code></a></dt>
Takes a list of pending i/o events and a file descriptor.
If the fd is ready to read,
the event is removed from the &#34;pending&#34; list and moved to the &#34;scheduled&#34; task queue.
<dt><a name="static_void*_io_thread"
><b><code>static void *io_thread</b></code></a></dt>
The IO thread uses select/poll to handle IO events and signals.It waits on input from the message pipe to insert file descriptors in the wait sets.
<dt><a name="static_void_stop_io_thread"
><b><code>static void stop_io_thread</b></code></a></dt>
Tell the IO thread to stop.
<dt><a name="void_Parrot_event_add_io_event"
><b><code>void Parrot_event_add_io_event</b></code></a></dt>
Create new i/o event.</dl>

<h2><a name="Event_Handler_Thread_Functions"
>Event Handler Thread Functions</a></h2>

<dl>
<dt><a name="static_QUEUE_ENTRY*_dup_entry"
><b><code>static QUEUE_ENTRY *dup_entry</b></code></a></dt>
Duplicate queue entry.
<dt><a name="static_QUEUE_ENTRY*_dup_entry_interval"
><b><code>static QUEUE_ENTRY *dup_entry_interval</b></code></a></dt>
Duplicate timed entry and add interval to <code>abs_time</code>.
<dt><a name="static_int_process_events"
><b><code>static int process_events</b></code></a></dt>
Do something,
when an event arrived caller has locked the mutex returns 0 if event thread terminates.
<dt><a name="static_void*_event_thread"
><b><code>static void *event_thread</b></code></a></dt>
The event thread is started by the first interpreter.
It handles all events for all interpreters.</dl>

<h2><a name="Sleep_Handling"
>Sleep Handling</a></h2>

<dl>
<dt><a name="static_opcode_t_*_wait_for_wakeup"
><b><code>static opcode_t *wait_for_wakeup</b></code></a></dt>
Sleep on the event queue condition.
If an event arrives,
the event is processed.
Terminate the loop if sleeping is finished.
<dt><a name="opcode_t_*_Parrot_sleep_on_event"
><b><code>opcode_t *Parrot_sleep_on_event</b></code></a></dt>
Go to sleep.
This is called from the <code>sleep</code> opcode.</dl>

<h2><a name="Event_Handling_for_Run&#45;Loops"
>Event Handling for Run&#45;Loops</a></h2>

<dl>
<dt><a name="opcode_t_*_Parrot_do_check_events"
><b><code>opcode_t *Parrot_do_check_events</b></code></a></dt>
Explicitly <code>sync</code> called by the check_event opcode from run loops.
<dt><a name="static_void_event_to_exception"
><b><code>static void event_to_exception</b></code></a></dt>
Convert event to exception and throw it.
<dt><a name="static_opcode_t_*_do_event"
><b><code>static opcode_t *do_event</b></code></a></dt>
Run user code or such.
The <code>event</code> argument is freed after execution.TODO: Instrument with splint args so splint knows event gets released.
<dt><a name="opcode_t_*_Parrot_do_handle_events"
><b><code>opcode_t *Parrot_do_handle_events</b></code></a></dt>
Called by the <code>check_event__</code> opcode from run loops or from above.
When called from the <code>check_events__</code> opcode,
we have to restore the <code>op_func_table</code>.</dl>

<h1><a name="SEE_ALSO"
>SEE ALSO</a></h1>

<p><em>include/parrot/events.h</em> and <em><a href="../docs/dev/events.pod.html">docs/dev/events.pod</a></em>.</p>
            </div> <!-- "mainbody" -->
            <div id="divider"></div>
            <div id="footer">
	        Copyright &copy; 2002-2009, Parrot Foundation.
            </div>
        </div> <!-- "wrapper" -->
    </body>
</html>
