<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>The Grammar of languages/PIR</title>
        <link rel="stylesheet" type="text/css"
            href="../../../../resources/parrot.css"
            media="all">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    </head>
    <body>
        <div id="wrapper">
            <div id="header">

                <img border=0 src="../../../../resources/parrot_logo.png" id="logo" alt="parrot">
            </div> <!-- "header" -->
            <div id="divider"></div>
            <div id="mainbody">
                <div id="breadcrumb">
                    <a href="../../../../html/index.html">Contents</a> &raquo; <a href="../../../../html/languages.html">Language Implementations</a> &raquo; <a href="../../../../html/pir.html">PIR</a> &raquo; The Grammar of languages/PIR
                </div>

<h1><a name="NAME"
>NAME</a></h1>

<p>pirgrammar.pod &#45; The Grammar of languages/PIR</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>This document provides a more readable grammar of languages/PIR.
The actual specification for PIR is a bit more complex.
This grammar for humans does not contain error handling and other issues unimportant for this PIR reference.</p>

<h1><a name="STATUS"
>STATUS</a></h1>

<p>For a bugs and issues,
see the section KNOWN ISSUES AND BUGS.</p>

<p>The grammar includes some constructs that <b>are</b> in the IMCC parser,
but are not implemented.</p>

<p>Please note that languages/PIR is <b>not</b> the official definition of the PIR language.
The reference implementation of PIR is IMCC,
located in <code>parrot/compilers/imcc</code>.
However,
languages/PIR tries to be as close to IMCC as possible.
IMCC&#39;s grammar could use some cleaning up; languages/PIR might be a basis to start with a clean reimplementation of PIR in C (using Lex/Yacc).</p>

<h1><a name="VERSION"
>VERSION</a></h1>

<p>0.2.0</p>

<h1><a name="LEXICAL_CONVENTIONS"
>LEXICAL CONVENTIONS</a></h1>

<h2><a name="PIR_Directives"
>PIR Directives</a></h2>

<p>PIR has a number of directives.
All directives start with a dot.
Macro identifiers (when using a macro,
on expansion) also start with a dot (see below).
Therefore,
it is important not to use any of the PIR directives as a macro identifier.
The PIR directives are:</p>

<pre>  .arg            .invocant          .begin_call
  .const          .lex               .call
                  .line              .end_return
  .end            .loadlib           .end_yield
  .endnamespace   .local             .end
                  .meth_call         .pragma
  .get_results    .namespace         .return
  .globalconst    .nci_call          .result
  .HLL_map        .param             .sub
  .HLL            .begin_return      .yield
  .include        .begin_yield</pre>

<h2><a name="Registers"
>Registers</a></h2>

<p>PIR has two types of registers: real registers and symbolic or temporary (or <i>virtual</i> if you like) registers. Real registers are actual registers in the Parrot VM. The symbolic, or temporary registers are mapped to those actual registers. Real registers are written like:</p>

<pre>  [S|N|I|P]n, where n is a positive integer.</pre>

<p>whereas symbolic registers have a <b>$</b> prefix, like this: <code>$P10</code>.</p>

<p>Symbolic registers can be thought of local variable identifiers that don&#39;t need a declaration. This prevents you from writing <code>.local</code> directives if you&#39;re in a hurry. Of course, it would make the code more self&#45;documenting if <code>.local</code>s would be used.</p>

<h2><a name="Constants"
>Constants</a></h2>

<p>An integer constant is a string of one or more digits. Examples: <code>0</code>, <code>42</code>.</p>

<p>A floatin&#45;point constant is a string of one or more digits, followed by a dot and one or more digits. Examples: <code>1.1</code>, <code>42.567</code></p>

<p>A string constant is a single or double quoted series of characters. Examples: <code>&#39;hello world&#39;</code>, <code>&#34;Parrot&#34;</code>.</p>

<p>TODO: PMC constants.</p>

<h2><a name="Identifiers"
>Identifiers</a></h2>

<p>An identifier starts with a character from [_a&#45;zA&#45;Z], followed by zero or more characters from [_a&#45;zA&#45;Z0&#45;9].</p>

<p>Examples: <code>x</code>, <code>x1</code>, <code>_foo</code></p>

<h2><a name="Labels"
>Labels</a></h2>

<p>A label is an identifier with a colon attached to it.</p>

<p>Examples: <code>LABEL:</code></p>

<h2><a name="Macro_identifiers"
>Macro identifiers</a></h2>

<p>A macro identifier is an identifier prefixed with an dot. A macro identifier is used when <i>expanding</i> the macro (on usage), not in the macro definition.</p>

<p>Examples: <code>.myMacro</code></p>

<h1><a name="GRAMMAR_RULES"
>GRAMMAR RULES</a></h1>

<h2><a name="Compilation_Units"
>Compilation Units</a></h2>

<p>A PIR program consists of one or more compilation units. A compilation unit is a global, sub, constant or macro definition, or a pragma or emit block. PIR is a line oriented language, which means that each statement ends in a newline (indicated as &#34;nl&#34;). Moreover, compilation units are always separated by a newline. Each of the different compilation units are discussed in this document.</p>

<pre>  program:
    compilation_unit [ nl compilation_unit ]*

  compilation_unit:
      global_def
    | sub_def
    | const_def
    | expansion
    | pragma</pre>

<h2><a name="Subroutine_definitions"
>Subroutine definitions</a></h2>

<pre>  sub_def:
    &#34;.sub&#34; sub_id sub_pragmas* nl body

  sub_id:
    identifier | string_constant

  sub_pragma:
      &#34;:load&#34;
    | &#34;:init&#34;
    | &#34;:immediate&#34;
    | &#34;:postcomp&#34;
    | &#34;:main&#34;
    | &#34;:anon&#34;
    | &#34;:lex&#34;
    | vtable_pragma
    | multi_pragma
    | outer_pragma

  vtable_pragma:
    &#34;:vtable&#34; parenthesized_string?

  parenthesized_string:
    &#34;(&#34; string_constant &#34;)&#34;

  multi_pragma:
    &#34;:multi&#34; &#34;(&#34; multi_types? &#34;)&#34;

  outer_pragma:
    &#34;:outer&#34; &#34;(&#34; sub_id &#34;)&#34;

  multi_tyes:
    multi_type [ &#34;,&#34; multi_type ]*

  multi_type:
      type
    | &#34;_&#34;
    | keylist
    | identifier
    | string_constant

  body:
    param_decl*
    labeled_pir_instr*
    &#34;.end&#34;

  param_decl:
    &#34;.param&#34;  [ [ string_constant &#34;=&#62;&#34; ] type identifier ] [ get_flags | &#34;:unique_reg&#34; ]* nl

  get_flags:
    [ &#34;:slurpy&#34;
    | &#34;:optional&#34;
    | &#34;:opt_flag&#34;
    | named_flag
    ]+

  named_flag:
    &#34;:named&#34; parenthesized_string?</pre>

<h3><a name="Examples_subroutine"
>Examples subroutine</a></h3>

<p>The simplest example for a subroutine definition looks like:</p>

<pre>  .sub foo
  # PIR instructions go here
  .end</pre>

<p>The body of the subroutine can contain PIR instructions. The subroutine can be given one or more flags, indicating the sub should behave in a special way. Below is a list of these flags and their meaning. The flag <code>:unique_reg</code> is discussed in the section defining local declarations.</p>

<ul>
<li></li>

<pre> :load</pre>

<p>Run this subroutine during the <b>load_library</b> opcode. <b>:load</b> is ignored, if another subroutine in that file is marked with <b>:main</b>. If multiple subs have the <b>:load</b> pragma, the subs are run in source code order.</p>

<li></li>

<pre> :init</pre>

<p>Run the subroutine when the program is run directly (that is, not loaded as a module). This is different from <b>:load</b>, which runs a subroutine when a library is being loaded. To get both behaviours, use <b>:init :load</b>.</p>

<li></li>

<pre> :postcomp</pre>

<p>Same as <code>:immediate</code>, except that the sub is not executed when compilation was triggered by a <code>load_bytecode</code> instruction (in a different file).</p>

<li></li>

<pre> :immediate</pre>

<p>This subroutine is executed immediately after being compiled. (Analagous to <code>BEGIN</code> in perl5.)</p>

<li></li>

<pre> :main</pre>

<p>Indicates that the sub being defined is the entry point of the program. It can be compared to the main function in C.</p>

<li></li>

<pre> :method</pre>

<p>Indicates the sub being defined is an instance method. The method belongs to the class whose namespace is currently active. (so, to define a method for a class &#39;Foo&#39;, the &#39;Foo&#39; namespace should be currently active). In the method body, the object PMC can be referred to with <code>self</code>.</p>

<li></li>

<pre> :vtable or vtable(&#39;x&#39;)</pre>

<p>Indicates the sub being defined replaces a vtable entry. This flag can only be used when defining a method.</p>

<li></li>

<pre> :multi(type [, type]*)</pre>

<p>Engage in multiple dispatch with the listed types.</p>

<li></li>

<pre> :outer(&#39;bar&#39;)</pre>

<p>Indicates the sub being defined is lexically nested within the subroutine &#39;bar&#39;.</p>

<li></li>

<pre> :anon</pre>

<p>Do not install this subroutine in the namespace. Allows the subroutine name to be reused.</p>

<li></li>

<pre> :lex</pre>

<p>Indicates the sub being defined needs to store lexical variables. This flag is not necessary if any lexical declarations are done (see below), the PIR compiler will figure this out by itself. The <code>:lex</code> attribute is necessary to tell Parrot the subroutine will store or find lexicals.</p>
</ul>

<p>The sub flags are listed after the sub name. The subroutine name can also be a string instead of a bareword, as is shown in this example:</p>

<pre>  .sub &#39;foo&#39; :load :init :anon
  # PIR body
  .end</pre>

<p>Parameter definitions have the following syntax:</p>

<pre>  .sub main
    .param int argc :optional
    .param int has_argc :optional
    .param num nParam
    .param pmc argv :slurpy
    .param string sParam :named(&#39;foo&#39;)
    # body
  .end</pre>

<p>As shown, parameter definitions may take flags as well. These flags are listed here:</p>

<ul>
<li></li>

<pre> :slurpy</pre>

<p>The parameter should be of type <code>pmc</code> and acts like a container that <code>slurps</code> up all remaining arguments. Details can be found in PDD03 &#45; Parrot Calling Conventions.</p>

<li></li>

<pre> :named(&#39;x&#39;)</pre>

<p>The parameter is known in the called sub by name <code>&#39;x&#39;</code>. The <code>:named</code> flag can also be used <b>without</b> an identifier, in combination with the <code>:flat</code> or <code>:slurpy</code> flag, i.e. on a container holding several values:</p>

<pre>  .param pmc args :slurpy :named</pre>

<p>and</p>

<pre>  .arg args :flat :named</pre>

<li></li>

<pre> :optional</pre>

<p>Indicates the parameter being defined is optional.</p>

<li></li>

<pre> :opt_flag</pre>

<p>This flag can be given to a parameter defined <i>after</i> an optional parameter. During runtime, the parameter is automatically given a value, and is <i>not</i> passed by the caller. The value of this parameter indicates whether the previous (optional) parameter was present.</p>
</ul>

<p>The correct order of the parameters depends on the flag they have.</p>

<h2><a name="PIR_instructions"
>PIR instructions</a></h2>

<pre>  labeled_pir_instr:
    label? instr nl

  labeled_pasm_instr:
    label? pasm_instr nl

  instr:
    pir_instr | pasm_instr</pre>

<p>NOTE: the rule &#39;pasm_instr&#39; is not included in this reference grammar. pasm_instr defines the syntax for pure PASM instructions.</p>

<pre>  pir_instr:
      local_decl
    | lexical_decl
    | const_def
    | globalconst_def
    | conditional_stat
    | assignment_stat
    | return_stat
    | sub_invocation
    | macro_invocation
    | jump_stat
    | source_info</pre>

<h2><a name="Local_declarations"
>Local declarations</a></h2>

<pre>  local_decl:
    &#34;.local&#34; type local_id_list

  local_id_list:
    local_id [ &#34;,&#34; local_id ]*

  local_id:
    identifier &#34;:unique_reg&#34;?</pre>

<h3><a name="Examples_local_declarations"
>Examples local declarations</a></h3>

<p>Local temporary variables can be declared by the directives <code>.local</code>.</p>

<pre>  .local int i
  .local num a, b, c</pre>

<p>The optional <code>:unique_reg</code> modifier will force the register allocator to associate the identifier with a unique register for the duration of the compilation unit.</p>

<pre>  .local int j :unique_reg</pre>

<h2><a name="Lexical_declarations"
>Lexical declarations</a></h2>

<pre>  lexical_decl:
    &#34;.lex&#34; string_constant &#34;,&#34; target</pre>

<h3><a name="Example_lexical_declarations"
>Example lexical declarations</a></h3>

<p>The declaration</p>

<pre>  .lex &#39;i&#39;, $P0</pre>

<p>indicates that the value in $P0 is stored as a lexical variable, named by &#39;i&#39;. Once the above lexical declaration is written, and given the following statement:</p>

<pre>  $P1 = new &#39;Integer&#39;</pre>

<p>then the following two statements have an identical effect:</p>

<ul>
<li></li>

<pre>  $P0 = $P1</pre>

<li></li>

<pre>  store_lex &#34;i&#34;, $P1</pre>
</ul>

<p>Likewise, these two statements also have an identical effect:</p>

<ul>
<li></li>

<pre>  $P1 = $P0</pre>

<li></li>

<pre>  $P1 = find_lex &#34;i&#34;</pre>
</ul>

<p>Instead of a register, one can also specify a local variable, like so:</p>

<pre>  .local pmc p
  .lex &#39;i&#39;, p</pre>

<p>The same is true when a parameter should be stored as a lexical:</p>

<pre>  .param pmc p
  .lex &#39;i&#39;, p</pre>

<p>So, now it is also clear why <code>.lex &#39;i&#39;, p</code> is <b>not</b> a declaration of p: it needs a separate declaration, because it may either be a <code>.local</code> or a <code>.param</code>. The <code>.lex</code> directive merely is a shortcut for saving and retrieving lexical variables.</p>

<h2><a name="Constant_definitions"
>Constant definitions</a></h2>

<pre>  const_def:
    &#34;.const&#34; type identifier &#34;=&#34; constant_expr</pre>

<h3><a name="Example_constant_definitions"
>Example constant definitions</a></h3>

<pre>  .const int answer = 42</pre>

<p>defines an integer constant by name &#39;answer&#39;, giving it a value of 42. Note that the constant type and the value type should match, i.e. you cannot assign a floating point number to an integer constant. The PIR parser will check for this.</p>

<h2><a name="Global_constant_definitions"
>Global constant definitions</a></h2>

<pre>  globalconst_def:
    &#34;.globalconst&#34; type identifier &#34;=&#34; constant_expr</pre>

<h3><a name="Example_global_constant_definitions"
>Example global constant definitions</a></h3>

<p>This directive is similar to <code>const_def</code>, except that once a <code>global constant</code> has been defined, it is accessible from <b>all</b> subroutines.</p>

<pre>  .sub main :main
    .global const int answer = 42
    foo()
  .end

  .sub foo
    print answer # prints 42
  .end</pre>

<h2><a name="Conditional_statements"
>Conditional statements</a></h2>

<pre>  conditional_stat:
      [ &#34;if&#34; | &#34;unless&#34; ]
    [ [ &#34;null&#34; target &#34;goto&#34; identifier ]
    | [ simple_expr [ relational_op simple_expr ]? ]
    ] &#34;goto&#34; identifier</pre>

<h3><a name="Examples_conditional_statements"
>Examples conditional statements</a></h3>

<p>The syntax for <code>if</code> and <code>unless</code> statements is the same, except for the keyword itself. Therefore the examples will use either.</p>

<pre>  if null $P0 goto L1</pre>

<p>Checks whether <code>$P0</code> is <code>null</code>, if it is, flow of control jumps to label <code>L1</code></p>

<pre>  unless $P0 goto L2
  unless x   goto L2
  unless 1.1 goto L2</pre>

<p>Unless $P0, x or 1.1 are &#39;true&#39;, flow of control jumps to L2. When the argument is a PMC (like the first example), true&#45;ness depends on the PMC itself. For instance, in some languages, the number 0 is defined as &#39;true&#39;, in others it is considered &#39;false&#39; (like C).</p>

<pre>  if x &#60; y goto L1
  if y != z  goto L1</pre>

<p>are examples that check for the logical expression after <code>if</code>. Any of the <i>relational</i> operators may be used here.</p>

<h2><a name="Branching_statements"
>Branching statements</a></h2>

<pre>  jump_stat:
    &#34;goto&#34; identifier</pre>

<h3><a name="Examples_branching_statements"
>Examples branching statements</a></h3>

<pre>  goto MyLabel</pre>

<p>The program will continue running at label &#39;MyLabel:&#39;.</p>

<h2><a name="Operators"
>Operators</a></h2>

<pre>  relational_op:
      &#34;==&#34; | &#34;!=&#34; | &#34;&#60;=&#34; | &#34;&#60;&#34; | &#60;&#34;=&#34; | &#60;&#34;&#34;

  binary_op:
      &#34;+&#34;  | &#34;&#45;&#34;   | &#34;/&#34;  | &#34;**&#34;
    | &#34;*&#34;  | &#34;%&#34;   | &#34;&#60;&#60;&#34; | &#60;&#34;&#62;&#62;&#34;
    | &#60;&#34;&#62;&#34; | &#34;&#38;&#38;&#34;  | &#34;||&#34; | &#34;~~&#34;
    | &#34;|&#34;  | &#34;&#38;&#34;   | &#34;~&#34;  | &#34;.&#34;

  assign_op:
      &#34;+=&#34; | &#34;&#45;=&#34; | &#34;/=&#34; | &#34;%=&#34;  | &#34;*=&#34;  | &#34;.=&#34;
    | &#34;&#38;=&#34; | &#34;|=&#34; | &#34;~=&#34; | &#34;&#60;&#60;=&#34; | &#60;&#34;&#62;=&#34; | &#60;&#34;&#62;&#62;=&#34;

  unary_op:
      &#34;!&#34; | &#34;&#45;&#34; | &#34;~&#34;</pre>

<h2><a name="Expressions"
>Expressions</a></h2>

<pre>  expression:
      simple_expr
    | simple_expr binary_op simple_expr
    | unary_op simple_expr

  simple_expr:
      float_constant
    | int_constant
    | string_constant
    | target</pre>

<h3><a name="Example_expressions"
>Example expressions</a></h3>

<pre>  42
  42 + x
  1.1 / 0.1
  &#34;hello&#34; . &#34;world&#34;
  str1 . str2
  &#45;100
  ~obj
  !isSomething</pre>

<p>Arithmetic operators are only allowed on floating&#45;point numbers and integer values (or variables of that type). Likewise, string concatenation (&#34;.&#34;) is only allowed on strings. These checks are <b>not</b> done by the PIR parser.</p>

<h2><a name="Assignments"
>Assignments</a></h2>

<pre>  assignment_stat:
      target &#34;=&#34; short_sub_call
    | target &#34;=&#34; target keylist
    | target &#34;=&#34; expression
    | target &#34;=&#34; &#34;new&#34; string_constant
    | target &#34;=&#34; &#34;new&#34; keylist
    | target &#34;=&#34; &#34;find_type&#34; [ string_constant | string_reg | id ]
    | target &#34;=&#34; heredoc
    | target assign_op simple_expr
    | target keylist &#34;=&#34; simple_expr
    | result_var_list &#34;=&#34; short_sub_call</pre>

<p>NOTE: the definition of assignment statements is <b>not</b> complete yet. As languages/PIR evolves, this will be completed.</p>

<pre>  keylist:
    &#34;[&#34; keys &#34;]&#34;

  keys:
    key [ sep key ]*

  sep:
    &#34;,&#34; | &#34;;&#34;

  key:
      simple_expr

  result_var_list:
    &#34;(&#34; result_vars? &#34;)&#34;

  result_vars:
    result_var [ &#34;,&#34; result_var ]*

  result_var:
    target get_flags?</pre>

<h3><a name="Examples_assignment_statements"
>Examples assignment statements</a></h3>

<pre>  $I1 = 1 + 2
  $I1 += 1
  $P0 = foo()
  $I0 = $P0[1]
  $I0 = $P0[12.34]
  $I0 = $P0[&#34;Hello&#34;]
  $P0 = new 42 # but this is really not very clear, better use identifiers

  $S0 = &#60;&#60;&#39;HELLO&#39;
  ...
  HELLO

  .local int a, b, c
  (a, b, c) = foo()</pre>

<h2><a name="Heredoc"
>Heredoc</a></h2>

<p>NOTE: the heredoc rules are not complete or tested. Some work is required here.</p>

<pre>  heredoc:
    &#34;&#60;&#60;&#34; string_constant nl
    heredoc_string
    heredoc_label

  heredoc_label:
    ^^ identifier

  heredoc_string:
    [ \N | \n ]*</pre>

<h3><a name="Example_Heredoc"
>Example Heredoc</a></h3>

<pre>  .local string str
  str = &#60;&#60;&#39;ENDOFSTRING&#39;
    this text
         is stored in the
               variable
      named &#39;str&#39;. Whitespace and newlines
    are                  stored as well.
  ENDOFSTRING</pre>

<p>Note that the Heredoc identifier should be at the beginning of the line, no whitespace in front of it is allowed. Printing <code>str</code> would print:</p>

<pre>    this text
         is stored in the
               variable
      named &#39;str&#39;. Whitespace and newlines
    are                  stored as well.</pre>

<p>In IMCC, a heredoc identifier can be specified as an argument, like this:</p>

<pre>    foo(42, &#34;hello&#34;, &#60;&#60;&#39;EOS&#39;)

    This is a heredoc text argument.

  EOS</pre>

<p>In IMCC, only <b>one</b> such argument can be specified. The languages/PIR implementation aims to allow for <b>any</b> number of heredoc arguments, like this:</p>

<pre>    foo(&#60;&#60;&#39;STR1&#39;, &#60;&#60;&#39;STR2&#39;)

    argument 1
  STR1
    argument 2
  STR2</pre>

<p><b>Currently, this is not working.</b></p>

<h2><a name="Invoking_subroutines_and_methods"
>Invoking subroutines and methods</a></h2>

<pre>  sub_invocation:
    long_sub_call | short_sub_call

  long_sub_call:
    &#34;.begin_call&#34; nl
    arguments
    [ method_call | non_method_call] nl
    [ local_decl nl ]*
    result_values
    &#34;.end_call&#34;

  non_method_call:
    [ &#34;.call&#34; | &#34;.nci_call&#34; ] target

  method_call:
    &#34;.invocant&#34; target nl
    &#34;.meth_call&#34; [ target | string_constant ]

  parenthesized_args:
    &#34;(&#34; args &#34;)&#34;

  args:
    arg [ &#34;,&#34; arg ]

  arg:
    [ float_constant
    | int_constant
    | string_constant [ &#34;=&#62;&#34; target ]?
    | target
    ]
    set_flags?


  arguments:
    [ &#34;.arg&#34; simple_expr set_flags? nl ]*

  result_values:
    [ &#34;.result&#34; target get_flags? nl ]*

  set_flags:
    [ &#34;:flat&#34;
    | named_flag
    ]+</pre>

<h3><a name="Example_long_subroutine_call"
>Example long subroutine call</a></h3>

<p>The long subroutine call syntax is very suitable to be generated by a language compiler targeting Parrot. Its syntax is rather verbose, but easy to read. The minimal invocation looks like this:</p>

<pre>  .begin_call
  .call $P0
  .end_call</pre>

<p>Invoking instance methods is a simple variation:</p>

<pre>  .begin_call
  .invocant $P0
  .meth_call $P1
  .end_call</pre>

<p>Passing arguments and retrieving return values is done like this:</p>

<pre>  .begin_call
  .arg 42
  .call $P0
  .local int res
  .result res
  .end_call</pre>

<p>Arguments can take flags as well. The following argument flags are defined:</p>

<ul>
<li></li>

<pre> :flat</pre>

<p>Flatten the (aggregate) argument. This argument can only be of type <code>pmc</code>.</p>

<li></li>

<pre> :named(&#39;x&#39;)</pre>

<p>Pass the denoted argument into the named parameter that is denoted by &#39;x&#39;, like so:</p>

<pre> .param int myX :named(&#39;x&#39;)   # the type &#39;int&#39; is just an example</pre>

<p>As was mentioned at the parameter declaration section, the <code>:named</code> section can be used on an aggregate value in combination with the <code>:flat</code> flag.</p>

<pre> .arg pmc myArgs :flat :named</pre>
</ul>

<pre>  .local pmc arr
  arr = new .Array
  arr = 2
  arr[0] = 42
  arr[1] = 43
  .begin_call
  .arg arr :flat
  .arg $I0 :named(&#39;intArg&#39;)
  .call foo
  .end_call</pre>

<p>The Native Calling Interface (NCI) allows for calling C routines, in order to talk to the world outside of Parrot. Its syntax is a slight variation; it uses <code>.nci_call</code> instead of <code>.call</code>.</p>

<pre>  .begin_call
  .nci_call $P0
  .end_call</pre>

<h2><a name="Short_subroutine_invocation"
>Short subroutine invocation</a></h2>

<pre>  short_sub_call:
    invocant? [ target | string_constant ] parenthesized_args

  invocant:
    target&#34;.&#34;</pre>

<h3><a name="Example_short_subroutine_call"
>Example short subroutine call</a></h3>

<p>The short subroutine call syntax is useful when manually writing PIR code. Its simplest form is:</p>

<pre>  foo()</pre>

<p>Or a method call:</p>

<pre>  obj.&#39;toString&#39;() # call the method &#39;toString&#39;
  obj.x() # call the method whose name is stored in &#39;x&#39;.</pre>

<p>Note that no spaces are allowed between the invocant and the dot; <code>&#34;obj . &#39;toString&#39;&#34;</code> is not valid, this will be interpreted as a concatenation.</p>

<p>And of course, using the short version, passing arguments can be done as well, including all flags that were defined for the long version. The same example from the &#39;long subroutine invocation&#39; is now shown in its short version:</p>

<pre>  .local pmc arr
  arr = new .Array
  arr = 2
  arr[0] = 42
  arr[1] = 43
  foo(arr :flat, $I0 :named(&#39;intArg&#39;))</pre>

<p>In order to do a Native Call Interface invocation, the subroutine to be invoked needs to be in referenced from a PMC register, as its name is <b>not</b> visible from Parrot. A NCI call looks like this:</p>

<pre>  .local pmc nci_sub, nci_lib
  .local string c_function, signature

  nci_lib = loadlib &#34;myLib&#34;

  # name of the C function to be called
  c_function = &#34;sayHello&#34;

  # set signature to &#34;void&#34; (no arguments)
  signature  = &#34;v&#34;

  # get a PMC representing the C function
  nci_sub = dlfunc nci_lib, c_function, signature

  # and invoke
  nci_sub()</pre>

<h2><a name="Return_values_from_subroutines"
>Return values from subroutines</a></h2>

<pre>  return_stat:
      long_return_stat
    | short_return_stat
    | long_yield_stat
    | short_yield_stat
    | tail_call

  long_return_stat:
    &#34;.begin_return&#34; nl
    return_directive*
    &#34;.end_return&#34;

  return_directive:
    &#34;.return&#34; simple_expr set_flags? nl</pre>

<h3><a name="Example_long_return_statement"
>Example long return statement</a></h3>

<p>Returning values from a subroutine is in fact similar to passing arguments <i>to</i> a subroutine. Therefore, the same flags can be used:</p>

<pre>  .begin_return
  .return 42 :named(&#39;answer&#39;)
  .return $P0 :flat
  .end_return</pre>

<p>In this example, the value <code>42</code> is passed into the return value that takes the named return value known by <code>&#39;answer&#39;</code>. The aggregate value in <code>$P0</code> is flattened, and each of its values is passed as a return value.</p>

<h2><a name="Short_return_statement"
>Short return statement</a></h2>

<pre>  short_return_stat:
    &#34;.return&#34; parenthesized_args</pre>

<h3><a name="Example_short_return_statement"
>Example short return statement</a></h3>

<pre>  .return(myVar, &#34;hello&#34;, 2.76, 3.14);</pre>

<p>Just as the return values in the <code>long return statement</code> could take flags, the <code>short return statement</code> may as well:</p>

<pre>  .return(42 :named(&#39;answer&#39;), $P0 :flat)</pre>

<h2><a name="Long_yield_statements"
>Long yield statements</a></h2>

<pre>  long_yield_stat:
    &#34;.begin_yield&#34; nl
    return_directive*
    &#34;.end_yield&#34;</pre>

<h3><a name="Example_long_yield_statement"
>Example long yield statement</a></h3>

<p>A <code>yield</code> statement works the same as a normal return value, except that the point where the subroutine was left is stored somewhere, so that the subroutine can be resumed from that point as soon as the subroutine is invoked again. Returning values is identical to <i>normal</i> return statements.</p>

<pre>  .sub foo
    .begin_yield
    .return 42
    .end_yield

    # and later in the sub, one could return another value:

    .begin_yield
    .return 43
    .end_yield
  .end

  # when invoking twice:
  foo() # returns 42
  foo() # returns 43</pre>

<h2><a name="Short_yield_statements"
>Short yield statements</a></h2>

<pre>  short_yield_stat:
    &#34;.yield&#34; parenthesized_args</pre>

<h3><a name="Example_short_yield_statement"
>Example short yield statement</a></h3>

<p>Again, the short version is identical to the short version of the return statement as well.</p>

<pre>  .yield(&#34;hello&#34;, 42)</pre>

<h2><a name="Tail_calls"
>Tail calls</a></h2>

<pre>  tail_call:
    &#34;.return&#34; short_sub_call</pre>

<h3><a name="Example_tail_call"
>Example tail call</a></h3>

<pre>  .return foo()</pre>

<p>Returns the return values from <code>foo</code>. This is implemented by a tail call, which is more efficient than:</p>

<pre>  .local pmc results = foo()
  .return(results)</pre>

<p>The call to <code>foo</code> can be considered a normal function call with respect to parameters: it can take the exact same format using argument flags. The tail call can also be a method call, like so:</p>

<pre>  .return obj.&#39;foo&#39;()</pre>

<h2><a name="Expansions"
>Expansions</a></h2>

<pre>  expansion:
      macro_def
    | include
    | pasm_constant


  include:
    &#34;.include&#34; string_constant

  pasm_constant:
    &#34;.macro_const&#34; identifier [ constant_value | register ]</pre>

<h2><a name="Macros"
>Macros</a></h2>

<pre>  macro_def:
    &#34;.macro&#34; identifier macro_parameters? nl
    macro_body

  macro_parameters:
    &#34;(&#34; id_list? &#34;)&#34;

  macro_body:
    &#60;labeled_pir_instr&#62;*
    &#34;.endm&#34; nl

  macro_invocation:
    macro_id parenthesized_args?</pre>

<p>Note that before a macro body will be parsed, some grammar rules will be changed. In a macro body, local variable declarations are done using the <code>.macro_local</code> directive. <b>TODO: decide on keyword for this</b>.</p>

<p>The <code>.label</code> directive is available for declaring unique labels.</p>

<pre>  macro_label:
    &#34;.macrolabel&#34; &#34;$&#34;identifier&#34;:&#34;</pre>

<h3><a name="Example_Macros"
>Example Macros</a></h3>

<p>When the following macro is defined:</p>

<pre>  .macro add2(n)
    inc .n
    inc .n
  .endm</pre>

<p>then one can write in a subroutine:</p>

<pre>  .sub foo
    .local int myNum
    myNum = 42
    .add2(myNum)
    print myNum  # prints 44
  .end</pre>

<h2><a name="PIR_Pragmas"
>PIR Pragmas</a></h2>

<pre>  pragma:
      new_operators
    | loadlib
    | namespace
    | hll_mapping
    | hll_specifier
    | source_info

  new_operators:
    &#34;.pragma&#34; &#34;n_operators&#34; int_constant

  loadlib:
    &#34;.loadlib&#34; string_constant

  namespace:
    &#34;.namespace&#34; [ &#34;[&#34; namespace_id &#34;]&#34; ]?

  hll_specifier:
    &#34;.HLL&#34; string_constant &#34;,&#34; string_constant

  hll_mapping:
    &#34;.HLL_map&#34; string_constant &#34;,&#34; string_constant

  namespace_id:
    string_constant [ &#34;;&#34; string_constant ]*

  source_info:
    &#34;.line&#34; int_constant [ &#34;,&#34; string_constant ]?

  id_list:
    identifier [ &#34;,&#34; identifier ]*</pre>

<h3><a name="Examples_pragmas"
>Examples pragmas</a></h3>

<pre>  .include &#34;myLib.pir&#34;</pre>

<p>includes the source from the file &#34;myLib.pir&#34; at the point of this directive.</p>

<pre>  .pragma n_operators 1</pre>

<p>makes Parrot automatically create new PMCs when using arithmetic operators, like:</p>

<pre>  $P1 = new &#39;Integer&#39;
  $P2 = new &#39;Integer&#39;
  $P1 = 42
  $P2 = 43
  $P0 = $P1 * $P2
  # now, $P0 is automatically assigned a newly created PMC.


  .line 100
  .line 100, &#34;myfile.pir&#34;</pre>

<p>NOTE: currently, the line directive is implemented in IMCC as #line. See the PROPOSALS document for more information on this.</p>

<pre>  .namespace [&#39;Foo&#39;] # namespace Foo

  .namespace [&#39;Object&#39;;&#39;Foo&#39;] # nested namespace

  .namespace # no [ id ] means the root namespace is activated</pre>

<p>The first line opens the namespace &#39;Foo&#39;. When doing Object Oriented programming, this would indicate that sub or method definitions belong to the class &#39;Foo&#39;. Of course, you can also define namespaces without doing OO&#45;programming.</p>

<p>Please note that this <code>.namespace</code> directive is <i>different</i> from the <code>.namespace</code> directive that is used within subroutines.</p>

<pre>  .HLL &#34;Lua&#34;, &#34;lua_group&#34;</pre>

<p>is an example of specifying the High Level Language (HLL) for which the PIR is being generated. It is a shortcut for setting the namespace to &#39;Lua&#39;, and for loading the PMCs in the lua_group library.</p>

<pre>  .HLL_map &#34;Integer&#34;, &#34;LuaNumber&#34;</pre>

<p>is a way of telling Parrot, that whenever an Integer is created somewhere in the system (C code), instead a LuaNumber object is created.</p>

<pre>  .loadlib &#34;myLib&#34;</pre>

<p>is a shortcut for telling Parrot that the library &#34;myLib&#34; should be loaded when running the program. In fact, it is a shortcut for:</p>

<pre>  .sub _load :load :anon
    loadlib &#34;myLib&#34;
  .end</pre>

<p>TODO: check flags and syntax for this.</p>

<h2><a name="Tokens,_types_and_targets"
>Tokens, types and targets</a></h2>

<pre>  string_constant:
    [ encoding_specifier? charset_specifier ]?  quoted_string

  encoding_specifier:
    &#34;utf8:&#34;

  charset_specifier:
      &#34;ascii:&#34;
    | &#34;binary:&#34;
    | &#34;unicode:&#34;
    | &#34;iso&#45;8859&#45;1:&#34;

  type:
      &#34;int&#34;
    | &#34;num&#34;
    | &#34;pmc&#34;
    | &#34;string&#34;

  target:
    identifier | register</pre>

<h3><a name="Notes_on_Tokens,_types_and_targets"
>Notes on Tokens, types and targets</a></h3>

<p>A string constant can be written like:</p>

<pre>  &#34;Hello world&#34;</pre>

<p>but if desirable, the character set can be specified:</p>

<pre>  unicode:&#34;Hello world&#34;</pre>

<p>When using the &#34;unicode&#34; character set, one can also specify an encoding specifier; currently only <code>utf8</code> is allowed:</p>

<pre>  utf8:unicode:&#34;hello world&#34;</pre>

<p>IMCC currently allows identifiers to be used as types. During the parse, the identifier is checked whether it is a defined class. The built&#45;in types int, num, pmc and string are always available.</p>

<p>A <code>target</code> is something that can be assigned to, it is an L&#45;value (but of course may be read just like an R&#45;value). It is either an identifier or a register.</p>

<h1><a name="AUTHOR"
>AUTHOR</a></h1>

<p>Klaas&#45;Jan Stol [parrotcode@gmail.com]</p>

<h1><a name="KNOWN_ISSUES_AND_BUGS"
>KNOWN ISSUES AND BUGS</a></h1>

<p>Some work should be done on:</p>

<ul>
<li>Heredoc parsing</li>

<li>Test. A lot.</li>

<p>Bugs or improvements may be sent to the author, and are of course greatly appreciated. Moreover, if you find any missing constructs that are in IMCC, indications of these would be appreciated as well.</p>

<p>Please see the PROPOSALS document for some proposals of the author to clean up the official grammar of PIR (as defined by the IMCC compiler).</p>
</ul>

<h1><a name="REFERENCES"
>REFERENCES</a></h1>

<ul>
<li>languages/PIR/lib/pir.pg &#45; The actual PIR grammar implementation</li>

<li>PDD03 &#45; Parrot Calling Conventions</li>

<li>PDD20 &#45; Lexically scoped variables in Parrot</li>

<li>docs/pdds/draft/pdd19_pir.pod</li>
</ul>

<h1><a name="CHANGES"
>CHANGES</a></h1>

<p>0.3.1</p>

<ul>
<li>Remove .namespace for scopes</li>

<li>Some clean&#45;ups</li>
</ul>

<p>0.3.0</p>

<ul>
<li>Remove <code>.pcc_</code> prefix on PCC directives</li>

<li>Remove <code>.emit</code> and <code>.eom</code> directives.</li>
</ul>

<p>0.2.0</p>

<ul>
<li>Many clean ups; remove experimental <code>:wrap</code> flag, remove <code>.global</code> directive, remove <code>.sym</code> directive, add <code>.label</code> directive for macros, remove <code>.sub</code>; remove some comments that are not true any more. In all, it&#39;s getting much cleaner!</li>
</ul>

<p>0.1.4</p>

<ul>
<li>Added <code>expansion</code> rule, moved <code>include</code> and <code>macro_def</code> rules to that rule. Added <code>pasm_constant</code> definition.</li>

<li>Removed newlines in operator definition to save some lines for readability.</li>
</ul>

<p>0.1.3</p>

<ul>
<li>Updated short sub invocation for NCI invocations.</li>

<li>Added an example for <code>.globalconst</code>.</li>

<li>Added some remarks at section for Macros.</li>

<li>Added some remarks here and there, and fixed some style issues.</li>
</ul>

<p>0.1.2</p>

<ul>
<li>Removed <code>.immediate</code>, it is <code>:immediate</code>, and thus not a PIR directive, but a flag. This was a mistake.</li>

<li>Added <code>.globalconst</code></li>

<li>Added macro parsing example (it is now fixed in languages/PIR).</li>

<li>Added reference to official doc for IMCC syntax.</li>

<li>Added <code>:unique_reg</code> to allowed flags for incoming parameters.</li>
</ul>

<p>0.1.1</p>

<ul>
<li>Switch to x.y.z version number; many fixes will follow.</li>

<li>Added more examples.</li>

<li>Fixed some errors.</li>
</ul>

<p>0.1</p>

<ul>
<li>Initial version having a version number.</li>
</ul>
            </div> <!-- "mainbody" -->
            <div id="divider"></div>
            <div id="footer">
	        Copyright &copy; 2002-2009, Parrot Foundation.
            </div>
        </div> <!-- "wrapper" -->
    </body>
</html>
