<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>Untitled</title>
        <link rel="stylesheet" type="text/css"
            href="../../../../../resources/parrot.css"
            media="all">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    </head>
    <body>
        <div id="wrapper">
            <div id="header">

                <img border=0 src="../../../../../resources/parrot_logo.png" id="logo" alt="parrot">
            </div> <!-- "header" -->
            <div id="divider"></div>
            <div id="mainbody">
                <div id="breadcrumb">
                    <a href="../../../../../html/index.html">Contents</a> &raquo; <a href="../../../../../html/languages.html">Language Implementations</a> &raquo; <a href="../../../../../html/cardinal.html">Cardinal</a> &raquo; Untitled
                </div>

<p>grammar cardinal::Grammar is PCT::Grammar;</p>

<p>token TOP { &#60;comp_stmt&#62; [ $ || &#60;panic: Syntax error&#62; ] {*} }</p>

<p>token comp_stmt { {*} #= open &#60;stmts&#62; {*} #= close }</p>

<p>rule stmts { &#60;.term&#62;?[ &#60;stmt&#62; [&#60;.term&#62;+ | &#60;.before &#60;end_block&#62;&#62; | $ | &#60;panic: unterminated statement&#62;] ]* {*} }</p>

<p>token term { \n | &#39;;&#39; } token end_block { &#60;.ws&#62; [ &#39;end&#39; | &#39;}&#39; ] }</p>

<p>token basic_stmt { | &#60;alias&#62; {*} #= alias | &#60;classdef&#62; {*} #= classdef | &#60;functiondef&#62; {*} #= functiondef | &#60;if_stmt&#62; {*} #= if_stmt | &#60;while_stmt&#62; {*} #= while_stmt | &#60;for_stmt&#62; {*} #= for_stmt | &#60;unless_stmt&#62; {*} #= unless_stmt | &#60;module&#62; {*} #= module | &#60;begin_end&#62; {*} #= begin_end | &#60;indexed_assignment&#62; {*} #= indexed_assignment | &#60;member_assignment&#62; {*} #= member_assignment | &#60;assignment&#62; {*} #= assignment | &#60;return_stmt&#62; {*} #= return_stmt | &#60;expr&#62; {*} #= expr | &#60;begin&#62; {*} #= begin | &#60;end&#62; {*} #= end }</p>

<p>token return_stmt { &#39;return&#39; &#60;.ws&#62; &#60;call_args&#62; {*} }</p>

<p>rule alias { &#39;alias&#39; &#60;fname&#62; &#60;fname&#62; {*} }</p>

<p>token stmt { &#60;basic_stmt&#62; &#60;.ws&#62; &#60;stmt_mod&#62;* {*} }</p>

<p>token stmt_mod { $&#60;sym&#62;=[if|while|unless|until] &#60;.ws&#62; &#60;expr&#62; {*} }</p>

<p>rule expr { [$&#60;not&#62;=[&#39;!&#39;|&#39;not&#39;]]?
&#60;arg&#62; [$&#60;op&#62;=[&#39;and&#39;|&#39;or&#39;] &#60;expr&#62;]?
{*} }</p>

<p>rule begin { &#39;BEGIN&#39; &#39;{&#39; &#60;comp_stmt&#62; &#39;}&#39; {*} }</p>

<p>rule end { &#39;END&#39; &#39;{&#39; &#60;comp_stmt&#62; &#39;}&#39; {*} }</p>

<p>token indexed_assignment { &#60;basic_primary&#62; &#39;[&#39; &#60;key=arg&#62; &#39;]&#39; &#60;.ws&#62; &#39;=&#39; &#60;.ws&#62; &#60;rhs=arg&#62; {*} }</p>

<p>token member_assignment { &#60;basic_primary&#62; &#39;.&#39; &#60;key=identifier&#62; &#60;.ws&#62; &#39;=&#39; &#60;.ws&#62; &#60;rhs=arg&#62; {*} }</p>

<p>rule assignment { &#60;mlhs=lhs&#62; &#39;=&#39; &#60;mrhs=arg&#62; #XXX need to figure out multiple assignment {*} }</p>

<p>rule mlhs { | &#60;lhs&#62; {*} #= lhs | &#39;(&#39; &#60;mlhs&#62; &#39;)&#39; {*} #= mlhs }</p>

<p>token lhs { | &#60;basic_primary&#62; {*} #= basic_primary }</p>

<p>token indexed { &#39;[&#39; &#60;args&#62;?
&#39;]&#39; {*} }</p>

<p>token member_variable { &#60;primary&#62; &#39;.&#39; &#60;identifier&#62; {*} }</p>

<p>token methodcall { $&#60;dot&#62;=&#39;.&#39; &#60;operation&#62; &#60;call_args&#62;?
&#60;do_block&#62;?
{*} }</p>

<p>rule do_block { | &#39;do&#39; &#60;do_args&#62;?
&#60;.term&#62;?
&#60;.before &#60;stmt&#62;&#62;&#60;comp_stmt&#62; &#39;end&#39; {*} | &#39;{&#39; &#60;do_args&#62;?
&#60;.term&#62;?
&#60;.before &#60;stmt&#62;&#62;&#60;comp_stmt&#62; &#39;}&#39; {*} }</p>

<p>rule super_call { &#39;super&#39; &#60;call_args&#62; {*} }</p>

<p>token operation { &#39;class&#39;| &#39;nil?&#39; | &#39;next&#39; | &#39;begin&#39;| &#39;end&#39; | &#39;`&#39; | &#60;.identifier&#62; (&#39;!&#39;|&#39;?&#39;)?
}</p>

<p>#XXX UGLY!
Refactor into &#60;args&#62; maybe?
token call_args { | &#39;()&#39; [&#60;.ws&#62; &#60;do_block&#62;]?
{*} | [ &#60;.after \s|\)&#62; | &#60;.before \s&#62; ] &#60;args&#62; [&#60;.ws&#62; &#60;do_block&#62;]?
{*} | &#39;(&#39; &#60;.ws&#62; &#60;args&#62; &#60;.ws&#62; &#39;)&#39; [&#60;.ws&#62; &#60;do_block&#62;]?
{*} }</p>

<p>rule do_args { &#39;|&#39; &#60;block_signature&#62; &#39;|&#39; }</p>

<p>rule sig_identifier { #XXX Should this be basic_primary or expr or what?
&#60;identifier&#62;[ &#39;=&#39; &#60;default=basic_primary&#62;]?
{*} }</p>

<p>rule block_signature { [ | &#60;sig_identifier&#62; [&#39;,&#39; &#60;sig_identifier&#62;]* [&#39;,&#39; &#60;slurpy_param&#62;]?
[&#39;,&#39; &#60;block_param&#62;]?
| &#60;slurpy_param&#62; [&#39;,&#39; &#60;block_param&#62;]?
| &#60;block_param&#62;?
] {*} }</p>

<p>token variable { | &#60;varname&#62; {*} #= varname | &#39;nil&#39; {*} #= nil | &#39;self&#39; {*} #= self }</p>

<p>token varname { &#60;!reserved_word&#62; [ &#60;global&#62; {*} #= global | &#60;class_variable&#62; {*} #= class_variable | &#60;instance_variable&#62; {*} #= instance_variable | &#60;local_variable&#62; {*} #= local_variable | &#60;constant_variable&#62; {*} #= constant_variable ] }</p>

<p>token funcall { &#60;!reserved_word&#62; &#60;local_variable&#62; &#60;.before \s|&#39;(&#39;&#62; &#60;.before &#60;call_args&#62;&#62; {*} }</p>

<p>token mrhs { &#60;args&#62; {*} }</p>

<p>rule args { &#60;arg&#62; [&#39;,&#39; &#60;arg&#62;]* {*} }</p>

<p>rule &#39;arg&#39; is optable { ...
}</p>

<p>proto &#39;infix:=&#39; is precedence(&#39;1&#39;) is pasttype(&#39;copy&#39;) is lvalue(1) { ...
}</p>

<p>token basic_primary { | &#60;literal&#62; {*} #= literal | &#60;funcall&#62; {*} #= funcall | &#60;variable&#62; {*} #= variable | &#60;ahash&#62; {*} #= ahash | &#60;regex&#62; {*} #= regex | &#60;do_block&#62; {*} #= do_block | &#60;quote_string&#62; {*} #= quote_string | &#60;warray&#62; {*} #= warray | &#60;array&#62; {*} #= array | &#60;pcomp_stmt&#62; {*} #= pcomp_stmt | &#60;yield&#62; {*} #= yield | &#60;control_command&#62; {*} #= control_command }</p>

<p>token primary { &#60;basic_primary&#62; &#60;post_primary_expr&#62;* {*} }</p>

<p>token post_primary_expr { | &#60;indexed&#62; {*} #= indexed | &#60;call_args&#62; {*} #= call_args | &#60;methodcall&#62; {*} #= methodcall | &#39;[&#39; &#60;args&#62;?
&#39;]&#39; {*} #= args }</p>

<p>token pcomp_stmt { &#39;(&#39; &#60;comp_stmt&#62; &#39;)&#39; {*} }</p>

<p>rule if_stmt { &#39;if&#39; &#60;expr&#62; &#60;.then&#62; [&#60;comp_stmt&#62; [&#39;elsif&#39; &#60;expr&#62; &#60;.then&#62; &#60;comp_stmt&#62;]* &#60;else&#62;?
&#39;end&#39; |&#60;panic: syntax error in if statement&#62;] {*} }</p>

<p>token then { &#39;:&#39; | &#39;then&#39; | &#60;term&#62; [&#39;then&#39;]?
}</p>

<p>rule while_stmt { $&#60;sym&#62;=[&#39;while&#39;|&#39;until&#39;] &#60;expr&#62; &#60;.do&#62; &#60;comp_stmt&#62; &#39;end&#39; {*} }</p>

<p>rule for_stmt { &#39;for&#39; &#60;variable&#62; &#39;in&#39; &#60;expr&#62; &#60;.do&#62; &#60;comp_stmt&#62; &#39;end&#39; {*} }</p>

<p>token do { &#39;:&#39; | &#39;do&#39; | &#60;term&#62; [&#39;do&#39;]?
}</p>

<p>rule unless_stmt { &#39;unless&#39; &#60;expr&#62; &#60;.then&#62; &#60;comp_stmt&#62; &#60;else&#62;?
&#39;end&#39; {*} }</p>

<p>token else { &#39;else&#39; &#60;.ws&#62; &#60;comp_stmt&#62; {*} }</p>

<p>token ensure { &#39;ensure&#39; &#60;.ws&#62; &#60;comp_stmt&#62; {*} }</p>

<p>rule rescue { # XXX check &#60;args&#62; [&#39;rescue&#39; &#60;args&#62; &#60;.then&#62; &#60;comp_stmt&#62;]+ {*} }</p>

<p>token control_command { | &#39;next&#39; {*} #= next | &#39;break&#39; {*} #= break | &#39;redo&#39; {*} #= redo }</p>

<p>token yield { &#39;yield&#39; &#60;call_args&#62; {*} }</p>

<p>rule module { &#39;module&#39; &#60;module_identifier&#62; &#60;comp_stmt&#62; &#39;end&#39; {*} }</p>

<p>rule classdef { &#39;class&#39; &#60;module_identifier&#62; {*} #= open &#60;comp_stmt&#62; &#39;end&#39; {*} #= block }</p>

<p>rule functiondef { &#39;def&#39; &#60;fname&#62; &#60;argdecl&#62; &#60;comp_stmt&#62; &#39;end&#39; {*} }</p>

<p>rule bodystmt { &#60;comp_stmt&#62; &#60;rescue&#62;?
&#60;else&#62;?
&#60;ensure&#62;?
}</p>

<p>rule argdecl { [&#39;(&#39; &#60;block_signature&#62; &#39;)&#39;]?
}</p>

<p>token slurpy_param { &#39;*&#39; &#60;identifier&#62; {*} }</p>

<p>token block_param { &#39;&#38;&#39; &#60;identifier&#62; {*} }</p>

<p>rule begin_end { &#39;begin&#39; &#60;comp_stmt&#62; [&#39;rescue&#39; &#60;args&#62;?
&#60;.do&#62; &#60;comp_stmt&#62;]+ [&#39;else&#39; &#60;comp_stmt&#62;]?
[&#39;ensure&#39; &#60;comp_stmt&#62;]?
&#39;end&#39; {*} }</p>

<p>token fname { &#60;.identifier&#62; &#60;[=!?]&#62;?
}</p>

<p>token quote_string { [&#39;%q&#39;|&#39;%Q&#39;] &#60;.before &#60;[&#60;[_|({]&#62;&#62; &#60;quote_expression: :qq&#62; {*} }</p>

<p>token warray { &#39;%w&#39; &#60;.before &#60;[&#60;[({]&#62;&#62; &#60;quote_expression: :w :q&#62; {*} }</p>

<p>rule array { &#39;[&#39; [ &#60;args&#62; [&#39;,&#39;]?
]?
&#39;]&#39; {*} }</p>

<p>rule ahash { &#39;{&#39; [ &#60;assocs&#62; [&#39;,&#39;]?
]?
&#39;}&#39; {*} }</p>

<p>rule assocs { &#60;assoc&#62; [&#39;,&#39; &#60;assoc&#62;]* {*} }</p>

<p>rule assoc { &#60;arg&#62; &#39;=&#62;&#39; &#60;arg&#62; {*} }</p>

<p>token identifier { &#60;!reserved_word&#62; &#60;ident&#62; {*} }</p>

<p>token module_identifier { &#60;.before &#60;[A..Z]&#62;&#62; &#60;ident&#62; {*} }</p>

<p>token global { &#39;$&#39; &#60;ident&#62; {*} }</p>

<p>token instance_variable { &#39;@&#39; &#60;ident&#62; {*} }</p>

<p>token class_variable { &#39;@@&#39; &#60;ident&#62; {*} }</p>

<p>token local_variable { [&#60;ns=ident&#62; &#39;::&#39;]* [ &#60;before &#60;[a..z_]&#62;&#62; | &#60;after &#39;::&#39;&#62; ] &#60;ident&#62; {*} }</p>

<p>token constant_variable { &#60;.before &#60;[A..Z]&#62;&#62; &#60;.ident&#62; {*} }</p>

<p>token literal { | &#60;float&#62; {*} #= float | &#60;integer&#62; {*} #= integer | &#60;string&#62; {*} #= string }</p>

<p>token float { &#39;&#45;&#39;?
\d* &#39;.&#39; \d+ {*} }</p>

<p>token integer { &#39;&#45;&#39;?
\d+ {*} }</p>

<p>token string { [ \&#39; &#60;string_literal: &#34;&#39;&#34;&#62; \&#39; | \&#34; &#60;string_literal: &#39;&#34;&#39;&#62; \&#34; ] {*} }</p>

<p>token regex { &#60;.before &#39;/&#39;&#62; [&#60;quote_expression: :regex&#62; $&#60;modifiers&#62;=[&#60;alpha&#62;]* |&#60;panic: problem parsing regex&#62;] {*} }</p>

<p>token reserved_word { [alias|and|BEGIN|begin|break|case |class|def|defined|do|else|elsif |END|end|ensure|false|for|if |in|module|next|nil|not|or |redo|rescue|retry|return|self|super |then|true|undef|unless|until|when |while|yield|__FILE__|__LINE__]&#62;&#62; }</p>

<p>token ws { | &#39;\\&#39; \n ## a backslash at end of line | &#60;after [&#39;,&#39;|&#39;=&#39;|&#39;+&#39;]&#62; \n ## a newline after a comma or operator is ignored | \h* [&#39;#&#39; \N* \n* &#60;ws&#62;]?
}</p>

<p>proto &#39;infix:=&#39; is precedence(&#39;1&#39;) is pasttype(&#39;copy&#39;) is lvalue(1) { ...
}</p>

<p>proto &#39;prefix:defined?&#39; is looser(&#39;infix:=&#39;) { ...
}</p>

<p>proto &#39;infix:+=&#39; is equiv(&#39;infix:=&#39;) { ...
}</p>

<p>proto &#39;infix:&#45;=&#39; is equiv(&#39;infix:=&#39;) { ...
}</p>

<p>proto &#39;infix:/=&#39; is equiv(&#39;infix:=&#39;) is pirop(&#39;div&#39;) { ...
}</p>

<p>proto &#39;infix:*=&#39; is equiv(&#39;infix:=&#39;) is pirop(&#39;mul&#39;) { ...
}</p>

<p>proto &#39;infix:%=&#39; is equiv(&#39;infix:=&#39;) is pirop(&#39;mul&#39;) { ...
}</p>

<p>proto &#39;infix:|=&#39; is equiv(&#39;infix:=&#39;) { ...
}</p>

<p>proto &#39;infix:&#38;=&#39; is equiv(&#39;infix:=&#39;) { ...
}</p>

<p>proto &#39;infix:~=&#39; is equiv(&#39;infix:=&#39;) { ...
}</p>

<p>proto infix:&#194;&#171;&#62;&#62;=&#194;&#187; is equiv(&#39;infix:=&#39;) is pirop(&#39;rsh&#39;) { ...
}</p>

<p>proto infix:&#194;&#171;&#60;&#60;=&#194;&#187; is equiv(&#39;infix:=&#39;) is pirop(&#39;lsh&#39;) { ...
}</p>

<p>proto &#39;infix:&#38;&#38;=&#39; is equiv(&#39;infix:=&#39;) is pirop(&#39;and&#39;) { ...
}</p>

<p>proto &#39;infix:**=&#39; is equiv(&#39;infix:=&#39;) is pirop(&#39;pow&#39;) { ...
}</p>

<p>proto &#39;ternary:?
:&#39; is tighter(&#39;infix:=&#39;) is pirop(&#39;if&#39;) { ...
}</p>

<p>proto &#39;infix:..&#39; is tighter(&#39;ternary:?
:&#39;) { ...
} #is parsed(&#38;primary) { ...
} #is pirop(&#39;add&#39;) { ...
}</p>

<p>proto &#39;infix:...&#39; is equiv(&#39;infix:..&#39;) { ...
}</p>

<p>proto &#39;infix:||&#39; is tighter(&#39;infix:..&#39;) is pasttype(&#39;unless&#39;) { ...
}</p>

<p>proto &#39;infix:&#38;&#38;&#39; is tighter(&#39;infix:||&#39;) is pasttype(&#39;if&#39;) { ...
}</p>

<p>proto &#39;infix:==&#39; is tighter(&#39;infix:&#38;&#38;&#39;) { ...
} proto &#39;infix:!=&#39; is equiv(&#39;infix:==&#39;) { ...
} proto &#39;infix:=~&#39; is equiv(&#39;infix:==&#39;) { ...
} proto &#39;infix:!~&#39; is equiv(&#39;infix:==&#39;) { ...
} proto &#39;infix:===&#39; is equiv(&#39;infix:==&#39;) { ...
} proto infix:&#194;&#171;&#60;=&#62;&#194;&#187; is equiv(&#39;infix:==&#39;) { ...
}</p>

<p>proto infix:&#194;&#171;&#62;&#194;&#187; is tighter(&#39;infix:===&#39;) { ...
} proto infix:&#194;&#171;&#60;&#194;&#187; is tighter(&#39;infix:===&#39;) { ...
} proto infix:&#194;&#171;&#60;=&#194;&#187; is tighter(&#39;infix:===&#39;) { ...
} proto infix:&#194;&#171;&#62;=&#194;&#187; is tighter(&#39;infix:===&#39;) { ...
}</p>

<p>proto &#39;infix:|&#39; is tighter(&#39;infix:&#60;=&#39;) { ...
} proto &#39;infix:^&#39; is equiv(&#39;infix:|&#39;) { ...
}</p>

<p>proto &#39;infix:&#38;&#39; is tighter(&#39;infix:|&#39;) { ...
}</p>

<p>proto infix:&#194;&#171;&#60;&#60;&#194;&#187; is tighter(&#39;infix:&#38;&#39;) { ...
} proto infix:&#194;&#171;&#62;&#62;&#194;&#187; is equiv(infix:&#194;&#171;&#60;&#60;&#194;&#187;) { ...
}</p>

<p>proto &#39;infix:+&#39; is tighter(infix:&#194;&#171;&#60;&#60;&#194;&#187;) { ...
}</p>

<p>proto &#39;infix:&#45;&#39; is equiv(&#39;infix:+&#39;) { ...
} #is pirop(&#39;sub&#39;) { ...
}</p>

<p>proto &#39;infix:*&#39; is tighter(&#39;infix:+&#39;) { ...
} #is pirop(&#39;mul&#39;) { ...
}</p>

<p>proto &#39;infix:/&#39; is equiv(&#39;infix:*&#39;) { ...
} #is pirop(&#39;div&#39;) { ...
}</p>

<p>proto &#39;infix:%&#39; is equiv(&#39;infix:*&#39;) is pirop(&#39;mod&#39;) { ...
}</p>

<p>proto &#39;postfix:++&#39; is tighter(&#39;infix:*&#39;) is pirop(&#39;n_add&#39;) { ...
}</p>

<p>proto &#39;postfix:&#45;&#45;&#39; is tighter(&#39;infix:*&#39;) is pirop(&#39;n_sub&#39;) { ...
} # #proto &#39;prefix:+&#39; is tighter(&#39;infix:*&#39;) { ...
} #proto &#39;prefix:&#45;&#39; is equiv(&#39;prefix:+&#39;) { ...
} #proto &#39;prefix:!&#39; is equiv(&#39;prefix:+&#39;) { ...
} #proto &#39;prefix:~&#39; is equiv(&#39;prefix:+&#39;) { ...
}</p>

<p>proto &#39;term:&#39; is tighter(&#39;infix:*&#39;) is parsed(&#38;primary) { ...
}</p>
            </div> <!-- "mainbody" -->
            <div id="divider"></div>
            <div id="footer">
	        Copyright &copy; 2002-2009, Parrot Foundation.
            </div>
        </div> <!-- "wrapper" -->
    </body>
</html>
