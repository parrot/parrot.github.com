<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>Untitled</title>
        <link rel="stylesheet" type="text/css"
            href="../../../../../resources/parrot.css"
            media="all">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    </head>
    <body>
        <div id="wrapper">
            <div id="header">

                <img border=0 src="../../../../../resources/parrot_logo.png" id="logo" alt="parrot">
            </div> <!-- "header" -->
            <div id="divider"></div>
            <div id="mainbody">
                <div id="breadcrumb">
                    <a href="../../../../../html/index.html">Contents</a> &raquo; <a href="../../../../../html/languages.html">Language Implementations</a> &raquo; <a href="../../../../../html/dotnet.html">.Net</a> &raquo; Untitled
                </div>

<h1><a name="Translating_Method_Calls"
>Translating Method Calls</a></h1>

<p>This document discusses .NET method calling and how this is translated to work on Parrot.</p>

<h2><a name="The_.NET_Model"
>The .NET Model</a></h2>

<p>The .NET CLI provides a stack based calling mechanism.
Arguments are pushed onto the stack left to right,
then the method is called.
If there is a return value then it is left on the stack.
Suckfully,
methods are limited to returning a single value.</p>

<p>The method to call is given as a parameter to the call instructions (apart from calli,
which calls through a method reference; here the signature is provided with the instruction).
The method to call is specified by a 4&#45;byte integer that points into the meta&#45;data table.
Note that if a virtual call is taking place then a method of the same name and signature may be called in place of the specific method the token refers to,
depending what is in the v&#45;table.</p>

<p>.NET does support having methods of the same name with different signatures,
however the VM does not &#34;support&#34; this at call&#45;time.
It is up to the compiler to resolve which method to call and put the correct meta&#45;data reference with the call.</p>

<h2><a name="The_Parrot_Model"
>The Parrot Model</a></h2>

<p>Parrot provides standard calling conventions that attempt to cover the needs of many languages.
They use Continuation Passing Style and under the hood are implemented as several variable argument register instructions (set_args,
get_params,
set_results and get_returns).
Both positional and named parameters are supported with required and slurply support for both,
subject to some ordering constraints (positional before named,
required before slurpy).</p>

<p>Parrot also provides a multi&#45;method dispatch mechanism.
This is used to call methods with the same name but varying signatures.
As Parrot supports dynamic languages,
the method that will be called can not be determined at compile time and may change throughout the lifetime of the program as new methods appear and inheritance hierachies change.
A cache is used to aid performance.
In fact,
in run cores that are capable of it the instruction stream is modified at runtime to just have a call to the method that the dispatch algorithm found,
so the cost of the dynamic dispatch is amortised.
This technique is known as a Polymorhpic Inline Cache (PIC).</p>

<h2><a name="The_Translated_Code_Will_Use_Parrot_Calling_Conventions"
>The Translated Code Will Use Parrot Calling Conventions</a></h2>

<p>The .NET method calls will be translated in a way that uses the Parrot calling conventions.
This will without doubt mean that calling times will be higher,
for the Parrot calling conventions are far more complex than the .NET ones.
However,
not using the Parrot calling conventions would create difficulties in calling methods on .NET classes and objects from other languages that target Parrot.
More bluntly,
as the entire point of writing this translator is interoperability,
not targetting the Parrot calling conventions would be pretty dumb.</p>

<h2><a name="Translating_Method_Calls"
>Translating Method Calls</a></h2>

<h3><a name="The_&#34;call&#34;_Instruction"
>The &#34;call&#34; Instruction</a></h3>

<p>The &#34;call&#34; instruction does a non&#45;virtual method call; the method specified by the meta&#45;data token referenced by the instruction is the one to,
no matter what.
This can be achieved in Parrot by looking up the method in the namespace holding the class it is exists in,
which can be determined from the meta&#45;data token.</p>

<p>Assuming that $P1 and $I2 contain the parameters to be passed and $I0 is to hold the return value,
then a call to the method &#34;factorial&#34; in the class &#34;Test&#34; in the namespace &#34;Testing&#34; will translate to Parrot instructions as shown below.</p>

<pre>  $P1000000 = get_hll_global &#34;Testing.Test&#34;, &#34;factorial&#34;
  $I0 = $P1000000($P1, $I2)</pre>

<h3><a name="The_&#34;callvirt&#34;_Instruction"
>The &#34;callvirt&#34; Instruction</a></h3>

<p>The &#34;callvirt&#34; instruction does a virtual method call. That is, an object currently viewed as being an A that is actually some subtype B of A may override some method &#34;foo&#34;. Whereas &#34;call&#34; would call the method &#34;foo&#34; as defined by the class A, callvirt uses the runtime type of the object to decide what method to call. This can be translated directly to Parrot method call syntax.</p>

<pre>  $I0 = $P1.&#34;foo&#34;($I2)</pre>

<h3><a name="The_&#34;calli&#34;_Instruction"
>The &#34;calli&#34; Instruction</a></h3>

<p>The &#34;calli&#34; instruction does a method call through a method reference. Another instruction is used to load a function reference. As shown in the example PIR for the &#34;call&#34; instruction, Parrot can handle storing a reference to a method in a PMC. This has not, however, been implemented at this time.</p>

<h2><a name="Supporting_Method_Overloading"
>Supporting Method Overloading</a></h2>

<p>Using Parrot&#39;s MMD mechanism will provide most of what is required to support .NET method overloading. However, there is a problem: Parrot does not recognize different types of integers and floating point numbers as fundemental types like .NET does. For efficiency it is desirable to have, for example, both 32&#45;bit and 16&#45;bit integers stored in Integer registers, but at dispatch time Parrot will be unable to distinguish between the two types.</p>

<p>A number of options exist to solve this. Name mangling the subs and then using the signature to generate the mangled name when translating the call would work. This avoids Parrot&#39;s MMD completely, meaning it is cheaper at runtime and that the intended method is always called. However, this really hurts interoperability with other languages.</p>

<p>Another option is to wrap up anything other than a native integer or double into a PMC type at call time &#45; essentially boxing it &#45; and then unboxing it inside the call. This allows the MMD system in Parrot to be used, avoids name mangling the methods so other languages can still see and call them as desired but makes calling more costly.</p>

<p>Since the goal of the project is interoperability rather than performance, the second option makes more sense. It is implemented by declaring a number of classes that derive either from Parrot&#39;s built in Integer or Float PMCs and named &#34;@@DOTNET_MMDBOX_I1&#34; for the single byte signed integer, etc. When translating a calling related instruction, code must be emitted to place any types that must be boxed for MMD purposes into the appropriate box type. All methods are annotated with &#34;:multi(...)&#34; directives using name of the boxed types where appropriate. Note that there is no need for explicit unboxing on the callee side; if an integer register is declared but a PMC is passed, then the get_integer v&#45;table method will be called on that PMC automatically.</p>

<h2><a name="References"
>References</a></h2>

<p>PIC &#45; <a href="http://citeseer.ist.psu.edu/hlzle91optimizing.html">http://citeseer.ist.psu.edu/hlzle91optimizing.html</a></p>
            </div> <!-- "mainbody" -->
            <div id="divider"></div>
            <div id="footer">
	        Copyright &copy; 2002-2009, Parrot Foundation.
            </div>
        </div> <!-- "wrapper" -->
    </body>
</html>
