<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>Untitled</title>
        <link rel="stylesheet" type="text/css"
            href="../../../../../resources/parrot.css"
            media="all">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    </head>
    <body>
        <div id="wrapper">
            <div id="header">

                <img border=0 src="../../../../../resources/parrot_logo.png" id="logo" alt="parrot">
            </div> <!-- "header" -->
            <div id="divider"></div>
            <div id="mainbody">
                <div id="breadcrumb">
                    <a href="../../../../../html/index.html">Contents</a> &raquo; <a href="../../../../../html/languages.html">Language Implementations</a> &raquo; <a href="../../../../../html/c99.html">C99</a> &raquo; Untitled
                </div>

<p>grammar C99::Grammar is PCT::Grammar;</p>

<p>## A.2.4 External definitions ##</p>

<p>token TOP { ^ &#60;external_declaration&#62;+ [ $ || &#60;.panic: Syntax error&#62; ] {*} }</p>

<p>rule external_declaration { | &#60;declaration&#62; {*} #= declaration | &#60;function_definition&#62; {*} #= function_definition }</p>

<p>rule function_definition { &#60;declaration_specifiers&#62; &#60;declarator&#62; &#60;declaration&#62;* &#60;compound_statement&#62; {*} }</p>

<p>## A.2.2 ##</p>

<p>rule declaration { &#60;declaration_specifiers&#62; [ &#60;init_declarator&#62; [&#39;,&#39; &#60;init_declarator&#62;]* ]?
&#39;;&#39; {*} }</p>

<p>rule declaration_specifiers { [ &#60;type_specifier&#62; | &#60;storage_class_specifier&#62; | &#60;type_qualifier&#62; | &#60;function_specifier&#62; ]+ }</p>

<p>rule function_specifier { &#39;inline&#39; }</p>

<p>rule init_declarator { &#60;declarator&#62; [&#39;=&#39; &#60;initializer&#62;]?
{*} }</p>

<p>rule storage_class_specifier { | &#39;typedef&#39; | &#39;extern&#39; | &#39;static&#39; | &#39;auto&#39; | &#39;register&#39; }</p>

<p>rule type_specifier { | &#60;builtin_type&#62; | &#60;struct_or_union_specifier&#62; | &#60;enum_specifier&#62; | &#60;typedef_name&#62; }</p>

<p>token builtin_type { | &#39;void&#39; | &#39;char&#39; | &#39;short&#39; | &#39;int&#39; | &#39;long&#39; | &#39;float&#39; | &#39;double&#39; | &#39;signed&#39; | &#39;unsigned&#39; | &#39;_Bool&#39; | &#39;_Complex&#39; | &#39;_Imaginary&#39; }</p>

<p>rule struct_or_union_specifier { $&#60;type&#62;=[&#39;struct&#39;|&#39;union&#39;] [ | &#60;struct_or_union_definition&#62; | &#60;pre_declaration&#62; ] }</p>

<p>rule struct_or_union_definition { &#60;identifier&#62;?
&#39;{&#39; &#60;struct_declaration&#62;+ &#39;}&#39; }</p>

<p>rule pre_declaration { &#60;identifier&#62; }</p>

<p>rule struct_declaration { &#60;specifier_qualifier_list&#62; &#60;struct_declarator_list&#62;* &#39;;&#39; }</p>

<p>rule specifier_qualifier_list { [ | &#60;type_specifier&#62; | &#60;type_qualifier&#62; ]+ }</p>

<p>rule struct_declarator_list { &#60;struct_declarator&#62; [&#39;,&#39; &#60;struct_declarator&#62;]* }</p>

<p>rule struct_declarator { | &#60;declarator&#62;?
&#39;:&#39; &#60;constant_expression&#62; | &#60;declarator&#62; }</p>

<p>rule enum_specifier { | &#39;enum&#39; &#60;identifier&#62;?
&#39;{&#39; &#60;enumerator_list&#62; [&#39;,&#39;]?
&#39;}&#39; | &#39;enum&#39; &#60;identifier&#62; }</p>

<p>rule enumerator_list { &#60;enumerator&#62; [&#39;,&#39; &#60;enumerator&#62;]* }</p>

<p>rule enumerator { &#60;enumeration_constant&#62; [&#39;=&#39; &#60;constant_expression&#62;]?
}</p>

<p>rule type_qualifier { $&#60;qualifier&#62;=[&#39;const&#39;|&#39;restrict&#39;|&#39;volatile&#39;] }</p>

<p>rule declarator { &#60;pointer&#62;?
&#60;direct_declarator&#62; {*} }</p>

<p>rule direct_declarator { &#60;declarator_prefix&#62; &#60;declarator_suffix&#62;* {*} }</p>

<p>rule declarator_prefix { | &#39;(&#39; &#60;declarator&#62; &#39;)&#39; {*} #= declarator | &#60;identifier&#62; {*} #= identifier }</p>

<p>rule declarator_suffix { | &#39;(&#39; &#60;parameter_type_list&#62; &#39;)&#39; {*} #= parameter_type_list ## old&#45;style C parameter declarations | &#39;(&#39; &#60;identifier_list&#62;?
&#39;)&#39; {*} #= identifier_list | &#39;[&#39; &#60;assignment_expression&#62;?
&#39;]&#39; | &#39;[&#39; &#39;*&#39; &#39;]&#39; }</p>

<p>rule pointer { &#39;*&#39; &#60;type_qualifier&#62;* [&#39;*&#39;]?
}</p>

<p>rule parameter_type_list { &#60;parameter_list&#62; [$&#60;vararg&#62;=[&#39;,&#39; &#39;...&#39;]]?
{*} }</p>

<p>rule parameter_list { &#60;parameter_declaration&#62; [&#39;,&#39; &#60;parameter_declaration&#62;]* {*} }</p>

<p>rule parameter_declaration { &#60;declaration_specifiers&#62; [ | &#60;declarator&#62; {*} #= declarator | &#60;abstract_declarator&#62;?
{*} #= abstract_declarator ] }</p>

<p>rule identifier_list { &#60;identifier&#62; [&#39;,&#39; &#60;identifier&#62;]* }</p>

<p>rule type_name { &#60;specifier_qualifier_list&#62; &#60;abstract_declarator&#62;?
}</p>

<p>rule abstract_declarator { | &#39;*&#39; | [&#39;*&#39;]?
&#60;direct_abstract_declarator&#62; }</p>

<p>rule direct_abstract_declarator { [ | &#39;(&#39; &#60;abstract_declatator&#62; &#39;)&#39; | &#39;[&#39; &#60;assignment_expression&#62;?
&#39;]&#39; | &#39;(&#39; &#60;parameter_type_list&#62; &#39;)&#39; ] &#60;direct_abstract_declarator_1&#62;* }</p>

<p>rule direct_abstract_declarator_1 { | &#39;[&#39; &#60;assignment_expression&#62;?
&#39;]&#39; | &#39;[&#39; &#39;*&#39; &#39;]&#39; | &#39;(&#39; &#60;parameter_type_list&#62; &#39;)&#39; }</p>

<p>rule typedef_name {</p>

<p>## a typedef name can be a return type specifier.
This is ambiguous,
because ## the parser doesn&#39;t know if it&#39;s a return type thingie or the name of the ## function.
Therefore,
typedef&#39;d names must be stored in a %hash,
so that ## this rule is not calling &#60;identifier&#62;,
but inspecting the registered ## typedef&#39;d names.
For now,
specify &#39;SOME_TYPEDEF_NAME&#39; as the only typedef&#39;d name.
## #&#60;identifier&#62; &#39;SOME_TYPEDEF_NAME&#39; }</p>

<p>rule initializer { | &#60;assignment_expression&#62; | &#39;{&#39; &#60;initializer_list&#62; [&#39;,&#39;]?
&#39;}&#39; }</p>

<p>rule initializer_list { &#60;initializer_item&#62; [&#39;,&#39; &#60;initializer_item&#62;]* }</p>

<p>rule initializer_item { &#60;designation&#62;?
&#60;initializer&#62; }</p>

<p>rule designation { &#60;designator&#62;+ &#39;=&#39; }</p>

<p>rule designator { | &#39;[&#39; &#60;constant_expression&#62; &#39;]&#39; | &#39;.&#39; &#60;identifier&#62; }</p>

<p>## A.2.3 Statements ##</p>

<p>rule statement { | &#60;labeled_statement&#62; | &#60;compound_statement&#62; {*} #= compound_statement | &#60;expression_statement&#62; {*} #= expression_statement | &#60;if_statement&#62; {*} #= if_statement | &#60;switch_statement&#62; | &#60;while_statement&#62; {*} #= while_statement | &#60;do_while_statement&#62; {*} #= do_while_statement | &#60;for1_statement&#62; {*} #= for1_statement | &#60;for2_statement&#62; {*} #= for2_statement | &#60;jump_statement&#62; {*} #= jump_statement }</p>

<p>rule labeled_statement { | &#60;identifier&#62; &#39;:&#39; &#60;statement&#62; | &#39;case&#39; &#60;constant_expression&#62; &#39;:&#39; &#60;statement&#62; | &#39;default&#39; &#39;:&#39; &#60;statement&#62; }</p>

<p>rule compound_statement { &#39;{&#39; &#60;block_item&#62;* &#39;}&#39; {*} }</p>

<p>rule block_item { | &#60;declaration&#62; {*} #= declaration | &#60;statement&#62; {*} #= statement }</p>

<p>rule expression_statement { &#60;expression&#62;?
&#39;;&#39; {*} }</p>

<p>rule if_statement { &#39;if&#39; &#39;(&#39; &#60;expression&#62; &#39;)&#39; &#60;statement&#62; [&#39;else&#39; $&#60;else&#62;=&#60;statement&#62;]?
{*} }</p>

<p>rule switch_statement { &#39;switch&#39; &#39;(&#39; &#60;expression&#62; &#39;)&#39; &#60;statement&#62; }</p>

<p>rule while_statement { &#39;while&#39; &#39;(&#39; &#60;expression&#62; &#39;)&#39; &#60;statement&#62; {*} }</p>

<p>rule do_while_statement { &#39;do&#39; &#60;statement&#62; &#39;while&#39; &#39;(&#39; &#60;expression&#62; &#39;)&#39; &#39;;&#39; {*} }</p>

<p>rule for1_statement { &#39;for&#39; &#39;(&#39; [$&#60;init&#62;=&#60;expression&#62;]?
&#39;;&#39; [$&#60;cond&#62;=&#60;expression&#62;]?
&#39;;&#39; [$&#60;step&#62;=&#60;expression&#62;]?
&#39;)&#39; &#60;statement&#62; {*} }</p>

<p>rule for2_statement { &#39;for&#39; &#39;(&#39; &#60;declaration&#62; [$&#60;cond&#62;=&#60;expression&#62;]?
&#39;;&#39; [$&#60;step&#62;=&#60;expression&#62;]?
&#39;)&#39; &#60;statement&#62; {*} }</p>

<p>rule jump_statement { | &#39;goto&#39; &#60;identifier&#62; &#39;;&#39; {*} #= goto | &#39;continue&#39; &#39;;&#39; {*} #= continue | &#39;break&#39; &#39;;&#39; {*} #= break | &#39;return&#39; &#60;expression&#62;?
&#39;;&#39; {*} #= return }</p>

<p>## A.1.1 Lexical elements ## ##rule token { ## | &#60;keyword&#62; ## | &#60;identifier&#62; ## | &#60;constant&#62; ## | &#60;c_string_literal&#62; ## | &#60;punctuator&#62; ##}</p>

<p>regex preprocessing_token { | &#60;header_name&#62; | &#60;identifier&#62; | &#60;pp_number&#62; | &#60;character_constant&#62; | &#60;string_literal&#62; | &#60;!pound&#62; &#60;punctuator&#62; | &#60;universal_character_name&#62; | &#60;&#45;[# \r\n\t]&#62;\S* ## &#60;&#45;[#]&#45;\S&#62;\S* ##non&#45;whitespace }</p>

<p>## A.1.2 Keywords ## token keyword { [ auto | enum | restrict | unsigned | break | extern | return | void | case | float | short | volatile | char | for | signed | while | const | goto | sizeof | _Bool | continue | if | static | _Complex | default | inline | struct | _Imaginary | do | int | switch | double | long | typedef | else | register | union ]&#62;&#62;</p>

<p>}</p>

<p>token reserved_word { &#60;keyword&#62; }</p>

<p>token identifier { &#60;!reserved_word&#62; &#60;identifier_nondigit&#62; [ &#60;identifier_nondigit&#62; | &#60;digit&#62; ]* {*} }</p>

<p>token identifier_nondigit { &#60;alpha&#62; | &#60;[_]&#62; | &#60;universal_character_name&#62; }</p>

<p>## A.1.4 Universal character names ## token universal_character_name { | &#39;\u&#39; &#60;xdigit&#62;**{4} | &#39;\U&#39; &#60;xdigit&#62;**{8} }</p>

<p>## A.1.5 Constants ## token constant { | &#60;floating_constant&#62; {*} #= floating_constant | &#60;integer_constant&#62; {*} #= integer_constant | &#60;enumeration_constant&#62; {*} #= enumeration_constant | &#60;character_constant&#62; {*} #= character_constant }</p>

<p>token integer_constant { [ &#60;decimal_constant&#62; | &#60;octal_constant&#62; | &#60;hexadecimal_constant&#62; ] &#60;integer_suffix&#62;?
{*} }</p>

<p>token decimal_constant { &#60;[1..9]&#62; &#60;digit&#62;* }</p>

<p>token octal_constant { 0 &#60;[0..7]&#62;* }</p>

<p>token hexadecimal_constant { 0 &#60;[xX]&#62; &#60;xdigit&#62;+ }</p>

<p>token integer_suffix { | &#60;[uU]&#62; [ll?|LL?]?
| [ll?|LL?] &#60;[uU]&#62;?
}</p>

<p>token floating_constant { [ | &#60;decimal_floating_constant&#62; | &#60;hexadecimal_floating_constant&#62; ] {*} }</p>

<p>token decimal_floating_constant { [ | &#60;fractional_constant&#62; &#60;exponent_part&#62;?
| &#60;digit_sequence&#62; &#60;exponent_part&#62; ] &#60;floating_suffix&#62;?
}</p>

<p>token hexadecimal_prefix { 0 &#60;[xX]&#62; }</p>

<p>token hexadecimal_floating_constant { &#60;hexadecimal_prefix&#62; [ | &#60;hexadecimal_fractional_constant&#62; | &#60;hexadecimal_digit_constant&#62; ] &#60;binary_exponent_part&#62; &#60;floating_suffix&#62;?
}</p>

<p>token fractional_constant { | &#60;digit_sequence&#62;?
\.
&#60;digit_sequence&#62; | &#60;digit_sequence&#62; \.
}</p>

<p>token exponent_part { &#60;[eE]&#62; [&#39;+&#39;|&#39;&#45;&#39;]?
&#60;digit_sequence&#62; }</p>

<p>token digit_sequence { &#60;digit&#62;+ }</p>

<p>token hexadecimal_fractional_constant { | &#60;hexadecimal_digit_sequence&#62;?
\.
&#60;hexadecimal_digit_sequence&#62; | &#60;hexadecimal_digit_sequence&#62; \.
}</p>

<p>token binary_exponent_part { &#60;[pP]&#62; [&#39;+&#39;|&#39;&#45;&#39;]?
&#60;digit_sequence&#62; }</p>

<p>token hexadecimal_digit_sequence { &#60;xdigit&#62;+ }</p>

<p>token floating_suffix { &#60;[fFlL]&#62; }</p>

<p>token enumeration_constant { &#60;identifier&#62; }</p>

<p>token character_constant { [L]?
\&#39; &#60;c_char&#62;+ \&#39; }</p>

<p>token &#60;c_char&#62; { &#60;&#45;[&#39;\\\n]&#62; | &#60;escape_sequence&#62; }</p>

<p>token escape_sequence { \\ [ &#60;[&#39;&#34;?\\abfnrtv]&#62; | &#60;octal_digit&#62;**{1..3} | x &#60;xdigit&#62;+ | &#60;universal_character_name&#62; ] }</p>

<p>## A.1.6 String literals token c_string_literal { [L]?
&#60;string_literal: &#39;&#34;&#39;&#62; {*} }</p>

<p>##\&#34; &#60;s_char&#62;* \&#34;</p>

<p>token s_char { &#60;&#45;[&#34;\\\n]&#62; | &#60;escape_sequence&#62; }</p>

<p>## A.2 Phrase structure grammar ##</p>

<p>## A.2.1 Expressions ##</p>

<p>rule constant_expression { &#60;conditional_expression&#62; {*} }</p>

<p>rule expression { &#60;assignment_expression&#62; [&#39;,&#39; &#60;assignment_expression&#62;]* {*} }</p>

<p>rule assignment_expression { [&#60;unary_expression&#62; &#60;assign_op&#62;]* &#60;conditional_expression&#62; {*} }</p>

<p>rule assign_op { &#39;=&#39;|&#39;*=&#39;|&#39;/=&#39;|&#39;%=&#39;|&#39;+=&#39;|&#39;&#45;=&#39;|&#39;&#60;&#60;=&#39;|&#39;&#62;&#62;=&#39;|&#39;&#38;=&#39;|&#39;^=&#39;|&#39;|=&#39; }</p>

<p>rule conditional_expression { &#60;logical_expression&#62; [&#39;?&#39; &#60;expression&#62; &#39;:&#39; &#60;conditional_expression&#62;]?
{*} }</p>

<p>rule logical_expression is optable { ...
}</p>

<p>proto &#39;infix:||&#39; is precedence(&#39;1&#39;) { ...
}</p>

<p>proto &#39;infix:&#38;&#38;&#39; is tighter(&#39;infix:||&#39;) { ...
}</p>

<p>proto &#39;infix:|&#39; is tighter(&#39;infix:&#38;&#38;&#39;) { ...
}</p>

<p>proto &#39;infix:^&#39; is tighter(&#39;infix:|&#39;) { ...
}</p>

<p>proto &#39;infix:&#38;&#39; is tighter(&#39;infix:^&#39;) { ...
}</p>

<p>proto &#39;infix:==&#39; is tighter(&#39;infix:&#38;&#39;) { ...
} proto &#39;infix:!=&#39; is equal(&#39;infix:==&#39;) { ...
}</p>

<p>proto &#39;infix:&#60;&#39; is tighter(&#39;infix:==&#39;) { ...
} proto &#39;infix:&#62;&#39; is equal(&#39;infix:&#60;&#39;) { ...
} proto &#39;infix:&#62;=&#39; is equal(&#39;infix:&#60;&#39;) { ...
} proto &#39;infix:&#60;=&#39; is equal(&#39;infix:&#60;&#39;) { ...
}</p>

<p>proto &#39;infix:&#60;&#60;&#39; is tighter(&#39;infix:==&#39;) { ...
} proto &#39;infix:&#62;&#62;&#39; is equal(&#39;infix:&#60;&#60;&#39;) { ...
}</p>

<p>proto &#39;infix:+&#39; is tighter(&#39;infix:&#60;&#60;&#39;) is pirop(&#39;n_add&#39;) { ...
} proto &#39;infix:&#45;&#39; is equal(&#39;infix:+&#39;) is pirop(&#39;n_sub&#39;) { ...
}</p>

<p>proto &#39;infix:*&#39; is tighter(&#39;infix:+&#39;) is pirop(&#39;n_mul&#39;) { ...
} proto &#39;infix:/&#39; is equal(&#39;infix:*&#39;) is pirop(&#39;n_div&#39;) { ...
} proto &#39;infix:%&#39; is equal(&#39;infix:*&#39;) is pirop(&#39;n_mod&#39;) { ...
}</p>

<p>proto &#39;term:&#39; is tighter(&#39;infix:*&#39;) is parsed(&#38;cast_expression) { ...
}</p>

<p>rule postfix_expression_prefix { | &#60;primary_expression&#62; {*} #= primary_expression | &#39;(&#39; &#60;type_name&#62; &#39;)&#39; &#39;{&#39; &#60;initializer_list&#62; [&#39;,&#39;]?
&#39;}&#39; {*} #= type_name }</p>

<p>rule postfix_expression { &#60;postfix_expression_prefix&#62; &#60;postfix_expression_suffix&#62;* {*} }</p>

<p>rule postfix_expression_suffix { | &#60;index&#62; {*} #= index | &#60;arguments&#62; {*} #= arguments | &#60;direct_field&#62; {*} #= direct_field | &#60;indirect_field&#62; {*} #= indirect_field | &#60;inc_or_dec&#62; {*} #= inc_or_dec }</p>

<p>rule inc_or_dec { $&#60;op&#62;=[&#39;++&#39;|&#39;&#45;&#45;&#39;] {*} }</p>

<p>rule index { &#39;[&#39; &#60;expression&#62; &#39;]&#39; {*} }</p>

<p>rule direct_field { &#39;.&#39; &#60;identifier&#62; {*} }</p>

<p>rule indirect_field { &#39;&#45;&#62;&#39; &#60;identifier&#62; {*} }</p>

<p>rule arguments { &#39;(&#39; &#60;argument_expression_list&#62;?
&#39;)&#39; {*} }</p>

<p>rule argument_expression_list { &#60;assignment_expression&#62; [&#39;,&#39; &#60;assignment_expression&#62;]* {*} }</p>

<p>rule unary_expression { | &#60;postfix_expression&#62; {*} #= postfix_expression | &#60;prefix_expression&#62; {*} #= prefix_expression | &#60;unary_operator&#62; &#60;cast_expression&#62; | &#39;sizeof&#39; &#60;unary_expression&#62; | &#39;sizeof&#39; &#39;(&#39; &#60;type_name&#62; &#39;)&#39; }</p>

<p>rule prefix_expression { $&#60;op&#62;=[&#39;++&#39;|&#39;&#45;&#45;&#39;] &#60;unary_expression&#62; {*} }</p>

<p>rule unary_operator { &#39;&#38;&#39; | &#39;*&#39; | &#39;+&#39; | &#39;&#45;&#39; | &#39;~&#39; | &#39;!&#39; }</p>

<p>rule cast_expression { [&#39;(&#39; &#60;type_name&#62; &#39;)&#39;]* &#60;unary_expression&#62; {*} }</p>

<p>rule primary_expression { | &#60;identifier&#62; {*} #= identifier | &#60;constant&#62; {*} #= constant | &#60;c_string_literal&#62; {*} #= c_string_literal | &#39;(&#39; &#60;expression&#62; &#39;)&#39; {*} #= expression }</p>

<p>token ws { [ | &#39;//&#39; \N* \n | &#39;/*&#39; .*?
&#39;*/&#39; | \s+ | &#39;#&#39; \N* \n ]* }</p>

<p>## A.1.7 Punctuators ##</p>

<p>token punctuator { | \[ | \] | &#60;[(){}.]&#62; | &#39;&#45;&#62;&#39; | &#39;++&#39; | &#39;&#45;&#45;&#39; | &#60;[&#38;*+\&#45;~!/%]&#62; | &#39;&#60;&#60;&#39; | &#39;&#62;&#62;&#39; | &#39;&#60;&#39; | &#39;&#62;&#39; | &#39;&#60;=&#39; | &#39;&#62;=&#39; | &#39;==&#39; | &#39;!=&#39; | &#60;[^|]&#62; | &#39;&#38;&#38;&#39; | &#39;||&#39; | &#60;[?:;]&#62; | &#39;...&#39; | &#60;[*/%+\&#45;&#38;^|]&#62; | &#39;&#60;&#60;&#39; | &#39;&#62;&#62;&#39; | &#39;=&#39; | &#60;[,#]&#62; | &#39;##&#39; | &#39;&#60;:&#39; | &#39;:&#62;&#39; | &#39;&#60;%&#39; | &#39;%&#62;&#39; | &#39;%:&#39; | &#39;%:%:&#39; }</p>

<p>## A.3 Preprocessing directives ##</p>

<p>rule pre_processing_file { &#60;group&#62;?
}</p>

<p>rule group { &#60;group_part&#62;+ }</p>

<p>rule group_part { | &#60;pp_tokens&#62;?
&#60;newline&#62; | &#60;if_section&#62; | &#60;control_line&#62; }</p>

<p>rule if_section { &#60;if_group&#62; &#60;elif_group&#62;* &#60;else_group&#62;?
&#60;endif_line&#62; }</p>

<p>rule if_group { | &#39;#&#39; &#39;if&#39; &#60;constant_expression&#62; &#60;newline&#62; &#60;group&#62;?
| &#39;#&#39; &#39;ifdef&#39; &#60;identifier&#62; &#60;newline&#62; &#60;group&#62;?
| &#39;#&#39; &#39;ifndef&#39; &#60;identifier&#62; &#60;newline&#62; &#60;group&#62;?
}</p>

<p>rule elif_group { &#39;#&#39; &#39;elif&#39; &#60;constant_expression&#62; &#60;newline&#62; &#60;group&#62;?
}</p>

<p>rule else_group { &#39;#&#39; &#39;else&#39; &#60;newline&#62; &#60;group&#62;?
}</p>

<p>rule endif_line { &#39;#&#39; &#39;endif&#39; &#60;newline&#62; }</p>

<p>rule control_line { | &#39;#&#39; &#39;include&#39; &#60;pp_tokens&#62; &#60;newline&#62; | &#39;#&#39; &#39;define&#39; &#60;identifier&#62; &#60;replacement_list&#62; &#60;newline&#62; | &#39;#&#39; &#39;define&#39; &#60;identifier&#62; &#60;lparen&#62; &#60;identifier_list&#62;?
&#39;)&#39; &#60;replacement_list&#62; &#60;newline&#62; | &#39;#&#39; &#39;define&#39; &#60;identifier&#62; &#60;lparen&#62; &#39;...&#39; &#39;)&#39; &#60;replacement_list&#62; &#60;newline&#62; | &#39;#&#39; &#39;define&#39; &#60;identifier&#62; &#60;lparen&#62; &#60;identifier_list&#62; &#39;,&#39; &#39;...&#39; &#39;)&#39; &#60;replacement_list&#62; &#60;newline&#62; | &#39;#&#39; &#39;undef&#39; &#60;identifier&#62; &#60;newline&#62; | &#39;#&#39; &#39;line&#39; &#60;pp_tokens&#62; &#60;newline&#62; | &#39;#&#39; &#39;error&#39; &#60;pp_tokens&#62;?
&#60;newline&#62; | &#39;#&#39; &#39;pragma&#39; &#60;pp_tokens&#62;?
&#60;newline&#62; | &#39;#&#39; &#60;newline&#62; }</p>

<p>rule pp_tokens { &#60;preprocessing_token&#62;+ }</p>

<p>rule preprocessing_token { | &#60;header_name&#62; | &#60;identifier&#62; | &#60;pp_number&#62; | &#60;character_constant&#62; | &#60;c_string_literal&#62; | &#60;punctuator&#62; }</p>

<p>rule pp_number { [&#39;.&#39;]?
&#60;digit&#62; &#60;pp_number_suffix&#62;* }</p>

<p>rule pp_number_suffix { | &#39;.&#39; | &#60;identifier_nondigit&#62; | &#60;digit&#62; | &#60;[eEpP]&#62; [&#39;+&#39;|&#39;&#45;&#39;] }</p>

<p>rule replacement_list { &#60;pp_tokens&#62;?
}</p>

<p>token lparen { &#39;(&#39; }</p>

<p>token newline { \n }</p>

<p>## A.1.8 Header names token header_name { | \&#60; &#60;h_char&#62;+ \&#62; | \&#34; &#60;q_char&#62;+ \&#34; }</p>

<p>token h_char { &#60;&#45;[\n&#62;]&#62; } token q_char { &#60;&#45;[\n&#34;]&#62; }</p>
            </div> <!-- "mainbody" -->
            <div id="divider"></div>
            <div id="footer">
	        Copyright &copy; 2002-2009, Parrot Foundation.
            </div>
        </div> <!-- "wrapper" -->
    </body>
</html>
