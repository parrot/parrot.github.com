<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>Parrot class representing surfaces in Parrot SDL</title>
        <link rel="stylesheet" type="text/css"
            href="../../../../../resources/parrot.css"
            media="all">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    </head>
    <body>
        <div id="wrapper">
            <div id="header">

                <img border=0 src="../../../../../resources/parrot_logo.png" id="logo" alt="parrot">
            </div> <!-- "header" -->
            <div id="divider"></div>
            <div id="mainbody">
                <div id="breadcrumb">
                    <a href="../../../../../html/index.html">Contents</a> &raquo; <a href="../../../../../html/libs.html">Libraries</a> &raquo; Parrot class representing surfaces in Parrot SDL
                </div>

<h1><a name="NAME"
>NAME</a></h1>

<p>SDL::Surface &#45; Parrot class representing surfaces in Parrot SDL</p>

<h1><a name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>    # load this library
    load_bytecode &#39;library/SDL/Surface.pir&#39;

    # create a new SDL::Surface object
    surface = new &#39;SDL::Surface&#39;
    surface.&#39;init&#39;( &#39;height&#39; =&#62; 480, &#39;width&#39; =&#62; 640 )

    # ... blit to, fill, update, and flip this surface as necessary</pre>

<h1><a name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>A SDL::Surface object represents a surface in SDL. All drawing operations draw to a surface (and most draw from a surface). You&#39;ll likely not instantiate this class directly, but all SDL::Image and SDL::Sprite objects operate on objects of this class, and you&#39;ll receive an SDL::Surface from the SDL::App constructor.</p>

<h1><a name="METHODS"
>METHODS</a></h1>

<p>All SDL::Surface objects have the following methods:</p>

<dl>
<dt><a name="init(_surface_args_)"
>init( surface_args )</a></dt>
Given a list of key&#45;value pairs, the attributes of this surface. The valid keys are <code>height</code> and <code>width</code>, two integer values representing the height and width of this surface in pixels. Other keys are <code>depth</code>, the screen depth, <code>flags</code>, the SDL flags, and <code>r</code>, <code>g</code>, <code>b</code>, and <code>a</code>, representing the bit depth of each component.
<dt><a name="new_from_surface(_raw_surface_)"
>new_from_surface( raw_surface )</a></dt>
Given a <code>raw_surface</code> object, sometimes returned from raw SDL functions, create and return a new SDL::Surface object.I&#39;m not sure I like the name of this method. It may change. That may be okay; you have little reason to use it directly.
<dt><a name="height()"
>height()</a></dt>
Returns the height of this surface, in pixels. This is always an integer value.
<dt><a name="width()"
>width()</a></dt>
Returns the width of this surface, in pixels. This is always an integer value.
<dt><a name="fill_rect(_rect,_color_)"
>fill_rect( rect, color )</a></dt>
Given an SDL::Rect representing a portion of this surface and an SDL::Color representing a color, fills a portion of this surface with the given color.
<dt><a name="update_rect(_rect_)"
>update_rect( rect )</a></dt>
If this is a single&#45;buffered surface (unless you&#39;ve explicitly requested double buffering when intializing your SDL::App), updates the portion of this surface represented by the SDL::Rect.Do this on the main surface to see your changes.
<dt><a name="update_rects(_array_of_rects_)"
>update_rects( array_of_rects )</a></dt>
Updates multiple areas represented by SDL::Rect objects within this surface all at once. Pass in an <code>Array</code> of rects to update.
<dt><a name="flip()"
>flip()</a></dt>
Given a double&#45;buffered surface (if you&#39;ve explicitly enabled double&#45;buffering when creating your SDL::App), flips the back buffer (to which you draw, in that case) to the main buffer, so you can see it.
<dt><a name="blit(_source_surface,_source_rect,_destination_rect_)"
>blit( source_surface, source_rect, destination_rect )</a></dt>
Given a SDL::Surface to use as a source, a SDL::Rect representing the source within the source surface, and a SDL::Rect representing the destination within the current surface to which to draw, copies the appropriate region from the source to this surface.That&#39;s a terrible sentence, but after you try it once or twice, you&#39;ll understand.
<dt><a name="surface()"
>surface()</a></dt>
Returns the underlying surface this object represents. You should never need to use this directly.
<dt><a name="color_key(_color_)"
>color_key( color )</a></dt>
Sets the transparent pixel value for the surface. This signature may change, if I add flag options.
<dt><a name="bpp()"
>bpp()</a></dt>
Returns the bitdepth of the current surface.
<dt><a name="lock()"
>lock()</a></dt>
Locks the surface for raw pixel drawing. Call this before calling <code>draw_pixel()</code> or any other pixel operation. Be careful what else you do while you hold the lock.
<dt><a name="unlock()"
>unlock()</a></dt>
Unlocks the surface after you&#39;ve finished raw pixel operations.
<dt><a name="draw_pixel(_x,_y,_color_)"
>draw_pixel( x, y, color )</a></dt>
Draws a pixel at the position represented by integers <code>x</code> and <code>y</code> with the given SDL::Color <code>color</code>.If you want as much speed as possible, call <code>color_for_surface</code> on the SDL::Color and pass in the value you receive instead. This method will not have to perform a time&#45;consuming conversion. This is a classic tradeoff between memory and speed. Happily, colors are (reasonably cheap) integers at heart.
<dt><a name="pixels()"
>pixels()</a></dt>
Return the raw pixels array of the surface. It can be filled with raw colors like this:
<pre>  .local pmc surface, pixels
  .local int offset, x, y, raw_color
  pixels  = surface.&#39;pixels&#39;()
  offset  = surface.&#39;width&#39;()
  ...
  $I0 = offset * y
  $I0 .= x
  pixels[0; $I0] = raw_color       # pixels[&#39;array&#39;; $O] = raw_color</pre>
Please note that the function returns an UnManagedStruct pointing to an array, therefore the double indexing is needed.See also <b>draw_pixels()</b> above for locking/unlocking the surface and how to fetch raw colors.
<dt><a name="convert_red()"
>convert_red()</a></dt>
A helper method to convert the red component of any color to work with this surface.
<dt><a name="convert_green()"
>convert_green()</a></dt>
A helper method to convert the green component of any color to work with this surface.
<dt><a name="convert_blue()"
>convert_blue()</a></dt>
A helper method to convert the blue component of any color to work with this surface.</dl>

<h1><a name="AUTHOR"
>AUTHOR</a></h1>

<p>Written and maintained by chromatic, &#60;chromatic at wgz dot org&#62;, with suggestions from Jens Rieks. Please send patches, feedback, and suggestions to the Perl 6 Internals mailing list.</p>

<h1><a name="COPYRIGHT"
>COPYRIGHT</a></h1>

<p>Copyright (C) 2004&#45;2008, Parrot Foundation.</p>
            </div> <!-- "mainbody" -->
            <div id="divider"></div>
            <div id="footer">
	        Copyright &copy; 2002-2009, Parrot Foundation.
            </div>
        </div> <!-- "wrapper" -->
    </body>
</html>
