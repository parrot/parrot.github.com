<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Parrot I/O</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Parrot I/O</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../html/index.html">Contents</a> | <a href="../../../html/docs.html">Documentation</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>docs/pdds/pdd22_io.pod &#45; Parrot I/O</p>

<h1><a name="ABSTRACT"
>ABSTRACT <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Parrot&#39;s I/O subsystem.</p>

<h1><a name="VERSION"
>VERSION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>$Revision$</p>

<h1><a name="DEFINITIONS"
>DEFINITIONS <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>A &#34;stream&#34; allows input or output operations on a source/destination such as a file,
keyboard,
or text console.
Streams are also called &#34;filehandles&#34;,
though only some of them have anything to do with files.</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<dl>
<dt><a name="&#45;_Parrot_I/O_objects_support_both_streams_and_network_I/O."
>&#45; Parrot I/O objects support both streams and network I/O.</a></dt><p class="pad"></p>

<dt><a name="&#45;_Parrot_has_both_synchronous_and_asynchronous_I/O_operations."
>&#45; Parrot has both synchronous and asynchronous I/O operations.</a></dt><p class="pad"></p>

<dt><a name="&#45;_Asynchronous_operations_must_interact_safely_with_Parrot&#39;s_other_concurrency_models."
>&#45; Asynchronous operations must interact safely with Parrot&#39;s other concurrency models.</a></dt><p class="pad"></p>
</dl>

<h1><a name="IMPLEMENTATION"
>IMPLEMENTATION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<h2><a name="Composition"
>Composition <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Currently,
the Parrot I/O subsystem uses a per&#45;interpreter stack to provide a layer&#45;based approach to I/O.
Each layer implements a subset of the <code lang='und' xml:lang='und'>ParrotIOLayerAPI</code> vtable.
To find an I/O function,
the layer stack is searched downwards until a non&#45;NULL function pointer is found for that particular slot.
This implementation will be replaced with a composition model.
Rather than living in a stack,
the module fragments that make up the ParrotIO class will be composed and any conflicts resolved when the class is loaded.
This strategy eliminates the need to search a stack on each I/O call,
while still allowing a &#34;layered&#34; combination of functionality for different platforms.</p>

<h2><a name="Concurrency_Model_for_Asynchronous_I/O"
>Concurrency Model for Asynchronous I/O <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Currently,
Parrot only implements synchronous I/O operations.
For the 1.0 release the asynchronous operations will be implemented separately from the synchronous ones.
There may be an implementation that uses one variant to implement the other someday,
but it&#39;s not an immediate priority.</p>

<p>Synchronous opcodes are differentiated from asynchronous opcodes by the presence of a callback argument in the asynchronous calls.
Asynchronous calls that don&#39;t supply callbacks (perhaps if the user wants to manually check later if the operation succeded) are enough of a fringe case that they don&#39;t need opcodes.
They can access the functionality via methods on ParrotIO objects.</p>

<p>The asynchronous I/O implementation will use the composition model to allow some platforms to take advantage of their built&#45;in asynchronous operations,
layered behind Parrot&#39;s asynchronous I/O interface.</p>

<p>Asynchronous operations use a lightweight concurrency model.
At the user level,
Parrot follows the callback function model of asynchronous I/O.
At the interpreter level,
each asynchronous operation registers a task with the interpreter&#39;s concurrency scheduler.
The registered task could represent a simple Parrot asynchronous I/O operation,
a platform&#45;native asynchronous I/O call,
or even synchronous code in a full Parrot thread (rare but possibly useful for prototyping new features,
or for mock objects in testing).</p>

<p>Communication between the calling code and the asynchronous operation task is handled by a shared status object.
The operation task updates the status object whenever the status changes,
and the calling code can check the status object at any time.
The status object contains a reference to the returned result of an asynchronous I/O call.
In order to allow sharing of the status object,
asynchronous ops both pass the status object to the callback PMC,
and return it to the calling code.</p>

<p>The lightweight tasks typically used by the asynchronous I/O system capture no state other than the arguments passed to the I/O call,
and share no variables with the calling code other than the status object.</p>

<p>[See <a href='http://en.wikipedia.org/wiki/Asynchronous_I/O'><a href="http://en.wikipedia.org/wiki/Asynchronous_I/O">http://en.wikipedia.org/wiki/Asynchronous_I/O</a></a>,
for a relatively comprehensive list of asynchronous I/O implementation options.]</p>

<h2><a name="I/O_PMC_API"
>I/O PMC API <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Methods</p>

<p>[Over and over again throughout this section,
I keep wanting an API that isn&#39;t possible with current low&#45;level PMCs.
This could mean that low&#45;level PMCs need a good bit of work to gain the same argument passing capabilities as higher&#45;level Parrot objects (which is true,
long&#45;term).
It could mean that Parrot I/O objects would be better off defined in a higher&#45;level syntax,
with embedded C (via NCI,
or a lighter&#45;weight embedding mechanism) for those pieces that really are direct C access.
Or,
it could mean that I&#39;ll come back and rip this interface down to a bare minimum.]</p>

<dl>
<dt><a name="new"
><b><code lang='und' xml:lang='und'>new</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  $P0 = new ParrotIO</pre>

<dd>Creates a new I/O stream object. [Note that this is usually performed via the <code lang='und' xml:lang='und'>open</code> opcode.]</dd><p class="pad"></p>

<dt><a name="open"
><b><code lang='und' xml:lang='und'>open</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  $P0 = $P1.open()
  $P0 = $P1.open($S2)
  $P0 = $P1.open($S2, $S3)</pre>

<dd>Opens a stream on an existing I/O stream object, and returns a status object. With no arguments, it can be used to reopen a previously opened I/O stream. $S2 is a file path and $S3 is an optional mode for the stream (read, write, read/write, etc), using the same format as the <code lang='und' xml:lang='und'>open</code> opcode: &#39;r&#39; for read, &#39;w&#39; for write, &#39;a&#39; for append, and &#39;p&#39; for pipe. When the mode is set to write or append, a file is created without warning if none exists. When the mode is read (without write), a nonexistent file is an error.</dd><p class="pad"></p>

<dd>The asynchronous version takes a PMC callback as an additional final argument. When the open operation is complete, it invokes the callback with a single argument: a status object containing the opened stream object.</dd><p class="pad"></p>

<dt><a name="close"
><b><code lang='und' xml:lang='und'>close</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  $P0 = $P1.close()
  $P0 = $P1.close($P2)</pre>

<dd>Closes an I/O stream, but leaves destruction of the I/O object to the GC. The <code lang='und' xml:lang='und'>close</code> method returns a PMC status object.</dd><p class="pad"></p>

<dd>The asynchronous version takes an additional final PMC callback argument $P1. When the close operation is complete, it invokes the callback, passing it a status object. [There&#39;s not really much advantage in this over just leaving the object for the GC to clean&#45;up, but it does give you the option of executing an action when the stream has been closed.]</dd><p class="pad"></p>

<dt><a name="print"
><b><code lang='und' xml:lang='und'>print</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  $P0 = $P1.print($I2)
  $P0 = $P1.print($N2)
  $P0 = $P1.print($S2)
  $P0 = $P1.print($P2)
  $P0 = $P1.print($I2, $P3)
  $P0 = $P1.print($N2, $P3)
  $P0 = $P1.print($S2, $P3)
  $P0 = $P1.print($P2, $P3)</pre>

<dd>Writes an integer, float, string, or PMC value to an I/O stream object. Returns a PMC status object.</dd><p class="pad"></p>

<dd>The asynchronous version takes an additional final PMC callback argument $P2. When the print operation is complete, it invokes the callback, passing it a status object.</dd><p class="pad"></p>

<dt><a name="read"
><b><code lang='und' xml:lang='und'>read</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  $S0 = $P1.read($I2)
  $P0 = $P1.read($I2, $P3)</pre>

<dd>Retrieves a specified number of bytes $I2, from a stream $P1 into a string $S0. By default it reads in bytes, but the ParrotIO object can be configured to read in code points instead, by applying a <code lang='und' xml:lang='und'>utf8</code> or similar role to the object [the syntax for applying a role to an object has yet to be defined in PDD 15]. If there are fewer bytes remaining in the stream than specified in the read request, it returns the remaining bytes (with no error).</dd><p class="pad"></p>

<dd>The asynchronous version takes an additional final PMC callback argument $P3, and only returns a status object $P0. When the read operation is complete, it invokes the callback, passing it a status object. The status object contains the return value: a string that may be in bytes or codepoints depending on the read mode of the I/O object. [The callback doesn&#39;t need to know the read mode of the original operation, as the information about the character encoding of the return value is contained in the string.]</dd><p class="pad"></p>

<dt><a name="readline"
><b><code lang='und' xml:lang='und'>readline</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  $S0 = $P1.readline()
  $P0 = $P1.readline($P2)</pre>

<dd>Retrieves a single line from a stream $P1 into a string $S1. Calling <code lang='und' xml:lang='und'>readline</code> flags the stream as operating in line&#45;buffer mode (see the <code lang='und' xml:lang='und'>buffer_type</code> method below). The <code lang='und' xml:lang='und'>readline</code> operation respects the read mode of the I/O object the same as <code lang='und' xml:lang='und'>read</code> does. Newlines are not removed from the end of the string.</dd><p class="pad"></p>

<dd>The asynchronous version takes an additional final PMC callback argument $P2, and only returns a status object $P0. When the readline operation is complete, it invokes the callback, passing it a status object and a string of bytes.</dd><p class="pad"></p>

<dt><a name="record_separator"
><b><code lang='und' xml:lang='und'>record_separator</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  $S0 = $P1.record_separator()
  $P0.record_separator($S1)</pre>

<dd>Accessor (get and set) for the I/O stream&#39;s record separator attribute. The default value is a newline (CR, LF, CRLF, etc. depending on the platform).</dd><p class="pad"></p>

<dt><a name="buffer_type"
><b><code lang='und' xml:lang='und'>buffer_type</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  $I0 = $P1.buffer_type()
  $S0 = $P1.buffer_type()
  $P0.buffer_type($I1)
  $P0.buffer_type($S1)</pre>

<dd>Accessor (get and set) for the I/O stream&#39;s buffer type attribute. The attribute is returned as an integer value of one of the following constants, or a string value of &#39;unbuffered&#39;, &#39;line&#45;buffered&#39;, or &#39;full&#45;buffered&#39;.</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  0    PIO_NONBUF
           Unbuffered I/O. Bytes are sent as soon as possible.
  1    PIO_LINEBUF
           Line buffered I/O. Bytes are sent when a record separator is
           encountered.
  2    PIO_FULLBUF
           Fully buffered I/O. Bytes are sent when the buffer is full.
           [Note, the constant was called &#34;BLKBUF&#34; because bytes are
           sent as a block, but line buffering also sends them as a
           block, so changed to &#34;FULLBUF&#34;.]</pre>

<dt><a name="buffer_size"
><b><code lang='und' xml:lang='und'>buffer_size</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  $I0 = $P1.buffer_size()
  $P0.buffer_size($I1)</pre>

<dd>Accessor (get and set) for the I/O stream&#39;s buffer size attribute. The size is specified in bytes (positive integer value), though the buffer may hold a varying number of characters when dealing with an encoding of multi&#45;byte codepoints. The role that implements the handling of a particular character set must provide the logic that marks the buffer as &#34;full&#34; when it can&#39;t hold the next codepoint even if there are empty bytes in the buffer.</dd><p class="pad"></p>

<dd>The buffer size can be set no matter what buffering mode is in use, but it&#39;s only relevant when in line buffering or full buffering mode (and line buffering mode will rarely reach the maximum buffer size).</dd><p class="pad"></p>

<dd>It is recommended to only change the buffer size before starting IO operations, or after flushing the buffer. If the new size is larger than the existing data in the buffer, a size change is non&#45;disruptive, but if the new size is smaller, it will truncate the buffer with a warning.</dd><p class="pad"></p>

<dt><a name="get_fd_[RT_#48312]"
><b><code lang='und' xml:lang='und'>get_fd</b></code> [RT #48312]</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  $I0 = $P1.get_fd()</pre>

<dd>For stream objects that are simple wrappers around a Unix filehandle, <code lang='und' xml:lang='und'>get_fd</code> retrieves the Unix integer file descriptor of the object. This method doesn&#39;t exist on stream objects that aren&#39;t Unix filehandles, so check <code lang='und' xml:lang='und'>does</code> for the appropriate role, or <code lang='und' xml:lang='und'>can</code> for the method before calling it.</dd><p class="pad"></p>

<dd>No asynchronous version.</dd><p class="pad"></p>

<dd>{{ NOTE: use a config probe (behind <code lang='und' xml:lang='und'>does</code> or <code lang='und' xml:lang='und'>can</code>) to determine support }}</dd><p class="pad"></p>
</dl>

<h2><a name="Status_Object_PMC_API"
>Status Object PMC API <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="get_integer_(vtable)"
><b><code lang='und' xml:lang='und'>get_integer</b></code> (vtable)</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  $I0 = $P1</pre>

<dd>Returns an integer status for the status object, 1 for successful completion, &#45;1 for an error, and 0 while still running. [Discuss: This is largely to preserve current expectations of &#45;1 for an error. If we move away from that, is there a better representation?]</dd><p class="pad"></p>

<dt><a name="get_bool_(vtable)"
><b><code lang='und' xml:lang='und'>get_bool</b></code> (vtable)</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  if $P0 goto ...</pre>

<dd>Returns a boolean status for the status object, <code lang='und' xml:lang='und'>true</code> for successful completion or while still running, <code lang='und' xml:lang='und'>false</code> for an error.</dd><p class="pad"></p>

<dt><a name="return"
><b><code lang='und' xml:lang='und'>return</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  $P0 = $P1.return()</pre>

<dd>Retrieves the return value of the asynchronous operation from the status object. Returns a NULL PMC while still running, or if the operation had no return value.</dd><p class="pad"></p>

<dt><a name="error"
><b><code lang='und' xml:lang='und'>error</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  $P0 = $P1.error()</pre>

<dd>Retrieves the error object from the status object, if the execution of the asynchronous operation terminated with an error. The error object is derived from Exception, and can be thrown from the callback. If there was no error, or the asynchronous operation is still running, returns a null PMC.</dd><p class="pad"></p>

<dt><a name="throw"
><b><code lang='und' xml:lang='und'>throw</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  $P0.throw()</pre>

<dd>Throw an exception from the status object if it contains an error object, otherwise do nothing.</dd><p class="pad"></p>
</dl>

<h2><a name="I/O_Iterator_PMC_API"
>I/O Iterator PMC API <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>[Implementation NOTE: this may either be the default Iterator object applied to a ParrotIO object, a separate Iterator object for I/O objects, or an Iterator role applied to I/O objects.]</p>

<dl>
<dt><a name="new"
><b><code lang='und' xml:lang='und'>new</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>    new $P0, &#39;Iterator&#39;, $P1</pre>

<dd>Create a new iterator object $P0 from I/O object $P1.</dd><p class="pad"></p>

<dt><a name="shift"
><b><code lang='und' xml:lang='und'>shift</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>      shift $S0, $P1</pre>

<dd>Retrieve the next line/block $S0 from the I/O iterator $P1. The amount of data retrieved in each iteration is determined by the I/O object&#39;s <code lang='und' xml:lang='und'>buffer_type</code> setting: unbuffered, line&#45;buffered, or fully&#45;buffered.</dd><p class="pad"></p>

<dt><a name="get_bool_(vtable)"
><b><code lang='und' xml:lang='und'>get_bool</b></code> (vtable)</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  unless $P0 goto iter_end</pre>

<dd>Returns a boolean value for the iterator, <code lang='und' xml:lang='und'>true</code> if there is more data to pull from the I/O object, <code lang='und' xml:lang='und'>false</code> if the iterator has reached the end of the data. [NOTE: this means that an iterator always checks for the next line/block of data when it retrieves the current one.]</dd><p class="pad"></p>
</dl>

<h2><a name="I/O_Opcodes"
>I/O Opcodes <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>The signatures for the asynchronous operations are nearly identical to the synchronous operations, but the asynchronous operations take an additional argument for a callback, and the only return value from the asynchronous operations is a status object. When the callbacks are invoked, they are passed the status object as their sole argument. Any return values from the operation are stored within the status object.</p>

<p>The listing below says little about whether the opcodes return error information. For now assume that they can either return a status object, or return nothing. Error handling is discussed more thoroughly below in <a href='#Error_Handling'>&#34;Error Handling&#34;</a>.</p>

<h2><a name="I/O_Stream_Opcodes"
>I/O Stream Opcodes <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<h3><a name="Opening_and_closing_streams"
>Opening and closing streams</a></h3>

<dl>
<dt><a name="open"
><b><code lang='und' xml:lang='und'>open</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  $P0 = open $S1
  $P0 = open $S1, $S2
  $P0 = open $P1
  $P0 = open $P1, $S2</pre>

<dd>Opens a stream object based on a file path in $S1 and returns it. The stream object defaults to read/write mode. The optional string argument $S2 specifies the mode of the stream (read, write, append, read/write, etc.). Currently the mode of the stream is set with a string argument similar to Perl 5 syntax, but a language&#45;agnostic mode string is preferable, using &#39;r&#39; for read, &#39;w&#39; for write, &#39;a&#39; for append, and &#39;p&#39; for pipe.</dd><p class="pad"></p>

<dd>The asynchronous version takes a PMC callback as an additional final argument. When the open operation is complete, it invokes the callback with a single argument: a status object containing the opened stream object.</dd><p class="pad"></p>

<dt><a name="close"
><b><code lang='und' xml:lang='und'>close</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  close $P0
  close $P0, $P1</pre>

<dd>Closes a stream object. It takes a single string object argument and returns a status object.</dd><p class="pad"></p>

<dd>The asynchronous version takes an additional final PMC callback argument. When the close operation is complete, it invokes the callback, passing it a status object.</dd><p class="pad"></p>
</dl>

<h3><a name="Retrieving_existing_streams"
>Retrieving existing streams</a></h3>

<p>These opcodes do not have asynchronous variants.</p>

<ul>
<li><code lang='und' xml:lang='und'>getstdin</code>, <code lang='und' xml:lang='und'>getstdout</code>, and <code lang='und' xml:lang='und'>getstderr</code> return a stream object for standard input, standard output, and standard error, respectively.</li><p class="pad"></p>

<li><code lang='und' xml:lang='und'>fdopen</code> converts an existing and already open UNIX integer file descriptor into a stream object. It also takes a string argument to specify the mode.</li><p class="pad"></p>
</ul>

<h3><a name="Writing_to_streams"
>Writing to streams</a></h3>

<dl>
<dt><a name="print"
><b><code lang='und' xml:lang='und'>print</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  print $I0
  print $N0
  print $S0
  print $P0
  print $P0, $I1
  print $P0, $N1
  print $P0, $S1
  print $P0, $P1
  print $P0, $I1, $P2
  print $P0, $N1, $P2
  print $P0, $S1, $P2
  print $P0, $P1, $P2</pre>

<dd>Writes an integer, float, string, or PMC value to a stream. It writes to standard output by default, but optionally takes a PMC argument to select another stream to write to.</dd><p class="pad"></p>

<dd>The asynchronous version takes an additional final PMC callback argument. When the print operation is complete, it invokes the callback, passing it a status object.</dd><p class="pad"></p>

<dt><a name="printerr"
><b><code lang='und' xml:lang='und'>printerr</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  printerr $I0
  printerr $N0
  printerr $S0
  printerr $P0</pre>

<dd>Writes an integer, float, string, or PMC value to standard error.</dd><p class="pad"></p>

<dd>There is no asynchronous variant of <code lang='und' xml:lang='und'>printerr</code>. [It&#39;s just a shortcut. If they want an asynchronous version, they can use <code lang='und' xml:lang='und'>print</code>.]</dd><p class="pad"></p>
</dl>

<h3><a name="Reading_from_streams"
>Reading from streams</a></h3>

<dl>
<dt><a name="read"
><b><code lang='und' xml:lang='und'>read</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  $S0 = read $I1
  $S0 = read $P1, $I2
  $P0 = read $P1, $I2, $P3</pre>

<dd>Retrieves a specified number of bytes, $I2, from a stream, $P2, into a string, $S0. [Note this is bytes, not codepoints.] By default it reads from standard input, but it also takes an alternate stream object source as an optional argument.</dd><p class="pad"></p>

<dd>The asynchronous version takes an additional final PMC callback argument, and only returns a status object. When the read operation is complete, it invokes the callback, passing it a status object and a string of bytes.</dd><p class="pad"></p>

<dt><a name="readline"
><b><code lang='und' xml:lang='und'>readline</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  $S0 = readline $P1
  $P0 = readline $P1, $P2</pre>

<dd>Retrieves a single line from a stream into a string. Calling <code lang='und' xml:lang='und'>readline</code> flags the stream as operating in line&#45;buffer mode (see <code lang='und' xml:lang='und'>pioctl</code> below).</dd><p class="pad"></p>

<dd>The asynchronous version takes an additional final PMC callback argument, and only returns a status object. When the readline operation is complete, it invokes the callback, passing it a status object and a string of bytes.</dd><p class="pad"></p>

<dt><a name="peek"
><b><code lang='und' xml:lang='und'>peek</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  $S0 = peek
  $S0 = peek $P1</pre>

<dd>[&#39;peek&#39;, &#39;seek&#39;, &#39;tell&#39;, and &#39;poll&#39; are all candidates for moving from opcodes to ParrotIO object methods.]</dd><p class="pad"></p>

<dd><code lang='und' xml:lang='und'>peek</code> retrieves the next byte from a stream into a string, but doesn&#39;t remove it from the stream. By default it reads from standard input, but it also takes a stream object argument for an alternate source.</dd><p class="pad"></p>

<dd>There is no asynchronous version of <code lang='und' xml:lang='und'>peek</code>. [Does anyone have a line of reasoning why one might be needed? The concept of &#34;next byte&#34; seems to be a synchronous one.]</dd><p class="pad"></p>
</dl>

<h3><a name="Retrieving_and_setting_stream_properties"
>Retrieving and setting stream properties</a></h3>

<dl>
<dt><a name="seek"
><b><code lang='und' xml:lang='und'>seek</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  seek $P0, $I1, $I2
  seek $P0, $I1, $I2, $I3
  seek $P0, $I1, $I2, $P3
  seek $P0, $I1, $I2, $I3, $P4</pre>

<dd>Sets the current file position of a stream object, $P0, to an integer byte offset, $I1, from an integer starting position, $I2, (0 for the start of the file, 1 for the current position, and 2 for the end of the file). It also has a 64&#45;bit variant that sets the byte offset by two integer arguments, $I1 and $I2, (one for the first 32 bits of the 64&#45;bit offset, and one for the second 32 bits). [The two&#45;register emulation for 64&#45;bit integers may be deprecated in the future.]</dd><p class="pad"></p>

<dd>The asynchronous version takes an additional final PMC callback argument. When the seek operation is complete, it invokes the callback, passing it a status object and the stream object it was called on.</dd><p class="pad"></p>

<dt><a name="tell"
><b><code lang='und' xml:lang='und'>tell</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  $I0 = tell $P1
  ($I0, $I1) = tell $P2</pre>

<dd>Retrieves the current file position of a stream object. It also has a 64&#45;bit variant that returns the byte offset as two integers (one for the first 32 bits of the 64&#45;bit offset, and one for the second 32 bits). [The two&#45;register emulation for 64&#45;bit integers may be deprecated in the future.]</dd><p class="pad"></p>

<dd>No asynchronous version.</dd><p class="pad"></p>

<dt><a name="poll"
><b><code lang='und' xml:lang='und'>poll</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  $I0 = poll $P1, $I2, $I3, $I4</pre>

<dd>Polls a stream or socket object for particular types of events (an integer flag) at a frequency set by seconds and microseconds (the final two integer arguments). [At least, that&#39;s what the documentation in src/io/io.c says. In actual fact, the final two arguments seem to be setting the timeout, exactly the same as the corresponding argument to the system version of <code lang='und' xml:lang='und'>poll</code>.]</dd><p class="pad"></p>

<dd>See the system documentation for <code lang='und' xml:lang='und'>poll</code> to see the constants for event types and return status.</dd><p class="pad"></p>

<dd>This opcode is inherently synchronous (poll is &#34;synchronous I/O multiplexing&#34;), but it can retrieve status information from a stream or socket object whether the object is being used synchronously or asynchronously.</dd><p class="pad"></p>
</dl>

<h3><a name="Deprecated_opcodes"
>Deprecated opcodes</a></h3>

<ul>
<li><code lang='und' xml:lang='und'>getfd</code> retrieves the UNIX integer file descriptor of a stream object. The opcode has been replaced by a &#39;get_fd&#39; method on the ParrotIO object. See RT #48310.</li><p class="pad"></p>

<li><code lang='und' xml:lang='und'>pioctl</code> provides low&#45;level access to the attributes of a stream object. It takes a stream object, an integer flag to select a command, and a single integer argument for the command. It returns an integer indicating the success or failure of the command.</li><p class="pad"></p>

<p>This opcode has been replaced with methods on the ParrotIO object, but is kept here for reference. See RT #48589</p>

<p>The following constants are defined for the commands that <code lang='und' xml:lang='und'>pioctl</code> can execute:</p>

<pre lang='und' xml:lang='und'>  0    PIOCTL_CMDRESERVED
           No documentation available.
  1    PIOCTL_CMDSETRECSEP
           Set the record separator. [This doesn&#39;t actually work at the
           moment.]
  2    PIOCTL_CMDGETRECSEP
           Get the record separator.
  3    PIOCTL_CMDSETBUFTYPE
           Set the buffer type.
  4    PIOCTL_CMDGETBUFTYPE
           Get the buffer type
  5    PIOCTL_CMDSETBUFSIZE
           Set the buffer size.
  6    PIOCTL_CMDGETBUFSIZE
           Get the buffer size.</pre>

<p>The following constants are defined as argument/return values for the buffer&#45;type commands:</p>

<pre lang='und' xml:lang='und'>  0    PIOCTL_NONBUF
           Unbuffered I/O. Bytes are sent as soon as possible.
  1    PIOCTL_LINEBUF
           Line buffered I/O. Bytes are sent when a newline is
           encountered.
  2    PIOCTL_BLKBUF
           Fully buffered I/O. Bytes are sent when the buffer is full.</pre>
</ul>

<h2><a name="Filesystem_Opcodes"
>Filesystem Opcodes <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>[Okay, I&#39;m seriously considering moving most of these to methods on the ParrotIO object. More than that, moving them into a role that is composed into the ParrotIO object when needed. For the ones that have the form &#39;<code lang='und' xml:lang='und'>opcodename parrotIOobject, arguments</code>&#39;, I can&#39;t see that it&#39;s much less effort than &#39;<code lang='und' xml:lang='und'>parrotIOobject.methodname(arguments)</code>&#39; for either manually writing PIR or generating PIR. The slowest thing about I/O is I/O, so I can&#39;t see that we&#39;re getting much speed gain out of making them opcodes. The ones to keep as opcodes are &#39;<code lang='und' xml:lang='und'>unlink</code>&#39;, &#39;<code lang='und' xml:lang='und'>rmdir</code>&#39;, and &#39;<code lang='und' xml:lang='und'>opendir</code>&#39;.]</p>

<ul>
<li><code lang='und' xml:lang='und'>stat</code> retrieves information about a file on the filesystem. It takes a string filename or an integer argument of a UNIX file descriptor [or an already opened stream object?], and an integer flag for the type of information requested. It returns an integer containing the requested information. The following constants are defined for the type of information requested (see <em lang='und' xml:lang='und'>runtime/parrot/include/stat.pasm</em>):</li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  0    STAT_EXISTS
           Whether the file exists.
  1    STAT_FILESIZE
           The size of the file.
  2    STAT_ISDIR
           Whether the file is a directory.
  3    STAT_ISDEV
           Whether the file is a device such as a terminal or a disk.
  4    STAT_CREATETIME
           The time the file was created.
           (Currently just returns &#45;1.)
  5    STAT_ACCESSTIME
           The last time the file was accessed.
  6    STAT_MODIFYTIME
           The last time the file data was changed.
  7    STAT_CHANGETIME
           The last time the file metadata was changed.
  8    STAT_BACKUPTIME
           The last time the file was backed up. 
           (Currently just returns &#45;1.)
  9    STAT_UID
           The user ID of the file.
  10   STAT_GID
           The group ID of the file.</pre>

<p>The asynchronous version takes an additional final PMC callback argument, and only returns a status object. When the stat operation is complete, it invokes the callback, passing it a status object and an integer containing the status information.</p>

<li><code lang='und' xml:lang='und'>unlink</code> deletes a file from the filesystem. It takes a single string argument of a filename (including the path).</li><p class="pad"></p>

<p>The asynchronous version takes an additional final PMC callback argument. When the unlink operation is complete, it invokes the callback, passing it a status object.</p>

<li><code lang='und' xml:lang='und'>rmdir</code> deletes a directory from the filesystem if that directory is empty. It takes a single string argument of a directory name (including the path).</li><p class="pad"></p>

<p>The asynchronous version takes an additional final PMC callback argument. When the rmdir operation is complete, it invokes the callback, passing it a status object.</p>

<li><code lang='und' xml:lang='und'>opendir</code> opens a stream object for a directory. It takes a single string argument of a directory name (including the path) and returns a stream object.</li><p class="pad"></p>

<p>The asynchronous version takes an additional final PMC callback argument, and only returns a status object. When the opendir operation is complete, it invokes the callback, passing it a status object and a newly created stream object.</p>

<li><code lang='und' xml:lang='und'>readdir</code> reads a single item from an open directory stream object. It takes a single stream object argument and returns a string containing the path and filename/directory name of the current item. (i.e. the directory stream object acts as an iterator.)</li><p class="pad"></p>

<p>The asynchronous version takes an additional final PMC callback argument, and only returns a status object. When the readdir operation is complete, it invokes the callback, passing it a status object and the string result.</p>

<li><code lang='und' xml:lang='und'>telldir</code> returns the current position of <code lang='und' xml:lang='und'>readdir</code> operations on a directory stream object.</li><p class="pad"></p>

<p>No asynchronous version.</p>

<li><code lang='und' xml:lang='und'>seekdir</code> sets the current position of <code lang='und' xml:lang='und'>readdir</code> operations on a directory stream object. It takes a stream object argument and an integer for the position. [The system <code lang='und' xml:lang='und'>seekdir</code> requires that the position argument be the result of a previous <code lang='und' xml:lang='und'>telldir</code> operation.]</li><p class="pad"></p>

<p>The asynchronous version takes an additional final PMC callback argument. When the seekdir operation is complete, it invokes the callback, passing it a status object and the directory stream object it was called on.</p>

<li><code lang='und' xml:lang='und'>rewinddir</code> sets the current position of <code lang='und' xml:lang='und'>readdir</code> operations on a directory stream object back to the beginning of the directory. It takes a stream object argument.</li><p class="pad"></p>

<p>No asynchronous version.</p>

<li><code lang='und' xml:lang='und'>closedir</code> closes a directory stream object. It takes a single stream object argument.</li><p class="pad"></p>

<p>The asynchronous version takes an additional final PMC callback argument. When the closedir operation is complete, it invokes the callback, passing it a status object.</p>
</ul>

<h2><a name="Network_I/O_Opcodes"
>Network I/O Opcodes <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Most of these opcodes conform to the standard UNIX interface, but the layer API allows alternate implementations for each.</p>

<p>[These I&#39;m also considering moving to methods in a role for the ParrotIO object. Keep &#39;socket&#39; as an opcode, or maybe just make &#39;socket&#39; an option on creating a new ParrotIO object.]</p>

<ul>
<li><code lang='und' xml:lang='und'>socket</code> returns a new socket object from a given address family, socket type, and protocol number (all integers). The socket object&#39;s boolean value can be tested for whether the socket was created.</li><p class="pad"></p>

<p>The asynchronous version takes an additional final PMC callback argument, and only returns a status object. When the socket operation is complete, it invokes the callback, passing it a status object and a new socket object.</p>

<li><code lang='und' xml:lang='und'>sockaddr</code> returns an object representing a socket address, generated from a port number (integer) and an address (string).</li><p class="pad"></p>

<p>No asynchronous version.</p>

<li><code lang='und' xml:lang='und'>connect</code> connects a socket object to an address.</li><p class="pad"></p>

<p>The asynchronous version takes an additional final PMC callback argument, and only returns a status object. When the socket operation is complete, it invokes the callback, passing it a status object and the socket object it was called on. [If you want notification when a connect operation is completed, you probably want to do something with that connected socket object.]</p>

<li><code lang='und' xml:lang='und'>recv</code> receives a message from a connected socket object. It returns the message in a string.</li><p class="pad"></p>

<p>The asynchronous version takes an additional final PMC callback argument, and only returns a status object. When the recv operation is complete, it invokes the callback, passing it a status object and a string containing the received message.</p>

<li><code lang='und' xml:lang='und'>send</code> sends a message string to a connected socket object.</li><p class="pad"></p>

<p>The asynchronous version takes an additional final PMC callback argument, and only returns a status object. When the send operation is complete, it invokes the callback, passing it a status object.</p>

<li><code lang='und' xml:lang='und'>sendto</code> sends a message string to an address specified in an address object (first connecting to the address).</li><p class="pad"></p>

<p>The asynchronous version takes an additional final PMC callback argument, and only returns a status object. When the sendto operation is complete, it invokes the callback, passing it a status object.</p>

<li><code lang='und' xml:lang='und'>bind</code> binds a socket object to the port and address specified by an address object (the packed result of <code lang='und' xml:lang='und'>sockaddr</code>).</li><p class="pad"></p>

<p>The asynchronous version takes an additional final PMC callback argument, and only returns a status object. When the bind operation is complete, it invokes the callback, passing it a status object and the socket object it was called on. [If you want notification when a bind operation is completed, you probably want to do something with that bound socket object.]</p>

<li><code lang='und' xml:lang='und'>listen</code> specifies that a socket object is willing to accept incoming connections. The integer argument gives the maximum size of the queue for pending connections.</li><p class="pad"></p>

<p>There is no asynchronous version. <code lang='und' xml:lang='und'>listen</code> marks a set of attributes on the socket object.</p>

<li><code lang='und' xml:lang='und'>accept</code> accepts a new connection on a given socket object, and returns a newly created socket object for the connection.</li><p class="pad"></p>

<p>The asynchronous version takes an additional final PMC callback argument, and only returns a status object. When the accept operation receives a new connection, it invokes the callback, passing it a status object and a newly created socket object for the connection. [While the synchronous <code lang='und' xml:lang='und'>accept</code> has to be called repeatedly in a loop (once for each connection received), the asynchronous version is only called once, but continues to send new connection events until the socket is closed.]</p>

<li><code lang='und' xml:lang='und'>shutdown</code> closes a socket object for reading, for writing, or for all I/O. It takes a socket object argument and an integer argument for the type of shutdown:</li><p class="pad"></p>

<pre lang='und' xml:lang='und'>  0    PIOSHUTDOWN_READ
           Close the socket object for reading.
  1    PIOSHUTDOWN_WRITE
           Close the socket object for writing.
  2    PIOSHUTDOWN
           Close the socket object.</pre>
</ul>

<h2><a name="Error_Handling"
>Error Handling <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Currently some of the networking opcodes (<code lang='und' xml:lang='und'>connect</code>, <code lang='und' xml:lang='und'>recv</code>, <code lang='und' xml:lang='und'>send</code>, <code lang='und' xml:lang='und'>poll</code>, <code lang='und' xml:lang='und'>bind</code>, and <code lang='und' xml:lang='und'>listen</code>) return an integer indicating the status of the call, &#45;1 or a system error code if unsuccessful. Other I/O opcodes (such as <code lang='und' xml:lang='und'>getfd</code> and <code lang='und' xml:lang='und'>accept</code>) have various different strategies for error notification, and others have no way of marking errors at all. We want to unify all I/O opcodes so they use a consistent strategy for error notification.</p>

<h3><a name="Synchronous_operations"
>Synchronous operations</a></h3>

<p>Synchronous I/O operations return an integer status code indicating success or failure in addition to their ordinary return value(s). This approach has the advantage of being lightweight: returning a single additional integer is cheap.</p>

<p>[Discuss: should synchronous operations take the same error handling strategy as asynchronous ones?]</p>

<h3><a name="Asynchronous_operations"
>Asynchronous operations</a></h3>

<p>Asynchronous I/O operations return a status object. The status object contains an integer status code, string status/error message, and boolean success value.</p>

<p>An error callback may be set on a status object, though it isn&#39;t required. This callback will be invoked if the asynchronous operation terminates in an error condition. The error callback takes one argument, which is the status object containing all information about the failed call. If no error callback is set, then the standard callback will be invoked, and the user will need to check for error conditions in the status object as the first operation of the handler code.</p>

<h3><a name="Exceptions"
>Exceptions</a></h3>

<p>At some point in the future, I/O objects may also provide a way to throw exceptions on error conditions. This feature will be enabled by calling a method on the I/O object to set an internal flag. The exception throwing will be implemented as a method call on the status object.</p>

<p>Note that exception handlers for asynchronous I/O operations will likely have to be set at a global scope because execution will have left the dynamic scope of the I/O call by the time the error occurs.</p>

<h2><a name="IPv6_Support"
>IPv6 Support <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>The transition from IPv4 to IPv6 is in progress, though not likely to be complete anytime soon. Most operating systems today offer at least dual&#45;stack IPv6 implementations, so they can use either IPv4 or IPv6, depending on what&#39;s available. Parrot also needs to support either protocol. For the most part, the network I/O opcodes should internally handle either addressing scheme, without requiring the user to specify which scheme is being used.</p>

<p>IETF recommends defaulting to IPv6 connections and falling back to IPv4 connections when IPv6 fails. This would give us more solid testing of Parrot&#39;s compatibility IPv6, but may be too slow. Either way, it&#39;s a good idea to make setting the default (or selecting one exclusively) an option when compiling Parrot.</p>

<p>The most important issues for Parrot to consider with IPv6 are:</p>

<ul>
<li>Support 128 bit addresses. IPv6 addresses are colon&#45;separated hexadecimal numbers, such as <code lang='und' xml:lang='und'>20a:95ff:fef5:7e5e</code>.</li><p class="pad"></p>

<li>Any address parsing should be able to support the address separated from a port number or prefix/length by brackets: <code lang='und' xml:lang='und'>[20a:95ff:fef5:7e5e]:80</code> and <code lang='und' xml:lang='und'>[20a:95ff::]/64</code>.</li><p class="pad"></p>

<li>Packed addresses, such as the result of the <code lang='und' xml:lang='und'>sockaddr</code> opcode, should be passed around as an object (or at least a structure) rather than as a string.</li><p class="pad"></p>
</ul>

<p>See the relevant IETF RFCs: &#34;Application Aspects of IPv6 Transition&#34; (<a href="http://www.ietf.org/rfc/rfc4038.txt">http://www.ietf.org/rfc/rfc4038.txt</a>) and &#34;Basic Socket Interface Extensions for IPv6&#34; (<a href="http://www.ietf.org/rfc/rfc3493.txt">http://www.ietf.org/rfc/rfc3493.txt</a>).</p>

<h1><a name="ATTACHMENTS"
>ATTACHMENTS <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>None.</p>

<h1><a name="FOOTNOTES"
>FOOTNOTES <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>None.</p>

<h1><a name="REFERENCES"
>REFERENCES <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<pre lang='und' xml:lang='und'>  src/io/io.c
  src/ops/io.ops
  include/parrot/io.h
  runtime/parrot/library/Stream/*
  src/io/io_unix.c
  src/io/io_win32.c
  Perl 5&#39;s IO::AIO
  Perl 5&#39;s POE</pre>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../resources/parrot_small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
