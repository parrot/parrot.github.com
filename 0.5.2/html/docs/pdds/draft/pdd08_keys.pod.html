<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Indexing Aggregate PMCs</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Indexing Aggregate PMCs</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../../html/index.html">Contents</a> | <a href="../../../../html/docs.html">Documentation</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>docs/pdds/pdd08_keys.pod &#45; Indexing Aggregate PMCs</p>

<h1><a name="ABSTRACT"
>ABSTRACT <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>This PDD aims to clear up the confusion regarding the implementation of keyed access to PMCs in Parrot.</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>First,
let&#39;s define some terminology.
An <b>aggregate PMC</b> is one which allows indexed access to sub&#45;element that it stores or references,
by supporting and implementing the <code lang='und' xml:lang='und'>_keyed</code> variants of vtable methods.
These variants are <b>indexing</b> operations,
as they act on a specific indexed element of an aggregate PMC.</p>

<p>Non&#45;aggregates also support <code lang='und' xml:lang='und'>_keyed</code> variants of the vtable methods,
but they may not do anything particularly clever &#45; for instance,
PMC types implementing Perl references will merely pass the index on to the referent.
These aren&#39;t aggregates because they don&#39;t directly store or reference sub&#45;elements.</p>

<p>Indexing operations take one or more aggregate&#45;<b>key</b> atoms.
At runtime,
these operations will index the key into the aggregate returning a <b>value</b>.
Here is a well&#45;known indexing operation in Perl 6:</p>

<pre lang='und' xml:lang='und'>    @a[12] = $b;</pre>

<p>The key here is the constant integer <code lang='und' xml:lang='und'>12</code>, and the aggregate is the <code lang='und' xml:lang='und'>PerlArray</code> <code lang='und' xml:lang='und'>@a</code>. In the process of this assignment, Parrot will have to extract the PMC in element 12 of the array, producing a value. <code lang='und' xml:lang='und'>$b</code> is then assigned to this value.</p>

<p>Now, how does this all get implemented?</p>

<h1><a name="IMPLEMENTATION"
>IMPLEMENTATION <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<h2><a name="The_key_structure"
>The key structure <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>The key structure has to have the following features: it must bundle up multiple keys so that multidimensional aggregates can be indexed; keys may be specified as integer, string, number or PMC.</p>

<p>Hence, the following structure was produced. First, the individual keys as we think of them from a language level are each stored in a Key PMC with the key type encoded in the private flags of the PMC and the value stored in the PMCs cache.</p>

<p>So, for instance, indexing the multidimensional array <code lang='und' xml:lang='und'>@foo[$a;12;&#34;hi&#34;]</code> produces three PMCs, one with a PMC type, one with an integer type and one with a string type.</p>

<p>As stated, the key type is encoded in the PMC flags using 8 bits based on the following scheme:</p>

<pre lang='und' xml:lang='und'>    typedef enum {
        KEY_integer_FLAG        = PObj_private0_FLAG,
        KEY_number_FLAG         = PObj_private1_FLAG,
        KEY_hash_iterator_FLAGS = PObj_private0_FLAG | PObj_private1_FLAG,
        KEY_string_FLAG         = PObj_private2_FLAG,
        KEY_pmc_FLAG            = PObj_private3_FLAG,
        KEY_register_FLAG       = PObj_private4_FLAG,

        KEY_start_slice_FLAG    = PObj_private5_FLAG,
        KEY_end_slice_FLAG      = PObj_private6_FLAG,
        KEY_inf_slice_FLAG      = PObj_private7_FLAG,

        KEY_type_FLAGS          = KEY_integer_FLAG |
                                  KEY_number_FLAG  |
                                  KEY_string_FLAG |
                                  KEY_pmc_FLAG |
                                  KEY_register_FLAG |
                                  KEY_hash_iterator_FLAGS
    } KEY_flags</pre>

<p>The <code lang='und' xml:lang='und'>KEY_register_FLAG</code> is used to indicate that the <code lang='und' xml:lang='und'>int_val</code> component of the PMC&#39;s cache contains the number of a register of the appropriate type that itself contains the value of the key component.</p>

<p>The next issue is to combine these things into a single key. This is done by using the <code lang='und' xml:lang='und'>data</code> member of the PMC to form a linked list so that each key points to the next key. A linked list is used so that partial keys can be easily generated as a multidimensional data structure is traversed.</p>

<p>These definitions, along with declarations of support routines used to manipulate keys, can be found in <em lang='und' xml:lang='und'>include/parrot/key.h</em></p>

<h2><a name="Aggregate_and_non&#45;aggregate_PMCs"
>Aggregate and non&#45;aggregate PMCs <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>We&#39;ve already said that what separates the aggregate PMCs from the non&#45;aggregates is their implementation of the <code lang='und' xml:lang='und'>_keyed</code> vtable methods. So it is Hereby Decreed that the default vtable which everyone inherits from defines the <code lang='und' xml:lang='und'>_keyed</code> forms to throw an exception.</p>

<dl>
<dt><a name="Todo"
>Todo</a></dt><p class="pad"></p>

<dd>Need discussion on whether <code lang='und' xml:lang='und'>OUT_OF_BOUNDS</code> is a good exception for this, or whether something else should be used. It&#39;s really a compiler screw&#45;up, since code which indexes a non&#45;aggregate shouldn&#39;t be generated.</dd><p class="pad"></p>
</dl>

<h2><a name="_keyed_vtable_methods"
><code lang='und' xml:lang='und'>_keyed</code> vtable methods <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>So what of these magical <code lang='und' xml:lang='und'>_keyed</code> vtable methods? They are generated when you add the <code lang='und' xml:lang='und'>keyed</code> tag to the appropriate entry in <em lang='und' xml:lang='und'>src/vtable.tbl</em>. They are constructed by following <b>every</b> <code lang='und' xml:lang='und'>PMC</code> argument with a second <code lang='und' xml:lang='und'>PMC</code> argument which acts as the key for that argument; the name of the second <code lang='und' xml:lang='und'>PMC</code> argument is formed by adding <code lang='und' xml:lang='und'>_key</code> onto the end of the first <code lang='und' xml:lang='und'>PMC</code> argument.</p>

<p>The reason why every PMC argument has an associated key is twofold. Firstly, it means that</p>

<pre lang='und' xml:lang='und'>    @a[$b] = $c</pre>

<p>and</p>

<pre lang='und' xml:lang='und'>    $a = @b[$c]</pre>

<p>use the same vtable method, reducing the multiplicity of methods. Secondly, a three&#45;argument <code lang='und' xml:lang='und'>assign</code> as suggested by the code above would be ambiguous &#45; the code above uses 3 PMCs in different ways.</p>

<p>Also, operations which take an aggregate key for one of their arguments should take aggregate keys for <b>all</b> of their arguments. This is to avoid the following:</p>

<pre lang='und' xml:lang='und'>    void foo_keyed_i(PMC* x, PMC* x_key, INT a)
    void foo_keyed_n(PMC* x, PMC* x_key, NUM a)
    void foo_keyed_p(PMC* x, PMC* x_key, PMC a)
    void foo_keyed_p_keyed(PMC* x, PMC* x_key, PMC* a, PMC* a_key)</pre>

<p>These are all replaced with the single entry</p>

<pre lang='und' xml:lang='und'>    void foo_keyed(PMC* x, PMC* a_key, PMC* a, PMC* a_key)</pre>

<p>(Think how much worse it gets when there are three or more PMCs in an entry...)</p>

<p>Yes. This means that you may need to turn some things into <code lang='und' xml:lang='und'>PMC</code>s that you didn&#39;t want to. Since the alternative is mega pollution and duplication in the vtable table, and since the majority of things that you&#39;ll deal with in a real world situation are expected to be <code lang='und' xml:lang='und'>PMC</code>s anyway, this shouldn&#39;t be too much of a problem.</p>

<p>So, if you have a PMC in a <code lang='und' xml:lang='und'>_keyed</code> method which you don&#39;t want to index, pass in <code lang='und' xml:lang='und'>NULL</code> instead of a real key. Code implementing these methods should understand <code lang='und' xml:lang='und'>PMC *foo, PMC *NULL</code> as meaning the entirety of <code lang='und' xml:lang='und'>foo</code> in some sense; this is trivial to understand if <code lang='und' xml:lang='und'>foo</code> is non&#45;aggregate, and implementation&#45;defined if <code lang='und' xml:lang='und'>foo</code> is aggregate. If you remember that a key PMC is really a linked list, you&#39;ll notice that after traversing down through the list, you&#39;ll reach a <code lang='und' xml:lang='und'>NULL</code> which again means the entirety of whatever object you traversed to.</p>

<p>Similarly, non&#45;<code lang='und' xml:lang='und'>_keyed</code> methods on aggregates are implementation defined; for instance, a <code lang='und' xml:lang='und'>set_integer</code> on a <code lang='und' xml:lang='und'>PerlArray</code> may be understood as setting <code lang='und' xml:lang='und'>@array.length</code>.</p>

<p>Historically, we first implemented keys as two separate keyed methods per applicable method &#45; <code lang='und' xml:lang='und'>..._index</code> and <code lang='und' xml:lang='und'>..._index_s</code> for integer and string indexing respectively. However, this didn&#39;t give us the flexibility and scalability that key structures give us.</p>

<h2><a name="Input_to_the_assembler"
>Input to the assembler <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>There are several different valid specifications of an aggregate key to the assembler. These are:</p>

<pre lang='und' xml:lang='und'>    op arg, P1[1234]  # Constant integer key
    op arg, P1[I1]    # Integer key

    op arg, P1[12.34] # Constant number key &#45; handled as constant key
    op arg, P1[&#34;foo&#34;] # Constant string key &#45; handled as constant key
    op arg, P1[I1;I2] # Multi&#45;level key &#45; handled as constant key

    op arg, P1[P1]    # Register key</pre>

<p>(Rationale: fits programmer&#39;s expectation, easier to understand at a glance than <code lang='und' xml:lang='und'>op P1, P2, P3</code>. Also, is <code lang='und' xml:lang='und'>op P1, P2, P3</code> the same as <code lang='und' xml:lang='und'>op P1[P2], P3</code> or <code lang='und' xml:lang='und'>op P1, P2[P3]</code>, or are these three separate PMCs?)</p>

<p>In all there are four types of key. The first two are integer keys and constant integer keys which are optimisations for the common case of single level integer keys.</p>

<p>The other two are constant keys, which can handle any combination of constants and registers with any number of levels; and register keys which are represented by a single PMC register that is assumed to contain a PMC of the Key class.</p>

<h2><a name="What_the_assembler_did_next"
>What the assembler did next <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>When the assembler sees an aggregate key, it &#34;detaches&#34; the key to form a separate argument. It then decides on the type of key. For integer keys (both constant and register) the data is encoded in the same way as an ordinary integer argument. For register keys the data is encoded as for an ordinary PMC register argument, while for constant keys a key constant is generated that encodes the list of constants and registers that make up the key and an appropriate index into the constant table is encoded as the argument.</p>

<p>Next it selects the appropriate op. Register keys have the signature <code lang='und' xml:lang='und'>k</code> and constant keys have the signature <code lang='und' xml:lang='und'>kc</code>. Integer register and constant keys are encoded as <code lang='und' xml:lang='und'>ki</code> and <code lang='und' xml:lang='und'>kic</code> respectively.</p>

<pre lang='und' xml:lang='und'>    set P1[&#34;hi&#34;], 1234</pre>

<p>finds an op named <code lang='und' xml:lang='und'>set_p_kc_i</code>. On the other hand,</p>

<pre lang='und' xml:lang='und'>    set P1[P1], 1234</pre>

<p>produces an op named <code lang='und' xml:lang='und'>set_p_k_i</code>. Likewise, this:</p>

<pre lang='und' xml:lang='und'>    set P1[1], 1234</pre>

<p>produces an op named <code lang='und' xml:lang='und'>set_p_kic</code>, and this:</p>

<pre lang='und' xml:lang='und'>    set P1[I1], 1234</pre>

<p>produces an op named <code lang='und' xml:lang='und'>set_p_ki</code>.</p>

<h2><a name="Bytecode_representation"
>Bytecode representation <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>The bytecode representation of these keys are as follows: constant keys are treated just like another constant, and are an index into the packfile&#39;s constant table.</p>

<p>Each key in that constant table consists of one word specifying its length in terms of number of keys. For instance, <code lang='und' xml:lang='und'>[&#34;hi&#34;]</code> has length 1; <code lang='und' xml:lang='und'>[&#34;hi&#34;;P1;S1;123]</code> has length 4. Next, each key is specified using two words. The first word is a type specifier:</p>

<pre lang='und' xml:lang='und'>    1 &#45; Integer constant
    2 &#45; Number constant
    4 &#45; String constant
    7 &#45; Integer register
    8 &#45; Number register
    9 &#45; PMC register
   10 &#45; String register</pre>

<p>and the second word is either a value (for integer constants), a register number (for registers) or an index into the appropriate constant table.</p>

<p>The type values shown above are actually the <code lang='und' xml:lang='und'>PARROT_ARG_*</code> values taken from <em lang='und' xml:lang='und'>include/parrot/op.h</em>.</p>

<h1><a name="VERSION"
>VERSION <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<h2><a name="CURRENT"
>CURRENT <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<pre lang='und' xml:lang='und'>   Maintainer: Simon Cozens &#60;simon@netthink.co.uk&#62;
   Class: Internals
   PDD Number: 8
   Version: 1.3
   Status: Developing
   Last Modified: 25 August, 2002
   PDD Format: 1
   Language: English</pre>

<h2><a name="HISTORY"
>HISTORY <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="Sun_Aug_25_11:14:43_GMT_2002_:_Version_1.3"
>Sun Aug 25 11:14:43 GMT 2002 : Version 1.3</a></dt><p class="pad"></p>

<dd>Updated to reflect Dan&#39;s decision to change keys to use PMCs instead of a custom data structure. Also corrects documentation of multi&#45;level keys and how they are compiled and work. tom@compton.nu.</dd><p class="pad"></p>

<dt><a name="Thu_Apr_25_18:30:36_UTC_2002_:_Version_1.2"
>Thu Apr 25 18:30:36 UTC 2002 : Version 1.2</a></dt><p class="pad"></p>

<dd>Renamed <code lang='und' xml:lang='und'>KEY_PAIR</code> to <code lang='und' xml:lang='und'>KEY_ATOM</code>, updated to reflect changeover to linked list. &#45; steve@fink.com</dd><p class="pad"></p>

<dt><a name="Fri_Mar_8_18:47:34_GMT_2002_:_Version_1.1"
>Fri Mar 8 18:47:34 GMT 2002 : Version 1.1</a></dt><p class="pad"></p>

<dd>updated to reflect Dan&#39;s comments that non&#45;aggregates also support <code lang='und' xml:lang='und'>_keyed</code> variant vtable methods.</dd><p class="pad"></p>
</dl>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../../resources/parrot_small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
