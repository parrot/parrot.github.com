<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Untitled</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Untitled</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../../../html/index.html">Contents</a> | <a href="../../../../../html/languages.html">Language Implementations</a> | <a href="../../../../../html/lolcode.html">lolcode</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<p>class lolcode::Grammar::Actions;</p>

<p>method TOP($/) { make $( $&#60;block&#62; ); }</p>

<p>method statement ($/,
$key) { if ($key eq &#39;bare_expression&#39;) { my $it := PAST::Var.new( :name( &#39;IT&#39; ),
:scope(&#39;package&#39;),
:viviself(&#39;Undef&#39;)); my $past := PAST::Op.new( :pasttype(&#39;bind&#39;),
:node( $/ ) ); $past.push( $it ); $past.push( $( $&#60;expression&#62; ) ); make $past; } else { make $( $/{$key} ); # For now } }</p>

<p>method visible($/) { my $past := PAST::Op.new( :name(&#39;VISIBLE&#39;),
:pasttype(&#39;call&#39;),
:node( $/ ) ); if ( $&#60;no_newline&#62; ) { $past.push( PAST::Val.new( :value( 1 ),
:named( PAST::Val.new( :value(&#39;no_newline&#39;) ) ) ) ); } for $&#60;expression&#62; { $past.push( $( $_ ) ); } make $past; }</p>

<p>method declare($/) { if ($&#60;expression&#62;) { $($&#60;variable&#62;).isdecl(1); # XXX Someone clever needs to refactor this into <code lang='und' xml:lang='und'>assign</code> my $past := PAST::Op.new( :pasttype(&#39;bind&#39;),
:node( $/ ) ); $past.push( $( $&#60;variable&#62; ) ); $past.push( $( $&#60;expression&#62;[0] ) ); make $past; } else { make $( $&#60;variable&#62; ); } }</p>

<p>method assign($/) { my $past := PAST::Op.new( :pasttype(&#39;bind&#39;),
:node( $/ ) ); $past.push( $( $&#60;variable&#62; ) ); $past.push( $( $&#60;expression&#62; ) ); make $past; }</p>

<p>method function($/) { my $block := $( $&#60;block&#62; ); $block.blocktype(&#39;declaration&#39;);</p>

<pre lang='und' xml:lang='und'>    # if there are any parameters, get the PAST for each of them and
    # adjust the scope to parameter.
    if $&#60;parameters&#62; {
        my @params := $&#60;parameters&#62;[0]&#60;identifier&#62;;
        for @params {
            my $param := $($_);
            $param.scope(&#39;parameter&#39;);
            $block.push($param);
        }
    }

    my $past := PAST::Op.new( :pasttype(&#39;bind&#39;), :node( $/ ) );
    $($&#60;variable&#62;).isdecl(1);
    $past.push( $( $&#60;variable&#62; ) );
    $past.push( $block );
    make $past;
}</pre>

<p>method ifthen($/) { my $count := +$&#60;expression&#62; &#45; 1; my $expr := $( $&#60;expression&#62;[$count] ); my $then := $( $&#60;block&#62;[$count] ); $then.blocktype(&#39;immediate&#39;); my $past := PAST::Op.new( $expr, $then, :pasttype(&#39;if&#39;), :node( $/ ) ); if ( $&#60;else&#62; ) { my $else := $( $&#60;else&#62;[0] ); $else.blocktype(&#39;immediate&#39;); $past.push( $else ); } while ($count != 0) { $count := $count &#45; 1; $expr := $( $&#60;expression&#62;[$count] ); $then := $( $&#60;block&#62;[$count] ); $then.blocktype(&#39;immediate&#39;); $past := PAST::Op.new( $expr, $then, $past, :pasttype(&#39;if&#39;), :node( $/ ) ); } my $it := PAST::Var.new( :name( &#39;IT&#39; ), :scope(&#39;package&#39;), :viviself(&#39;Undef&#39;)); my $bind := PAST::Op.new( :pasttype(&#39;bind&#39;), :node( $/ ) ); $bind.push( $it ); $bind.push( $expr ); my $past := PAST::Stmts.new( $bind, $past, :node( $/ ) ); make $past; }</p>

<p>method block($/) { my $past := PAST::Block.new( :blocktype(&#39;declaration&#39;), :node( $/ ) ); for $&#60;statement&#62; { $past.push( $( $_ ) ); } make $past; }</p>

<p>method value($/, $key) { make $( $/{$key} ); }</p>

<p>method expression($/, $key) { if ($key eq &#39;var_or_function&#39;) { my $past := PAST::Op.new( :name(&#39;var_or_function&#39;), :pasttype(&#39;call&#39;), :node( $/ ) ); $past.push( $( $&#60;variable&#62; ) ); make $past; } else { make $( $/{$key} ); } }</p>

<p>method integer($/) { make PAST::Val.new( :value( ~$/ ), :returns(&#39;Integer&#39;), :node($/) ); }</p>

<p>method float($/) { make PAST::Val.new( :value( ~$/ ), :returns(&#39;Float&#39;), :node($/) ); }</p>

<p>method boolean($/) { if (~$/ eq &#39;FAIL&#39; ) { make PAST::Val.new( :value( 0 ), :returns(&#39;Boolean&#39;), :node($/) ); } else { make PAST::Val.new( :value( 1 ), :returns(&#39;Boolean&#39;), :node($/) ); } }</p>

<p>method quote($/) { make PAST::Val.new( :value( $($&#60;string_literal&#62;) ), :node($/) ); }</p>

<p>method identifier($/) { make PAST::Val.new( :value( ~$/ ), :node($/) ); }</p>

<p>method variable ($/) { if ($&#60;identifier&#62;&#60;name&#62; eq &#39;IT&#39;) { make PAST::Var.new( :name( &#39;IT&#39; ), :scope(&#39;package&#39;), :viviself(&#39;Undef&#39;)); } else { make PAST::Var.new( :name( ~$&#60;identifier&#62;&#60;name&#62; ), :scope(&#39;lexical&#39;), :viviself(&#39;Undef&#39;), :node( $/ ) ); } }</p>

<p># Local Variables: # mode: cperl # cperl&#45;indent&#45;level: 4 # fill&#45;column: 100 # End: # vim: expandtab shiftwidth=4:</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../../../resources/parrot_small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
