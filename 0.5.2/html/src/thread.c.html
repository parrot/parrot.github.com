<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Thread handling stuff</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Thread handling stuff</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../html/index.html">Contents</a> | <a href="../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>src/thread.c &#45; Thread handling stuff</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>Threads are created by creating new <code lang='und' xml:lang='und'>ParrotInterpreter</code> objects.</p>

<h2><a name="Functions"
>Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="static_PMC_*_make_local_copy"
><b><code lang='und' xml:lang='und'>static PMC *make_local_copy</b></code></a></dt><p class="pad"></p>

<dd>Create a local copy of the PMC if necessary.
(No copy is made if it is marked shared.) This includes workarounds for Parrot_clone() not doing the Right Thing with subroutines (specifically,
code segments aren&#39;t preserved and it is difficult to do so as long as Parrot_clone() depends on freezing).</dd><p class="pad"></p>

<dt><a name="static_Shared_gc_info_*_get_pool"
><b><code lang='und' xml:lang='und'>static Shared_gc_info *get_pool</b></code></a></dt><p class="pad"></p>

<dd>Get the shared gc information.
TODO: improve the docs here.</dd><p class="pad"></p>

<dt><a name="void_pt_free_pool"
><b><code lang='und' xml:lang='und'>void pt_free_pool</b></code></a></dt><p class="pad"></p>

<dd>Frees the shared gc information.
This clears any global data hen joining all threads at parent interpreter destruction.</dd><p class="pad"></p>

<dt><a name="static_PMC_*_make_local_args_copy"
><b><code lang='und' xml:lang='und'>static PMC *make_local_args_copy</b></code></a></dt><p class="pad"></p>

<dd>Make a local copy of the corresponding array of arguments.</dd><p class="pad"></p>

<dt><a name="PMC_*_pt_shared_fixup"
><b><code lang='und' xml:lang='und'>PMC *pt_shared_fixup</b></code></a></dt><p class="pad"></p>

<dd>Fixup a PMC to be sharable.
Right now,
reassigns the vtable to one owned by some master interpreter,
so the PMC can be safely reused after thread death.</dd><p class="pad"></p>

<dd>In the future the PMC returned might be different than the one passed,
e.g.,
if we need to reallocate the PMC in a different interpreter.</dd><p class="pad"></p>

<dt><a name="static_void_pt_thread_signal"
><b><code lang='und' xml:lang='und'>static void pt_thread_signal</b></code></a></dt><p class="pad"></p>

<dd>Wakeup a <code lang='und' xml:lang='und'>interp</code> which should have called pt_thread_wait().</dd><p class="pad"></p>

<dt><a name="void_pt_thread_wait_with"
><b><code lang='und' xml:lang='und'>void pt_thread_wait_with</b></code></a></dt><p class="pad"></p>

<dd>Wait for this interpreter to be signalled through its condition variable,
dealing properly with GC issues.
<code lang='und' xml:lang='und'>*mutex</code> is assumed locked on entry and will be locked on exit from this function.
If a GC run occurs in the middle of this function,
then a spurious wakeup may occur.</dd><p class="pad"></p>

<dt><a name="static_void_pt_thread_wait"
><b><code lang='und' xml:lang='und'>static void pt_thread_wait</b></code></a></dt><p class="pad"></p>

<dd>Wait for us to be signalled.
GC matters are handled correctly.
<code lang='und' xml:lang='und'>interpreter_array_mutex</code> is assumed held.
Spurious wakeups may occur.</dd><p class="pad"></p>

<dt><a name="static_void*_thread_func"
><b><code lang='und' xml:lang='und'>static void *thread_func</b></code></a></dt><p class="pad"></p>

<dd>The actual thread function.</dd><p class="pad"></p>
</dl>

<h2><a name="Helper_functions_used_also_for_running_plain_interpreters"
>Helper functions used also for running plain interpreters <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="void_pt_clone_code"
><b><code lang='und' xml:lang='und'>void pt_clone_code</b></code></a></dt><p class="pad"></p>

<dd>Copy/clone the packfile/code from interpreter <code lang='und' xml:lang='und'>s</code> to <code lang='und' xml:lang='und'>d</code>.
All resources are created in <code lang='und' xml:lang='und'>d</code>.</dd><p class="pad"></p>

<dt><a name="static_void_pt_ns_clone"
><b><code lang='und' xml:lang='und'>static void pt_ns_clone</b></code></a></dt><p class="pad"></p>

<dd>Clone all globals from <code lang='und' xml:lang='und'>s</code> to <code lang='und' xml:lang='und'>d</code>.</dd><p class="pad"></p>

<dt><a name="void_pt_clone_globals"
><b><code lang='und' xml:lang='und'>void pt_clone_globals</b></code></a></dt><p class="pad"></p>

<dd>Copy global namespace when cloning new interpreter</dd><p class="pad"></p>

<dt><a name="void_pt_thread_prepare_for_run"
><b><code lang='und' xml:lang='und'>void pt_thread_prepare_for_run</b></code></a></dt><p class="pad"></p>

<dd>Setup code,
and TODO ...</dd><p class="pad"></p>
</dl>

<h2><a name="ParrotThread_methods"
>ParrotThread methods <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="PMC_*_pt_transfer_sub"
><b><code lang='und' xml:lang='und'>PMC *pt_transfer_sub</b></code></a></dt><p class="pad"></p>

<dd>create a clone of the sub suitable for the other interpreter</dd><p class="pad"></p>

<dt><a name="int_pt_thread_run"
><b><code lang='und' xml:lang='und'>int pt_thread_run</b></code></a></dt><p class="pad"></p>

<dd>Run the <code lang='und' xml:lang='und'>*sub</code> PMC in a separate thread using interpreter in <code lang='und' xml:lang='und'>*dest_interp</code>.</dd><p class="pad"></p>

<dd><code lang='und' xml:lang='und'>arg</code> should be an array of arguments for the subroutine.
int</dd><p class="pad"></p>

<dt><a name="int_pt_thread_run_1"
><b><code lang='und' xml:lang='und'>int pt_thread_run_1</b></code></a></dt><p class="pad"></p>

<dd>Runs a type 1 thread.
Nothing is shared,
both interpreters are free running without any communication.</dd><p class="pad"></p>

<dt><a name="int_pt_thread_run_2"
><b><code lang='und' xml:lang='und'>int pt_thread_run_2</b></code></a></dt><p class="pad"></p>

<dd>Runs a type 2 thread.
No shared variables,
threads are communicating by sending messages.</dd><p class="pad"></p>

<dt><a name="int_pt_thread_run_3"
><b><code lang='und' xml:lang='und'>int pt_thread_run_3</b></code></a></dt><p class="pad"></p>

<dd>Run a type 3 thread.
Threads may have shared variables and are managed in a thread pool.</dd><p class="pad"></p>

<dt><a name="void_pt_thread_yield"
><b><code lang='und' xml:lang='und'>void pt_thread_yield</b></code></a></dt><p class="pad"></p>

<dd>Relinquishes hold on the processor.</dd><p class="pad"></p>

<dt><a name="static_Parrot_Interp_pt_check_tid"
><b><code lang='und' xml:lang='und'>static Parrot_Interp pt_check_tid</b></code></a></dt><p class="pad"></p>

<dd>Helper function.
Check if <code lang='und' xml:lang='und'>tid</code> is valid.
The caller holds the mutex.
Returns the interpreter for <code lang='und' xml:lang='und'>tid</code>.</dd><p class="pad"></p>

<dt><a name="static_void_mutex_unlock"
><b><code lang='und' xml:lang='und'>static void mutex_unlock</b></code></a></dt><p class="pad"></p>

<dd>Unlocks the mutex <code lang='und' xml:lang='und'>*arg</code>.</dd><p class="pad"></p>

<dt><a name="static_int_is_suspended_for_gc"
><b><code lang='und' xml:lang='und'>static int is_suspended_for_gc</b></code></a></dt><p class="pad"></p>

<dd>Returns true iff <code lang='und' xml:lang='und'>interp</code> is suspended so a global GC can be performed.
interpreter_array_mutex must be held.</dd><p class="pad"></p>

<dt><a name="static_QUEUE_ENTRY_*_remove_queued_suspend_gc"
><b><code lang='und' xml:lang='und'>static QUEUE_ENTRY *remove_queued_suspend_gc</b></code></a></dt><p class="pad"></p>

<dd>Remove an event requesting that the interpreter suspend itself for a garbage&#45;collection run from the event queue.</dd><p class="pad"></p>

<dt><a name="static_int_pt_gc_count_threads"
><b><code lang='und' xml:lang='und'>static int pt_gc_count_threads</b></code></a></dt><p class="pad"></p>

<dd>interpreter_array_mutex must be held</dd><p class="pad"></p>

<dt><a name="static_void_pt_gc_wait_for_stage"
><b><code lang='und' xml:lang='und'>static void pt_gc_wait_for_stage</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_void_pt_gc_wakeup_check"
><b><code lang='und' xml:lang='und'>static void pt_gc_wakeup_check</b></code></a></dt><p class="pad"></p>

<dd>Check if we need to wake threads to perform garbage collection.
This is called after thread death.
interpreter_array_mutex is assumed held.</dd><p class="pad"></p>

<dt><a name="static_void_pt_suspend_one_for_gc"
><b><code lang='und' xml:lang='und'>static void pt_suspend_one_for_gc</b></code></a></dt><p class="pad"></p>

<dd>Suspend a single interpreter for GC.
<code lang='und' xml:lang='und'>interpreter_array_mutex</code> assumed held.</dd><p class="pad"></p>

<dt><a name="static_void_pt_suspend_all_for_gc"
><b><code lang='und' xml:lang='und'>static void pt_suspend_all_for_gc</b></code></a></dt><p class="pad"></p>

<dd>Get all threads to perform a GC run.</dd><p class="pad"></p>

<dt><a name="void_pt_suspend_self_for_gc"
><b><code lang='und' xml:lang='und'>void pt_suspend_self_for_gc</b></code></a></dt><p class="pad"></p>

<dd>Suspend this thread for a full GC run.</dd><p class="pad"></p>

<dd>XXX FIXME &#45;&#45; if GC is blocked,
we need to do a GC run as soon as it becomes unblocked.</dd><p class="pad"></p>

<dt><a name="PMC*_pt_thread_join"
><b><code lang='und' xml:lang='und'>PMC *pt_thread_join</b></code></a></dt><p class="pad"></p>

<dd>Join (wait for) a joinable thread.</dd><p class="pad"></p>

<dt><a name="void_pt_join_threads"
><b><code lang='und' xml:lang='und'>void pt_join_threads</b></code></a></dt><p class="pad"></p>

<dd>Possibly wait for other running threads.
This is called when destroying <code lang='und' xml:lang='und'>interp</code>.</dd><p class="pad"></p>

<dt><a name="static_Parrot_Interp_detach"
><b><code lang='und' xml:lang='und'>static Parrot_Interp detach</b></code></a></dt><p class="pad"></p>

<dd>Helper for detach and kill.</dd><p class="pad"></p>

<dd>Returns the interpreter,
if it didn&#39;t finish yet.</dd><p class="pad"></p>

<dt><a name="void_pt_thread_detach"
><b><code lang='und' xml:lang='und'>void pt_thread_detach</b></code></a></dt><p class="pad"></p>

<dd>Detaches (make non&#45;joinable) the thread.</dd><p class="pad"></p>

<dt><a name="void_pt_thread_kill"
><b><code lang='und' xml:lang='und'>void pt_thread_kill</b></code></a></dt><p class="pad"></p>

<dd>Kills the thread.</dd><p class="pad"></p>
</dl>

<h2><a name="Threaded_interpreter_book&#45;keeping"
>Threaded interpreter book&#45;keeping <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="void_pt_add_to_interpreters"
><b><code lang='und' xml:lang='und'>void pt_add_to_interpreters</b></code></a></dt><p class="pad"></p>

<dd>All threaded interpreters are stored in an array.
Assumes that caller holds LOCK.</dd><p class="pad"></p>
</dl>

<h2><a name="DOD_Synchronization_Functions"
>DOD Synchronization Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="void_pt_DOD_start_mark"
><b><code lang='und' xml:lang='und'>void pt_DOD_start_mark</b></code></a></dt><p class="pad"></p>

<dd>DOD is going to start the mark phase.
In the presence of shared PMCs,
we can only run one DOD run at a time because <code lang='und' xml:lang='und'>PMC&#45;&#62;next_for_GC</code> may be changed.</dd><p class="pad"></p>

<dd><code lang='und' xml:lang='und'>flags</code> are the DOD flags.
We check if we need to collect shared objects or not.</dd><p class="pad"></p>

<dd>TODO &#45; Have a count of shared PMCs and check it during DOD.</dd><p class="pad"></p>

<dd>TODO &#45; Evaluate if a interpreter lock is cheaper when <code lang='und' xml:lang='und'>dod_mark_ptr</code> is updated.</dd><p class="pad"></p>

<dt><a name="void_pt_DOD_mark_root_finished"
><b><code lang='und' xml:lang='und'>void pt_DOD_mark_root_finished</b></code></a></dt><p class="pad"></p>

<dd>DOD is finished for the root set.</dd><p class="pad"></p>

<dt><a name="void_pt_DOD_stop_mark"
><b><code lang='und' xml:lang='und'>void pt_DOD_stop_mark</b></code></a></dt><p class="pad"></p>

<dd>DOD&#39;s mark phase is done.</dd><p class="pad"></p>

<dt><a name="void_Parrot_shared_DOD_block"
><b><code lang='und' xml:lang='und'>void Parrot_shared_DOD_block</b></code></a></dt><p class="pad"></p>

<dd>Block stop&#45;the&#45;world DOD runs.</dd><p class="pad"></p>

<dt><a name="void_Parrot_shared_DOD_unblock"
><b><code lang='und' xml:lang='und'>void Parrot_shared_DOD_unblock</b></code></a></dt><p class="pad"></p>

<dd>Unblock stop&#45;the&#45;world DOD runs.</dd><p class="pad"></p>
</dl>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../resources/parrot_small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
