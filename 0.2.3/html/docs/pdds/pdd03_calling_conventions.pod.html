<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Parrot Calling Conventions</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Parrot Calling Conventions</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../html/index.html">Contents</a> | <a href="../../../html/docs.html">Documentation</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>docs/pdds/pdd03_calling_conventions.pod &#45; Parrot Calling Conventions</p>

<h1><a name="ABSTRACT"
>ABSTRACT <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>This PDD describes Parrot&#39;s inter&#45;routine calling conventions.</p>

<h1><a name="AND_NOW_FOR_SOMETHING_COMPLETELY_DIFFERENT"
>AND NOW FOR SOMETHING COMPLETELY DIFFERENT <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>This document&#39;s current contents are a complete change of direction from the original direction of Parrot design.
Brand new and/or improved!
Share and enjoy!</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>This document describes how to pass arguments from registers to subroutines,
and how subroutines can extract their parameters into registers for use.</p>

<p>Since Parrot&#39;s calling conventions are continuation&#45;based,
there is arguably very little difference between a call and a return.
Because of this,
the conversion rules are the same regardless of whether code is invoking a subroutine or a return continuation.</p>

<h2><a name="Common_Features_of_Argument/Return_Opcodes"
>Common Features of Argument/Return Opcodes <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>XXX FIXME: PIR should have pretty syntactical sugar around this,
but it doesn&#39;t.
Document here what it should look like.</p>

<p>There are four opcodes involved in parameter and return value propagation:</p>

<ul>
<li><code lang='und' xml:lang='und'>set_args</code>,
for passing arguments;</li><p class="pad"></p>

<li><code lang='und' xml:lang='und'>set_returns</code>,
for returning values;</li><p class="pad"></p>

<li><code lang='und' xml:lang='und'>get_params</code>,
for accepting parameters; and</li><p class="pad"></p>

<li><code lang='und' xml:lang='und'>get_results</code>,
for accepting return values.</li><p class="pad"></p>
</ul>

<p>The common syntax of these opcodes is:</p>

<pre lang='und' xml:lang='und'>    &#60;set_opcode&#62; &#34;(flags0, flags1, ..., flagsN)&#34;, VAL0, VAL1, ... VALN
    &#60;get_opcode&#62; &#34;(flags0, flags1, ..., flagsN)&#34;, REG0, REG1, ... REGN</pre>

<p>The flags string is a literal quoted string denoting a list of zero or more comma&#45;separated integers. The list as a whole may be surrounded by parentheses. Integers may be specified either in decimal, or if prefixed with &#34;0b&#34;/&#34;0x&#34;, in binary/hexadecimal. There must be exactly one integer for each value or register given.</p>

<h3><a name="Flag_Words;_Common_Flag_Word_Bits"
>Flag Words; Common Flag Word Bits</a></h3>

<p>Each integer in the flag string controls the processing of the corresponding value or register.</p>

<p>These bits of each flag word have common meanings for all argument/ return&#45;value opcodes:</p>

<pre lang='und' xml:lang='und'>    0b0011  TYPE
               0b00 = I
               0b01 = S
               0b10 = P
               0b11 = N</pre>

<p>You can just set these bits (as well as the <i>CONSTANT</i> bit below) to zero as the assembler calculates the correct setting depending on the given arguments.</p>

<h2><a name="Passing_Arguments,_Returning_Values"
>Passing Arguments, Returning Values <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Just before calling a subroutine with <code lang='und' xml:lang='und'>invokecc</code> or calling a method with &#60;call_methodcc&#62;, use the <code lang='und' xml:lang='und'>set_args</code> opcode to tell Parrot where the subroutine&#39;s or method&#39;s arguments will come from and how they should be expanded by the target.</p>

<p>Similarly, just before returning from such a subroutine or method, use the <code lang='und' xml:lang='und'>set_returns</code> opcode to tell Parrot where the return values will come from and how to expand them for the caller&#39;s use.</p>

<h3><a name="Flag_Word_Bits_For_&#39;Setting&#39;"
>Flag Word Bits For &#39;Setting&#39;</a></h3>

<p>These bits of each flag word have these meanings specific to <code lang='und' xml:lang='und'>set_args</code> and <code lang='und' xml:lang='und'>set_returns</code>:</p>

<pre lang='und' xml:lang='und'>    0b00100  CONSTANT
               the value is a literal constant, not a register
               (also set by the assembler, if a onstant is given)

    0b01000  FLATTEN
               If this bit is set on a PMC value, then the PMC must
               be an aggregate or a scalar containing a reference to
               an aggregate.  The contents of the aggregate, rather
               than the aggregate itself, will be passed.

               The meaning of this bit is undefined when applied to
               integer, number, and string values.

    0b10000  MAY_FLATTEN
               If this bit is set on a PMC value, and the PMC is
               an aggregate or a scalar containing a reference to
               an aggregate, _and_ when the called function has a
               slurpy flag on the corresponding parameter, then
               the content of this aggregate is flattened.

    0b000000000
            INVOCANT
            INVOCANT2

    0b000000000
            OPTIONAL

    0b000000000
            NAMED

    0b000000000
            LEXICAL

    0b000000000
            COPY

    0b000000000
            WRITABLE</pre>

<h2><a name="Accepting_Parameters,_Accepting_Return_Values"
>Accepting Parameters, Accepting Return Values <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>As the <i>first opcode</i> in a subroutine that will be called with <code lang='und' xml:lang='und'>invokecc</code> or a method that will be called with &#60;call_methodcc&#62;, use the <code lang='und' xml:lang='und'>get_params</code> opcode to tell Parrot where the subroutine&#39;s or method&#39;s arguments should be stored and how they should be expanded.</p>

<p>Similarly, just <i>before</i> (yes, <i>before</i>) calling such a subroutine or method, use the <code lang='und' xml:lang='und'>get_results</code> opcode to tell Parrot where the return values should be stored and how to expand them for your use.</p>

<p>NOTE: It should be obvious, but in case it&#39;s not: You must name only registers as targets of these opcodes, not constants. (You can&#39;t store anything into a constant. That would make it a variable.)</p>

<h3><a name="Flag_Word_Bits_For_&#39;Getting&#39;"
>Flag Word Bits For &#39;Getting&#39;</a></h3>

<p>These bits of each flag word have these meanings specific to <code lang='und' xml:lang='und'>get_params</code> and <code lang='und' xml:lang='und'>get_results</code>:</p>

<pre lang='und' xml:lang='und'>    0b1000  FLATTEN
               If this bit is set on a PMC register, then the PMC
               will be populated with an aggregate (e.g. Array)
               that will contain all of the remaining values that
               have not already been stored in other registers.

               All such values will be converted to PMCs according
               to the detailed rules below, and those PMCs will be
               stored into the new aggregate.

               The meaning of this bit is undefined when applied to
               integer, number, and string registers.</pre>

<h3><a name="Overflow"
>Overflow</a></h3>

<p>If too many values are provided to fit into the given target registers, Parrot will throw an exception. Note that if the final target is a P register with the FLATTEN flag bit, then this exception can never occur.</p>

<p>XXX &#45; FIXME &#45; which exception? We really could use an exception subsystem. Oh, wait, that&#39;s my job. Never mind. &#45;&#45;Chip</p>

<h3><a name="Underflow"
>Underflow</a></h3>

<p>If too few values are provided so that some target registers are left unset, this too results in an exception.</p>

<h3><a name="Type_Conversions"
>Type Conversions</a></h3>

<p>Unlike the <code lang='und' xml:lang='und'>set_*</code> opcodes, the <code lang='und' xml:lang='und'>get_*</code> opcodes must perform conversion from one register type to another. Here are the conversion rules:</p>

<ul>
<li>When the target is an I, N, or S register, storage will behave like an <code lang='und' xml:lang='und'>assign</code> (standard conversion).</li><p class="pad"></p>

<li>When the target and source are both P registers, storage will behave like a <code lang='und' xml:lang='und'>set</code> (pass by reference).</li><p class="pad"></p>

<li>When the target is a P register and the source is an integer, the P will be set to a new .Integer which has been <code lang='und' xml:lang='und'>assign</code>ed the given integer.</li><p class="pad"></p>

<li>When the target is a P register and the source is a number, the P will be set to a new .Float which has been <code lang='und' xml:lang='und'>assign</code>ed the given number.</li><p class="pad"></p>

<li>When the target is a P register and the source is a string, the P will be set to a new .String which has been <code lang='und' xml:lang='und'>assign</code>ed the given string.</li><p class="pad"></p>
</ul>

<h1><a name="BUGS"
>BUGS <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Required features are missing:</p>

<ul>
<li>Type checking</li><p class="pad"></p>

<li>Default values</li><p class="pad"></p>

<li>Optional parameters</li><p class="pad"></p>

<li>Named parameters</li><p class="pad"></p>

<li>Specific exceptions to throw for specific errors.</li><p class="pad"></p>
</ul>

<p>Also, PIR should have pretty syntactical sugar around the get and set opcodes, but it doesn&#39;t. This document should specify what that looks like, too.</p>

<h1><a name="REFERENCES"
>REFERENCES <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>None.</p>

<h1><a name="VERSION"
>VERSION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>2.0</p>

<h2><a name="CURRENT"
>CURRENT <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<pre lang='und' xml:lang='und'>    Maintainer: Chip Salzenberg
    Class: Internals
    PDD Number: 03
    Version: 2.0
    Status: Overhauled
    Last Modified: 13 June 2005
    PDD Format: 1
    Language: English</pre>

<h2><a name="HISTORY"
>HISTORY <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="Version_2.0"
>Version 2.0</a></dt><p class="pad"></p>

<dd>13 June 2005</dd><p class="pad"></p>

<dt><a name="Version_1.4"
>Version 1.4</a></dt><p class="pad"></p>

<dd>17 November 2003</dd><p class="pad"></p>

<dt><a name="Version_1.3"
>Version 1.3</a></dt><p class="pad"></p>

<dd>2 May 2003</dd><p class="pad"></p>

<dt><a name="Version_1,2"
>Version 1,2</a></dt><p class="pad"></p>

<dd>11 March 2003</dd><p class="pad"></p>

<dt><a name="Version_1.1"
>Version 1.1</a></dt><p class="pad"></p>

<dd>16 September 2002</dd><p class="pad"></p>

<dt><a name="version_1"
>version 1</a></dt><p class="pad"></p>

<dd>None. First version</dd><p class="pad"></p>
</dl>

<h1><a name="CHANGES"
>CHANGES <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<dl>
<dt><a name="Version_2.0"
>Version 2.0</a></dt><p class="pad"></p>

<dd>Meet the new boss, definitely not the same as the old boss. All the register&#45;window fixed&#45;register&#45;number ideas are gone. In their place are specialized conversion opcodes.</dd><p class="pad"></p>

<dt><a name="Version_1.4"
>Version 1.4</a></dt><p class="pad"></p>

<dd>Unified call and return, tossed useless stuff</dd><p class="pad"></p>

<dt><a name="Version_1.3"
>Version 1.3</a></dt><p class="pad"></p>

<dd>No longer use the stack, with overflow going into the array in P3.</dd><p class="pad"></p>

<dd>Clarified some muddy language.</dd><p class="pad"></p>

<dt><a name="Version_1.2"
>Version 1.2</a></dt><p class="pad"></p>

<dd>Dropped the number of registers passed in and out of subs.</dd><p class="pad"></p>

<dt><a name="Version_1.1"
>Version 1.1</a></dt><p class="pad"></p>

<dd>We now call with a frame, rather than pushing on the stack, and we return frames, rather than returning a stack. We also pass in context information for the return.</dd><p class="pad"></p>

<dt><a name="Version_1.0"
>Version 1.0</a></dt><p class="pad"></p>

<dd>None. First version</dd><p class="pad"></p>
</dl>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
