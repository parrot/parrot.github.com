<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Untitled</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Untitled</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../../html/index.html">Contents</a> | <a href="../../../../html/languages.html">Language Implementations</a> | <a href="../../../../html/lua.html">Lua</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<p>class Lua::Grammar::Actions;</p>

<p>method TOP($/) { my $past := $( $&#60;block&#62; ); $past.blocktype(&#39;declaration&#39;); make $past; }</p>

<p>method block($/,
$key) { our @?BLOCK; our $?BLOCK;</p>

<pre lang='und' xml:lang='und'>    ## A chunk is a sequence of statements, and a chunk is also a block.
    ## See section 2.4.1 of Lua reference manual.

    if $key eq &#39;open&#39; {
        $?BLOCK := PAST::Block.new( :blocktype(&#39;immediate&#39;), :node($/) );
        @?BLOCK.unshift($?BLOCK);
    }
    elsif $key eq &#39;close&#39; {

        for $&#60;statement&#62; {
            $?BLOCK.push( $($_) );
        }
        ## handle break or return
        if $&#60;end_statement&#62; {
            $?BLOCK.push( $($&#60;last_statement&#62;[0]) );
        }
        make $?BLOCK;

        ## remove this block from scope stack and restore &#39;current&#39;.
        @?BLOCK.shift();
        $?BLOCK := @?BLOCK[0];
    }</pre>

<p>}</p>

<p>method last_statement($/, $key) { make $( $/{$key} ); }</p>

<p>method statement($/,$key) { make $( $/{$key} ); }</p>

<p>method expression_list($/) { my $past := PAST::Stmts.new( :node($/) ); for $&#60;expression&#62; { $past.push( $( $_ ) ); } make $past; }</p>

<p>method do_block($/) { make $( $&#60;block&#62; ); }</p>

<p>method if_stat($/) { my $cond := +$&#60;expression&#62; &#45; 1; my $past := PAST::Op.new( $( $&#60;expression&#62;[$cond] ), $( $&#60;block&#62;[$cond] ), :pasttype(&#39;if&#39;), :node( $/ ) ); if ( $&#60;else&#62; ) { $past.push( $( $&#60;else&#62;[0] ) ); } while ($cond != 0) { $cond := $cond &#45; 1; $past := PAST::Op.new( $( $&#60;expression&#62;[$cond] ), $( $&#60;block&#62;[$cond] ), $past, :pasttype(&#39;if&#39;), :node( $/ ) ); } make $past; }</p>

<p>method while_stat($/) { my $cond := $( $&#60;expression&#62; ); my $block := $( $&#60;block&#62; ); make PAST::Op.new( $cond, $block, :pasttype(&#39;while&#39;), :node($/) ); }</p>

<p>method repeat_stat($/) { my $cond := $( $&#60;expression&#62; ); my $block := $( $&#60;block&#62; ); make PAST::Op.new( $cond, $block, :pasttype(&#39;repeat_until&#39;), :node($/) ); }</p>

<p>method for_stat($/, $key) { make $( $/{$key} ); }</p>

<p>method fornum($/) { my $past := PAST::Block.new( :blocktype(&#39;immediate&#39;), :node($/) );</p>

<pre lang='und' xml:lang='und'>    my $var      := $( $&#60;Name&#62; );
    my $initval  := $( $&#60;var&#62; );
    my $limitval := $( $&#60;limit&#62; );
    my $stepval;

    ## if there&#39;s a step value, get it, otherwise make it default to 1.
    if $&#60;step&#62; {
        $stepval := $( $&#60;step&#62;[0] );
    }
    else {
        $stepval := PAST::Val.new( :value(&#39;1&#39;), :returns(&#39;Integer&#39;), :scope($/) );
    }

    ## create the var, limit and step internal variables. Note their names which
    ## are not valid Lua identifiers; this prevents accidental reference to them.
    my $itervar  := PAST::Var.new( :name(&#39;(var)&#39;),
                                   :isdecl(1),
                                   :scope(&#39;lexical&#39;),
                                   :viviself($initval),
                                   :node($/) );

    my $limitvar := PAST::Var.new( :name(&#39;(limit)&#39;),
                                   :isdecl(1),
                                   :scope(&#39;lexical&#39;),
                                   :viviself($limitval),
                                   :node($/) );

    my $stepvar  := PAST::Var.new( :name(&#39;(step)&#39;),
                                   :isdecl(1),
                                   :scope(&#39;lexical&#39;),
                                   :viviself($stepval),
                                   :node($/) );

    $past.push($itervar);
    $past.push($limitvar);
    $past.push($stepvar);


    ## XXX finish this, or, maybe add special functions for doing this for loop.
    ##
    my $body := $( $&#60;block&#62; );

    ## XXX cond1
    my $cond1 := PAST::Op.new( $var, $var, :pasttype(&#39;if&#39;), :node($/) );
    ## XXX cond2
    my $cond2 := PAST::Op.new( $var, $var, :pasttype(&#39;if&#39;), :node($/) );

    my $cond  := PAST::Op.new( $cond1, $cond2, :pasttype(&#39;unless&#39;), :node($/) );
    my $loop  := PAST::Op.new( $cond, $body, :pasttype(&#39;while&#39;), :node($/) );
    ## XXX increment step here and init $var.
    $past.push($loop);

    make $past;
}</pre>

<p>method forlist($/) { # XXX todo make PAST::Op.new( :inline(&#39; # for&#45;list not implemented&#39;), :node($/) ); }</p>

<p>method break_stat($/) { # XXX wait for PCT support. make PAST::Op.new( :inline(&#39; # break not implemented&#39;), :node($/) ); }</p>

<p>method return_stat($/) { my $past := PAST::Op.new( :node($/) ); # XXX return? wait for PCT support if $&#60;expression_list&#62; { my $retvals := $( $&#60;expression_list&#62; ); for @($retvals) { $past.push( $_ ); } } make $past; }</p>

<p>method local_stat($/, $key) { make $( $/{$key} ); }</p>

<p>method local_function($/) { our $?BLOCK; ## local function foo() ... end translates to 2 statements: ## local foo; foo = function() ... end. ## my $past := PAST::Stmts.new( :node($/) ); my $name := $( $&#60;Name&#62; ); $name.isdecl(1); $name.scope(&#39;lexical&#39;);</p>

<pre lang='und' xml:lang='und'>    my $func := $( $&#60;function_body&#62; );

    ## assign the function object to the specified name. It&#39;s only a binding;
    ## it&#39;s not the name of the function object, which remains anonymous.
    my $bind := PAST::Op.new( $name, $func, :pasttype(&#39;bind&#39;), :node($/) );
    $past.push($bind);

    ## register the name as a local in the current block&#39;s symbol table.
    $?BLOCK.symbol( $name.name(), :scope(&#39;lexical&#39;) );
    make $past;
}</pre>

<p>method local_declaration($/) { our $?BLOCK; my $past := PAST::Stmts.new( :node($/) );</p>

<pre lang='und' xml:lang='und'>    ## get number of names and experssions
    my $numnames := +$&#60;Name&#62;;

    my $expressions;
    my $numexprs;
    if $&#60;expression_list&#62; {
        $expressions := $($&#60;expression_list&#62;[0]);
        $numexprs    := +@($expressions); ##+$&#60;expression_list&#62;[0]&#60;expression&#62;;
    }
    else {
        $numexprs    := 0;
    }

    ## while there are enough names and expressions, use the expressions
    ## to initialize the names.
    my $index := 0;
    while (($index != $numnames) &#38;&#38; ($index != $numexprs)) {

        my $name := $( $&#60;Name&#62;[$index] );
        ## XXX why doesn&#39;t @($expressions)[$index] work?
        my $expr := $( $&#60;expression_list&#62;[0]&#60;expression&#62;[$index] );
        #my $expr := $expressions[$index];


        $name.isdecl(1);
        $name.scope(&#39;lexical&#39;);
        $name.viviself($expr);
        $past.push($name);
        $?BLOCK.symbol( $name.name(), :scope(&#39;lexical&#39;) );
        $index := $index + 1;
    }

    ## we may have run out of expressions, initialize rest of names
    ## to &#39;nil&#39; and declare them.
    while ($index != $numnames)  {
        my $name := $( $&#60;Name&#62;[$index] );
        $name.isdecl(1);
        $name.scope(&#39;lexical&#39;);
        $past.push($name);
        $?BLOCK.symbol( $name.name(), :scope(&#39;lexical&#39;) );
        $index := $index + 1;
    }

    make $past;
}</pre>

<p>method function_stat($/) { my $name := $( $&#60;function_name&#62; ); my $body := $( $&#60;function_body&#62; ); make PAST::Op.new( $name, $body, :pasttype(&#39;bind&#39;), :node($/) ); }</p>

<p>method function_name($/) { ## XXX improve this ## how to handle method name (the part after &#34;:&#34;)? ## how to implement Lua&#39;s &#34;object model&#34;? Lua doesn&#39;t have really an object model, ## but maybe it&#39;s nice to cheat and use OO&#45;like model anyhow.</p>

<pre lang='und' xml:lang='und'>    my $count := +$&#60;Name&#62;;
    my $past := $( $&#60;Name&#62;[0] );
    my $idx  := 1;

    while ($idx != $count) {

        my $name := $( $&#60;Name&#62;[$idx] );
        $name.scope(&#39;keyed&#39;);
        my $field := PAST::Val.new( :value($name.name()), :returns(&#39;String&#39;) );

        ## XXX viviself should not be here; you have to create the tables yourself
        ## but for now this is nice.
        $past.viviself(&#39;Hash&#39;);

        $past := PAST::Var.new( $past, $field, :scope(&#39;keyed&#39;), :node($/) );

        $idx := $idx + 1;
    }

    make $past;
}</pre>

<p>method function_body($/) { my $past := $( $&#60;parameter_list&#62; ); $past.push( $( $&#60;block&#62; ) ); make $past; }</p>

<p>method name_list($/) { my $past := PAST::VarList.new( :node($/) ); for $&#60;Name&#62; { $past.push( $($_) ); } make $past; }</p>

<p>method parameter_list($/) { my $past := PAST::Block.new( :blocktype(&#39;declaration&#39;), :node($/) ); if $&#60;name_list&#62; { my $params := $( $&#60;name_list&#62; ); for @($params) { $_.scope(&#39;parameter&#39;); $past.push( $_ );</p>

<pre lang='und' xml:lang='und'>            ## enter the symbol into this function block&#39;s symbol table.
            $past.symbol( $_.name(), :scope(&#39;lexical&#39;) );
        }
    }
    if $&#60;vararg&#62; {
        $past.push( PAST::Var.new( :name(&#39;arg&#39;),
                                   :scope(&#39;parameter&#39;),
                                   :slurpy(1),
                                   :node($/) ) );
                                   ## XXX check out this name &#34;arg&#34;;
                                   ## otherwise, how to refer to it?
                                   ## Maybe munge it a bit, so it becomes
                                   ## an illegal Lua identifer, such as &#34;(arg)&#34;.
    }
    make $past;
}</pre>

<p>method expression_stat($/) { ## if there&#39;s an expression list,this is an assignment, otherwise it should ## be a function call. if $&#60;expression_list&#62; { ## XXX just handle 1 rhs value now my $lhs := $( $&#60;primary_expression&#62;[0] ); my $rhs := $( $&#60;expression_list&#62;[0] ); $rhs := $rhs[0]; make PAST::Op.new( $lhs, $rhs, :pasttype(&#39;bind&#39;), :node($/) );</p>

<pre lang='und' xml:lang='und'>    }
    else {
        ## primary expression must be a function call
        my $past   := $( $&#60;primary_expression&#62;[0] );
        my $iscall := $past[&#39;iscall&#39;];

        ## Check here whether it&#39;s a call. If it&#39;s not, that&#39;s an error.
        ## This is the same way that Lua checks this (see lparser.c).
        unless $iscall {
            # XXX use $/.panic + emit line no where error occurred.
            print(&#34;Syntax error: &#39;=&#39; or function arguments expected\n&#34;);
        }

        make $past;
    }
}</pre>

<p>method primary_expression($/) { my $past := $( $&#60;prefix_expression&#62; );</p>

<pre lang='und' xml:lang='und'>    for $&#60;slice_expression&#62; {
        my $slice := $( $_ );
        $slice.unshift($past);
        $past := $slice;
    }

    ## get a reference to the last slice, this will later be
    ## checked for being a function call.
    my $numslices := +$&#60;slice_expression&#62;;
    if $numslices {
        my $lastslice := $($&#60;slice_expression&#62;[$numslices &#45; 1]);

        ## copy the &#39;iscall&#39; flag from this last slice to the
        ## primary_expression past op.
        ## XXX Not all slice expressions set a flag yet. Fix that.
        $past[&#39;iscall&#39;] := $lastslice[&#39;iscall&#39;];
    }

    make $past;
}</pre>

<p>method function_args($/, $key) { my $past := $( $/{$key} ); ## set a flag on this past that it&#39;s a function call. $past[&#39;iscall&#39;] := 1; make $past; }</p>

<p>method string_argument($/) { ## this rule is there to create a :pasttype(&#39;call&#39;) node; ## something that is otherwise done by method arguments(), ## but not by &#60;quote&#62;. This is a wrapper rule to solve that. my $arg := $( $&#60;quote&#62; ); make PAST::Op.new( $arg, :pasttype(&#39;call&#39;), :node($/) ); }</p>

<p>method arguments($/) { my $past := PAST::Op.new( :pasttype(&#39;call&#39;), :node($/) ); if $&#60;expression_list&#62; { ## get the PAST node of expression_list, which is just a ## Stmts node. my $args := $( $&#60;expression_list&#62;[0] ); ## interpret this object as an array, and stuff all elements ## into the :pasttype(&#39;call&#39;) $past object. for @($args) { $past.push( $_ ); } } make $past; }</p>

<p>method slice_expression($/, $key) { make $( $/{$key} ); }</p>

<p>method field($/, $key) { make $( $/{$key} ); }</p>

<p>method field_name($/) { my $field := $( $&#60;Name&#62; ); $field := PAST::Val.new( :returns(&#39;String&#39;), :value($field.name()), :node($/) ); ## XXX __index meta&#45;method should be invoked from the &#34;mt&#34; table... ## Read more lua reference stuff. make PAST::Op.new( $field, :name(&#39;__index&#39;), :pasttype(&#39;callmethod&#39;), :node($/) ); }</p>

<p>method method_call($/) { ## XXX handle the &#39;self&#39; parameter, this is the &#39;table&#39; on which ## this method is invoked. This is the &#39;previous slice_expression. ## Possibly need to rewrite grammar in order to make this easier. my $past := $( $&#60;function_args&#62; ); ## set the name of the method on the PAST::Op( :pasttype(&#39;call&#39;)) object. my $method := $( $&#60;Name&#62; ); $past.name( $method.name() ); make $past; }</p>

<p>method constructor($/) { if $&#60;tablefieldlist&#62; { make $( $&#60;tablefieldlist&#62;[0] ); } else { make PAST::Op.new( :inline(&#39; %r = new &#34;Hash&#34;&#39;), :node($/) ); } }</p>

<p>method tablefieldlist($/) { my $past := PAST::Stmts.new( :node($/) ); my $ctor := PAST::Op.new( :inline(&#39; %r = new &#34;Hash&#34;&#39;), :node($/) ); $past.push($ctor);</p>

<pre lang='und' xml:lang='und'>    ## XXX think a bit more about how to initialize tables and the indexing
    ## mechanism; use __index meta&#45;method?
    ## Currently it doesn&#39;t work correctly.
    ##
    for $&#60;tablefield&#62; {
        my $field := $($_);

        ## how to reuse this %r generated in $ctor?
        $field.unshift($ctor);
        $past.push( $field );
    }
    make $past;
}</pre>

<p>method tablefield($/, $key) { make $( $/{$key} ); }</p>

<p>method expr_field($/) { # XXX get index somehwere; keep track. my $index := PAST::Val.new( :returns(&#39;Integer&#39;), :value(&#39;0&#39;), :node($/) );</p>

<pre lang='und' xml:lang='und'>    my $expr := $( $&#60;expression&#62; );
    make PAST::Op.new( $index,
                       $expr,
                       :pasttype(&#39;callmethod&#39;),
                       :name(&#39;__index&#39;),
                       :node($/) );
}</pre>

<p>method record_field($/) { my $field := $( $&#60;field&#62; ); my $expr := $( $&#60;expression&#62; ); ## should this be &#34;rawset&#34;? See Lua ref.man. ## &#60;field&#62; already creates a call to &#39;__index&#39;, add the 2nd operand to it here: $field.push($expr); make $field; }</p>

<p>method index($/) { my $expr := $( $&#60;expression&#62; ); make PAST::Op.new( $expr, :name(&#39;__index&#39;), :pasttype(&#39;callmethod&#39;), :node($/) ); }</p>

<p>method prefix_expression($/, $key) { make $( $/{$key} ); }</p>

<p>method simple_expression($/, $key) { make $( $/{$key} ); }</p>

<p>method Name($/) { our $?BLOCK;</p>

<pre lang='und' xml:lang='und'>    my $name := ~$/;
    my $scope;
    if $?BLOCK.symbol($name) {
        $scope := &#39;lexical&#39;;
    }
    else {
        $scope := &#39;package&#39;;
    }

    make PAST::Var.new( :name($name), :scope($scope), :viviself(&#39;Undef&#39;), :node($/) );
}</pre>

<p>method integer($/) { make PAST::Val.new( :value( ~$/ ), :returns(&#39;Integer&#39;), :node($/) ); }</p>

<p>method number($/) { make PAST::Val.new( :value( ~$/ ), :returns(&#39;Float&#39;), :node($/) ); }</p>

<p>method quote($/) { make PAST::Val.new( :value( $($&#60;string_literal&#62;) ), :node($/) ); }</p>

<p>method nil($/) { ## XXX does this work? Maybe get_global &#34;nil&#34;? make PAST::Val.new( :returns(&#39;Undef&#39;), :node($/) ); }</p>

<p>method true($/) { # XXX change type into boolean make PAST::Val.new( :value(&#39;1&#39;), :returns(&#39;Integer&#39;), :node($/) ); }</p>

<p>method false($/) { # XXX change type into boolean make PAST::Val.new( :value(&#39;0&#39;), :returns(&#39;Integer&#39;), :node($/) ); }</p>

<p>method expression($/, $key) { if ($key eq &#39;end&#39;) { make $($&#60;expr&#62;); } else { my $past := PAST::Op.new( :name($&#60;type&#62;), :pasttype($&#60;top&#62;&#60;pasttype&#62;), :pirop($&#60;top&#62;&#60;pirop&#62;), :lvalue($&#60;top&#62;&#60;lvalue&#62;), :node($/) ); for @($/) { $past.push( $($_) ); } make $past; } }</p>

<p># Local Variables: # mode: cperl # cperl&#45;indent&#45;level: 4 # fill&#45;column: 100 # End: # vim: expandtab shiftwidth=4:</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../../resources/parrot_small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
