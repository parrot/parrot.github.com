<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Generational mark and sweep garbage collection</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Generational mark and sweep garbage collection</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../html/index.html">Contents</a> | <a href="../../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>src/gc/gc_gms.c &#45; Generational mark and sweep garbage collection</p>

<h1><a name="OVERVIEW"
>OVERVIEW <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>The following comments describe a generational garbage collection scheme for Parrot.</p>

<p>Keywords:</p>

<pre lang='und' xml:lang='und'> &#45; non&#45;copying, mark &#38; sweep
 &#45; generational
 &#45; implicit reclamation, treadmill</pre>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>A plain mark &#38; sweep collector performs work depending on the amount of all allocated objects. The advantage of a generational GC is achieved by not processing all objects. This is based on the weak generational hypothesis, which states that young objects are likely to die early. Old objects, which have survived a few GC cycles tend to be long&#45;lived.</p>

<p>The terms young and old objects imply that there is some ordering in object creation time and the ordering is also followed by object references.</p>

<p>Specifically object references have to follow the marking direction. In pure functional programming languages this can be a very simple scheme:</p>

<pre lang='und' xml:lang='und'>        +&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;+    object references
        v            |
   old   .... young .... youngest
                            |
                   &#60;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;  scan direction</pre>

<p>If (simplified) the only reference&#45;like operation of the interpreter is:</p>

<pre lang='und' xml:lang='und'>   cons = (car, cdr)</pre>

<p>and the object references &#34;car&#34; and &#34;cdr&#34; are created prior to the &#34;aggregate&#34; &#34;cons&#34;, all object references point always to older objects. By scanning from the youngest to the oldest objects, all non&#45;marked objects can be reclaimed immediately. And the scan can be aborted at any time after some processing, creating a generational GC in a trivial way.</p>

<p>But the programming languages we are serving are working basically the other direction, when it comes to object history:</p>

<pre lang='und' xml:lang='und'>  @a[$i] = $n</pre>

<p>A reference operation like this needs first an aggregate and then the contents of it. So the scan direction is from old objects to younger ones. In such a scheme it&#39;s a bit more complicated to skip parts of the objects.</p>

<p>To take advantage of not processing all the objects, these are divided into generations, e.g.:</p>

<pre lang='und' xml:lang='und'>   old               young := nursery
   generation 0      generation 1</pre>

<p>A mark phase now processes the root set and only objects from the young generation. When all objects are either referenced by the root set or only by the young generation, the algorithm is correct and complete.</p>

<p>But there is of course the possibilty that a young object is stored into an aggregate of an older generation. This case is tracked by the write barrier, which remembers all such operations in the IGP (inter generational pointer) list. When now generation 1 is marked, the IGP list can be considered as an extension to the root set, so that again all live objects of the young generation are detected.</p>

<h2><a name="Structures"
>Structures <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="typedef_struct__gc_gms_gen_Gc_gms_gen"
><b><code lang='und' xml:lang='und'>typedef struct _gc_gms_gen Gc_gms_gen</b></code></a></dt><p class="pad"></p>

<dd>Describes the state of one generation for one pool.</dd><p class="pad"></p>

<dt><a name="typedef_struct__gc_gms_hdr_Gc_gms_hdr"
><b><code lang='und' xml:lang='und'>typedef struct _gc_gms_hdr Gc_gms_hdr</b></code></a></dt><p class="pad"></p>

<dd>This header is in front of all Parrot objects. It forms a doubly&#45;linked list of all objects in one pool and points to its generation.</dd><p class="pad"></p>

<dt><a name="PObj_to_GMSH(o)"
>PObj_to_GMSH(o)</a></dt><p class="pad"></p>

<dt><a name="GMSH_to_PObj(p)"
>GMSH_to_PObj(p)</a></dt><p class="pad"></p>

<dd>These two macros convert from and to headers and objects.</dd><p class="pad"></p>

<dt><a name="typedef_struct__gc_gms_hdr_list_Gc_gms_hdr_list"
><b><code lang='und' xml:lang='und'>typedef struct _gc_gms_hdr_list Gc_gms_hdr_list</b></code></a></dt><p class="pad"></p>

<dd>A chained list of headers used e.g. for the IGP list.</dd><p class="pad"></p>
</dl>

<pre lang='und' xml:lang='und'> * XXX</pre>

<p>Main problem TODO 1):</p>

<pre lang='und' xml:lang='und'> [ PCont ]       ... continuation object in old generation
    |
    v
 [ Stack chunk ] &#45;&#45;&#62; [ e.g. P register frame ]  ... new generation</pre>

<p>By pushing a new stack chunk onto the (old) existing stack frame, we&#39;d need a WRITE_BARRIER that promotes the stack chunk to the old generation of the continuation. This would also need an IGP entry for the stack chunk buffer. But &#45; as buffers aren&#39;t really containers in Parrot &#45; this isn&#39;t possible.</p>

<p>To get that right, the code needs better support by the running interpreter. &#45; never promote continuations (and stacks) in the current stack frame to an old generation &#45; create scope_enter / scope_exit opcodes</p>

<p>A scope_enter happens on a subroutine call *and&#39; with new_pad / push_pad opcodes. Each lexical scope must have its distinct register frame, else timely destruction can&#39;t work. If the frame needs active destruction, the old frame should be converted to the (new&#45;1) generation, the inner frame is the nursery. On scope exit the newest (nursery) generation is collected and the current generation number is reset back to (new&#45;1).</p>

<p>If the scope_enter doesn&#39;t indicate timely destruction, generation promoting should be done only, if object statistics indicate the presence of a fair amount of live objects.</p>

<p>TODO 2) in lazy sweep If timely destruction didn&#39;t find (all) eager objects, go back to older generations, until all these objects have been seen.</p>

<p>TODO 3) interpreter startup After all internal structures are created, promote interpreter state into initial first old generation by running one GC cycle before program execution begins (or just treat all objects as being alive).</p>

<h2><a name="Initialization_functions"
>Initialization functions <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="static_void_parrot_gc_gms_deinit"
><b><code lang='und' xml:lang='und'>static void parrot_gc_gms_deinit</b></code></a></dt><p class="pad"></p>

<dd>Free used resources.</dd><p class="pad"></p>

<dt><a name="static_void_gc_gms_pool_init"
><b><code lang='und' xml:lang='und'>static void gc_gms_pool_init</b></code></a></dt><p class="pad"></p>

<dd>Initialize pool variables. This function must set the pool function pointers for <code lang='und' xml:lang='und'>add_free_object</code>, <code lang='und' xml:lang='und'>get_free_object</code>, <code lang='und' xml:lang='und'>alloc_objects</code>, and <code lang='und' xml:lang='und'>more_objects</code>.</dd><p class="pad"></p>

<dt><a name="void_Parrot_gc_gms_init"
><b><code lang='und' xml:lang='und'>void Parrot_gc_gms_init</b></code></a></dt><p class="pad"></p>

<dd>Initialize the state structures of the gc system. Called immediately before creation of memory pools.</dd><p class="pad"></p>
</dl>

<h2><a name="Interface_functions"
>Interface functions <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="static_void_gc_gms_add_free_object"
><b><code lang='und' xml:lang='und'>static void gc_gms_add_free_object</b></code></a></dt><p class="pad"></p>

<dd>Unused. White (dead) objects are added in a bunch to the free_list.</dd><p class="pad"></p>

<dt><a name="static_void_gc_gms_chain_objects"
><b><code lang='und' xml:lang='und'>static void gc_gms_chain_objects</b></code></a></dt><p class="pad"></p>

<dd>TODO: interfere active_destroy and put these items into a separate white area, so that a sweep has just to run through these objects</dd><p class="pad"></p>

<dd>Header chain layout: &#45; all objects are chained together forming a circular list &#45; pool&#45;&#62;marker is the &#34;anchor&#34; of the circle (shown twice below)</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'> 1) object allocation

 1a) one bunch of allocated objects was consumed: the free ptr did
     hit the marker

 +===+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+===+
 I M I w | w | w | w | w I M I
 +   +&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+   +
       ^                   ^
       |                   |
       white               free == marker

 All these pointer ranges include the first element, but not the last one.

  [white ... free_list)   is the list of all whites

 1b) after allocating another bunch of objects

 +===+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+===+
 I M I w | w | w | w | w | f | f | f | f | f I M I
 +   +&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+   +
       ^                   ^                   ^
       |                   |                   |
       white               free                marker</pre>

<dt><a name="static_void_gc_gms_alloc_objects"
><b><code lang='und' xml:lang='und'>static void gc_gms_alloc_objects</b></code></a></dt><p class="pad"></p>

<dd>Allocate new objects for the given pool.</dd><p class="pad"></p>

<dt><a name="static_void_gc_gms_more_objects"
><b><code lang='und' xml:lang='und'>static void gc_gms_more_objects</b></code></a></dt><p class="pad"></p>

<dd>Run a GC cycle or allocate new objects for the given pool.</dd><p class="pad"></p>

<dt><a name="static_PObj_*_gc_gms_get_free_object"
><b><code lang='und' xml:lang='und'>static PObj *gc_gms_get_free_object</b></code></a></dt><p class="pad"></p>

<dd>Get a new object off the free_list in the given pool.</dd><p class="pad"></p>

<dd>2) object consumption the free ptr moves towards the marker</dd><p class="pad"></p>
</dl>

<h2><a name="Generation_handling_functions"
>Generation handling functions <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>overall header chain layout</p>

<pre lang='und' xml:lang='und'>           gen 0         gen 1      ...    gen N
  marker [first last) [first last)  ...   [first last)  marker</pre>

<p>The last (youngest) generation N holds these (pool) pointers:</p>

<pre lang='und' xml:lang='und'>  [ black ... gray )          during marking
  [ gray ... white )          during marking
  [ white ... free_list )     allocated items
  [ free_list ... marker )    free items</pre>

<p>The black, white, and generation ranges have additionally (TODO) *fin variants, which refer to PMCs that need destruction/finalization. These are always in front of the ranges to be processed first.</p>

<dl>
<dt><a name="static_Gc_gms_gen_*_gc_gms_create_gen"
><b><code lang='und' xml:lang='und'>static Gc_gms_gen *gc_gms_create_gen</b></code></a></dt><p class="pad"></p>

<dd>Create a generation structure for the given generation number.</dd><p class="pad"></p>

<dt><a name="static_void_gc_gms_init_gen"
><b><code lang='und' xml:lang='und'>static void gc_gms_init_gen</b></code></a></dt><p class="pad"></p>

<dd>Initalize the generation system by creating the first two generations.</dd><p class="pad"></p>

<dt><a name="static_Gc_gms_gen_*_gc_gms_find_gen"
><b><code lang='und' xml:lang='und'>static Gc_gms_gen *gc_gms_find_gen</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_void_gc_gms_promote"
><b><code lang='und' xml:lang='und'>static void gc_gms_promote</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_void_gc_gms_store_hdr_list"
><b><code lang='und' xml:lang='und'>static void gc_gms_store_hdr_list</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_void_gc_gms_clear_hdr_list"
><b><code lang='und' xml:lang='und'>static void gc_gms_clear_hdr_list</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_void_gc_gms_store_igp"
><b><code lang='und' xml:lang='und'>static void gc_gms_store_igp</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_void_gc_gms_clear_igp"
><b><code lang='und' xml:lang='und'>static void gc_gms_clear_igp</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="void_parrot_gc_gms_wb"
><b><code lang='und' xml:lang='und'>void parrot_gc_gms_wb</b></code></a></dt><p class="pad"></p>

<dd>Called by the write barrier. The aggregate belongs to an older generation then the <i>new</i> value written into it. Put the header of the new value onto the IGP list for the current generation, if it contains pointers to other items, and promote it to the old generation.</dd><p class="pad"></p>

<dt><a name="void_parrot_gc_gms_wb_key"
><b><code lang='und' xml:lang='und'>void parrot_gc_gms_wb_key</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_void_gc_gms_merge_gen"
><b><code lang='und' xml:lang='und'>static void gc_gms_merge_gen</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_void_gc_gms_use_gen"
><b><code lang='und' xml:lang='und'>static void gc_gms_use_gen</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_int_set_gen_cb"
><b><code lang='und' xml:lang='und'>static int set_gen_cb</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_void_gc_gms_set_gen"
><b><code lang='und' xml:lang='und'>static void gc_gms_set_gen</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>
</dl>

<h2><a name="Marking_functions"
>Marking functions <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Header chain layout</p>

<p>Init: gray := black := white</p>

<pre lang='und' xml:lang='und'> 3) marking the root set

 3a) the white &#39;h&#39; is to be set to gray to be scanned for children

 +&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#62;      +&#45;&#45;&#45;+&#45;&#62;
 | b | b | g | g | g | w          | h |
 +&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+      &#60;&#45;+&#45;&#45;&#45;+
   ^       ^           ^
   |       |           |
   black   gray        white

 3b) DFS if &#39;h&#39; needs timely destruction

 +&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#62;
 | b | b | h | g | g | g | w
 +&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+
   ^       ^               ^
   |       |               |
   black   gray            white


 3c) BFS in the normal case

 +&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#62;
 | b | b | g | g | g | h | w
 +&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+
   ^       ^               ^
   |       |               |
   black   gray            white

 3d) the white is a scalar and immediately blackened


 +&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#62;
 | b | b | h | g | g | g | w
 +&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+
   ^           ^           ^
   |           |           |
   black       gray        white

 3e) blacken the gray &#39;h&#39; during trace_children

 +&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#62;
 | b | b | h | g | g | g | w
 +&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+
   ^       ^               ^
   |       |               |
   black   gray            white


 +&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#62;
 | b | b | h | g | g | g | w
 +&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+&#45;&#45;&#45;+
   ^           ^           ^
   |           |           |
   black       gray        white</pre>

<dl>
<dt><a name="static_void_gc_gms_setto_gray"
><b><code lang='und' xml:lang='und'>static void gc_gms_setto_gray</b></code></a></dt><p class="pad"></p>

<dd>Set the white header <code lang='und' xml:lang='und'>h</code> to gray.</dd><p class="pad"></p>

<dt><a name="static_void_gc_gms_setto_black"
><b><code lang='und' xml:lang='und'>static void gc_gms_setto_black</b></code></a></dt><p class="pad"></p>

<dd>Set the white header <code lang='und' xml:lang='und'>h</code> to black.</dd><p class="pad"></p>

<dt><a name="void_parrot_gc_gms_pobject_lives"
><b><code lang='und' xml:lang='und'>void parrot_gc_gms_pobject_lives</b></code></a></dt><p class="pad"></p>

<dd>Set the object live &#45; called by the pobject_lives macro</dd><p class="pad"></p>

<dt><a name="static_int_init_mark_cb"
><b><code lang='und' xml:lang='und'>static int init_mark_cb</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_void_gc_gms_init_mark"
><b><code lang='und' xml:lang='und'>static void gc_gms_init_mark</b></code></a></dt><p class="pad"></p>

<dd>Initialize the mark phase of GC.</dd><p class="pad"></p>

<dt><a name="static_int_trace_igp_cb"
><b><code lang='und' xml:lang='und'>static int trace_igp_cb</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_int_gc_gms_trace_root"
><b><code lang='und' xml:lang='und'>static int gc_gms_trace_root</b></code></a></dt><p class="pad"></p>

<dd>Trace the root set. If <code lang='und' xml:lang='und'>trace_stack</code> is true, trace system areas.</dd><p class="pad"></p>

<dt><a name="static_int_trace_children_cb"
><b><code lang='und' xml:lang='und'>static int trace_children_cb</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_int_gc_gms_trace_children"
><b><code lang='und' xml:lang='und'>static int gc_gms_trace_children</b></code></a></dt><p class="pad"></p>

<dd>Traverse gray objects: mark and blacken. Returns 0 if the trace was aborted lazily.</dd><p class="pad"></p>

<dt><a name="static_int_sweep_cb_pmc"
><b><code lang='und' xml:lang='und'>static int sweep_cb_pmc</b></code></a></dt><p class="pad"></p>

<dd>move everything from white up to the free_list to the free_list scan for active destroy objects TODO put these in front of the pool at pool&#45;&#62;white_fin</dd><p class="pad"></p>

<dt><a name="static_int_sweep_cb_buf"
><b><code lang='und' xml:lang='und'>static int sweep_cb_buf</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_void_gc_gms_sweep"
><b><code lang='und' xml:lang='und'>static void gc_gms_sweep</b></code></a></dt><p class="pad"></p>

<dd>Free unused resources, put white objects onto free_list.</dd><p class="pad"></p>

<dt><a name="static_int_end_cycle_cb"
><b><code lang='und' xml:lang='und'>static int end_cycle_cb</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_void_gc_gms_end_cycle"
><b><code lang='und' xml:lang='und'>static void gc_gms_end_cycle</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>
</dl>

<h2><a name="Interface_function_main_entry"
>Interface function main entry <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="static_void_parrot_gc_gms_run"
><b><code lang='und' xml:lang='und'>static void parrot_gc_gms_run</b></code></a></dt><p class="pad"></p>

<dd>Interface to <code lang='und' xml:lang='und'>Parrot_do_dod_run</code>. <code lang='und' xml:lang='und'>flags</code> is one of:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  DOD_lazy_FLAG   ... timely destruction
  DOD_finish_FLAG ... run a final sweep to destruct objects at
                      interpreter shutdown</pre>

<dt><a name="static_void_gms_debug_verify"
><b><code lang='und' xml:lang='und'>static void gms_debug_verify</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>
</dl>

<h1><a name="SEE_ALSO"
>SEE ALSO <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p><em lang='und' xml:lang='und'><a href="dod.c.html">src/gc/dod.c</a></em>, <em lang='und' xml:lang='und'>include/parrot/dod.h</em>, <em lang='und' xml:lang='und'>include/parrot/pobj.h</em>, <em lang='und' xml:lang='und'><a href="gc_ims.c.html">src/gc/gc_ims.c</a></em></p>

<h1><a name="HISTORY"
>HISTORY <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Initial version by leo (2005.01.12 &#45; 2005.01.30)</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../resources/parrot_small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
