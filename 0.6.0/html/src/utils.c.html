<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Some utility functions</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Some utility functions</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../html/index.html">Contents</a> | <a href="../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>src/utils.c &#45; Some utility functions</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>Prototypes are in <em lang='und' xml:lang='und'>src/misc.h</em>.</p>

<p>Opcode helper functions that don&#39;t really fit elsewhere.</p>

<h2><a name="Functions"
>Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="INTVAL_intval_mod"
><b><code lang='und' xml:lang='und'>INTVAL intval_mod</b></code></a></dt><p class="pad"></p>

<dd>NOTE: This &#34;corrected mod&#34; algorithm is based on the C code on page 70 of [1].
Assuming correct behavior of the built&#45;in mod operator (%) with positive arguments,
this algorithm implements a mathematically convenient version of mod,
defined thus:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    x mod y = x &#45; y * floor(x / y)</pre>

<dd>For more information on this definition of mod, see section 3.4 of [2], pages 81&#45;85.</dd><p class="pad"></p>

<dd>References:</dd><p class="pad"></p>

<dd>[1] Donald E. Knuth, *MMIXware: A RISC Computer for the Third Millennium* Springer, 1999.</dd><p class="pad"></p>

<dd>[2] Ronald L. Graham, Donald E. Knuth and Oren Patashnik, *Concrete Mathematics*, Second Edition. Addison&#45;Wesley, 1994.</dd><p class="pad"></p>

<dt><a name="FLOATVAL_floatval_mod"
><b><code lang='und' xml:lang='und'>FLOATVAL floatval_mod</b></code></a></dt><p class="pad"></p>

<dd>Returns <code lang='und' xml:lang='und'>n2 mod n3</code>.</dd><p class="pad"></p>

<dd>Includes a workaround for buggy code generation in the <code lang='und' xml:lang='und'>lcc</code> compiler.</dd><p class="pad"></p>
</dl>

<h2><a name="Random_Number_Generator"
>Random Number Generator <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Based on the <code lang='und' xml:lang='und'>rand48()</code> family of functions.</p>

<dl>
<dt><a name="static_void_next_rand"
><b><code lang='und' xml:lang='und'>static void next_rand</b></code></a></dt><p class="pad"></p>

<dd>Returns the next random number in <code lang='und' xml:lang='und'>X</code>.</dd><p class="pad"></p>

<dt><a name="static_FLOATVAL__erand48"
><b><code lang='und' xml:lang='und'>static FLOATVAL _erand48</b></code></a></dt><p class="pad"></p>

<dd>Returns a <code lang='und' xml:lang='und'>double</code> in the interval <code lang='und' xml:lang='und'>[0.0, 1.0)</code>.</dd><p class="pad"></p>

<dt><a name="static_FLOATVAL__drand48"
><b><code lang='und' xml:lang='und'>static FLOATVAL _drand48</b></code></a></dt><p class="pad"></p>

<dd>Returns a <code lang='und' xml:lang='und'>double</code> in the interval <code lang='und' xml:lang='und'>[0.0, 1.0)</code>.</dd><p class="pad"></p>

<dt><a name="static_long__jrand48"
><b><code lang='und' xml:lang='und'>static long _jrand48</b></code></a></dt><p class="pad"></p>

<dd>Returns a <code lang='und' xml:lang='und'>long</code> in the interval <code lang='und' xml:lang='und'>[&#45;2^31, 2^31)</code>.</dd><p class="pad"></p>

<dt><a name="static_long__nrand48"
><b><code lang='und' xml:lang='und'>static long _nrand48</b></code></a></dt><p class="pad"></p>

<dd>Returns a <code lang='und' xml:lang='und'>long</code> in the interval <code lang='und' xml:lang='und'>[0, 2^31)</code>.</dd><p class="pad"></p>

<dt><a name="static_long__lrand48"
><b><code lang='und' xml:lang='und'>static long _lrand48</b></code></a></dt><p class="pad"></p>

<dd>Returns a <code lang='und' xml:lang='und'>long</code> in the interval <code lang='und' xml:lang='und'>[0, 2^31)</code>.</dd><p class="pad"></p>

<dt><a name="static_long__mrand48"
><b><code lang='und' xml:lang='und'>static long _mrand48</b></code></a></dt><p class="pad"></p>

<dd>Returns a <code lang='und' xml:lang='und'>long</code> in the interval <code lang='und' xml:lang='und'>[&#45;2^31, 2^31)</code>.</dd><p class="pad"></p>

<dt><a name="static_void__srand48"
><b><code lang='und' xml:lang='und'>static void _srand48</b></code></a></dt><p class="pad"></p>

<dd>Sets the high order 32 bits to the argument <code lang='und' xml:lang='und'>seed</code>. The low order 16 bits are set to the arbitrary value 0x330e.</dd><p class="pad"></p>

<dt><a name="FLOATVAL_Parrot_float_rand"
><b><code lang='und' xml:lang='und'>FLOATVAL Parrot_float_rand</b></code></a></dt><p class="pad"></p>

<dd>Returns a <code lang='und' xml:lang='und'>FLOATVAL</code> in the interval <code lang='und' xml:lang='und'>[0.0, 1.0)</code>.</dd><p class="pad"></p>

<dd><code lang='und' xml:lang='und'>how_random</code> is ignored.</dd><p class="pad"></p>

<dt><a name="INTVAL_Parrot_uint_rand"
><b><code lang='und' xml:lang='und'>INTVAL Parrot_uint_rand</b></code></a></dt><p class="pad"></p>

<dd>Returns an <code lang='und' xml:lang='und'>INTVAL</code> in the interval <code lang='und' xml:lang='und'>[0, 2^31)</code>.</dd><p class="pad"></p>

<dd><code lang='und' xml:lang='und'>how_random</code> is ignored.</dd><p class="pad"></p>

<dt><a name="INTVAL_Parrot_int_rand"
><b><code lang='und' xml:lang='und'>INTVAL Parrot_int_rand</b></code></a></dt><p class="pad"></p>

<dd>Returns an <code lang='und' xml:lang='und'>INTVAL</code> in the interval <code lang='und' xml:lang='und'>[&#45;2^31, 2^31)</code>.</dd><p class="pad"></p>

<dd><code lang='und' xml:lang='und'>how_random</code> is ignored.</dd><p class="pad"></p>

<dt><a name="INTVAL_Parrot_range_rand"
><b><code lang='und' xml:lang='und'>INTVAL Parrot_range_rand</b></code></a></dt><p class="pad"></p>

<dd>Returns an <code lang='und' xml:lang='und'>INTVAL</code> in the range <code lang='und' xml:lang='und'>[from, to]</code>.</dd><p class="pad"></p>

<dd><code lang='und' xml:lang='und'>how_random</code> is ignored.</dd><p class="pad"></p>

<dt><a name="void_Parrot_srand"
><b><code lang='und' xml:lang='und'>void Parrot_srand</b></code></a></dt><p class="pad"></p>

<dd>Seeds the random number generator with <code lang='und' xml:lang='und'>seed</code>.</dd><p class="pad"></p>

<dt><a name="PMC*_tm_to_array"
><b><code lang='und' xml:lang='und'>PMC *tm_to_array</b></code></a></dt><p class="pad"></p>

<dd>Helper to convert a <b>struct tm *</b> to an Array</dd><p class="pad"></p>

<dt><a name="INTVAL_Parrot_byte_index"
><b><code lang='und' xml:lang='und'>INTVAL Parrot_byte_index</b></code></a></dt><p class="pad"></p>

<dd>Looks for the location of a substring within a longer string. Takes pointers to the strings and the offset within the string at which to start searching as arguments.</dd><p class="pad"></p>

<dd>Returns an offset value if it is found, or &#45;1 if no match.</dd><p class="pad"></p>

<dt><a name="INTVAL_Parrot_byte_rindex"
><b><code lang='und' xml:lang='und'>INTVAL Parrot_byte_rindex</b></code></a></dt><p class="pad"></p>

<dd>Substring search (like Parrot_byte_index), but works backwards, from the rightmost end of the string.</dd><p class="pad"></p>

<dd>Returns offset value or &#45;1 (if no match).</dd><p class="pad"></p>

<dt><a name="static_void_rec_climb_back_and_mark"
><b><code lang='und' xml:lang='und'>static void rec_climb_back_and_mark</b></code></a></dt><p class="pad"></p>

<dd>Recursive function, used by Parrot_register_move to climb back the graph of register moves operations.</dd><p class="pad"></p>

<dd>The node must have a predecessor: it is implicit because if a node has a node_index, it must have a predecessor because the node_index are the index of registers in dest_regs[] array, so by definition they have a corrsponding src_regs register.</dd><p class="pad"></p>

<dd>Then it emits the move operation with its predecessor, or its backup if already used/visited.</dd><p class="pad"></p>

<dd>Then continues the climbing if the predecessor was not modified, anf in that case marks it, and set node_index as its backup.</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  node_index  ... the index of a destination (i.e. with a pred.) register
  c           ... the graph and all the needed params : the context</pre>

<dt><a name="static_void_process_cycle_without_exit"
><b><code lang='und' xml:lang='und'>static void process_cycle_without_exit</b></code></a></dt><p class="pad"></p>

<dd>Recursive function, used by Parrot_register_move to handle the case of cycles without exits, that are cycles of move ops between registers where each register has exactly one predecessor and one successor</dd><p class="pad"></p>

<dd>For instance: 1&#45;&#45;&#62;2, 2&#45;&#45;&#62;3, 3&#45;&#45;&#62;1</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  node_index  ... the index of a destination (i.e. with a pred.) register
  c           ... the graph and all the needed params : the context</pre>

<dt><a name="void_Parrot_register_move"
><b><code lang='und' xml:lang='und'>void Parrot_register_move</b></code></a></dt><p class="pad"></p>

<dd>Move <code lang='und' xml:lang='und'>n_regs</code> from the given register list <code lang='und' xml:lang='und'>src_regs</code> to <code lang='und' xml:lang='und'>dest_regs</code>.</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  n_regs    ... amount of registers to move
  dest_regs ... list of register numbers 0..255
  src_regs  ... list of register numbers 0..255
  temp_reg  ... a register number not in one of these lists
  mov       ... a register move function to be called to move one register
  mov_alt   ... a register move function to be called to move one register
                which triese fetching from an alternate src (or NULLfunc):

    (void)  (mov)(interp, dest, src, info);
    moved = (mov_alt)(interp, dest, src, info);</pre>

<dd>Some <code lang='und' xml:lang='und'>dest_regs</code> might be the same as <code lang='und' xml:lang='und'>src_regs</code>, which makes this a bit non&#45;trivial, because if the destination is already clobbered, using it later as source doesn&#34;t work. E.g.</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  0 &#60;&#45; 1
  1 &#60;&#45; 0     # register 0 already clobbered</pre>

<dd>or</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  2 &#60;&#45; 0
  0 &#60;&#45; 1
  3 &#60;&#45; 2      # register 2 already clobbered &#45; reorder moves</pre>

<dd>To handle such cases, we do:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  a) rearrange the order of moves (not possible in the first case)
     and/or if that failed:
  b) if an alternate move function is available, it may fetch the
     source from a different (non&#45;clobbered) location &#45; call it.
     if the function returns 0 also use c)
  c) if no alternate move function is available, use the temp reg</pre>

<dd>The amount of register moves should of course be minimal.</dd><p class="pad"></p>

<dd>TODO The current implementation will not work for following cases</dd><p class="pad"></p>

<dd>Talked to Leo and he said those cases are not likely (Vishal Soni). 1. I0&#45;&#62;I1 I1&#45;&#62;I0 I0&#45;&#62;I3 2. I1&#45;&#62;I2 I3&#45;&#62;I2</dd><p class="pad"></p>

<dd>TODO: Add tests for the above conditions.</dd><p class="pad"></p>
</dl>

<h1><a name="HISTORY"
>HISTORY <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>Initial version by leo 2003.09.09.</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../resources/parrot_small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
