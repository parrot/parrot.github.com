<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Strings and character sets</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Strings and character sets</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../../html/index.html">Contents</a> | <a href="../../../../html/docs.html">Documentation</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>docs/pdds/pdd28_character_sets.pod &#45; Strings and character sets</p>

<h1><a name="ABSTRACT"
>ABSTRACT <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>This PDD describes the conventions expected for users of Parrot strings,
including but not limited to support for multiple character sets,
encodings and languages.</p>

<h1><a name="VERSION"
>VERSION <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>$Revision$</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>Here is a summary of the design decisions described in this PDD.</p>

<ul>
<li>Parrot supports multiple string formats,
and so users of Parrot strings must be aware at all times of string encoding issues and how these relate to the string interface.</li><p class="pad"></p>

<li>The native Parrot string format is an array of 32&#45;bit Unicode codepoints in <b>grapheme normalization form</b>.
(NFG)</li><p class="pad"></p>

<li>NFG is defined as a normalization which allocates at most one codepoint to each visible character.</li><p class="pad"></p>

<li>An interface is defined for interacting with Parrot strings and converting between character sets and encodings.</li><p class="pad"></p>
</ul>

<h2><a name="Encoding_awareness"
>Encoding awareness <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Parrot was designed from the outset to support multiple string formats.
Unlike other such projects,
we don&#39;t standardize on Unicode internally.
This is because for the majority of use cases,
it&#39;s still far more efficient to deal with whatever input data the user sends us,
which,
equally in the majority of use cases,
is something like ASCII &#45; or at least,
some kind of byte&#45;based rather than character&#45;based encoding.</p>

<p>So internally,
consumers of Parrot strings have to be aware that there is a plurality of string encodings going on inside Parrot.
(Producers of Parrot strings can do whatever is most efficient for them.) The implications of this for the internal API will be detailed in the implementation section below,
but to put it in simple terms: if you find yourself writing <code lang='und' xml:lang='und'>*s++</code> or any other C string idioms,
you need to stop and think if that&#39;s what you really mean.
Not everything is byte&#45;based any more.</p>

<p>However,
we&#39;re going to try to make it as easy for <code lang='und' xml:lang='und'>*s++</code>&#45;minded people as possible,
and part of that is the declaration of a Parrot native string format.
You don&#39;t have to use it,
but if you do all your dreams will come true.</p>

<h2><a name="Native_string_format"
>Native string format <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Dealing with variable&#45;byte encodings is not fun; for instance,
you need to do a bunch of computations every time you traverse a string.
In order to make programming a lot easier,
we define a Parrot native string format to be an array of unsigned 32&#45;bit Unicode codepoints.
This is equivalent to UCS&#45;4 except for the normalization form semantics described below.</p>

<p>This means that <b>if</b> you&#39;ve done the necessary checks,
and hence you know you&#39;re dealing with a Parrot native string,
then you can continue to program in the usual C idioms &#45; for the most part.
Of course you&#39;ll need to be careful with your comparisons,
since what you&#39;ll be getting back will be a <code lang='und' xml:lang='und'>Parrot_UInt4</code> instead of a <code lang='und' xml:lang='und'>char</code>.</p>

<h2><a name="Grapheme_normalization_form"
>Grapheme normalization form <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Unicode characters can be expressed in a number of different ways according to the Unicode Standard.
This is partly to do with maintaining compatibility with existing character encodings.
For instance,
in Serbo&#45;Croatian and Slovenian,
there&#39;s a letter which looks like an <code lang='und' xml:lang='und'>i</code> without the dot but with two grave (<code lang='und' xml:lang='und'>`</code>) accents.
If you have an especially good POD renderer,
you can see it here: &#521;.</p>

<p>There are two ways you can represent this in Unicode.
You can use character 0x209,
also known as <code lang='und' xml:lang='und'>LATIN SMALL LETTER I WITH DOUBLE GRAVE</code>,
which does the job all in one go.
This is called a &#34;composed&#34; character,
as opposed to its equivalent decomposed sequence: <code lang='und' xml:lang='und'>LATIN SMALL LETTER I</code> (0x69) followed by <code lang='und' xml:lang='und'>COMBINING DOUBLE GRAVE ACCENT</code> (0x30F).</p>

<p>Unicode standardises in a number of &#34;normalization forms&#34; which repesentation you should use.
We&#39;re using an extension of Normalization Form C,
which says basically,
decompose everything,
then re&#45;compose as much as you can.
So if you see the integer stream <code lang='und' xml:lang='und'>0x69 0x30F</code>,
it needs to be replaced by <code lang='und' xml:lang='und'>0x209</code>.
This means that Parrot string data structures need to keep track of what normalization form a given string is in,
and Parrot must provide functions to convert between normalization forms.</p>

<p>Now,
Serbo&#45;Croat is sometimes also written with Cyrillic letters rather than Latin letters.
The Cyrillic equivalent of the above character is not part of Unicode,
but would be specified as a decomposed pair <code lang='und' xml:lang='und'>CYRILLIC SMALL LETTER I</code> (0x438) <code lang='und' xml:lang='und'>COMBINING DOUBLE GRAVE ACCENT</code> (0x30F).
(This PDD does not require Parrot to convert strings between differing political sensibilities.) However,
it is still visible as one character and despite being expressed even in NFC as two characters,
is still a single character as far as a human reader is concerned.</p>

<p>Hence we introduce the distinction between a &#34;character&#34; and a &#34;grapheme&#34;.
This is a Parrot distinction &#45; it does not exist in the Unicode Standard.</p>

<p>When a regular expression engine from one of Parrot&#39;s target languages wishes to match a grapheme,
then NFC is clearly not normalized enough.
This is why we have defined a further normalization stage,
NFG &#45; Normalization Form for Graphemes.</p>

<p>NFG uses out&#45;of&#45;band signalling in the string to refer the conforming implementation to a decomposition table.
UCS&#45;4 specifies an encoding for Unicode codepoints from 0 to 0x7FFFFFFF.
In other words,
any codepoints with the first bit set are undefined.
We define these out&#45;of&#45;band codepoints as indexes into a lookup table,
which maps between a temporary ID and its associated decomposition.</p>

<p>In practice,
this goes as follows: Assuming our Russified Serbo&#45;Croat string is the first string that Parrot sees,
when it is converted to Parrot&#39;s default format,
it would be normalized to a single character having the codepoint <code lang='und' xml:lang='und'>0x80000000</code>.
At the same time,
Parrot would insert an entry into a temporary array at array index 0,
consisting of the bytestream <code lang='und' xml:lang='und'>0x00000438 0x000000030F</code> &#45; that is,
the Unicode decomposition of the grapheme.</p>

<p>This has one big advantage: applications which don&#39;t care about graphemes can just pass the codepoint around as if it&#39;s any other number &#45; uh,
character.
Only applications which care about the specific properties of Unicode characters need to take the overload of peeking inside the array and reading the decomposition.</p>

<p>Individual languages may need to think carefully about their concept of,
for instance,
&#34;the length of a string&#34; to determine whether or not they need to visit the lookup table for these strings.
At any rate,
Parrot should provide both grapheme&#45;aware and codepoint&#45;aware iterators for string traversal.</p>

<h1><a name="IMPLEMENTATION"
>IMPLEMENTATION <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<h2><a name="Changes_required_to_current_string_implementation"
>Changes required to current string implementation <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<h2><a name="String_access_API"
>String access API <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<h2><a name="Normalization_form"
>Normalization form <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<h2><a name="String_encoding_API"
>String encoding API <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<h2><a name="String_programming_checklist"
>String programming checklist <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<h1><a name="REFERENCES"
>REFERENCES <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p><a href="http://plan9.bell&#45;labs.com/sys/doc/utf.html">http://plan9.bell&#45;labs.com/sys/doc/utf.html</a> &#45; Plan 9&#39;s Runes are not dissimilar to Parrot&#39;s integer codepoints,
and this is a good introduction to the Unicode world.</p>

<p><a href="http://www.unicode.org/reports/tr15/">http://www.unicode.org/reports/tr15/</a> &#45; The Unicode Consortium&#39;s explanation of different normalization forms.</p>

<p>&#34;Unicode: A Primer&#34;,
Tony Graham &#45; Arguably the most readable book on how Unicode works.</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../../resources/parrot_small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
