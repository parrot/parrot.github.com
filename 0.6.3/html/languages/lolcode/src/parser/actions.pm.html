<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
    <HEAD>
        <TITLE>Untitled</TITLE>
        <LINK REL="stylesheet" TYPE="text/css"
            HREF="../../../../../resources/perl.css"
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY>
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Untitled</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../../../html/index.html">Contents</a> | <a href="../../../../../html/languages.html">Language Implementations</a> | <a href="../../../../../html/lolcode.html">lolcode</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<p>class lolcode::Grammar::Actions;</p>

<p>method TOP($/) { my $block := $( $&#60;block&#62; ); my $it := PAST::Var.new( :name( &#39;IT&#39; ),
:scope(&#39;lexical&#39;),
:viviself(&#39;Undef&#39;),
:isdecl(1)); $block.unshift($it); make $block; }</p>

<p>method statement ($/,
$key) { if (($key eq &#39;expression&#39;)&#38;&#38;($&#60;expression&#62;&#60;tokens&#62;[0]&#60;identifier&#62; ne &#39;VISIBLE&#39;)) { my $it := PAST::Var.new( :name( &#39;IT&#39; ),
:scope(&#39;lexical&#39;),
:viviself(&#39;Undef&#39;)); my $past := PAST::Op.new( :pasttype(&#39;bind&#39;),
:node( $/ ) ); $past.push( $it ); $past.push( $( $&#60;expression&#62; ) ); make $past; } else { make $( $/{$key} ); # For now } }</p>

<p>method declare($/) { if ($&#60;expression&#62;) { $($&#60;variable&#62;).isdecl(1); # XXX Someone clever needs to refactor this into <code lang='und' xml:lang='und'>assign</code> my $past := PAST::Op.new( :pasttype(&#39;bind&#39;),
:node( $/ ) ); $past.push( $( $&#60;variable&#62; ) ); $past.push( $( $&#60;expression&#62;[0] ) ); make $past; } else { make $( $&#60;variable&#62; ); } }</p>

<p>method assign($/) { my $past := PAST::Op.new( :pasttype(&#39;bind&#39;),
:node( $/ ) ); $past.push( $( $&#60;variable&#62; ) ); $past.push( $( $&#60;expression&#62; ) ); make $past; }</p>

<p>method function($/) { my $block := $( $&#60;block&#62; ); $block.blocktype(&#39;declaration&#39;);</p>

<pre lang='und' xml:lang='und'>    my $arglist;
    $arglist := PAST::Stmts.new();
    # if there are any parameters, get the PAST for each of them and
    # adjust the scope to parameter.
    $block.arity(0);
    for $&#60;parameters&#62; {
        #my $param := $($_);
        #$param.scope(&#39;parameter&#39;);
        my $param := PAST::Var.new(:name(~$_&#60;identifier&#62;), :scope(&#39;parameter&#39;), :node($($_)));
        $param.isdecl(1);
        $arglist.push($param);
        $block.arity($block.arity() + 1);
    }


    my $it := PAST::Var.new( :name( &#39;IT&#39; ), :scope(&#39;lexical&#39;), :viviself(&#39;Undef&#39;), :isdecl(1));
    $block[0].unshift($it);

    $it := PAST::Var.new( :name( &#39;IT&#39; ), :scope(&#39;lexical&#39;));
    $block[0].push($it);

    if $&#60;parameters&#62; { $block.unshift($arglist); }

    $block.name(~$&#60;variable&#62;&#60;identifier&#62;);
    make $block;
    #my $past := PAST::Op.new( :pasttype(&#39;bind&#39;), :node( $/ ) );
    #$($&#60;variable&#62;).isdecl(1);
    #$past.push( $( $&#60;variable&#62; ) );
    #$past.push( $block );
    #make $past;
}</pre>

<p>method ifthen($/) { my $count := +$&#60;expression&#62; &#45; 1; my $expr := $( $&#60;expression&#62;[$count] ); my $then := $( $&#60;block&#62;[$count] ); $then.blocktype(&#39;immediate&#39;); my $past := PAST::Op.new( $expr, $then, :pasttype(&#39;if&#39;), :node( $/ ) ); if ( $&#60;else&#62; ) { my $else := $( $&#60;else&#62;[0] ); $else.blocktype(&#39;immediate&#39;); $past.push( $else ); } while ($count != 0) { $count := $count &#45; 1; $expr := $( $&#60;expression&#62;[$count] ); $then := $( $&#60;block&#62;[$count] ); $then.blocktype(&#39;immediate&#39;); $past := PAST::Op.new( $expr, $then, $past, :pasttype(&#39;if&#39;), :node( $/ ) ); } $expr := $past.shift(); my $it := PAST::Var.new( :name( &#39;IT&#39; ), :scope(&#39;lexical&#39;), :viviself(&#39;Undef&#39;)); my $bind := PAST::Op.new( :pasttype(&#39;bind&#39;), :node( $/ ) ); $bind.push( $it ); $bind.push( $expr ); $past.unshift( $it ); my $past := PAST::Stmts.new( $bind, $past, :node( $/ ) ); make $past; }</p>

<p>method block($/) { my $past := PAST::Block.new( :blocktype(&#39;declaration&#39;), :node( $/ ) ); my $stmts := PAST::Stmts.new( :node( $/ ) ); for $&#60;statement&#62; { $stmts.push( $( $_ ) ); } $past.push($stmts); make $past; }</p>

<p>method value($/, $key) { make $( $/{$key} ); }</p>

<p>method bang($/) { make PAST::Val.new( :value( ~$/ ), :returns(&#39;String&#39;), :node($/) ); }</p>

<p>method expression($/) { my $past := PAST::Op.new( :name(&#39;expr_parse&#39;), :pasttype(&#39;call&#39;), :node( $/ ) ); for $&#60;tokens&#62; { if($_&#60;identifier&#62;) { my $inline := &#39;%r = find_name &#34;&#39; ~ $_&#60;identifier&#62; ~ &#39;&#34;&#39;; $past.push(PAST::Op.new( :inline($inline) )); } elsif($_ eq &#34;MKAY&#34;){ my $inline := &#39;%r = find_name &#34;MKAY&#34;&#39;; $past.push(PAST::Op.new( :inline($inline) )); } else { $past.push( $( $_ ) ); } } make $past; }</p>

<p>method integer($/) { make PAST::Val.new( :value( ~$/ ), :returns(&#39;Integer&#39;), :node($/) ); }</p>

<p>method float($/) { make PAST::Val.new( :value( ~$/ ), :returns(&#39;Float&#39;), :node($/) ); }</p>

<p>method boolean($/) { if (~$/ eq &#39;FAIL&#39; ) { make PAST::Val.new( :value( 0 ), :returns(&#39;Boolean&#39;), :node($/) ); } else { make PAST::Val.new( :value( 1 ), :returns(&#39;Boolean&#39;), :node($/) ); } }</p>

<p>method quote($/) { make PAST::Val.new( :value( $($&#60;yarn_literal&#62;) ), :node($/) ); }</p>

<p>method variable ($/) { if ($&#60;identifier&#62; eq &#39;IT&#39;) { make PAST::Var.new( :name( &#39;IT&#39; ), :scope(&#39;lexical&#39;), :viviself(&#39;Undef&#39;)); } else { make PAST::Var.new( :name( $&#60;identifier&#62; ), :scope(&#39;lexical&#39;), :viviself(&#39;Undef&#39;), :node( $/ ) ); } }</p>

<p># Local Variables: # mode: cperl # cperl&#45;indent&#45;level: 4 # fill&#45;column: 100 # End: # vim: expandtab shiftwidth=4:</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../../../resources/parrot_small.png"
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
