<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
    <HEAD>
        <TITLE>Untitled</TITLE>
        <LINK REL="stylesheet" TYPE="text/css"
            HREF="../../../../../resources/perl.css"
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY>
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Untitled</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../../../html/index.html">Contents</a> | <a href="../../../../../html/languages.html">Language Implementations</a> | <a href="../../../../../html/squaak.html">Squaak</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<p>grammar Squaak::Grammar is PCT::Grammar;</p>

<p>rule TOP { {*} #= open &#60;stat_or_def&#62;* [ $ || &#60;.panic: &#39;Syntax error&#39;&#62; ] {*} #= close }</p>

<p>rule stat_or_def { | &#60;statement&#62; {*} #= statement | &#60;sub_definition&#62; {*} #= sub_definition }</p>

<p>rule statement { | &#60;if_statement&#62; {*} #= if_statement | &#60;while_statement&#62; {*} #= while_statement | &#60;for_statement&#62; {*} #= for_statement | &#60;try_statement&#62; {*} #= try_statement | &#60;throw_statement&#62; {*} #= throw_statement | &#60;return_statement&#62; {*} #= return_statement | &#60;sub_call&#62; {*} #= sub_call | &#60;assignment&#62; {*} #= assignment | &#60;variable_declaration&#62; {*} #= variable_declaration | &#60;do_block&#62; {*} #= do_block }</p>

<p>rule if_statement { &#39;if&#39; &#60;expression&#62; &#39;then&#39; &#60;block&#62; [&#39;else&#39; &#60;else=block&#62;]?
&#39;end&#39; {*} }</p>

<p>rule while_statement { &#39;while&#39; &#60;expression&#62; &#39;do&#39; &#60;block&#62; &#39;end&#39; {*} }</p>

<p>rule for_statement { &#39;for&#39; &#60;for_init&#62; &#39;,&#39; &#60;expression&#62; [&#39;,&#39; &#60;step=expression&#62;]?
&#39;do&#39; &#60;statement&#62;* &#39;end&#39; {*} }</p>

<p>rule for_init { &#39;var&#39; &#60;identifier&#62; &#39;=&#39; &#60;expression&#62; {*} }</p>

<p>rule try_statement { &#39;try&#39; &#60;try=block&#62; &#39;catch&#39; &#60;exception&#62; &#60;catch=block&#62; &#39;end&#39; {*} }</p>

<p>rule exception { &#60;identifier&#62; {*} }</p>

<p>rule throw_statement { &#39;throw&#39; &#60;expression&#62; {*} }</p>

<p>rule return_statement { &#39;return&#39; &#60;expression&#62; {*} }</p>

<p>rule block { {*} #= open &#60;statement&#62;* {*} #= close }</p>

<p>rule do_block { &#39;do&#39; &#60;block&#62; &#39;end&#39; {*} }</p>

<p>rule assignment { &#60;primary&#62; &#39;=&#39; &#60;expression&#62; {*} }</p>

<p>rule sub_definition { &#39;sub&#39; &#60;identifier&#62; &#60;parameters&#62; &#60;statement&#62;* &#39;end&#39; {*} }</p>

<p>rule parameters { &#39;(&#39; [ &#60;identifier&#62; [&#39;,&#39; &#60;identifier&#62;]* ]?
&#39;)&#39; {*} }</p>

<p>rule variable_declaration { &#39;var&#39; &#60;identifier&#62; [&#39;=&#39; &#60;expression&#62;]?
{*} }</p>

<p>rule sub_call { &#60;primary&#62; &#60;arguments&#62; {*} }</p>

<p>rule arguments { &#39;(&#39; [ &#60;expression&#62; [&#39;,&#39; &#60;expression&#62;]* ]?
&#39;)&#39; {*} }</p>

<p>rule primary { &#60;identifier&#62; &#60;postfix_expression&#62;* {*} }</p>

<p>rule postfix_expression { | &#60;key&#62; {*} #= key | &#60;member&#62; {*} #= member | &#60;index&#62; {*} #= index }</p>

<p>rule key { &#39;{&#39; &#60;expression&#62; &#39;}&#39; {*} }</p>

<p>rule member { &#39;.&#39; &#60;identifier&#62; {*} }</p>

<p>rule index { &#39;[&#39; &#60;expression&#62; &#39;]&#39; {*} }</p>

<p>rule term { | &#60;float_constant&#62; {*} #= float_constant | &#60;integer_constant&#62; {*} #= integer_constant | &#60;string_constant&#62; {*} #= string_constant | &#60;hash_constructor&#62; {*} #= hash_constructor | &#60;array_constructor&#62; {*} #= array_constructor | &#60;sub_call&#62; {*} #= sub_call | &#60;primary&#62; {*} #= primary | &#39;(&#39; &#60;expression&#62; &#39;)&#39; {*} #= expression }</p>

<p>rule hash_constructor { &#39;{&#39; [ &#60;named_field&#62; [&#39;,&#39; &#60;named_field&#62;]* ]?
&#39;}&#39; {*} }</p>

<p>rule named_field { &#60;string_constant&#62; &#39;=&#62;&#39; &#60;expression&#62; {*} }</p>

<p>rule array_constructor { &#39;[&#39; [ &#60;expression&#62; [&#39;,&#39; &#60;expression&#62;]* ]?
&#39;]&#39; {*} }</p>

<p>token identifier { &#60;!keyword&#62; &#60;ident&#62; {*} }</p>

<p>token integer_constant { \d+ {*} }</p>

<p>token float_constant { [ | \d+ &#39;.&#39; \d* | \d* &#39;.&#39; \d+ ] {*} }</p>

<p>token string_constant { \&#34; &#60;string_literal: &#39;&#34;&#39;&#62; \&#34; {*} }</p>

<p>token keyword { [&#39;and&#39;|&#39;catch&#39; |&#39;do&#39; |&#39;else&#39; |&#39;end&#39; |&#39;for&#39;|&#39;if&#39; |&#39;not&#39; |&#39;or&#39; |&#39;return&#39;|&#39;sub&#39;|&#39;throw&#39;|&#39;try&#39; |&#39;var&#39;|&#39;while&#39;]&#62;&#62; }</p>

<p>rule expression is optable { ...
}</p>

<p>proto &#39;infix:or&#39; is precedence(&#39;1&#39;) is pasttype(&#39;unless&#39;) { ...
} proto &#39;infix:and&#39; is tighter(&#39;infix:or&#39;) is pasttype(&#39;if&#39;) { ...
}</p>

<p>proto &#39;infix:&#60;&#39; is tighter(&#39;infix:and&#39;) { ...
} proto &#39;infix:&#60;=&#39; is equiv(&#39;infix:&#60;&#39;) { ...
} proto &#39;infix:&#62;&#39; is equiv(&#39;infix:&#60;&#39;) { ...
} proto &#39;infix:&#62;=&#39; is equiv(&#39;infix:&#60;&#39;) { ...
} proto &#39;infix:==&#39; is equiv(&#39;infix:&#60;&#39;) { ...
} proto &#39;infix:!=&#39; is equiv(&#39;infix:&#60;&#39;) { ...
}</p>

<p>proto &#39;infix:+&#39; is tighter(&#39;infix:&#60;&#39;) is pirop(&#39;n_add&#39;) { ...
} proto &#39;infix:&#45;&#39; is equiv(&#39;infix:+&#39;) is pirop(&#39;n_sub&#39;) { ...
}</p>

<p>proto &#39;infix:..&#39; is equiv(&#39;infix:+&#39;) is pirop(&#39;n_concat&#39;) { ...
}</p>

<p>proto &#39;infix:*&#39; is tighter(&#39;infix:+&#39;) is pirop(&#39;n_mul&#39;) { ...
} proto &#39;infix:%&#39; is equiv(&#39;infix:*&#39;) is pirop(&#39;n_mod&#39;) { ...
} proto &#39;infix:/&#39; is equiv(&#39;infix:*&#39;) is pirop(&#39;n_div&#39;) { ...
}</p>

<p>proto &#39;prefix:not&#39; is tighter(&#39;infix:*&#39;) is pirop(&#39;n_not&#39;) { ...
} proto &#39;prefix:&#45;&#39; is tighter(&#39;prefix:not&#39;) is pirop(&#39;n_neg&#39;) { ...
}</p>

<p>proto &#39;term:&#39; is tighter(&#39;prefix:&#45;&#39;) is parsed(&#38;term) { ...
}</p>

<p>## this &#60;ws&#62; rule treats # as &#34;comment to eol&#34; ## you may want to replace it with something appropriate token ws { &#60;!ww&#62; [ &#39;#&#39; \N* \n?
| \s+ ]* }</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../../../resources/parrot_small.png"
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
