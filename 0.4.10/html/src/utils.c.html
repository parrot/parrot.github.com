<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Some utility functions</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Some utility functions</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../html/index.html">Contents</a> | <a href="../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>src/utils.c &#45; Some utility functions</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>Prototypes are in <em lang='und' xml:lang='und'>src/misc.h</em>.</p>

<p>Opcode helper functions that don&#39;t really fit elsewhere.</p>

<h2><a name="Functions"
>Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="INTVAL_intval_mod(INTVAL_i2,_INTVAL_i3)"
><b><code lang='und' xml:lang='und'>INTVAL intval_mod(INTVAL i2, INTVAL i3)</b></code></a></dt><p class="pad"></p>

<dd>NOTE: This &#34;corrected mod&#34; algorithm is based on the C code on page 70 of [1].
Assuming correct behavior of the built&#45;in mod operator (%) with positive arguments,
this algorithm implements a mathematically convenient version of mod,
defined thus:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    x mod y = x &#45; y * floor(x / y)</pre>

<dd>For more information on this definition of mod, see section 3.4 of [2], pages 81&#45;85.</dd><p class="pad"></p>

<dd>References:</dd><p class="pad"></p>

<dd>[1] Donald E. Knuth, *MMIXware: A RISC Computer for the Third Millennium* Springer, 1999.</dd><p class="pad"></p>

<dd>[2] Ronald L. Graham, Donald E. Knuth and Oren Patashnik, *Concrete Mathematics*, Second Edition. Addison&#45;Wesley, 1994.</dd><p class="pad"></p>

<dt><a name="FLOATVAL_floatval_mod(FLOATVAL_n2,_FLOATVAL_n3)"
><b><code lang='und' xml:lang='und'>FLOATVAL floatval_mod(FLOATVAL n2, FLOATVAL n3)</b></code></a></dt><p class="pad"></p>

<dd>Returns <code lang='und' xml:lang='und'>n2 mod n3</code>.</dd><p class="pad"></p>

<dd>Includes a workaround for buggy code generation in the <code lang='und' xml:lang='und'>lcc</code> compiler.</dd><p class="pad"></p>
</dl>

<h2><a name="Random_Number_Generator"
>Random Number Generator <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Based on the <code lang='und' xml:lang='und'>rand48()</code> family of functions.</p>

<dl>
<dt><a name="static_void_next_rand(_rand_buf_X)"
><b><code lang='und' xml:lang='und'>static void next_rand(_rand_buf X)</b></code></a></dt><p class="pad"></p>

<dd>Returns the next random number in <code lang='und' xml:lang='und'>X</code>.</dd><p class="pad"></p>

<dt><a name="static_FLOATVAL__erand48(_rand_buf_buf)"
><b><code lang='und' xml:lang='und'>static FLOATVAL _erand48(_rand_buf buf)</b></code></a></dt><p class="pad"></p>

<dd>Returns a <code lang='und' xml:lang='und'>double</code> in the interval <code lang='und' xml:lang='und'>[0.0, 1.0)</code>.</dd><p class="pad"></p>

<dt><a name="static_FLOATVAL__drand48(void)"
><b><code lang='und' xml:lang='und'>static FLOATVAL _drand48(void)</b></code></a></dt><p class="pad"></p>

<dd>Returns a <code lang='und' xml:lang='und'>double</code> in the interval <code lang='und' xml:lang='und'>[0.0, 1.0)</code>.</dd><p class="pad"></p>

<dt><a name="static_long__jrand48(_rand_buf_buf)"
><b><code lang='und' xml:lang='und'>static long _jrand48(_rand_buf buf)</b></code></a></dt><p class="pad"></p>

<dd>Returns a <code lang='und' xml:lang='und'>long</code> in the interval <code lang='und' xml:lang='und'>[&#45;2^31, 2^31)</code>.</dd><p class="pad"></p>

<dt><a name="static_long__nrand48(_rand_buf_buf)"
><b><code lang='und' xml:lang='und'>static long _nrand48(_rand_buf buf)</b></code></a></dt><p class="pad"></p>

<dd>Returns a <code lang='und' xml:lang='und'>long</code> in the interval <code lang='und' xml:lang='und'>[0, 2^31)</code>.</dd><p class="pad"></p>

<dt><a name="static_long__lrand48(void)"
><b><code lang='und' xml:lang='und'>static long _lrand48(void)</b></code></a></dt><p class="pad"></p>

<dd>Returns a <code lang='und' xml:lang='und'>long</code> in the interval <code lang='und' xml:lang='und'>[0, 2^31)</code>.</dd><p class="pad"></p>

<dt><a name="static_long__mrand48(void)"
><b><code lang='und' xml:lang='und'>static long _mrand48(void)</b></code></a></dt><p class="pad"></p>

<dd>Returns a <code lang='und' xml:lang='und'>long</code> in the interval <code lang='und' xml:lang='und'>[&#45;2^31, 2^31)</code>.</dd><p class="pad"></p>

<dt><a name="static_void__srand48(long_seed)"
><b><code lang='und' xml:lang='und'>static void _srand48(long seed)</b></code></a></dt><p class="pad"></p>

<dd>Sets the high order 32 bits to the argument <code lang='und' xml:lang='und'>seed</code>. The low order 16 bits are set to the arbitrary value 0x330e.</dd><p class="pad"></p>

<dt><a name="FLOATVAL_Parrot_float_rand(INTVAL_how_random)"
><b><code lang='und' xml:lang='und'>FLOATVAL Parrot_float_rand(INTVAL how_random)</b></code></a></dt><p class="pad"></p>

<dd>Returns a <code lang='und' xml:lang='und'>FLOATVAL</code> in the interval <code lang='und' xml:lang='und'>[0.0, 1.0)</code>.</dd><p class="pad"></p>

<dd><code lang='und' xml:lang='und'>how_random</code> is ignored.</dd><p class="pad"></p>

<dt><a name="INTVAL_Parrot_uint_rand(INTVAL_how_random)"
><b><code lang='und' xml:lang='und'>INTVAL Parrot_uint_rand(INTVAL how_random)</b></code></a></dt><p class="pad"></p>

<dd>Returns an <code lang='und' xml:lang='und'>INTVAL</code> in the interval <code lang='und' xml:lang='und'>[0, 2^31)</code>.</dd><p class="pad"></p>

<dd><code lang='und' xml:lang='und'>how_random</code> is ignored.</dd><p class="pad"></p>

<dt><a name="INTVAL_Parrot_int_rand(INTVAL_how_random)"
><b><code lang='und' xml:lang='und'>INTVAL Parrot_int_rand(INTVAL how_random)</b></code></a></dt><p class="pad"></p>

<dd>Returns an <code lang='und' xml:lang='und'>INTVAL</code> in the interval <code lang='und' xml:lang='und'>[&#45;2^31, 2^31)</code>.</dd><p class="pad"></p>

<dd><code lang='und' xml:lang='und'>how_random</code> is ignored.</dd><p class="pad"></p>

<dt><a name="INTVAL_Parrot_range_rand(INTVAL_from,_INTVAL_to,_INTVAL_how_random)"
><b><code lang='und' xml:lang='und'>INTVAL Parrot_range_rand(INTVAL from, INTVAL to, INTVAL how_random)</b></code></a></dt><p class="pad"></p>

<dd>Returns an <code lang='und' xml:lang='und'>INTVAL</code> in the range <code lang='und' xml:lang='und'>[from, to]</code>.</dd><p class="pad"></p>

<dd><code lang='und' xml:lang='und'>how_random</code> is ignored.</dd><p class="pad"></p>

<dt><a name="void_Parrot_srand(INTVAL_seed)"
><b><code lang='und' xml:lang='und'>void Parrot_srand(INTVAL seed)</b></code></a></dt><p class="pad"></p>

<dd>Seeds the random number generator with <code lang='und' xml:lang='und'>seed</code>.</dd><p class="pad"></p>
</dl>

<h2><a name="Array_Functions"
>Array Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="void_*_Parrot_make_la(Interp_*interp,_PMC_*array)"
><b><code lang='und' xml:lang='und'>void *Parrot_make_la(Interp *interp, PMC *array)</b></code></a></dt><p class="pad"></p>

<dd>Creates a C array of <code lang='und' xml:lang='und'>long</code>s with one more element than the number of elements in <code lang='und' xml:lang='und'>*array</code>. The elements are then copied from <code lang='und' xml:lang='und'>*array</code> to the new array, and the last (extra) element is set to 0.</dd><p class="pad"></p>

<dd>Used in <code lang='und' xml:lang='und'>src/nci.c</code>.</dd><p class="pad"></p>

<dt><a name="void_Parrot_destroy_la(long_*array)"
><b><code lang='und' xml:lang='und'>void Parrot_destroy_la(long *array)</b></code></a></dt><p class="pad"></p>

<dd>Use this to destroy an array created with <code lang='und' xml:lang='und'>Parrot_make_la()</code>.</dd><p class="pad"></p>

<dt><a name="void_*_Parrot_make_cpa(Interp_*interp,_PMC_*array)"
><b><code lang='und' xml:lang='und'>void *Parrot_make_cpa(Interp *interp, PMC *array)</b></code></a></dt><p class="pad"></p>

<dd>Creates a C array of <code lang='und' xml:lang='und'>char *</code>s with one more element than the number of elements in <code lang='und' xml:lang='und'>*array</code>. The elements are then copied from <code lang='und' xml:lang='und'>*array</code> to the new array, and the last (extra) element is set to 0.</dd><p class="pad"></p>

<dd>Currently unused.</dd><p class="pad"></p>

<dt><a name="void_Parrot_destroy_cpa(char_**array)"
><b><code lang='und' xml:lang='und'>void Parrot_destroy_cpa(char **array)</b></code></a></dt><p class="pad"></p>

<dd>Use this to destroy an array created with <code lang='und' xml:lang='und'>Parrot_make_cpa()</code>.</dd><p class="pad"></p>

<dt><a name="PMC*_tm_to_array(Parrot_Interp,_struct_tm_*)"
><b><code lang='und' xml:lang='und'>PMC *tm_to_array(Parrot_Interp, struct tm *)</b></code></a></dt><p class="pad"></p>

<dd>Helper to convert a <b>struct tm *</b> to an Array</dd><p class="pad"></p>

<dt><a name="void_rec_climb_back_and_mark(int_node_index,_parrot_prm_context*_c)"
><b><code lang='und' xml:lang='und'>void rec_climb_back_and_mark(int node_index, parrot_prm_context *c)</b></code></a></dt><p class="pad"></p>

<dd>Recursive function, used by Parrot_register_move to climb back the graph of register moves operations.</dd><p class="pad"></p>

<dd>The node must have a predecessor: it is implicit because if a node has a node_index, it must have a predecessor because the node_index are the index of registers in dest_regs[] array, so by definition they have a corrsponding src_regs register.</dd><p class="pad"></p>

<dd>Then it emits the move operation with its predecessor, or its backup if already used/visited.</dd><p class="pad"></p>

<dd>Then continues the climbing if the predecessor was not modified, anf in that case marks it, and set node_index as its backup.</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  node_index  ... the index of a destination (i.e. with a pred.) register
  c           ... the graph and all the needed params : the context</pre>

<dt><a name="void_process_cycle_without_exit(int_node_index,_parrot_prm_context*_c)"
><b><code lang='und' xml:lang='und'>void process_cycle_without_exit(int node_index, parrot_prm_context *c)</b></code></a></dt><p class="pad"></p>

<dd>Recursive function, used by Parrot_register_move to handle the case of cycles without exits, that are cycles of move ops between registers where each register has exactly one predecessor and one successor</dd><p class="pad"></p>

<dd>For instance: 1&#45;&#45;&#62;2, 2&#45;&#45;&#62;3, 3&#45;&#45;&#62;1</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  node_index  ... the index of a destination (i.e. with a pred.) register
  c           ... the graph and all the needed params : the context</pre>

<dt><a name="typedef_int_(*reg_move_func)(Interp*,_unsigned_char_d,_unsigned_char_s,_void_*);"
><b><code lang='und' xml:lang='und'>typedef int (*reg_move_func)(Interp*, unsigned char d, unsigned char s, void *);</b></code></a></dt><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>void Parrot_register_move(Interp *, int n_regs, unsigned char *dest_regs, unsigned char *src_regs, unsigned char temp_reg, reg_move_func mov, reg_move_func mov_alt, void *info)</b></code></a></dt><p class="pad"></p>

<dd>Move <code lang='und' xml:lang='und'>n_regs</code> from the given register list <code lang='und' xml:lang='und'>src_regs</code> to <code lang='und' xml:lang='und'>dest_regs</code>.</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  n_regs    ... amount of registers to move
  dest_regs ... list of register numbers 0..255
  src_regs  ... list of register numbers 0..255
  temp_reg  ... a register number not in one of these lists
  mov       ... a register move function to be called to move one register
  mov_alt   ... a register move function to be called to move one register
                which triese fetching from an alternate src (or NULLfunc):

    (void)  (mov)(interp, dest, src, info);
    moved = (mov_alt)(interp, dest, src, info);</pre>

<dd>Some <code lang='und' xml:lang='und'>dest_regs</code> might be the same as <code lang='und' xml:lang='und'>src_regs</code>, which makes this a bit non&#45;trivial, because if the destination is already clobbered, using it later as source doesn&#34;t work. E.g.</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  0 &#60;&#45; 1
  1 &#60;&#45; 0     # register 0 already clobbered</pre>

<dd>or</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  2 &#60;&#45; 0
  0 &#60;&#45; 1
  3 &#60;&#45; 2      # register 2 already clobbered &#45; reorder moves</pre>

<dd>To handle such cases, we do:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  a) rearrange the order of moves (not possible in the first case)
     and/or if that failed:
  b) if an alternate move function is available, it may fetch the
     source from a different (non&#45;clobbered) location &#45; call it.
     if the function returns 0 also use c)
  c) if no alternate move function is available, use the temp reg</pre>

<dd>The amount of register moves should of course be minimal.</dd><p class="pad"></p>

<dd>TODO The current implementation will not work for following cases</dd><p class="pad"></p>

<dd>Talked to Leo and he said those cases are not likely (Vishal Soni). 1. I0&#45;&#62;I1 I1&#45;&#62;I0 I0&#45;&#62;I3 2. I1&#45;&#62;I2 I3&#45;&#62;I2</dd><p class="pad"></p>

<dd>TODO: Add tests for the above conditions.</dd><p class="pad"></p>
</dl>

<h1><a name="HISTORY"
>HISTORY <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>Initial version by leo 2003.09.09.</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
