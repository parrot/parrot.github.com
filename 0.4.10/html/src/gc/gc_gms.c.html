<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Generational mark and sweep garbage collection</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Generational mark and sweep garbage collection</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../html/index.html">Contents</a> | <a href="../../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>src/gc_gms.c &#45; Generational mark and sweep garbage collection</p>

<h1><a name="OVERVIEW"
>OVERVIEW <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>The following comments describe a generational garbage collection scheme for Parrot.</p>

<p>Keywords:</p>

<pre lang='und' xml:lang='und'> &#45; non&#45;copying, mark &#38; sweep
 &#45; generational
 &#45; implicit reclamation, treadmill</pre>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>A plain mark &#38; sweep collector performs work depending on the amount of all allocated objects. The advantage of a generational GC is achieved by not processing all objects. This is based on the weak generational hypothesis, which states that young objects are likely to die early. Old objects, which have survived a few GC cycles tend to be long&#45;lived.</p>

<p>The terms young and old objects imply that there is some ordering in object creation time and the ordering is also followed by object references.</p>

<p>Specifically object references have to follow the marking direction. In pure functional programming languages this can be a very simple scheme:</p>

<pre lang='und' xml:lang='und'>        +&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;+    object references
        v            |
   old   .... young .... youngest
                            |
                   &#60;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;  scan direction</pre>

<p>If (simplified) the only reference&#45;like operation of the interpreter is:</p>

<pre lang='und' xml:lang='und'>   cons = (car, cdr)</pre>

<p>and the object references &#34;car&#34; and &#34;cdr&#34; are created prior to the &#34;aggregate&#34; &#34;cons&#34;, all object references point always to older objects. By scanning from the youngest to the oldest objects, all non&#45;marked objects can be reclaimed immediately. And the scan can be aborted at any time after some processing, creating a generational GC in a trivial way.</p>

<p>But the programming languages we are serving are working basically the other direction, when it comes to object history:</p>

<pre lang='und' xml:lang='und'>  @a[$i] = $n</pre>

<p>A reference operation like this needs first an aggregate and then the contents of it. So the scan direction is from old objects to younger ones. In such a scheme it&#39;s a bit more complicated to skip parts of the objects.</p>

<p>To take advantage of not processing all the objects, these are divided into generations, e.g.:</p>

<pre lang='und' xml:lang='und'>   old               young := nursery
   generation 0      generation 1</pre>

<p>A mark phase now processes the root set and only objects from the young generation. When all objects are either referenced by the root set or only by the young generation, the algorithm is correct and complete.</p>

<p>But there is of course the possibilty that a young object is stored into an aggregate of an older generation. This case is tracked by the write barrier, which remembers all such operations in the IGP (inter generational pointer) list. When now generation 1 is marked, the IGP list can be considered as an extension to the root set, so that again all live objects of the young generation are detected.</p>

<h2><a name="Structures"
>Structures <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="typedef_struct__gc_gms_gen_Gc_gms_gen"
><b><code lang='und' xml:lang='und'>typedef struct _gc_gms_gen Gc_gms_gen</b></code></a></dt><p class="pad"></p>

<dd>Describes the state of one generation for one pool.</dd><p class="pad"></p>

<dt><a name="typedef_struct__gc_gms_hdr_Gc_gms_hdr"
><b><code lang='und' xml:lang='und'>typedef struct _gc_gms_hdr Gc_gms_hdr</b></code></a></dt><p class="pad"></p>

<dd>This header is in front of all Parrot objects. It forms a doubly&#45;linked list of all objects in one pool and points to its generation.</dd><p class="pad"></p>

<dt><a name="PObj_to_GMSH(o)"
>PObj_to_GMSH(o)</a></dt><p class="pad"></p>

<dt><a name="GMSH_to_PObj(p)"
>GMSH_to_PObj(p)</a></dt><p class="pad"></p>

<dd>These two macros convert from and to headers and objects.</dd><p class="pad"></p>

<dt><a name="typedef_struct__gc_gms_hdr_list_Gc_gms_hdr_list"
><b><code lang='und' xml:lang='und'>typedef struct _gc_gms_hdr_list Gc_gms_hdr_list</b></code></a></dt><p class="pad"></p>

<dd>A chained list of headers used e.g. for the IGP list.</dd><p class="pad"></p>
</dl>

<h2><a name="Initialization_functions"
>Initialization functions <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="static_void_parrot_gc_gms_deinit(Interp*)"
><b><code lang='und' xml:lang='und'>static void parrot_gc_gms_deinit(Interp*)</b></code></a></dt><p class="pad"></p>

<dd>Free used resources.</dd><p class="pad"></p>

<dt><a name="static_void_gc_gms_pool_init(Interp_*,_struct_Small_Object_Pool_*pool)"
><b><code lang='und' xml:lang='und'>static void gc_gms_pool_init(Interp *, struct Small_Object_Pool *pool)</b></code></a></dt><p class="pad"></p>

<dd>Initialize pool variables. This function must set the pool function pointers for <code lang='und' xml:lang='und'>add_free_object</code>, <code lang='und' xml:lang='und'>get_free_object</code>, <code lang='und' xml:lang='und'>alloc_objects</code>, and <code lang='und' xml:lang='und'>more_objects</code>.</dd><p class="pad"></p>

<dt><a name="void_Parrot_gc_gms_init(Interp*_interp)"
><b><code lang='und' xml:lang='und'>void Parrot_gc_gms_init(Interp *interp)</b></code></a></dt><p class="pad"></p>

<dd>Initialize the state structures of the gc system. Called immediately before creation of memory pools.</dd><p class="pad"></p>
</dl>

<h2><a name="Interface_functions"
>Interface functions <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="static_void_gc_gms_add_free_object(Interp_*,_struct_Small_Object_Pool_*pool,_void_*to_add)"
><b><code lang='und' xml:lang='und'>static void gc_gms_add_free_object(Interp *, struct Small_Object_Pool *pool, void *to_add)</b></code></a></dt><p class="pad"></p>

<dd>Unused. White (dead) objects are added in a bunch to the free_list.</dd><p class="pad"></p>

<dt><a name="static_void_*_gc_gms_get_free_object(Interp_*,_struct_Small_Object_Pool_*pool)"
><b><code lang='und' xml:lang='und'>static void *gc_gms_get_free_object(Interp *, struct Small_Object_Pool *pool)</b></code></a></dt><p class="pad"></p>

<dd>Get a new object off the free_list in the given pool.</dd><p class="pad"></p>

<dt><a name="static_void_gc_gms_alloc_objects(Interp_*,_struct_Small_Object_Pool_*pool)"
><b><code lang='und' xml:lang='und'>static void gc_gms_alloc_objects(Interp *, struct Small_Object_Pool *pool)</b></code></a></dt><p class="pad"></p>

<dd>Allocate new objects for the given pool.</dd><p class="pad"></p>

<dt><a name="static_void_gc_gms_more_objects(Interp_*,_struct_Small_Object_Pool_*pool)"
><b><code lang='und' xml:lang='und'>static void gc_gms_more_objects(Interp *, struct Small_Object_Pool *pool)</b></code></a></dt><p class="pad"></p>

<dd>Run a GC cycle or allocate new objects for the given pool.</dd><p class="pad"></p>
</dl>

<h2><a name="Generation_handling_functions"
>Generation handling functions <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a
><b><code lang='und' xml:lang='und'>static Gc_gms_gen *gc_gms_create_gen(Interp *, struct Small_Object_Pool *pool, size_t gen_no)</b></code></a></dt><p class="pad"></p>

<dd>Create a generation structure for the given generation number.</dd><p class="pad"></p>

<dt><a name="static_void_gc_gms_init_gen(Interp_*,_struct_Small_Object_Pool_*pool)"
><b><code lang='und' xml:lang='und'>static void gc_gms_init_gen(Interp *, struct Small_Object_Pool *pool)</b></code></a></dt><p class="pad"></p>

<dd>Initalize the generation system by creating the first two generations.</dd><p class="pad"></p>

<dt><a name="void_parrot_gc_gms_wb(Interp_*,_PMC_*,_PMC_*old,_PMC_*new)"
><b><code lang='und' xml:lang='und'>void parrot_gc_gms_wb(Interp *, PMC *, PMC *old, PMC *new)</b></code></a></dt><p class="pad"></p>

<dd>Called by the write barrier. The aggregate belongs to an older generation then the <i>new</i> value written into it. Put the header of the new value onto the IGP list for the current generation, if it contains pointers to other items, and promote it to the old generation.</dd><p class="pad"></p>
</dl>

<h2><a name="Marking_functions"
>Marking functions <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="static_void_gc_gms_setto_gray(Interp_*,_Gc_gms_hdr_*h,_int_priority)"
><b><code lang='und' xml:lang='und'>static void gc_gms_setto_gray(Interp *, Gc_gms_hdr *h, int priority)</b></code></a></dt><p class="pad"></p>

<dd>Set the white header <code lang='und' xml:lang='und'>h</code> to gray.</dd><p class="pad"></p>

<dt><a name="static_void_gc_gms_setto_black(Interp_*,_Gc_gms_hdr_*h,_int_priority)"
><b><code lang='und' xml:lang='und'>static void gc_gms_setto_black(Interp *, Gc_gms_hdr *h, int priority)</b></code></a></dt><p class="pad"></p>

<dd>Set the white header <code lang='und' xml:lang='und'>h</code> to black.</dd><p class="pad"></p>

<dt><a name="parrot_gc_gms_pobject_lives(Interp*,_PObj_*)"
><b><code lang='und' xml:lang='und'>parrot_gc_gms_pobject_lives(Interp*, PObj *)</b></code></a></dt><p class="pad"></p>

<dd>Set the object live &#45; called by the pobject_lives macro</dd><p class="pad"></p>

<dt><a name="static_void_gc_gms_init_mark(Interp_*)"
><b><code lang='und' xml:lang='und'>static void gc_gms_init_mark(Interp *)</b></code></a></dt><p class="pad"></p>

<dd>Initialize the mark phase of GC.</dd><p class="pad"></p>

<dt><a name="static_int_gc_gms_trace_root(Interp_*,_int_trace_stack)"
><b><code lang='und' xml:lang='und'>static int gc_gms_trace_root(Interp *, int trace_stack)</b></code></a></dt><p class="pad"></p>

<dd>Trace the root set. If <code lang='und' xml:lang='und'>trace_stack</code> is true, trace system areas.</dd><p class="pad"></p>

<dt><a name="static_int_gc_gms_trace_children(Interp_*)"
><b><code lang='und' xml:lang='und'>static int gc_gms_trace_children(Interp *)</b></code></a></dt><p class="pad"></p>

<dd>Traverse gray objects: mark and blacken. Returns 0 if the trace was aborted lazily.</dd><p class="pad"></p>

<dt><a name="static_int_gc_gms_sweep(Interp_*)"
><b><code lang='und' xml:lang='und'>static int gc_gms_sweep(Interp *)</b></code></a></dt><p class="pad"></p>

<dd>Free unused resources, put white objects onto free_list.</dd><p class="pad"></p>
</dl>

<h2><a name="Interface_function_main_entry"
>Interface function main entry <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="void_parrot_gc_gms_run(Interp_*,_int_flags)"
><b><code lang='und' xml:lang='und'>void parrot_gc_gms_run(Interp *, int flags)</b></code></a></dt><p class="pad"></p>

<dd>Interface to <code lang='und' xml:lang='und'>Parrot_do_dod_run</code>. <code lang='und' xml:lang='und'>flags</code> is one of:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  DOD_lazy_FLAG   ... timely destruction
  DOD_finish_FLAG ... run a final sweep to destruct objects at
                      interpreter shutdown</pre>
</dl>

<h1><a name="SEE_ALSO"
>SEE ALSO <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p><em lang='und' xml:lang='und'>src/dod.c</em>, <em lang='und' xml:lang='und'>include/parrot/dod.h</em>, <em lang='und' xml:lang='und'>include/parrot/pobj.h</em>, <em lang='und' xml:lang='und'>src/gc_ims.c</em></p>

<h1><a name="HISTORY"
>HISTORY <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Initial version by leo (2005.01.12 &#45; 2005.01.30)</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
