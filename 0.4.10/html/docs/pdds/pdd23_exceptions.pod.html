<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Parrot Exceptions</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Parrot Exceptions</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../html/index.html">Contents</a> | <a href="../../../html/docs.html">Documentation</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>docs/pdds/pdd23_exceptions.pod &#45; Parrot Exceptions</p>

<h1><a name="ABSTRACT"
>ABSTRACT <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>This document defines the requirements and implementation strategy for Parrot&#39;s exception system.</p>

<h1><a name="VERSION"
>VERSION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>$Revision$</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p><i>Exceptions</i> are indications by running code that something unusual &#45;&#45; an &#34;exception&#34; to the normal processing &#45;&#45; has occurred.
When code detects an exceptional condition,
it <i>throws</i> an exception object.
Before this occurs,
code can register exception <i>handlers</i>,
which are functions (or closures) which may (but are not obligated to) <i>handle</i> the exception.
Some exceptions permit continued execution immediately after the <i>throw</i>; some don&#39;t.</p>

<p>Exceptions transfer control to a piece of code outside the normal flow of control.
They are mainly used for error reporting or cleanup tasks.</p>

<p>(A digression on terminology: In a system analysis sense,
the word &#34;exception&#34; usually refers to the exceptional event that requires out&#45;of&#45;band handling.
However,
in Parrot,
&#34;exception&#34; also refers to the object that holds all the information describing the exceptional condition: the nature of the exception,
the error message describing it,
and other ancillary information.
The specific type (class) of an exception object indicates its category.)</p>

<h2><a name="Exception_Opcodes"
>Exception Opcodes <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>These are the opcodes relevant to exceptions and exception handlers:</p>

<dl>
<dt><a name="push_eh_SUB_LABEL"
><b>push_eh <i>SUB_LABEL</i></b></a></dt><p class="pad"></p>

<dt><a name="push_eh_INVOCABLE_PMC"
><b>push_eh <i>INVOCABLE_PMC</i></b></a></dt><p class="pad"></p>

<dd>Push an invocable PMC &#45;&#45; usually a closure or,
in rarer cases,
a subroutine &#45;&#45; onto the exception handler stack.</dd><p class="pad"></p>

<dd>If a <i>SUB_LABEL</i> is provided,
Parrot automatically performs the equivalent of a <code lang='und' xml:lang='und'>newclosure</code> operation on the given subroutine,
and pushes the resulting closure.</dd><p class="pad"></p>

<dd>When an exception is thrown,
Parrot walks up the stack of active exception handlers,
invoking each one in turn,
but still in the dynamic context of the exception (i.e.
the call stack is <i>not</i> unwound first).
See below for more detail.</dd><p class="pad"></p>

<dt><a name="pop_eh"
><b>pop_eh</b></a></dt><p class="pad"></p>

<dd>Pop the most recently pushed exception handler off the exception handler stack.</dd><p class="pad"></p>

<dd>{{ TODO: Provide exception handler stack introspection.
}}</dd><p class="pad"></p>

<dt><a name="throw_EXCEPTION"
><b>throw <i>EXCEPTION</i></b></a></dt><p class="pad"></p>

<dd>Throw an exception consisting of the given <i>EXCEPTION</i> PMC.
Active exception handlers (if any) will be invoked with <i>EXCEPTION</i> as the only parameter.</dd><p class="pad"></p>

<dd>Throwing an exception with <code lang='und' xml:lang='und'>throw</code> is a one&#45;way trip (unless you have made other arrangements) because Parrot does not take a continuation after this opcode.
(But see <b>throwcc</b> below.)</dd><p class="pad"></p>

<dd>Any type of PMC can be thrown as an exception.
However,
if there&#39;s any chance of cross&#45;language calls &#45;&#45; and in a Parrot environment,
cross&#45;language operations are kind of the point &#45;&#45; then you should be prepared to catch exception classes you would never have thrown yourself.</dd><p class="pad"></p>

<dd>That said,
it is <i>VERY STRONGLY RECOMMENDED</i> that any thrown PMC that can possibly escape your private sandbox should meet the minimal interface requirements of the <code lang='und' xml:lang='und'>parrot;exception</code> class,
described below.</dd><p class="pad"></p>

<dt><a name="throwcc_EXCEPTION_[_,_CONTINUATION_]"
><b>throwcc <i>EXCEPTION</i> [ ,
<i>CONTINUATION</i> ]</b></a></dt><p class="pad"></p>

<dd>Throw an exception consisting of the given <i>EXCEPTION</i> PMC after taking a continuation at the next opcode.
When a <i>CONTINUATION</i> is passed in,
it will use that instead.
Active exception handlers (if any) will be invoked with <i>EXCEPTION</i> and the given continuation as parameters.</dd><p class="pad"></p>

<dd>Except for the continuation which is passed to exception handlers,
<code lang='und' xml:lang='und'>throwcc</code> is just like <code lang='und' xml:lang='und'>throw</code>.
This opcode is useful for exceptions that are more like warnings or notices than errors.</dd><p class="pad"></p>

<dd>Exception handlers can resume execution immediately after the <code lang='und' xml:lang='und'>throwcc</code> opcode by executing the <code lang='und' xml:lang='und'>handled</code> opcode,
and then invoking the given continuation which they receive as a parameter.
That continuation must be invoked with no parameters; in other words,
<code lang='und' xml:lang='und'>throwcc</code> never returns a value.</dd><p class="pad"></p>

<dt><a name="die_[_MESSAGE_]"
><b>die [ <i>MESSAGE</i> ]</b></a></dt><p class="pad"></p>

<dd>The <code lang='und' xml:lang='und'>die</code> opcode throws an exception of type <code lang='und' xml:lang='und'>exception;death</code> with a payload of <i>MESSAGE</i>.
If <i>MESSAGE</i> is a string register,
the exception payload is a <code lang='und' xml:lang='und'>String</code> PMC containing <i>MESSAGE</i>; if <i>MESSAGE</i> is a PMC,
it is used directly as the exception payload.</dd><p class="pad"></p>

<dd>The default when no <i>MESSAGE</i> is given is &#34;Fatal exception at LINE in FILE.&#34; followed by a backtrace.</dd><p class="pad"></p>

<dd>If this exception is not handled,
it results in Parrot returning an error indication and the stringification of <i>MESSAGE</i> to its embedding environment.
When running standalone,
this means writing the stringification of <i>MESSAGE</i> to standard error and executing the standard C function <code lang='und' xml:lang='und'>exit(1)</code>.</dd><p class="pad"></p>

<dt><a name="exit_[_EXITCODE_]"
><b>exit [ <i>EXITCODE</i> ]</b></a></dt><p class="pad"></p>

<dd>Throw an exception of type <code lang='und' xml:lang='und'>exception;exit</code> with a payload of <i>EXITCODE</i>,
which defaults to zero,
as an Integer PMC.</dd><p class="pad"></p>

<dd>If not handled,
this exception results in Parrot returning <i>EXITCODE</i> as a status to its embedded environment,
or when running standalone,
to execute the C function <code lang='und' xml:lang='und'>exit(<i>EXITCODE</i>)</code>.</dd><p class="pad"></p>

<dt><a name="handled_EXCEPTION"
><b>handled <i>EXCEPTION</i></b></a></dt><p class="pad"></p>

<dd>While handling an exception,
tell Parrot that the exception has been handled and should be removed from the stack of active exceptions.
This opcode is an exception handler&#39;s way of telling Parrot that it has handled the exception.</dd><p class="pad"></p>
</dl>

<h2><a name="Order_of_Operations_in_Exception_Handling"
>Order of Operations in Exception Handling <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>When <b>throw</b> or <b>throwcc</b> is called,
for all active exception handlers,
in LIFO order:</p>

<dl>
<dt><a name="1_Find_the_topmost_exception_handler."
>1 Find the topmost exception handler.</a></dt><p class="pad"></p>

<dt><a
>2 Push an exception record somewhere,
presumably on the exception handler stack.
The exception record contains a pointer to an exception handler block,
an exception PMC,
and (optionally) a continuation.</a></dt><p class="pad"></p>

<dt><a name="3_Invoke_the_handler_(note:_this_is_still_in_the_thrower&#39;s_dynamic_context)."
>3 Invoke the handler (note: this is still in the thrower&#39;s dynamic context).</a></dt><p class="pad"></p>
</dl>

<p>If the handler returns without calling <code lang='und' xml:lang='und'>handled</code>:</p>

<dl>
<dt><a name="1_Find_the_&#34;exception_handling_in_progress&#34;_record."
>1 Find the &#34;exception handling in progress&#34; record.</a></dt><p class="pad"></p>

<dt><a name="2_Find_the_next_exception_handler."
>2 Find the next exception handler.</a></dt><p class="pad"></p>

<dt><a name="3_If_the_handler_is_found,_invoke_it."
>3 If the handler is found,
invoke it.</a></dt><p class="pad"></p>

<dt><a
>4 If no handler is found,
and the exception is non&#45;fatal (such as a warning),
and there is a continuation in the exception record (because the throwing opcode was <b><code lang='und' xml:lang='und'>throwcc</b></code>),
invoke the continuation (resume execution).
Whether to resume or die when an exception isn&#39;t handled is determined by the severity of the exception.</a></dt><p class="pad"></p>

<dt><a name="5_Otherwise_terminate_program_a_la_die."
>5 Otherwise terminate program a la <b><code lang='und' xml:lang='und'>die</b></code>.</a></dt><p class="pad"></p>
</dl>

<p>When running an embedded Parrot interpreter,
the interpreter does not immediately terminate on an unhandled exception,
it merely returns control to the embedding program and stores the unhandled exception so that it may be queried by the embedding program.
The embedding program may choose to handle the exception and continue execution by invoking the exception&#39;s continuation.</p>

<p>When the <code lang='und' xml:lang='und'>handled</code> opcode is called:</p>

<dl>
<dt><a name="1_Pop_and_destroy_the_exception_record."
>1 Pop and destroy the exception record.</a></dt><p class="pad"></p>

<dt><a name="2_If_there_was_a_continuation_in_the_exception_record,_invoke_the_continuation."
>2 If there was a continuation in the exception record,
invoke the continuation.</a></dt><p class="pad"></p>
</dl>

<h1><a name="STANDARD_EXCEPTIONS"
>STANDARD EXCEPTIONS <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<h2><a name="Universal_Exception_Object_Interface_[Advisory]"
>Universal Exception Object Interface [Advisory] <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>All of Parrot&#39;s standard exceptions provide at least the following interface.
It is <i>STRONGLY RECOMMENDED</i> that all classes intended for throwing also provide at least this interface as well.</p>

<dl>
<dt><a name="PMC_*get_message()"
><b>PMC *get_message()</b></a></dt><p class="pad"></p>

<dd>Get an exception&#39;s human&#45;readable self&#45;description.
Note that the type of the returned PMC may not be <code lang='und' xml:lang='und'>String</code>,
but you should still be able to stringify and print it.</dd><p class="pad"></p>

<dt><a name="PMC_*get_payload()"
><b>PMC *get_payload()</b></a></dt><p class="pad"></p>

<dd>Get the datum that more specifically identifies the detailed cause/nature of the exception.
Each exception class will have its own specific payload type(s).
See the table of standard exception classes for examples.</dd><p class="pad"></p>

<dt><a name="PMC_*get_inner_exception()"
><b>PMC *get_inner_exception()</b></a></dt><p class="pad"></p>

<dd>If an exception is a consequence of a previous exception,
the <code lang='und' xml:lang='und'>get_inner_exception()</code> method returns that previous exception,
else it returns null.</dd><p class="pad"></p>
</dl>

<h2><a name="Interface_of_Standard_Parrot_Exceptions"
>Interface of Standard Parrot Exceptions <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Parrot&#39;s standard exceptions provide some additional methods beyond the three universal exception methods shown above.
The additional methods are:</p>

<dl>
<dt><a name="init_pmc(PMC_*payload)"
><b>init_pmc(PMC *payload)</b></a></dt><p class="pad"></p>

<dd>Initialize the exception PMC with the given payload.
Note that the payload will be interpreted differently depending on the specific type of the exception.
For example,
the payload of <code lang='und' xml:lang='und'>exception;errno</code> is an integer.
In addition,
some exceptions don&#39;t require payloads,
thus:</dd><p class="pad"></p>

<dt><a name="init()"
><b>init()</b></a></dt><p class="pad"></p>

<dd>Initialize the exception PMC without a payload.
Some exceptions are adequately self&#45;explanatory without payloads.</dd><p class="pad"></p>

<dt><a name="void_set_inner_exception(PMC_*inner)"
><b>void set_inner_exception(PMC *inner)</b></a></dt><p class="pad"></p>

<dd>If an exception is a consequence of a previous exception,
use the <code lang='und' xml:lang='und'>set_inner_exception()</code> method to store that previous exception as part of the exception object.</dd><p class="pad"></p>
</dl>

<h2><a name="Standard_Parrot_Exceptions"
>Standard Parrot Exceptions <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Parrot comes with a small hierarchy of classes designed for use as exceptions.
Parrot throws them when internal Parrot errors occur,
but any user code can throw them too.</p>

<dl>
<dt><a name="exception"
><b>exception</b></a></dt><p class="pad"></p>

<dd>Base class of all standard exceptions.
Provides no special functionality.
Exists for the purpose of <code lang='und' xml:lang='und'>isa</code> testing.</dd><p class="pad"></p>

<dt><a name="exception;errno"
><b>exception;errno</b></a></dt><p class="pad"></p>

<dd>A system error as reported in the C variable <code lang='und' xml:lang='und'>errno</code>.
Payload is an integer.
Message is the return value of the standard C function <code lang='und' xml:lang='und'>strerror()</code>.</dd><p class="pad"></p>

<dt><a name="exception;math"
><b>exception;math</b></a></dt><p class="pad"></p>

<dd>Generic base class for math errors.</dd><p class="pad"></p>

<dt><a name="exception;math;division_by_zero"
><b>exception;math;division_by_zero</b></a></dt><p class="pad"></p>

<dd>Division by zero (integer or float).
No payload.</dd><p class="pad"></p>

<dt><a name="exception;domain"
><b>exception;domain</b></a></dt><p class="pad"></p>

<dd>Generic base class for miscellaneous domain (input value) errors.
Payload is an array,
the first element of which is the operation that failed (e.g.
the opcode name); subsequent elements depend on the value of the first element.</dd><p class="pad"></p>

<dd>(Note: There is not a separate exception class for every operation that might throw a domain exception.
Class proliferation is expensive,
both to Parrot and to the humans working with it who have to memorize a class hierarchy.
But I understand the temptation.)</dd><p class="pad"></p>

<dt><a name="exception;lexical"
><b>exception;lexical</b></a></dt><p class="pad"></p>

<dd>An <code lang='und' xml:lang='und'>find_lex</code> or <code lang='und' xml:lang='und'>store_lex</code> operation failed because a given lexical variable was not found.
Payload is an array: [0] the name of the lexical variable that was not found,
[1] the LexPad in which it was not found.</dd><p class="pad"></p>
</dl>

<h2><a name="Opcodes_that_Throw_Exceptions"
>Opcodes that Throw Exceptions <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Exceptions have been incorporated into built&#45;in opcodes in a limited way.
For the most part,
they&#39;re used when the return value is either impractical to check (perhaps because we don&#39;t want to add that many error checks in line),
or where the output type is unable to represent an error state (e.g.
the output I register of the <code lang='und' xml:lang='und'>ord</code> opcode).</p>

<p>The <code lang='und' xml:lang='und'>div</code>,
<code lang='und' xml:lang='und'>fdiv</code>,
and <code lang='und' xml:lang='und'>cmod</code> opcodes throw <code lang='und' xml:lang='und'>exception;math;division_by_zero</code>.</p>

<p>The <code lang='und' xml:lang='und'>ord</code> opcode throws <code lang='und' xml:lang='und'>exception;domain</code> when it&#39;s passed an empty argument or a string index that&#39;s outside the length of the string.
Payload is an array,
first element being the string &#39;ord&#39;.</p>

<p>The <code lang='und' xml:lang='und'>classoffset</code> opcode throws <code lang='und' xml:lang='und'>exception;domain</code> when it&#39;s asked to retrieve the attribute offset for a class that isn&#39;t in the object&#39;s inheritance hierarchy.
Payload is an array: [0] string &#39;classoffset&#39;,
[1] object in question,
[2] ID of class not found.</p>

<p>The <code lang='und' xml:lang='und'>find_charset</code> opcode throws <code lang='und' xml:lang='und'>exception;domain</code> if the charset name it&#39;s looking up doesn&#39;t exist.
Payload is an array: [0] string &#39;find_charset&#39;,
[1] charset name that was not found.</p>

<p>The <code lang='und' xml:lang='und'>trans_charset</code> opcode throws <code lang='und' xml:lang='und'>exception;domain</code> on &#34;information loss&#34; (presumably,
this means when one charset doesn&#39;t have a one&#45;to&#45;one correspondence in the other charset).
Payload is an array: [0] string &#39;trans_charset&#39;,
[1] source charset name,
[2] destination charset name,
[3] untranslatable code point.</p>

<p>The <code lang='und' xml:lang='und'>find_encoding</code> opcode throws <code lang='und' xml:lang='und'>exception;domain</code> if the encoding name it&#39;s looking up doesn&#39;t exist.
Payload is an array: [0] string &#39;find_encoding&#39;,
[1] encoding name that was not found.</p>

<p>The <code lang='und' xml:lang='und'>trans_encoding</code> opcode throws <code lang='und' xml:lang='und'>exception;domain</code> on &#34;information loss&#34; (presumably,
this means when one encoding doesn&#39;t have a one&#45;to&#45;one correspondence in the other encoding).
Payload is an array: [0] string &#39;trans_encoding&#39;,
[1] source encoding name,
[2] destination encoding name,
[3] untranslatable code point.</p>

<p>Parrot&#39;s default version of the <code lang='und' xml:lang='und'>LexPad</code> PMC throws <code lang='und' xml:lang='und'>exception;lexical</code> for some error conditions,
though other implementations can choose to return error values instead.</p>

<p>By default,
the <code lang='und' xml:lang='und'>find_lex</code> and <code lang='und' xml:lang='und'>store_lex</code> opcodes throw an exception (<code lang='und' xml:lang='und'>exception;lexical</code>) when the given name can&#39;t be found in any visible lexical pads.
However,
this behavior is only a default,
as provided by the default Parrot lexical pad PMC <code lang='und' xml:lang='und'>LexPad</code>.
If a given HLL has its own lexical pad PMC,
its behavior may be very different.
(For example,
in Tcl,
<code lang='und' xml:lang='und'>store_lex</code> is likely to succeed every time,
as creating new lexicals at runtime is OK in Tcl.)</p>

<p>{{ TODO: List any other opcodes that currently throw exceptions and general categories of opcodes that should throw exceptions.
}}</p>

<p>Other opcodes respond to an <code lang='und' xml:lang='und'>errorson</code> setting to decide whether to throw an exception or return an error value.
<code lang='und' xml:lang='und'>find_global</code> throws an exception (or returns a Null PMC) if the global name requested doesn&#39;t exist.
<code lang='und' xml:lang='und'>find_name</code> throws an exception (or returns a Null PMC) if the name requested doesn&#39;t exist in a lexical,
current,
global,
or built&#45;in namespace.</p>

<p>{{ TODO: &#34;errorson&#34; as specified is dynamically rather than lexically scoped; is this good?
Probably not good.
Let&#39;s revisit it when we get the basic exceptions functionality implemented.
}}</p>

<p>It&#39;s a little odd that so few opcodes throw exceptions (these are the ones that are documented,
but a few others throw exceptions internally even though they aren&#39;t documented as doing so).
It&#39;s worth considering either expanding the use of exceptions consistently throughout the opcode set,
or eliminating exceptions from the opcode set entirely.
The strategy for error handling should be consistent,
whatever it is.
[I like the way <code lang='und' xml:lang='und'>LexPad</code>s and the <code lang='und' xml:lang='und'>errorson</code> settings provide the option for exception&#45;based or non&#45;exception&#45;based implementations,
rather than forcing one or the other.]</p>

<p>{{ NOTE: There are a couple of different factors here.
One is the ability to globally define the severity of certain exceptions or categories of exceptions without needing to define a handler for each one.
(e.g.
Perl 6 may have pragmas to set how severe type&#45;checking errors are.
A simple &#34;incompatible type&#34; error may be fatal under one pragma,
a resumable warning under another pragma,
and completely silent under a third pragma.) Another is the ability to &#34;defang&#34; opcodes so they return error codes instead of throwing exceptions.
We might provide a very simple interface to catch an exception and capture its payload without the full complexity of manually defining exception handlers (though it would still be implemented as an exception handler internally).
Something like:</p>

<pre lang='und' xml:lang='und'>  .local pmc error_code
  .capture_start error_code
  $P1 = find_lex &#39;foo&#39;
  .capture_end

  # error_code contains what would have been the &#34;error&#34; return value</pre>

<p>This could eliminate the need for &#34;defanging&#34; because it would be almost as easy to use as error codes. It could be implemented once for all exceptional opcodes, instead of needing to be defined for each one. And, it still keeps the error information out&#45;of&#45;band, instead of mixing the error in with normal return values. }}</p>

<h2><a name="Resuming_after_Exceptions"
>Resuming after Exceptions <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Exceptions thrown by standard Parrot opcodes (like the one thrown by <code lang='und' xml:lang='und'>find_global</code> above or by the <code lang='und' xml:lang='und'>throw</code> opcode) are always resumable, so when the exception handler function returns normally it continues execution at the opcode immediately after the one that threw the exception. Other exceptions at the run&#45;loop level are also generally resumable.</p>

<pre lang='und' xml:lang='und'>  $P0 = new String
  $P0 = &#34;something bad happened&#34;
  $P1 = new [&#39;parrot&#39;;&#39;exception&#39;], $P0  # create new exception object
  throw $P1                              # throw it</pre>

<h1><a name="ATTACHMENTS"
>ATTACHMENTS <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>None.</p>

<h1><a name="FOOTNOTES"
>FOOTNOTES <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>None.</p>

<h1><a name="REFERENCES"
>REFERENCES <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<pre lang='und' xml:lang='und'>  src/ops/core.ops
  src/exceptions.c</pre>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
