<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>Parrot  - PCT: Parrot Compiler Tools</title>
        <link rel="stylesheet" type="text/css"
            href="../../../resources/parrot.css"
            media="all">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    </head>
    <body>
        <div id="wrapper">
            <div id="header">

                <a href="http://www.parrot.org">
                <img border=0 src="../../../resources/parrot_logo.png" id="logo" alt="parrot">
                </a>
            </div> <!-- "header" -->
            <div id="divider"></div>
            <div id="mainbody">
                <div id="breadcrumb">
                    <a href="../../../html/index.html">Home</a> &raquo; PCT: Parrot Compiler Tools
                </div>

<h1><a name="PCT:_Parrot_Compiler_Tools"
>PCT: Parrot Compiler Tools</a></h1>

<p></p>

<p>So far we&#39;ve talked a lot about low&#45;level Parrot programming with PIR and PASM.
However,
the true power of Parrot is its ability to host programs written in high level languages such as Perl 6,
Python,
Ruby,
Tcl,
and PHP.
In order to write code in these languages developers need there to be compilers that convert from the language into PIR or PASM (or even directly convert to Parrot Bytecode).
People who have worked on compilers before may be anticipating us to use terms like &#34;Lex and Yacc&#34; here,
but we promise that we wont.</p>

<p>Instead of traditional lexical analyzers and parser&#45;generators that have been the mainstay of compiler designers for decades,
Parrot uses an advanced set of parsing tools called the Parrot Compiler Tools (PCT)<!--
	INDEX: Parrot Compiler Tools
-->.
PCT uses a subset of the Perl 6 programming language called <i>Not Quite Perl</i><!--
	INDEX: Not Quite Perl
--> (NQP) and an implementation of the Perl 6 Grammar Engine <!--
	INDEX: Perl 6 Grammar Engine
--> (PGE) to build compilers for Parrot.
Instead of using traditional low&#45;level languages to write compilers,
we can use a modern dynamic language like Perl 6 to write it instead.
On a more interesting note,
this means that the Perl 6 compiler is itself being written in Perl 6,
a mind&#45;boggling process known as <code>bootstrapping</code>.</p>

<h2><a name="PCT_Overview"
>PCT Overview</a></h2>

<p>PCT is a collection of classes which handle the creation of a compiler and driver program for a high&#45;level language.
The <code>PCT::HLLCompiler</code> class handles building the compiler front end while the <code>PCT::Grammar</code> and <code>PCT::Grammar::Actions</code> classes handle building the parser and lexical analyzer.
Creating a new HLL compiler is as easy as subclassing these three entities with methods specific to that high&#45;level language.</p>

<p>While it was originally designed as the backend for Perl 6,
Parrot has since grown to become a language agnostic virtual machine.
However,
PCT is still very tied to Perl 6 development,
and was actually developed by Perl 6 developers for Perl 6 development.
The fact that it&#39;s very powerful,
flexible,
and useful for other languages is a nice bonus,
And a mark of good design! but the needs of other languages is not the driving force behind PCT.
Perl 6 is such a large and varied language that a tool capable of implementing it is also capable of implementing many other languages as well,
a fact that has been exploited by many language designers and implementers on Parrot.</p>

<h3><a name="Grammars_and_Action_Files"
>Grammars and Action Files</a></h3>

<p>Creating a compiler using PCT requires three basic files,
plus any additional files needed to implement the languages logic and library:</p>

<ul>
<li>A main file</li>

<p>The main file should contain the <code>:main</code> function that is the driver program for the compiler.
Here,
a new <code>PCT::HLLCompiler</code> object is instantiated,
libraries are loaded,
and necessary special global variables are created.
The driver program is typically written in PIR,
although thankfully they tend to be very short.
Most of the action happens elsewhere.</p>

<li>A parser file</li>

<p>The grammar for the high level language is specified using the Perl 6 grammar engine (PGE) and is stored in a <code>.pg</code> file.
This file should subclass the <code>PCT::Grammar</code> class and implement all the necessary rules to successfully parse the language.</p>

<li>An actions file</li>

<p>Actions files are written in NQP.
They take match objects generated by the grammar file and convert them into an Abstract Syntax Tree (AST) <!--
	INDEX: Abstract Syntax Tree;Parrot Abstract Syntax Tree;AST;PAST
--> which is converted by PCT into PIR for compiling and execution.
The PIR implementation of these AST trees and nodes is called the Parrot Abstract Syntax Tree (PAST).</p>
</ul>

<h3><a name="make_language_shell.pl"
><code>make_language_shell.pl</code></a></h3>

<p>The Parrot repository contains a number of helpful utilities for doing some common development and building tasks with Parrot.
These utilities are all currently written in Perl 5,
although in future releases the majority will likely be built in Perl 6 and run on Parrot directly.
This is a bootstrapping problem that the developers have not tackled yet.</p>

<p>One of the tools of use to new compiler designers and language implementers is <code>make_language_shell.pl</code>.
<code>make_language_shell.pl</code> is a tool for automatically creating all the necessary stub files for creating a new compiler for Parrot.
It generates the driver file,
parser grammar and actions files,
builtin functions stub file,
makefile,
and test harness.
All of these are demonstrative stubs and will obviously need to be edited furiously or even completely overwritten,
but they give a good idea of what is needed to start on development of the compiler.</p>

<p><code>make_language_shell.pl</code> is designed to be run from within the Parrot repository file structure.
It creates a subfolder in <code>/languages/</code> with the name of your new language implementation.
Typically a new implementation of an existing language is not simply named after the language,
but is given some other descriptive name to let users know it is only one implementation available.
Consider the way Perl 5 distributions are named things like &#34;Active Perl&#34; or &#34;Strawberry Perl&#34;,
or how Python distributions might be &#34;IronPython&#34; or &#34;VPython&#34;.
If,
on the other hand,
you are implementing an entirely new language,
you don&#39;t need to give it a fancy distribution name.</p>

<h3><a name="Parsing_Fundamentals"
>Parsing Fundamentals</a></h3>

<p>Compilers typically consist of three components: The lexical analyzer,
the parser,
and the code generator <code>This is an oversimplification, compilers also may have semantic analyzers, symbol tables, optimizers, preprocessors, data flow analyzers, dependency analyzers, and resource allocators, among other components. All these things are internal to Parrot and aren&#39;t the concern of the compiler implementer. Plus, these are all well beyond the scope of this book</code>.
The lexical analyzer converts the HLL input file into individual tokens.
A token may consist of an individual punctuation mark(&#34;+&#34;),
an identifier (&#34;myVar&#34;),
or a keyword (&#34;while&#34;),
or any other artifact that cannot be sensibly broken down.
The parser takes a stream of these input tokens,
and attempts to match them against a given pattern,
or grammar.
The matching process orders the input tokens into an abstract syntax tree (AST),
which is a form that the computer can easily work with.
This AST is passed to the code generator which converts it into code of the target language.
For something like the GCC C compiler,
the target language is machine code.
For PCT and Parrot,
the target language is PIR and PBC.</p>

<p>Parsers come in two general varieties: Top&#45;down and bottom&#45;up.
Top&#45;down parsers start with a top&#45;level rule,
a rule which is supposed to represent the entire input.
It attempts to match various combination of subrules until the entire input is matched.
Bottom&#45;down parsers,
on the other hand,
start with individual tokens from the lexical analyzer and attempt to combine them together into larger and larger patterns until they produce a top&#45;level token.</p>

<p>PGE itself is a top&#45;down parser,
although it also contains a bottom&#45;up <i>operator precedence</i> parser,
for things like mathematical expressions where bottom&#45;up methods are more efficient.
We&#39;ll discuss both,
and the methods for switching between the two,
throughout this chapter.</p>

<h2><a name="Driver_Programs"
>Driver Programs</a></h2>

<p>The driver program for the new compiler must create instances of the various necessary classes that run the parser.
It must also include the standard function libraries,
create global variables,
and handle commandline options.
Most commandline options are handled by PCT,
but there are some behaviors that the driver program will want to override.</p>

<p>PCT programs can,
by default,
be run in two ways: Interactive mode,
which is run one statement at a time in the console,
and file mode which loads and runs an entire file.
For interactive mode,
it is necessary to specify information about the prompt that&#39;s used and the environment that&#39;s expected.
Help and error messages need to be written for the user too.</p>

<h3><a name="HLLCompiler_class"
><code>HLLCompiler</code> class</a></h3>

<h2><a name="Parrot_Grammar_Engine"
>Parrot Grammar Engine</a></h2>

<p>The Parrot Grammar Engine <!--
	INDEX: Parrot Grammar Engine;PGE
--> is an implementation of the Perl 6 grammar syntax in Parrot.
The grammar engine in Perl 6 is much more advanced and flexible then the regular expression syntax of Perl 5.
Since most other languages who implement regular expressions use a copy (or a subset) of Perl 5&#39;s regular expressions,
PGE is much more powerful then those too.</p>

<p>PGE uses a recursive descent algorithm it also uses an operator precedence parser,
when you ask it nicelywhich should be very familiar to users of the Perl 5 module <code>Parse::RecDescent</code>.
In fact,
both were originally designed by the same developer,
Damian Conway.
Recursive Descent,
for those who get into the algorithmic details,
is a top&#45;down parsing algorithm,
unlike the bottom&#45;up LALR algorithm used in parser&#45; generators like Yacc and Bison.
Most programmers won&#39;t notice the difference between the two for most applications,
although there are some specific places where the behavior will be different.</p>

<h3><a name="Rules_and_Actions"
>Rules and Actions</a></h3>

<p>A recursive descent parser,
like the one used in PGE,
is a top&#45;down parser.
This means it attempts to start at the highest&#45;level rule and work its way down to the individual input tokens in order to match the given input.
Once the parser has matched the entire input a source code file,
or a line of input at the terminal in interactive mode the parse is considered successful and the generated AST is delivered to the code generator for conversion into PIR.</p>

<p>The parser is formed by creating a <i>grammar</i>.
Grammars consist of three primary components: rules,
tokens,
and protoregexes.</p>

<ul>
<li>Rules</li>

<p>Rules are the most basic grammar element.
Rules may call subrules and may also contain arbitrary whitespace,
which is ignored.</p>

<li>Tokens</li>

<p>Tokens represent basic regular expressions.
They may not call subrules and whitespace is treated literally.
{{I don&#39;t think this is right,
but I&#39;m adding it here anyway as a placeholder &#45;&#45; Whiteknight}}</p>

<li>Protoregex</li>

<p>A protoregex is like a rule or a token,
except it can be overloaded dynamically.</p>
</ul>

<p>When a rule matches a sequence of input tokens,
an associated method in NQP is called to convert that match into an AST node.
This node is then inserted into the <i>parse tree</i>.</p>

<h3><a name="Basic_Rules"
>Basic Rules</a></h3>

<p>Let&#39;s start off with a simple rule:</p>

<pre> rule persons_name {
    &#60;first_name&#62; &#60;last_name&#62;
 }</pre>

<p>We also define the two name tokens as:</p>

<pre> token first_name { &#60;alpha&#62;+ }
 token last_name { &#60;alpha&#62;+ }</pre>

<p>The special token <code>&#60;alpha&#62;</code> is a built&#45;in construct that only accepts upper case and lower case letters. The &#34;+&#34; after the <code>&#60;alpha&#62;</code> tag is a short way of saying &#34;one or more&#34;. Our rule <code>persons_name</code> would match something like <code>Darth Vader</code> Actually, it matches a lot of things that aren&#39;t people&#39;s namesbut wouldn&#39;t match something like <code>C 3P0</code>. Notice that the rule above would match <code>Jar Jar Binks</code>, but not the way you would expect: It would match the first &#34;Jar&#34; as <code>&#60;first_name&#62;</code> and the second &#34;Jar&#34; as <code>&#60;last_name&#62;</code> and wouldn&#39;t match &#34;Binks&#34; at all.</p>

<p>In PGE, the top&#45;level rule which starts the match process and must successfully match in order for the compiler to continue is always called <code>TOP</code>. Without a TOP rule, your compiler won&#39;t do anything Actually, it will print out an error saying that you have no TOP rule, and then it will exit, but that isn&#39;t anything that we would want it to do.</p>

<p>Here&#39;s an example TOP rule that uses our definition for <code>&#60;persons_name&#62;</code> above and matches a file that contains a comma&#45; separated list of names:</p>

<pre> rule TOP {
    [ &#60;persons_name&#62; &#39;,&#39; ]*
 }</pre>

<p>this example shows another new construct, the square brackets. Square brackets are ways to group things together. The star at the end means that we take all the things inside the brackets zero or more times. This is similar to the plus, except the plus matches one or more times. Notice, however, that the above rule always matches a comma at the end, so we would need to have something like:</p>

<pre> Darth Vader, Luke Skywalker,</pre>

<p>Instead of something more natural like:</p>

<pre> Darth Vader, Luke Skywalker</pre>

<p>We can modify the rule a little bit so that it always ends with a name instead of a comma:</p>

<pre> rule TOP {
    [ &#60;persons_name&#62; &#39;,&#39; ]* &#60;persons_name&#62;
 }</pre>

<p>Now we don&#39;t need a trailing comma, but at the same time we can&#39;t match an empty file because it always expects to have at least one name at the end. If we still want to match empty files successfully, we need to make the whole rule optional:</p>

<pre> rule TOP {
    [ [ &#60;persons_name&#62; &#39;,&#39; ]* &#60;persons_name&#62; ]?
 }</pre>

<p>We&#39;ve grouped the whole rule together in another set of brackets, and put a &#34;?&#34; question mark at the end. The question mark means zero or one of the prior item.</p>

<p>The symbols &#34;*&#34; (zero or more), &#34;+&#34; (one or more) and &#34;?&#34; are called <i>quantifiers</i>, and allow an item in the rule to match a variable number of times. These aren&#39;t the only quantifiers, but they are the most common. We will talk about other quantifiers later on.</p>

<h3><a name="Calling_Actions"
>Calling Actions</a></h3>

<p>We haven&#39;t covered actions yet, but it&#39;s still important now to talk about how we will call them when we are ready. We call an action by inserting the <code>{*}</code> token into the rule. When the <code>{*}</code> rule is encountered, PGE calls the associated action method with the current match object as an argument. Let&#39;s take our <code>persons_name</code> rule from above, and sprinkle liberally with action calls:</p>

<pre> rule persons_name {
    {*} &#60;first_name&#62; {*} &#60;last_name&#62; {*}
 }</pre>

<p>The first call to the action method contains an empty match object because the parser hasn&#39;t had a chance to match anything yet. The second call contains only the first name of the match. The third and final call contains both the matched first and last name. Notice that if the match fails halfway through, we still call the actions where we succeeded, but do not call the actions after the failure. So, if we try to match the string &#34;Leia&#34;, the action is called before the name and after the first name. When the rule tries to match the last name, it fails because no last name is provided, and the third action method call is never made.</p>

<h3><a name="Alternations_and_Keys"
>Alternations and Keys</a></h3>

<p>In addition to sub&#45;rules, groups, and quantifiers, we also are able to take alternations between options that are either&#45;or. The vertical bar token &#34;|&#34; can be used to distinguish between options where only one may match, Here&#39;s an example:</p>

<pre> rule hero {
    [&#39;Luke&#39; | &#39;Leia&#39;] &#39;Skywalker&#39;
 }</pre>

<p>This rule will match either &#34;Luke Skywalker&#34; or &#34;Leia Skywalker&#34; but won&#39;t match &#34;Luke Leia Skywalker&#34; or anything else, for that matter. With things like alternations, if we want to call an action method it&#39;s helpful to distinguish which combination we matched:</p>

<pre> rule hero {
    [
      &#39;Luke&#39; {*}    #= Luke
    | &#39;Leia&#39; {*}    #= Leia
    ]
    &#39;Skywalker&#39;
 }</pre>

<p>This is the same rule, except now it passes two arguments to its action method: the match object and the name of the person who got matched.</p>

<h3><a name="Warning:_Left_Recursion"
>Warning: Left Recursion</a></h3>

<p>Getting into all the nitty&#45;gritty theory behind parsers is well beyond the scope of this book. However, there is one potential pitfall that developers should be made aware of that is not immediately obvious. Like functions in ordinary procedural or functional languages, the methods in the PGE parser grammar can call themselves recursively. Consider the following rules derived in part from the grammar for the C programming language:</p>

<pre> rule if_statement {
    &#39;if&#39; &#60;condition&#62; &#39;{&#39; &#60;statement&#62;* &#39;}&#39; &#60;else_block&#62;?
 }

 rule statement {
    &#60;if_statement&#62; | &#60;expression&#62;
 }

 rule else_block {
    &#39;else&#39; &#39;{&#39; &#60;statements&#62;* &#39;}&#39;
 }</pre>

<p>Notice that an <code>if_statement</code> can contain a list of <code>statement</code>s, and that each statement may itself be an <code>if_statement</code>? This is called <i>recursion</i> <!--
	INDEX: Recursion
-->, and is part of where the &#34;Recursive Descent&#34; algorithm gets its name from.</p>

<p>Now, let&#39;s look at a more direct example of a comma&#45;separated list of integer digits to form an array. We can define this recursively as follows:</p>

<pre> rule list {
     &#60;list&#62; &#39;,&#39; &#60;digit&#62; | &#60;digit&#62;
 }</pre>

<p>The intention is that if there is only one digit, we match the second option in the alternation, and if there are more digits we can match them recursively in the first alternation. However, take a close look at the insidious result. The recursive descent parser enters the <code>list</code> rule. It&#39;s first option is to enter the list rule again, so it does. Recursive descent is a depth&#45;first algorithm, and it will continue to descent down a particular path until it finds a successful match or a match failure. In this case, it matches <code>list</code> and then it matches <code>list</code> again, then it matches <code>list</code> again, and so on and so forth. What we have created is an infinite loop pattern called <i>left recursion</i>.</p>

<p>Left recursion is caused when the left&#45;most item of the left&#45;most alternation is a recursion. The rule above can be easily resolved by writing:</p>

<pre> rule list {
    &#60;digit&#62; | &#60;list&#62; &#39;,&#39; &#60;digit&#62;
 }</pre>

<p>Or even</p>

<pre> rule list {
    &#60;digit&#62; &#39;,&#39; &#60;list&#62; | &#60;digit&#62;
 }</pre>

<p>Both of these two options make sure the left&#45;most item in our rule is not a recursion, therefore preventing left recursion.</p>

<p>Here is a more tricky example where the left recursion is hidden from view:</p>

<pre> rule term {
    &#60;expression&#62; &#39;*&#39; &#60;term&#62; | &#60;digit&#62;
 }

 rule expression {
    &#60;term&#62; &#39;+&#39; &#60;expression&#62; | &#60;term&#62;
 }</pre>

<p>This is a very limited subset of mathematical equations that we might like to write, and even in this small subset we have this same problem: To match a <code>term</code>, the parser first tries to match an <code>expression</code>, which in turn matches a <code>term</code> and then an <code>expression</code> ...</p>

<p>Left recursion is not the only problem you can run into with a recursive descent grammar, but it&#39;s one that&#39;s likely going to come up relatively often for new language designers, and one that is not always likely to generate useful error messages.</p>

<h3><a name="Operator_Precedence_Parser"
>Operator Precedence Parser</a></h3>

<p>Places where there are lots of little tokens in a statement, and where there are lots of possible options that a top&#45;down parser will have to attempt can become relatively inefficient using PCT&#39;s recursive descent parser. Specifically, mathematical expressions are very open&#45;ended and have forms that are difficult to anticipate. Consider the expression:</p>

<pre> a + b * c + d</pre>

<p>The recursive descent parser is going to have to recognize through significant trial and error how this statement should be parsed. For tasks like this, recursive descent parsers are not ideal, although a type of bottom&#45;up parser called an <i>operator precedence</i> <!--
	INDEX: Parser, Operator precedence
--> parser is. Operator precedence parsers work similarly to more versatile bottom&#45;up parsers such as Lex or Yacc, but are optimized for use with expressions and equations. The &#34;things&#34; in an equation are split into two subtypes: <i>terms</i> and <i>operators</i>. Operators themselves are split into a number of types including prefix (<code>&#45;a</code>), postfix (<code>i++</code>), infix (<code>x + y</code>), circumfix (<code>[z]</code>), postcircumix (<code>a[b]</code>), and list (<code>1, 2, 3</code>). Each operator gets its own precedence number that specifies how closely it binds to the terms. In the example above, the expression is parsed</p>

<pre> a + (b * c) + d</pre>

<p>This is because the <code>*</code> operator has a higher precedence and therefore binds more tightly then the <code>+</code> operator.</p>

<p>To switch from the top&#45;down recursive descent parser to the bottom&#45;up operator precedence parser, a rule must be defined that is an <code>optable</code> <!--
	INDEX: Parser, optable
-->:</p>

<pre> rule expression is optable { ... }</pre>

<p>The <code>...</code> ellipses aren&#39;t an editorial shortcut, it&#39;s the Perl 6 operator that is used to define a function signature. The <code>...</code> indicates that this is just a signature and that the actual guts of it will be filled in somewhere else. In this case, that &#34;somewhere else&#34; is in the definition of the optable role.</p>

<h3><a name="Protofunction_Definitions"
>Protofunction Definitions</a></h3>

<p>Protofunctions are used to define operators in the optable in the same way that rules and tokens are used throughout the rest of the grammar. A proto is a way of saying that the rule is overridable dynamically, and that it might be defined somewhere else. In this case, PCT takes information from the proto declaration and fills in the details for us. On another note, this also means that the HLL itself can modify its own grammar at run time, by overriding the proto definitions for its operator table. Some languages call this process &#34;operator overloading&#34;.</p>

<p>A proto is defined like this, taking some of our grammar rules above:</p>

<pre> &#39;proto&#39; &#60;proto_name&#62; [ &#39;is&#39; &#60;property&#62; ] &#39;{&#39; &#39;...&#39; &#39;}&#39;</pre>

<p>The name of the operator, listed as <code>&#60;proto_name&#62;</code> above, contains both a location part and an identifier part. The location is one of the places where the operator can be located, such as infix, postfix, prefix, circumfix, and postcircumfix. The name of the operator is the symbol used for the operator in any of the quotes that Perl 6 understands:</p>

<pre> proto infix:&#60;+&#62;                  # a + b
 proto postfix:&#39;&#45;&#45;&#39;               # i&#45;&#45;
 proto circumfix:&#171;&#60;&#62;&#187;             # &#60;x&#62;</pre>

<p>The <code>is</code> <!--
	INDEX: Parser, is
--> keyword defines a property of the rule. Some examples of this are:</p>

<pre> is precedence(1)     # Specifies an exact precedence
 is equiv(&#39;+&#39;)        # Has the same precedence as the &#34;+&#34; operator
 is assoc(&#39;right&#39;)    # Right associative. May also be &#34;left&#34; or &#34;list&#34;
 is pirop(&#39;add&#39;)      # Operands are passed to the PIR operator &#34;and&#34;
 is subname(&#39;mySub&#39;)  # Operands are passed to the function &#34;mySub&#34;
 is pasttype(&#39;if&#39;)    # Operands are passed as children to an &#34;if&#34; PAST node in
                      # the parse tree
 is parsed(&#38;myRule)   # The token is parsed and identified using the rule
                      # &#34;myRule&#34; from the top&#45;down parser</pre>

<p>Protofunction definitions are function signatures which can be overridden via multimethod dispatch. This means functions can be written <i>with the same name</i> as the rule to implement the behavior of the operator:</p>

<pre> rule infix:&#34;+&#34; { ... }</pre>

<p>And in a PIR file for built&#45;in functions:</p>

<pre> .sub &#39;infix:+&#39;
    .param pmc a
    .param pmc b
    .local pmc c
    c = a + b
    .return(c)
 .end</pre>

<p>The question to ask then is &#34;Why have an <code>is subname()</code> property, if all operators can be defined as subroutines?&#34; The answer is that using the <code>is subname()</code> property allows PCT to call a subroutine of a different name then the operator. This is a good idea if there is already a built&#45;in function in the language that duplicates the functionality of the operator. There is no sense duplicating functionality, is there?</p>

<p>The great thing about protos being overloadable is that you can specify different functions to call with different signatures:</p>

<pre> .sub &#39;infix:+&#39; :multi(&#39;Integer&#39;, &#39;Integer&#39;)
    ...
 .end

 .sub &#39;infix:+&#39; :multi(&#39;CLispRatio&#39;, &#39;Number&#39;)
    ...
 .end

 .sub &#39;infix:+&#39; :multi(&#39;Perl6Double&#39;, &#39;PythonInteger&#39;)
    ...
 .end</pre>

<p>This list can be a bit intimidating, and it&#39;s hard to imagine that it would be necessary to write up a new function to handle addition between every conceivable pair of operands. Fortunately for us all, this isn&#39;t the case because all these data types have those VTABLE interfaces that we can use. For most data types Parrot already has basic arithmetic operations built in, and it&#39;s only necessary to override for those data types with special needs. This example was only a demonstration of the flexibility of the method.</p>

<h2><a name="Actions_and_NQP"
>Actions and NQP</a></h2>

<p>Protofunction signatures aren&#39;t the only way to apply functions to rules matched by the parser. In fact, they might be the most primative because they use PIR code to implement the operator logic. Another way has been made available, by programming function actions in a language that&#39;s almost, but Not Quite Perl (NQP).</p>

<p>NQP is a small language that&#39;s implemented as a subset of Perl 6 syntax and semantics. It&#39;s represents almost the smallest subset of the Perl 6 language necessary to implement the logic of a parser, although some developers have complained enough to get a few extra syntactic features added in above the bare minimum. NQP also happens to be a Perl 6 subset that&#39;s not entirely dissimilar from Perl 5, so Perl 5 programmers should not be too lost when writing NQP.</p>

<h3><a name="NQP_Basics"
>NQP Basics</a></h3>

<p>Like Perl, NQP uses sigils to differentiate different types of variables. The <code>$</code> sigil is used for scalars, <code>@</code> is used for arrays, and <code>%</code> is used for hashes Perl 6 aficionados will know that this isn&#39;t entirely true, but an in&#45;depth look at Perl 6&#39;s context awareness is another topic for another book. A &#34;scalar&#34; is really any single value, and can interchangably be given a string value, or an integer value, or an object. In NQP we can write things like this:</p>

<pre> $scalar := &#34;This is a string&#34;
 $x      := 123
 $pi     := 3.1415      # rounding</pre>

<p>Wait a minute, what&#39;s that weird <code>:=</code> symbol? Why don&#39;t we just use the plain old vanilla <code>=</code> sign? The problem is that <i>NQP doesn&#39;t have it</i>. Remember how we mentioned that NQP was a minimal subset or Perl 6? The <code>:=</code> operator is the <i>bind</i> operator, that makes one value an alias <code>C programmers and the like may call it a &#34;reference&#34;</code> for another. In most cases you can ignore the distinction between the two, but be warned that it&#39;s not a regular variable assignment.</p>

<p>With hashes and arrays, it might be tempting to do a list assignment like we&#39;ve all grown familiar with in Perl 5 and other dynamic languages:</p>

<pre> @small_integers := (1, 2, 3, 4);                        # WRONG!
 %leading_ladies := (&#34;Leia&#34; =&#62; &#34;Starwars&#34;,
                    &#34;Trillian&#34; =&#62; &#34;Hitchhikers Guide&#34;); # WRONG!</pre>

<p>Here&#39;s another little gotcha, NQP doesn&#39;t have list or hash context! If it&#39;s necessary to initialize a whole list at once, you can write:</p>

<pre> @small_integers[0] := 1;
 @small_integers[1] := 2;
 # ... And so on, and so forth ...</pre>

<p>It&#39;s also possible to assign a list in <i>scalar context</i> as follows:</p>

<pre> $array_but_a_scalar := (1, 2, 3, 4)</pre>

<p>Remember how we said NQP was a bare&#45;bones subset of Perl 6? If NQP had too many features, people would use it instead of Perl 6!</p>

<h3><a name="Calling_Actions_From_Rules"
>Calling Actions From Rules</a></h3>

<p>When talking about grammar rules, we discussed the funny little <code>{*}</code> symbol that calls an action. The action in question is an NQP method with the same name as the rule that calls it. NQP rules can be called with two different function signatures:</p>

<pre> method name ($/) { ... }</pre>

<p>And with a key:</p>

<pre> method name($/, $key) { ... }</pre>

<p>Here&#39;s an example that shows how the keys are used:</p>

<pre> rule cavepeople {
      &#39;Fred&#39;  {*}    #= Caveman
    | &#39;Wilma&#39; {*}    #= Cavewoman
    | &#39;Dino&#39;  {*}    #= Dinosaur
 }</pre>

<p>And here is the rule that tells us the result:</p>

<pre> method cavepeople($/, $key) {
    if($key eq &#39;Caveman&#39;) {
        say &#34;We&#39;ve found a caveman!&#34;;
    } elsif($key eq &#39;Cavewoman&#39;) {
        say &#34;We&#39;ve found a cavewoman!&#34;;
    } elsif($key eq &#39;Dinosaur&#39;) {
        say &#34;A dinosaur isn&#39;t a caveperson at all!&#34;;
    }
 }</pre>

<p>The key is just a string that contains whatever text is on the line after the <code>#=</code> symbol. If we don&#39;t have a <code>#=</code> we don&#39;t use a <code>$key</code> in our method.</p>

<h3><a name="The_Match_Object_$/"
>The Match Object <code>$/</code></a></h3>

<p>The match object <code>$/</code> may have a funny&#45;looking name, but it&#39;s a data structure that&#39;s all business. It&#39;s both a hash and an array. Plus, since it&#39;s a special variable it also gets a special shortcut syntax that can be used to save a few keystrokes:</p>

<pre> $/(&#39;Match_item&#39;)   is the same as  $&#60;Match_item&#62;
 $/[0]              is the same as  $[0]</pre>

<p>In the match object, each item in the hash is named after one of the items that we matched in the rule. So, if we have a file with input &#34;<code>X + 5</code>&#34; and a rule:</p>

<pre> rule introductions {
    &#60;variable&#62; &#60;operator&#62; &#60;number&#62;
 }</pre>

<p>Our match object is going to look like this: <code>$/ = (&#34;variable&#34; =</code> &#34;x&#34;, &#34;operator&#34; =&#62; &#34;+&#34;, &#34;number&#34; =&#62; &#34;5&#34;)&#62;</p>

<p>If we have multiple values with the same name, or items with quantifiers <code>*</code> or <code>+</code> on it, those members of the match object may be arrays. So, if we have the input &#34;A A A B B&#34;, and the following rule:</p>

<pre> rule letters {
    &#60;vowel&#62;* &#60;consonant&#62;*
 }</pre>

<p>The match object will look like this (in Perl 5 syntax):</p>

<pre> $/ = (&#34;vowel&#34; =&#62; [&#34;A&#34;, &#34;A&#34;, &#34;A&#34;], &#34;consonant&#34; =&#62; [&#34;B&#34;, &#34;B&#34;])</pre>

<p>We can get the number of matches in each group by casting it to a scalar using the <code>$( )</code> operator:</p>

<pre> $($&#60;vowel&#62;) == 3</pre>

<h3><a name="Inline_PIR"
>Inline PIR</a></h3>

<p>Now that we know what the match object is, we can talk about the inline PIR functionality. In a PGE rule, we can use the <code>{{ }}</code> double curly brackets to go into inline&#45;PIR mode. Inside these brackets arbitrary PIR code can be executed to affect the operation of the parser. We can access the variable <code>$/</code> directly in the grammar without having to jump into NQP, and actually examine and affect the values in it.</p>

<h3><a name="PAST_Nodes"
>PAST Nodes</a></h3>

<p>The job of NQP is to make abstract syntax trees, and the PCT implementation of syntax trees is implemented in the PAST class. There are many different types of objects in the PAST class, each of which represents a particular program construct. These constructs are relatively common and simple, but there are powerful levels of configuration that allow complicated programming structures to be represented.</p>

<h3><a name="Making_Trees"
>Making Trees</a></h3>

<p>Every action has the ability to create a PAST node that represents that action and additional PAST nodes, that are children of that node. Calling the <code>make</code> command on that node adds it into the growing PAST tree that PCT maintains. Once the <code>TOP</code> rule matches successfully and returns, PCT takes that tree and starts the process of optimizing it and converting it into PIR and PBC code for execution.</p>
            </div> <!-- "mainbody" -->
            <div id="divider"></div>
            <div id="footer">
	        Copyright &copy; 2002-2009, Parrot Foundation.
            </div>
        </div> <!-- "wrapper" -->
    </body>
</html>
