<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Global setup</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Global setup</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../html/index.html">Contents</a> | <a href="../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>src/global_setup.c &#45; Global setup</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>Performs all the global setting up of things.
This includes the very few global variables that Parrot totes around.</p>

<p><i>What are these global variables?</i></p>

<h2><a name="Functions"
>Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>*/</p>

<p>#define INSIDE_GLOBAL_SETUP #include &#34;parrot/parrot.h&#34; #include &#34;global_setup.str&#34;</p>

<p>/* These functions are defined in the auto&#45;generated file core_pmcs.c */ /* XXX Get it into some public place */ extern void Parrot_initialize_core_pmcs(PARROT_INTERP); void Parrot_register_core_pmcs(PARROT_INTERP,
PMC* registry);</p>

<p>static const unsigned char* parrot_config_stored = NULL; static unsigned int parrot_config_size_stored = 0;</p>

<p>/* HEADERIZER HFILE: include/parrot/global_setup.h */</p>

<p>/* HEADERIZER BEGIN: static */</p>

<p>static void parrot_set_config_hash_interpreter( PARROT_INTERP ) __attribute__nonnull__(1);</p>

<p>/* HEADERIZER END: static */</p>

<p>/*</p>

<p>FUNCDOC: Parrot_set_config_hash_internal</p>

<p>Called by Parrot_set_config_hash with the serialised hash which will be used in subsequently created Interpreters.</p>

<p>*/</p>

<p>PARROT_API void Parrot_set_config_hash_internal(NOTNULL(const unsigned char* parrot_config),
unsigned int parrot_config_size) { parrot_config_stored = parrot_config; parrot_config_size_stored = parrot_config_size; }</p>

<p>/*</p>

<p>FUNCDOC: parrot_set_config_hash_interpreter</p>

<p>Used internally to associate the config hash with an Interpreter using the last registered config data.</p>

<p>*/</p>

<p>static void parrot_set_config_hash_interpreter(PARROT_INTERP) { PMC *iglobals = interp&#45;&#62;iglobals;</p>

<pre lang='und' xml:lang='und'>    PMC *config_hash = NULL;

    if (parrot_config_size_stored &#62; 1) {
        STRING * const config_string =
            string_make_direct(interp,
                               (const char *)parrot_config_stored, parrot_config_size_stored,
                               PARROT_DEFAULT_ENCODING, PARROT_DEFAULT_CHARSET,
                               PObj_external_FLAG|PObj_constant_FLAG);

        config_hash = Parrot_thaw(interp, config_string);
    }
    else {
        config_hash = pmc_new(interp, enum_class_Hash);
    }

    VTABLE_set_pmc_keyed_int(interp, iglobals,
                             (INTVAL) IGLOBALS_CONFIG_HASH, config_hash);
}</pre>

<p>/*</p>

<p>FUNCDOC: init_world_once(PARROT_INTERP)&#62;</p>

<p>Call init_world() if it hasn&#39;t been called before.</p>

<p><code lang='und' xml:lang='und'>interp</code> should be the root interpreter created in <code lang='und' xml:lang='und'>Parrot_new(NULL)</code>.</p>

<p>*/</p>

<p>void init_world_once(PARROT_INTERP) { if (!interp&#45;&#62;world_inited) { /* init_world() sets up some vtable stuff. * It must only be called once. */</p>

<pre lang='und' xml:lang='und'>        interp&#45;&#62;world_inited = 1;
        init_world(interp);
    }
}</pre>

<p>/*</p>

<p>FUNCDOC: init_world(PARROT_INTERP)&#62;</p>

<p>This is the actual initialization code called by <code lang='und' xml:lang='und'>init_world_once()</code>.</p>

<p>It sets up the Parrot system, running any platform&#45;specific init code if necessary, then initializing the string subsystem, and setting up the base vtables and core PMCs.</p>

<p><code lang='und' xml:lang='und'>interp</code> should be the root interpreter created in <code lang='und' xml:lang='und'>Parrot_new(NULL)</code>.</p>

<p>*/</p>

<p>void init_world(PARROT_INTERP) { PMC *iglobals; PMC *self, *pmc; int i;</p>

<p>#ifdef PARROT_HAS_PLATFORM_INIT_CODE Parrot_platform_init_code(); #endif</p>

<pre lang='und' xml:lang='und'>    parrot_alloc_vtables(interp);

    /* Call base vtable class constructor methods */
    Parrot_initialize_core_pmcs(interp);

    /* We have a Proxy PMC for each of the PMCs; now need to attach that to
     * the class slot for the namespace each of the PMCs reference. */
    for (i = 0; i &#60;= interp&#45;&#62;n_vtable_max; i++)
        if (interp&#45;&#62;vtables[i])
            Parrot_PCCINVOKE(interp, interp&#45;&#62;vtables[i]&#45;&#62;_namespace,
                string_from_literal(interp, &#34;set_class&#34;), &#34;P&#45;&#62;&#34;,
                VTABLE_get_pmc_keyed_int(interp, interp&#45;&#62;pmc_proxies, i));

    iglobals = interp&#45;&#62;iglobals;
    VTABLE_set_pmc_keyed_int(interp, iglobals,
            (INTVAL)IGLOBALS_CLASSNAME_HASH, interp&#45;&#62;class_hash);
    self = pmc_new_noinit(interp, enum_class_ParrotInterpreter);
    PMC_data(self) = interp;
    VTABLE_set_pmc_keyed_int(interp, iglobals,
            (INTVAL) IGLOBALS_INTERPRETER, self);

    parrot_set_config_hash_interpreter(interp);

    /*
     * lib search paths
     */
    parrot_init_library_paths(interp);
    /*
     * load_bytecode and dynlib loaded hash
     */
    pmc = pmc_new(interp, enum_class_Hash);
    VTABLE_set_pmc_keyed_int(interp, iglobals,
            IGLOBALS_PBC_LIBS, pmc);
    pmc = pmc_new(interp, enum_class_Hash);
    VTABLE_set_pmc_keyed_int(interp, iglobals,
            IGLOBALS_DYN_LIBS, pmc);
}</pre>

<p>/* * called from inmidst of PMC bootstrapping between pass 0 and 1 */</p>

<p>void parrot_global_setup_2(PARROT_INTERP) { PMC *classname_hash, *iglobals; int i;</p>

<pre lang='und' xml:lang='und'>    /* create the namespace root stash */
    interp&#45;&#62;root_namespace = pmc_new(interp, enum_class_NameSpace);
    Parrot_init_HLL(interp);

    CONTEXT(interp&#45;&#62;ctx)&#45;&#62;current_namespace =
        VTABLE_get_pmc_keyed_int(interp, interp&#45;&#62;HLL_namespace, 0);

    /* We need a class hash */
    interp&#45;&#62;class_hash = classname_hash = pmc_new(interp, enum_class_NameSpace);
    Parrot_register_core_pmcs(interp, classname_hash);

    /* Also a PMC array to store PMC Proxy objects. */
    interp&#45;&#62;pmc_proxies = pmc_new(interp, enum_class_ResizablePMCArray);

    /* init the interpreter globals array */
    iglobals         = pmc_new(interp, enum_class_SArray);
    interp&#45;&#62;iglobals = iglobals;
    VTABLE_set_integer_native(interp, iglobals, (INTVAL)IGLOBALS_SIZE);

    /* clear the array */
    for (i = 0; i &#60; (INTVAL)IGLOBALS_SIZE; i++)
        VTABLE_set_pmc_keyed_int(interp, iglobals, i, NULL);
}</pre>

<p>/* * Local variables: * c&#45;file&#45;style: &#34;parrot&#34; * End: * vim: expandtab shiftwidth=4: */</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
