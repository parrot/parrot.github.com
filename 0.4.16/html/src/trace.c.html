<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Tracing</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Tracing</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../html/index.html">Contents</a> | <a href="../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>src/trace.c &#45; Tracing</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>Tracing support for the <code lang='und' xml:lang='und'>runops_slow_core()</code> function in <em lang='und' xml:lang='und'><a href="runops_cores.c.html">src/runops_cores.c</a></em>.</p>

<p>This is turned on with Parrot&#39;s <code lang='und' xml:lang='und'>&#45;t</code> option.</p>

<p>src/test_main.c</p>

<h2><a name="Functions"
>Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>*/</p>

<p>#include &#34;trace.h&#34; #include &#34;parrot/oplib/ops.h&#34;</p>

<p>/* HEADERIZER HFILE: src/trace.h */</p>

<p>/* HEADERIZER BEGIN: static */</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL static STRING* trace_class_name( NOTNULL(const PMC* pmc) ) __attribute__nonnull__(1);</p>

<p>/* HEADERIZER END: static */</p>

<p>/*</p>

<p>FUNCDOC: trace_pmc_dump</p>

<p>Prints a PMC to <code lang='und' xml:lang='und'>stderr</code>.</p>

<p>*/</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL static STRING* trace_class_name(NOTNULL(const PMC* pmc)) { STRING *class_name; if (PObj_is_class_TEST(pmc)) { SLOTTYPE * const class_array = (SLOTTYPE *)PMC_data(pmc); PMC * const class_name_pmc = get_attrib_num(class_array,
PCD_CLASS_NAME); class_name = PMC_str_val(class_name_pmc); } else class_name = pmc&#45;&#62;vtable&#45;&#62;whoami; return class_name; }</p>

<p>void trace_pmc_dump(PARROT_INTERP,
NOTNULL(PMC *pmc)) { Interp * const debugger = interp&#45;&#62;debugger;</p>

<pre lang='und' xml:lang='und'>    if (!pmc) {
        PIO_eprintf(debugger, &#34;(null)&#34;);
        return;
    }
    if ( PMC_IS_NULL(pmc) )  {
        PIO_eprintf(debugger, &#34;PMCNULL&#34;);
        return;
    }
    if (!pmc&#45;&#62;vtable || (UINTVAL)pmc&#45;&#62;vtable == 0xdeadbeef) {
        PIO_eprintf(debugger, &#34;&#60;!!no vtable!!&#62;&#34;);
        return;
    }
    if (PObj_on_free_list_TEST(pmc)) {
        PIO_eprintf(debugger, &#34;**************** PMC is on free list *****\n&#34;);
    }
    if (pmc&#45;&#62;vtable&#45;&#62;pmc_class == pmc) {
        STRING * const name = trace_class_name(pmc);
        PIO_eprintf(debugger, &#34;Class=%Ss:PMC(%#p)&#34;, name, pmc);
    }
    else if (pmc&#45;&#62;vtable&#45;&#62;base_type == enum_class_String) {
        const STRING * const s = VTABLE_get_string(interp, pmc);
        if (!s)
            PIO_eprintf(debugger, &#34;%S=PMC(%#p Str:(NULL))&#34;,
                    VTABLE_name(interp, pmc), pmc);
        else {
            STRING* const escaped = string_escape_string_delimited(
                            interp, s, 20);
            if (escaped)
                PIO_eprintf(debugger, &#34;%S=PMC(%#p Str:\&#34;%Ss\&#34;)&#34;,
                    VTABLE_name(interp, pmc), pmc,
                    escaped);
            else
                PIO_eprintf(debugger, &#34;%S=PMC(%#p Str:\&#34;(null)\&#34;)&#34;,
                    VTABLE_name(interp, pmc), pmc);
        }
    }
    else if (pmc&#45;&#62;vtable&#45;&#62;base_type == enum_class_Boolean) {
        PIO_eprintf(debugger, &#34;Boolean=PMC(%#p: %d)&#34;,
                pmc, PMC_int_val(pmc));
    }
    else if (pmc&#45;&#62;vtable&#45;&#62;base_type == enum_class_Integer) {
        PIO_eprintf(debugger, &#34;Integer=PMC(%#p: %d)&#34;,
                pmc, PMC_int_val(pmc));
    }
    else if (pmc&#45;&#62;vtable&#45;&#62;base_type == enum_class_BigInt) {
        STRING * const s = VTABLE_get_string(interp, pmc);
        PIO_eprintf(debugger, &#34;BigInt=PMC(%#p: %Ss)&#34;,
                pmc, s);
    }
    else if (pmc&#45;&#62;vtable&#45;&#62;base_type == enum_class_Complex) {
        STRING * const s = VTABLE_get_string(interp, pmc);
        PIO_eprintf(debugger, &#34;Complex=PMC(%#p: %Ss)&#34;,
                pmc, s);
    }
    else if (pmc&#45;&#62;vtable&#45;&#62;base_type == enum_class_RetContinuation
            ||  pmc&#45;&#62;vtable&#45;&#62;base_type == enum_class_Continuation
            ||  pmc&#45;&#62;vtable&#45;&#62;base_type == enum_class_Sub) {
        PIO_eprintf(debugger, &#34;%S=PMC(%#p pc:%d)&#34;,
                VTABLE_name(interp, pmc), pmc,
                PMC_sub(pmc)&#45;&#62;start_offs);
    }
    else if (PObj_is_object_TEST(pmc)) {
        PIO_eprintf(debugger, &#34;Object(%Ss)=PMC(%#p)&#34;,
                VTABLE_name(interp, pmc), pmc);
    }
    else if (pmc&#45;&#62;vtable&#45;&#62;base_type == enum_class_delegate) {
        PIO_eprintf(debugger, &#34;delegate=PMC(%#p)&#34;, pmc);
    }
    else {
        PIO_eprintf(debugger, &#34;%S=PMC(%#p)&#34;,
                VTABLE_name(interp, pmc), pmc);
    }
}</pre>

<p>/*</p>

<p>FUNCDOC: trace_key_dump</p>

<p>Prints a key to <code lang='und' xml:lang='und'>stderr</code>, returns the length of the output.</p>

<p>*/</p>

<p>int trace_key_dump(PARROT_INTERP, NOTNULL(const PMC *key)) { Interp * const debugger = interp&#45;&#62;debugger;</p>

<pre lang='und' xml:lang='und'>    int len = PIO_eprintf(debugger, &#34;[&#34;);

    while (key) {
        switch (PObj_get_FLAGS(key) &#38; KEY_type_FLAGS) {
        case KEY_integer_FLAG:
            len += PIO_eprintf(debugger, &#34;%vi&#34;, PMC_int_val(key));
            break;
        case KEY_number_FLAG:
            len += PIO_eprintf(debugger, &#34;%vg&#34;, PMC_num_val(key));
            break;
        case KEY_string_FLAG:
            {
            const STRING * const s = PMC_str_val(key);
            STRING* const escaped = string_escape_string_delimited(
                            interp, s, 20);
            if (escaped)
                len += PIO_eprintf(debugger, &#34;\&#34;%Ss\&#34;&#34;, escaped);
            else
                len += PIO_eprintf(debugger, &#34;\&#34;(null)\&#34;&#34;);
            }
            break;
        case KEY_integer_FLAG|KEY_register_FLAG:
            len += PIO_eprintf(debugger, &#34;I%vd=%vd&#34;, PMC_int_val(key),
                    REG_INT(interp, PMC_int_val(key)));
            break;
        case KEY_number_FLAG|KEY_register_FLAG:
            len += PIO_eprintf(debugger, &#34;I%vd=%vd&#34;, PMC_int_val(key),
                    REG_NUM(interp, PMC_int_val(key)));
            break;
        case KEY_string_FLAG|KEY_register_FLAG:
            {
            const STRING * const s = REG_STR(interp, PMC_int_val(key));
            STRING* const escaped = string_escape_string_delimited(
                            interp, s, 20);
            if (escaped)
                len += PIO_eprintf(debugger, &#34;S%vd=\&#34;%Ss\&#34;&#34;, PMC_int_val(key),
                        escaped);
            else
                len += PIO_eprintf(debugger, &#34;S%vd=\&#34;(null)\&#34;&#34;,
                        PMC_int_val(key));
            }
            break;
        case KEY_pmc_FLAG|KEY_register_FLAG:
            len += PIO_eprintf(debugger, &#34;P%vd=&#34;, PMC_int_val(key));
            trace_pmc_dump(debugger, REG_PMC(interp, PMC_int_val(key)));
            break;
        default:
            len += PIO_eprintf(debugger, &#34;??&#34;);
            key = NULL;
            break;
        }

        if (key) {
            key = (PMC *)PMC_data(key);
            if (key)
                len += PIO_eprintf(debugger, &#34;;&#34;);
        }
    } /* while */

    len += PIO_eprintf(debugger, &#34;]&#34;);
    return len;
}</pre>

<p>/*</p>

<p>FUNCDOC: trace_op_dump</p>

<p>TODO: This isn&#39;t really part of the API, but here&#39;s its documentation.</p>

<p>Prints the PC, OP and ARGS. Used by <code lang='und' xml:lang='und'>trace_op()</code>.</p>

<p>*/</p>

<p>void trace_op_dump(PARROT_INTERP, NOTNULL(const opcode_t *code_start), NOTNULL(const opcode_t *pc)) { INTVAL s, n; int more = 0, var_args; Interp * const debugger = interp&#45;&#62;debugger; op_info_t * const info = &#38;interp&#45;&#62;op_info_table[*pc]; PMC *sig; int type; int len; #define ARGS_COLUMN 40</p>

<pre lang='und' xml:lang='und'>    PARROT_ASSERT(debugger);
    sig = NULL; /* silence compiler uninit warning */

    s = 1;
    len = PIO_eprintf(debugger, &#34;%6vu &#34;, (UINTVAL)(pc &#45; code_start));
    if (strcmp(info&#45;&#62;name, &#34;infix&#34;) == 0) {
        /* this should rather be MMD_opcode_name, which doesn&#39;t
         * exit yet
         */
        len += PIO_eprintf(debugger, &#34;%s&#34;,
                Parrot_MMD_method_name(interp, pc[1]) + 2);
        s = 2;
    }
    else if (strcmp(info&#45;&#62;name, &#34;n_infix&#34;) == 0) {
        len += PIO_eprintf(debugger, &#34;n_%s&#34;,
                Parrot_MMD_method_name(interp, pc[1]) + 2);
        s = 2;
    }
    else
        len += PIO_eprintf(debugger, &#34;%s&#34;, info&#45;&#62;name);

    n = info&#45;&#62;op_count;
    var_args = 0;

    if (*pc == PARROT_OP_set_args_pc ||
            *pc == PARROT_OP_get_results_pc ||
            *pc == PARROT_OP_get_params_pc ||
            *pc == PARROT_OP_set_returns_pc) {
        sig = interp&#45;&#62;code&#45;&#62;const_table&#45;&#62;constants[pc[1]]&#45;&#62;u.key;
        if (!sig) {
            real_exception(interp, NULL, 1,
                    &#34;NULL sig PMC detected in trace_op_dump&#34;);
        }
        var_args = VTABLE_elements(interp, sig);
        n += var_args;
    }

    if (n &#62; 1) {
        INTVAL i;
        len += PIO_eprintf(debugger, &#34; &#34;);
        /* pass 1 print arguments */
        for (i = s; i &#60; n; i++) {
            const opcode_t o = pc[i];
            if (i &#60; info&#45;&#62;op_count) {
                type = info&#45;&#62;types[i &#45; 1];
            }
            else {
                if (!sig) {
                    real_exception(interp, NULL, 1,
                            &#34;NULL sig PMC detected in trace_op_dump&#34;);
                }
                type = SIG_ITEM(sig, i &#45; 2) &#38;
                    (PARROT_ARG_TYPE_MASK|PARROT_ARG_CONSTANT);
            }
            if (i &#62; s &#38;&#38;
                    type != PARROT_ARG_KC &#38;&#38;
                    type != PARROT_ARG_KIC &#38;&#38;
                    type != PARROT_ARG_KI &#38;&#38;
                    type != PARROT_ARG_K) {
                len += PIO_eprintf(debugger, &#34;, &#34;);
            }
            switch (type) {
                case PARROT_ARG_IC:
                    len += PIO_eprintf(debugger, &#34;%vd&#34;, o);
                    break;
                case PARROT_ARG_NC:
                    len += PIO_eprintf(debugger, &#34;%vg&#34;, PCONST(o)&#45;&#62;u.number);
                    break;
                case PARROT_ARG_PC:
                    if (var_args)
                        len += PIO_eprintf(debugger, &#34;PC%d (%d)&#34;,
                                (int)o, var_args);
                    else
                        len += PIO_eprintf(debugger, &#34;PC%d&#34;, (int)o);
                    break;
                case PARROT_ARG_SC:
                    {
                    STRING* const escaped = string_escape_string_delimited(
                            interp,
                            PCONST(o)&#45;&#62;u.string, 20);
                    if (escaped)
                        len += PIO_eprintf(debugger, &#34;\&#34;%Ss\&#34;&#34;, escaped);
                    else
                        len += PIO_eprintf(debugger, &#34;\&#34;(null)\&#34;&#34;);
                    }
                    break;
                case PARROT_ARG_KC:
                    len += trace_key_dump(interp, PCONST(o)&#45;&#62;u.key);
                    break;
                case PARROT_ARG_KIC:
                    len += PIO_eprintf(debugger, &#34;[%vd]&#34;, o);
                    break;
                case PARROT_ARG_KI:
                    len += PIO_eprintf(debugger, &#34;[I%vd]&#34;, o);
                    more = 1;
                    break;
                case PARROT_ARG_K:
                    len += PIO_eprintf(debugger, &#34;[P%vd]&#34;,o);
                    more = 1;
                    break;
                case PARROT_ARG_I:
                    len += PIO_eprintf(debugger, &#34;I%vd&#34;, o);
                    more = 1;
                    break;
                case PARROT_ARG_N:
                    len += PIO_eprintf(debugger, &#34;N%vd&#34;, o);
                    more = 1;
                    break;
                case PARROT_ARG_P:
                    len += PIO_eprintf(debugger, &#34;P%vd&#34;, o);
                    more = 1;
                    break;
                case PARROT_ARG_S:
                    len += PIO_eprintf(debugger, &#34;S%vd&#34;, o);
                    more = 1;
                    break;
                default:
                    real_exception(interp, NULL, 1, &#34;unhandled type in trace&#34;);
                    break;
            }
        }
        if (!more)
            goto done;
        if (len &#60; ARGS_COLUMN)  {
            STRING * const fill = string_repeat(debugger,
                    const_string(debugger, &#34; &#34;),
                    ARGS_COLUMN &#45; len, NULL);
            PIO_putps(debugger, PIO_STDERR(debugger), fill);
        }
        else {
            PIO_eprintf(debugger, &#34;\t&#34;);
        }

        /* pass 2 print argument details if needed */
        for (i = 1; i &#60; n; i++) {
            const opcode_t o = pc[i];
            if (i &#60; info&#45;&#62;op_count)
                type = info&#45;&#62;types[i &#45; 1];
            else
                type = SIG_ITEM(sig, i &#45; 2) &#38;
                    (PARROT_ARG_TYPE_MASK|PARROT_ARG_CONSTANT);
            if (i &#62; s) {
                PIO_eprintf(debugger, &#34; &#34;);
            }
            switch (type) {
                case PARROT_ARG_I:
                    PIO_eprintf(debugger, &#34;I%vd=%vd&#34;, o, REG_INT(interp, o));
                    break;
                case PARROT_ARG_N:
                    PIO_eprintf(debugger, &#34;N%vd=%vf&#34;, o, REG_NUM(interp, o));
                    break;
                case PARROT_ARG_PC:
                    PIO_eprintf(debugger, &#34;PC%vd=&#34;, o);
                    trace_pmc_dump(interp, PCONST(o)&#45;&#62;u.key);
                    break;
                case PARROT_ARG_P:
                    PIO_eprintf(debugger, &#34;P%vd=&#34;, o);
                    trace_pmc_dump(interp, REG_PMC(interp, o));
                    break;
                case PARROT_ARG_S:
                    if (REG_STR(interp, o)) {
                        STRING* const escaped = string_escape_string_delimited(
                                interp, REG_STR(interp, o), 20);
                        PIO_eprintf(debugger, &#34;S%vd=\&#34;%Ss\&#34;&#34;, o,
                                escaped);
                    }
                    else
                        PIO_eprintf(debugger, &#34;S%vd=\&#34;(null)\&#34;&#34;, o);
                    break;
                case PARROT_ARG_K:
                    PIO_eprintf(debugger, &#34;P%vd=&#34;, o);
                    trace_key_dump(interp, REG_PMC(interp, *(pc + i)));
                    break;
                case PARROT_ARG_KI:
                    PIO_eprintf(debugger, &#34;I%vd=[%vd]&#34;, o, REG_INT(interp, o));
                    break;
                default:
                    break;
            }
        }
    }
done:
    PIO_eprintf(debugger, &#34;\n&#34;);
}</pre>

<p>/*</p>

<p>FUNCDOC: trace_op</p>

<p>TODO: This isn&#39;t really part of the API, but here&#39;s its documentation.</p>

<p>Prints the PC, OP and ARGS. Used by <code lang='und' xml:lang='und'>runops_trace()</code>. With bounds checking.</p>

<p>*/</p>

<p>void trace_op(PARROT_INTERP, NOTNULL(const opcode_t *code_start), NOTNULL(const opcode_t *code_end), NULLOK(const opcode_t *pc)) { if (!pc) { return; }</p>

<pre lang='und' xml:lang='und'>    if (pc &#62;= code_start &#38;&#38; pc &#60; code_end)
        trace_op_dump(interp, code_start, pc);
    else
        PIO_eprintf(interp, &#34;PC=%ld; OP=&#60;err&#62;\n&#34;, (long)(pc &#45; code_start));
}</pre>

<p>/*</p>

<h1><a name="SEE_ALSO"
>SEE ALSO <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p><em lang='und' xml:lang='und'>src/trace.h</em></p>

<p>*/</p>

<p>/* * Local variables: * c&#45;file&#45;style: &#34;parrot&#34; * End: * vim: expandtab shiftwidth=4: */</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
