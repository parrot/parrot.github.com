<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>The base vtable calling functions</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">The base vtable calling functions</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../html/index.html">Contents</a> | <a href="../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>src/pmc.c &#45; The base vtable calling functions</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<h2><a name="Functions"
>Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>*/</p>

<p>#include &#34;parrot/parrot.h&#34; #include &#34;pmc.str&#34;</p>

<p>/* HEADERIZER HFILE: include/parrot/pmc.h */</p>

<p>/* HEADERIZER BEGIN: static */</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL static PMC* create_class_pmc( PARROT_INTERP,
INTVAL type ) __attribute__nonnull__(1);</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL static PMC* get_new_pmc_header( PARROT_INTERP,
INTVAL base_type,
UINTVAL flags ) __attribute__nonnull__(1);</p>

<p>/* HEADERIZER END: static */</p>

<p>#if PARROT_CATCH_NULL PARROT_API PMC * PMCNULL; #endif</p>

<p>/*</p>

<p>FUNCDOC: pmc_new Creates a new PMC of type <code lang='und' xml:lang='und'>base_type</code> (which is an index into the list of PMC types declared in <code lang='und' xml:lang='und'>vtables</code> in <em lang='und' xml:lang='und'>include/parrot/pmc.h</em>).
Once the PMC has been successfully created and its vtable pointer initialized,
we call its <code lang='und' xml:lang='und'>init</code> method to perform any other necessary initialization.</p>

<p>*/</p>

<p>PARROT_API PARROT_CANNOT_RETURN_NULL PARROT_MALLOC PMC * pmc_new(PARROT_INTERP,
INTVAL base_type) { PMC * const pmc = pmc_new_noinit(interp,
base_type); VTABLE_init(interp,
pmc); return pmc; }</p>

<p>/*</p>

<p>FUNCDOC: pmc_reuse Reuse an existing PMC,
turning it into an empty PMC of the new type.
Any required internal structure will be put in place (such as the extension area) and the PMC will be ready to go.
This will throw an exception if the PMC is constant or of a singleton type (such as the environment PMC) or is being turned into a PMC of a singleton type.</p>

<p>*/</p>

<p>PARROT_API PARROT_CANNOT_RETURN_NULL PMC* pmc_reuse(PARROT_INTERP,
NOTNULL(PMC *pmc),
INTVAL new_type,
SHIM(UINTVAL flags)) { INTVAL has_ext,
new_flags; VTABLE *new_vtable;</p>

<pre lang='und' xml:lang='und'>    if (pmc&#45;&#62;vtable&#45;&#62;base_type == new_type)
        return pmc;

    new_vtable = interp&#45;&#62;vtables[new_type];

    /* Singleton/const PMCs/types are not eligible */

    if ((pmc&#45;&#62;vtable&#45;&#62;flags | new_vtable&#45;&#62;flags)
        &#38; (VTABLE_PMC_IS_SINGLETON | VTABLE_IS_CONST_FLAG))
    {
        /* First, is the destination a singleton? No joy for us there */
        if (new_vtable&#45;&#62;flags &#38; VTABLE_PMC_IS_SINGLETON)
            real_exception(interp, NULL, ALLOCATION_ERROR,
                               &#34;Parrot VM: Can&#39;t turn to a singleton type!\n&#34;);

        /* First, is the destination a constant? No joy for us there */
        if (new_vtable&#45;&#62;flags &#38; VTABLE_IS_CONST_FLAG)
            real_exception(interp, NULL, ALLOCATION_ERROR,
                               &#34;Parrot VM: Can&#39;t turn to a constant type!\n&#34;);

        /* Is the source a singleton? */
        if (pmc&#45;&#62;vtable&#45;&#62;flags &#38; VTABLE_PMC_IS_SINGLETON)
            real_exception(interp, NULL, ALLOCATION_ERROR,
                               &#34;Parrot VM: Can&#39;t modify a singleton\n&#34;);

        /* Is the source constant? */
        if (pmc&#45;&#62;vtable&#45;&#62;flags &#38; VTABLE_IS_CONST_FLAG)
            real_exception(interp, NULL, ALLOCATION_ERROR,
                               &#34;Parrot VM: Can&#39;t modify a constant\n&#34;);
    }

    /* Do we have an extension area? */
    has_ext = (PObj_is_PMC_EXT_TEST(pmc) &#38;&#38; pmc&#45;&#62;pmc_ext);

    /* Do we need one? */
    if (new_vtable&#45;&#62;flags &#38; VTABLE_PMC_NEEDS_EXT) {
        if (!has_ext) {
            /* If we need an ext area, go allocate one */
            add_pmc_ext(interp, pmc);
        }
        new_flags = PObj_is_PMC_EXT_FLAG;
    }
    else {
        if (has_ext)
            Parrot_free_pmc_ext(interp, pmc);</pre>

<p>#if ! PMC_DATA_IN_EXT PMC_data(pmc) = NULL; #endif new_flags = 0; }</p>

<pre lang='und' xml:lang='und'>    /* we are a PMC + maybe is_PMC_EXT */
    PObj_flags_SETTO(pmc, PObj_is_PMC_FLAG | new_flags);

    /* Set the right vtable */
    pmc&#45;&#62;vtable = new_vtable;

    /* Call the base init for the redone pmc */
    VTABLE_init(interp, pmc);

    return pmc;
}</pre>

<p>/*</p>

<p>FUNCDOC: get_new_pmc_header Gets a new PMC header.</p>

<p>*/</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL static PMC* get_new_pmc_header(PARROT_INTERP, INTVAL base_type, UINTVAL flags) { PMC *pmc; VTABLE *vtable = interp&#45;&#62;vtables[base_type];</p>

<pre lang='und' xml:lang='und'>    if (!vtable) {
        /* This is usually because you either didn&#39;t call init_world early
         * enough, you added a new PMC class without adding
         * Parrot_(classname)_class_init to init_world, or you forgot
         * to run &#39;make realclean&#39; after adding a new PMC class.
         */
        PANIC(interp, &#34;Null vtable used&#34;);
    }

    /* we only have one global Env object, living in the interp */
    if (vtable&#45;&#62;flags &#38; VTABLE_PMC_IS_SINGLETON) {
        /*
         * singletons (monadic objects) exist only once, the interface
         * with the class is:
         * &#45; get_pointer: return NULL or a pointer to the single instance
         * &#45; set_pointer: set the only instance once
         *
         * &#45; singletons are created in the constant pmc pool
         */
        PMC *pmc = (PMC *)(vtable&#45;&#62;get_pointer)(interp, NULL);
        /* LOCK */
        if (!pmc) {
            pmc = new_pmc_header(interp, PObj_constant_FLAG);
            PARROT_ASSERT(pmc);
            pmc&#45;&#62;vtable = vtable;
            pmc&#45;&#62;real_self = pmc;
            VTABLE_set_pointer(interp, pmc, pmc);
        }
        return pmc;
    }
    if (vtable&#45;&#62;flags &#38; VTABLE_IS_CONST_PMC_FLAG) {
        flags |= PObj_constant_FLAG;
    }
    else if (vtable&#45;&#62;flags &#38; VTABLE_IS_CONST_FLAG) {
        /* put the normal vtable in, so that the pmc can be initialized first
         * parrot or user code has to set the _ro property then,
         * to morph the PMC to the const variant
         * This assumes that a constant PMC enum is one bigger then
         * the normal one.
         */

        /*
         * XXX not yet we can&#39;t assure that all contents in the
         * const PMC is const too
         * see e.g. t/pmc/sarray_13.pir
         */
#if 0
        flags |= PObj_constant_FLAG;
#endif
        &#45;&#45;base_type;
        vtable = interp&#45;&#62;vtables[base_type];
    }
    if (vtable&#45;&#62;flags &#38; VTABLE_PMC_NEEDS_EXT) {
        flags |= PObj_is_PMC_EXT_FLAG;
        if (vtable&#45;&#62;flags &#38; VTABLE_IS_SHARED_FLAG)
            flags |= PObj_is_PMC_shared_FLAG;
    }

    pmc = new_pmc_header(interp, flags);
    if (!pmc)
        real_exception(interp, NULL, ALLOCATION_ERROR,
                &#34;Parrot VM: PMC allocation failed!\n&#34;);

    pmc&#45;&#62;vtable = vtable;
    pmc&#45;&#62;real_self = pmc;</pre>

<p>#ifdef GC_VERBOSE if (Interp_flags_TEST(interp, PARROT_TRACE_FLAG)) { /* XXX make a more verbose trace flag */ fprintf(stderr, &#34;\t=&#62; new %p type %d\n&#34;, pmc, (int)base_type); } #endif return pmc; }</p>

<p>/*</p>

<p>FUNCDOC: pmc_new_noinit Creates a new PMC of type <code lang='und' xml:lang='und'>base_type</code> (which is an index into the list of PMC types declared in <code lang='und' xml:lang='und'>vtables</code> in <em lang='und' xml:lang='und'>include/parrot/pmc.h</em>). Unlike <code lang='und' xml:lang='und'>pmc_new()</code>, <code lang='und' xml:lang='und'>pmc_new_noinit()</code> does not call its <code lang='und' xml:lang='und'>init</code> method. This allows separate allocation and initialization for continuations.</p>

<p>*/</p>

<p>PARROT_API PARROT_CANNOT_RETURN_NULL PMC * pmc_new_noinit(PARROT_INTERP, INTVAL base_type) { PMC * const pmc = get_new_pmc_header(interp, base_type, 0);</p>

<pre lang='und' xml:lang='und'>    return pmc;
}</pre>

<p>/*</p>

<p>FUNCDOC: constant_pmc_new_noinit Creates a new constant PMC of type <code lang='und' xml:lang='und'>base_type</code>.</p>

<p>*/</p>

<p>PARROT_API PARROT_CANNOT_RETURN_NULL PMC * constant_pmc_new_noinit(PARROT_INTERP, INTVAL base_type) { PMC * const pmc = get_new_pmc_header(interp, base_type, PObj_constant_FLAG); return pmc; }</p>

<p>/*</p>

<p>FUNCDOC: constant_pmc_new Creates a new constant PMC of type <code lang='und' xml:lang='und'>base_type</code>, the call <code lang='und' xml:lang='und'>init</code>.</p>

<p>*/</p>

<p>PARROT_API PARROT_CANNOT_RETURN_NULL PMC * constant_pmc_new(PARROT_INTERP, INTVAL base_type) { PMC * const pmc = get_new_pmc_header(interp, base_type, PObj_constant_FLAG); VTABLE_init(interp, pmc); return pmc; }</p>

<p>/*</p>

<p>FUNCDOC: pmc_new_init As <code lang='und' xml:lang='und'>pmc_new()</code>, but passes <code lang='und' xml:lang='und'>init</code> to the PMC&#39;s <code lang='und' xml:lang='und'>init_pmc()</code> method.</p>

<p>*/</p>

<p>PARROT_API PARROT_CANNOT_RETURN_NULL PMC * pmc_new_init(PARROT_INTERP, INTVAL base_type, NULLOK(PMC *init)) { PMC * const pmc = pmc_new_noinit(interp, base_type);</p>

<pre lang='und' xml:lang='und'>    VTABLE_init_pmc(interp, pmc, init);

    return pmc;
}</pre>

<p>/*</p>

<p>FUNCDOC: constant_pmc_new_init As <code lang='und' xml:lang='und'>constant_pmc_new</code>, but passes <code lang='und' xml:lang='und'>init</code> to the PMC&#39;s <code lang='und' xml:lang='und'>init_pmc</code> method.</p>

<p>*/</p>

<p>PARROT_API PARROT_CANNOT_RETURN_NULL PMC * constant_pmc_new_init(PARROT_INTERP, INTVAL base_type, NULLOK(PMC *init)) { PMC * const pmc = get_new_pmc_header(interp, base_type, PObj_constant_FLAG); VTABLE_init_pmc(interp, pmc, init); return pmc; }</p>

<p>/*</p>

<p>FUNCDOC: pmc_register This segment handles PMC registration and such.</p>

<p>*/</p>

<p>PARROT_API INTVAL pmc_register(PARROT_INTERP, NOTNULL(STRING *name)) { INTVAL type; PMC *classname_hash; /* If they&#39;re looking to register an existing class, return that class&#39; type number */ type = pmc_type(interp, name);</p>

<pre lang='und' xml:lang='und'>    if (type &#62; enum_type_undef) {
        return type;
    }
    if (type &#60; enum_type_undef) {
        real_exception(interp, NULL, 1, &#34;native type with name &#39;%s&#39; already exists &#45; &#34;
                &#34;can&#39;t register PMC&#34;, data_types[type].name);
        return 0;
    }

    classname_hash = interp&#45;&#62;class_hash;
    type = interp&#45;&#62;n_vtable_max++;
    /* Have we overflowed the table? */
    if (type &#62;= interp&#45;&#62;n_vtable_alloced) {
        parrot_realloc_vtables(interp);
    }
    /* set entry in name&#45;&#62;type hash */
    VTABLE_set_integer_keyed_str(interp, classname_hash, name, type);
    return type;
}</pre>

<p>/*</p>

<p>FUNCDOC: pmc_type Returns the PMC type for <code lang='und' xml:lang='und'>name</code>.</p>

<p>*/</p>

<p>PARROT_API PARROT_WARN_UNUSED_RESULT INTVAL pmc_type(PARROT_INTERP, NOTNULL(STRING *name)) { PMC * const classname_hash = interp&#45;&#62;class_hash; PMC * const item = (PMC *)VTABLE_get_pointer_keyed_str(interp, classname_hash, name);</p>

<pre lang='und' xml:lang='und'>    /* nested namespace with same name */
    if (item&#45;&#62;vtable&#45;&#62;base_type == enum_class_NameSpace)
        return 0;
    if (!PMC_IS_NULL(item))
        return VTABLE_get_integer(interp, item);

    return Parrot_get_datatype_enum(interp, name);
}</pre>

<p>/*</p>

<p>FUNCDOC: pmc_type_p Returns the PMC type for <code lang='und' xml:lang='und'>name</code>.</p>

<p>*/</p>

<p>PARROT_API INTVAL pmc_type_p(PARROT_INTERP, NOTNULL(PMC *name)) { PMC * const classname_hash = interp&#45;&#62;class_hash; PMC * const item = (PMC *)VTABLE_get_pointer_keyed(interp, classname_hash, name);</p>

<pre lang='und' xml:lang='und'>    if (!PMC_IS_NULL(item))
        return VTABLE_get_integer(interp, item);
    return 0;
}</pre>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL static PMC* create_class_pmc(PARROT_INTERP, INTVAL type) { /* * class interface &#45; a PMC is its own class * put an instance of this PMC into class * * create a constant PMC */ PMC * const _class = get_new_pmc_header(interp, type, PObj_constant_FLAG); /* If we are a second thread, we may get the same object as the * original because we have a singleton. Just set the singleton to * be our class object, but don&#39;t mess with its vtable. */ if ((interp&#45;&#62;vtables[type]&#45;&#62;flags &#38; VTABLE_PMC_IS_SINGLETON) &#38;&#38; (_class == _class&#45;&#62;vtable&#45;&#62;pmc_class)) { interp&#45;&#62;vtables[type]&#45;&#62;pmc_class = _class; return _class; }</p>

<pre lang='und' xml:lang='und'>    if (PObj_is_PMC_EXT_TEST(_class))
        Parrot_free_pmc_ext(interp, _class);

    DOD_flag_CLEAR(is_special_PMC, _class);
    PMC_pmc_val(_class)   = (PMC *)0xdeadbeef;
    PMC_struct_val(_class)= (void*)0xdeadbeef;

    PObj_is_PMC_shared_CLEAR(_class);

    interp&#45;&#62;vtables[type]&#45;&#62;pmc_class = _class;

    return _class;
}</pre>

<p>/*</p>

<p>FUNCDOC: Parrot_create_mro Create the MRO (method resolution order) array for this type.</p>

<p>*/</p>

<p>PARROT_API void Parrot_create_mro(PARROT_INTERP, INTVAL type) { STRING *class_name, *isa; INTVAL pos, parent_type, total; PMC *_class, *mro;</p>

<pre lang='und' xml:lang='und'>    VTABLE *vtable = interp&#45;&#62;vtables[type];

    /* multithreaded: has already mro */
    if (vtable&#45;&#62;mro)
        return;
    mro = pmc_new(interp, enum_class_ResizablePMCArray);
    vtable&#45;&#62;mro = mro;
    if (vtable&#45;&#62;ro_variant_vtable) {
        vtable&#45;&#62;ro_variant_vtable&#45;&#62;mro = mro;
    }
    class_name = vtable&#45;&#62;whoami;
    isa = vtable&#45;&#62;isa_str;
    total = (INTVAL)string_length(interp, isa);
    for (pos = 0; ;) {
        INTVAL len = string_length(interp, class_name);
        pos += len + 1;
        parent_type = pmc_type(interp, class_name);
        if (!parent_type)   /* abstract classes don&#39;t have a vtable */
            break;
        vtable = interp&#45;&#62;vtables[parent_type];
        if (!vtable&#45;&#62;_namespace) {
            /* need a namespace Hash, anchor at parent, name it */
            PMC * const ns = pmc_new(interp,
                    Parrot_get_ctx_HLL_type(interp, enum_class_NameSpace));
            vtable&#45;&#62;_namespace = ns;
            /* anchor at parent, aka current_namespace, that is &#39;parrot&#39; */
            VTABLE_set_pmc_keyed_str(interp,
                    CONTEXT(interp&#45;&#62;ctx)&#45;&#62;current_namespace,
                    class_name, ns);
        }
        _class = vtable&#45;&#62;pmc_class;
        if (!_class) {
            _class = create_class_pmc(interp, parent_type);
        }
        VTABLE_push_pmc(interp, mro, _class);
        if (pos &#62;= total)
            break;
        len = string_str_index(interp, isa,
                CONST_STRING(interp, &#34; &#34;), pos);
        if (len == &#45;1)
            len = total;
        class_name = string_substr(interp, isa, pos,
                len &#45; pos, NULL, 0);
    }
}</pre>

<p>/*</p>

<h2><a name="DOD_registry_interface"
>DOD registry interface <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>FUNCDOC: dod_register_pmc Registers the PMC with the interpreter&#39;s DOD registery.</p>

<p>*/</p>

<p>PARROT_API void dod_register_pmc(PARROT_INTERP, NOTNULL(PMC* pmc)) { /* Better not trigger a DOD run with a potentially unanchored PMC */ Parrot_block_DOD(interp);</p>

<pre lang='und' xml:lang='und'>    if (!interp&#45;&#62;DOD_registry)
        interp&#45;&#62;DOD_registry = pmc_new(interp, enum_class_AddrRegistry);
    VTABLE_set_pmc_keyed(interp, interp&#45;&#62;DOD_registry, pmc, PMCNULL);
    Parrot_unblock_DOD(interp);</pre>

<p>}</p>

<p>/*</p>

<p>FUNCDOC: dod_unregister_pmc Unregisters the PMC from the interpreter&#39;s DOD registry.</p>

<p>*/</p>

<p>void dod_unregister_pmc(PARROT_INTERP, NOTNULL(PMC* pmc)) { if (!interp&#45;&#62;DOD_registry) return; /* XXX or signal exception? */ VTABLE_delete_keyed(interp, interp&#45;&#62;DOD_registry, pmc); }</p>

<p>/*</p>

<h2><a name="PMC_Proxy_related_things"
>PMC Proxy related things <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>FUNCDOC: Parrot_create_pmc_proxy Creates a PMC Proxy for the supplied class number and puts it into the array of proxies.</p>

<p>*/</p>

<p>PARROT_API void Parrot_create_pmc_proxy(PARROT_INTERP, int type_num) { PMC *proxy; Parrot_PMCProxy *proxy_info;</p>

<pre lang='und' xml:lang='und'>    /* Ensure that it&#39;s a valid type number. */
    if (type_num &#62; interp&#45;&#62;n_vtable_max || type_num &#60; 0) {
        real_exception(interp, NULL, 1,
            &#34;Attempt to create PMC Proxy for invalid type number!&#34;);
    }

    /* Create PMC proxy object and set up number, name and namespcae. */
    proxy = pmc_new(interp, enum_class_PMCProxy);
    proxy_info = PARROT_PMCPROXY(proxy);
    proxy_info&#45;&#62;id = type_num;
    proxy_info&#45;&#62;name = interp&#45;&#62;vtables[type_num]&#45;&#62;whoami;
    proxy_info&#45;&#62;_namespace = interp&#45;&#62;vtables[type_num]&#45;&#62;_namespace;

    /* XXX Parents and MRO still todo. */

    /* Enter it in the list of proxy objects. */
    VTABLE_set_pmc_keyed_int(interp, interp&#45;&#62;pmc_proxies, type_num, proxy);
}</pre>

<p>/*</p>

<h1><a name="SEE_ALSO"
>SEE ALSO <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p><em lang='und' xml:lang='und'>include/parrot/vtable.h</em>.</p>

<p><code lang='und' xml:lang='und'>5.1.0.14.2.20011008152120.02158148@pop.sidhe.org</code> (<a href="http://www.nntp.perl.org/group/perl.perl6.internals/5516">http://www.nntp.perl.org/group/perl.perl6.internals/5516</a>).</p>

<h1><a name="HISTORY"
>HISTORY <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>Initial version by Simon on 2001.10.20.</p>

<p>*/</p>

<p>/* * Local variables: * c&#45;file&#45;style: &#34;parrot&#34; * End: * vim: expandtab shiftwidth=4: */</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
