<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Header management functions</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Header management functions</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../html/index.html">Contents</a> | <a href="../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>src/headers.c &#45; Header management functions</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>Handles getting of various headers,
and pool creation.</p>

<p>*/</p>

<p>#include &#34;parrot/parrot.h&#34; #include &#34;parrot/headers.h&#34;</p>

<p>/* HEADERIZER HFILE: include/parrot/headers.h */</p>

<p>/* HEADERIZER BEGIN: static */</p>

<p>static void fix_pmc_syncs( NOTNULL(Interp *dest_interp),
NOTNULL(Small_Object_Pool *pool) ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>static void free_pool( NOTNULL(Small_Object_Pool *pool) ) __attribute__nonnull__(1);</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL static void * get_free_buffer( PARROT_INTERP,
NOTNULL(Small_Object_Pool *pool) ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL static PMC_EXT * new_pmc_ext( PARROT_INTERP ) __attribute__nonnull__(1);</p>

<p>static int sweep_cb_buf( PARROT_INTERP,
NOTNULL(Small_Object_Pool *pool),
SHIM(int flag),
NOTNULL(void *arg) ) __attribute__nonnull__(1) __attribute__nonnull__(2) __attribute__nonnull__(4);</p>

<p>static int sweep_cb_pmc( PARROT_INTERP,
NOTNULL(Small_Object_Pool *pool),
int flag,
NOTNULL(void *arg) ) __attribute__nonnull__(1) __attribute__nonnull__(2) __attribute__nonnull__(4);</p>

<p>/* HEADERIZER END: static */</p>

<p>#ifndef GC_IS_MALLOC # define PMC_HEADERS_PER_ALLOC 10240 / sizeof (PMC) # define BUFFER_HEADERS_PER_ALLOC 5120 / sizeof (Buffer) # define STRING_HEADERS_PER_ALLOC 5120 / sizeof (STRING) #else /* GC_IS_MALLOC */ # define PMC_HEADERS_PER_ALLOC 10240 / sizeof (PMC) # define BUFFER_HEADERS_PER_ALLOC 10240 / sizeof (Buffer) # define STRING_HEADERS_PER_ALLOC 10240 / sizeof (STRING) #endif /* GC_IS_MALLOC */</p>

<p># define CONSTANT_PMC_HEADERS_PER_ALLOC 64</p>

<p>/*</p>

<h2><a name="Buffer_Header_Functions_for_small&#45;object_lookup_table"
>Buffer Header Functions for small&#45;object lookup table <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>FUNCDOC: get_free_buffer</p>

<p>Gets a free <code lang='und' xml:lang='und'>Buffer</code> from <code lang='und' xml:lang='und'>pool</code> and returns it.
Memory is cleared.</p>

<p>*/</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL static void * get_free_buffer(PARROT_INTERP,
NOTNULL(Small_Object_Pool *pool)) { PObj * const buffer = (PObj *)pool&#45;&#62;get_free_object(interp,
pool);</p>

<pre lang='und' xml:lang='und'>    /* don&#39;t mess around with flags */
    PObj_bufstart(buffer) = NULL;
    PObj_buflen(buffer) = 0;

    if (pool&#45;&#62;object_size  &#45; GC_HEADER_SIZE &#62; sizeof (PObj))
        memset(buffer + 1, 0,
                pool&#45;&#62;object_size &#45; sizeof (PObj) &#45; GC_HEADER_SIZE);
    return buffer;
}</pre>

<p>/*</p>

<h2><a name="Header_Pool_Creation_Functions"
>Header Pool Creation Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>FUNCDOC: new_pmc_pool</p>

<p>Creates an new pool for PMCs and returns it.</p>

<p>*/</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL Small_Object_Pool * new_pmc_pool(PARROT_INTERP) { const int num_headers = PMC_HEADERS_PER_ALLOC; Small_Object_Pool * const pmc_pool = new_small_object_pool(sizeof (PMC), num_headers);</p>

<pre lang='und' xml:lang='und'>    pmc_pool&#45;&#62;mem_pool   = NULL;
    pmc_pool&#45;&#62;dod_object = Parrot_dod_free_pmc;

    (interp&#45;&#62;arena_base&#45;&#62;init_pool)(interp, pmc_pool);
    return pmc_pool;
}</pre>

<p>/*</p>

<p>FUNCDOC: new_bufferlike_pool</p>

<p>Creates a new pool for buffer&#45;like structures. Usually you would need <code lang='und' xml:lang='und'>make_bufferlike_pool()</code>.</p>

<p>*/</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL Small_Object_Pool * new_bufferlike_pool(PARROT_INTERP, size_t actual_buffer_size) { const int num_headers = BUFFER_HEADERS_PER_ALLOC; const size_t buffer_size = (actual_buffer_size + sizeof (void *) &#45; 1) &#38; ~(sizeof (void *) &#45; 1); Small_Object_Pool * const pool = new_small_object_pool(buffer_size, num_headers);</p>

<pre lang='und' xml:lang='und'>    pool&#45;&#62;dod_object = Parrot_dod_free_sysmem;
    pool&#45;&#62;mem_pool   = interp&#45;&#62;arena_base&#45;&#62;memory_pool;
    (interp&#45;&#62;arena_base&#45;&#62;init_pool)(interp, pool);
    return pool;
}</pre>

<p>/*</p>

<p>FUNCDOC: new_buffer_pool</p>

<p>Non&#45;constant strings and plain Buffers are in the sized header pools.</p>

<p>*/</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL Small_Object_Pool * new_buffer_pool(PARROT_INTERP) { Small_Object_Pool *pool = make_bufferlike_pool(interp, sizeof (Buffer));</p>

<p>#ifdef GC_IS_MALLOC pool&#45;&#62;dod_object = Parrot_dod_free_buffer_malloc; #else pool&#45;&#62;dod_object = Parrot_dod_free_buffer; #endif</p>

<pre lang='und' xml:lang='und'>    return pool;
}</pre>

<p>/*</p>

<p>FUNCDOC: new_string_pool</p>

<p>Creates a new pool for <code lang='und' xml:lang='und'>STRINGS</code> and returns it.</p>

<p>*/</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL Small_Object_Pool * new_string_pool(PARROT_INTERP, INTVAL constant) { Small_Object_Pool *pool; if (constant) { pool = new_bufferlike_pool(interp, sizeof (STRING)); pool&#45;&#62;mem_pool = interp&#45;&#62;arena_base&#45;&#62;constant_string_pool; } else pool = make_bufferlike_pool(interp, sizeof (STRING)); pool&#45;&#62;objects_per_alloc = STRING_HEADERS_PER_ALLOC; return pool; }</p>

<p>/*</p>

<p>FUNCDOC: make_bufferlike_pool</p>

<p>Make and return a bufferlike header pool.</p>

<p>*/</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL Small_Object_Pool * make_bufferlike_pool(PARROT_INTERP, size_t buffer_size) { const UINTVAL num_old = interp&#45;&#62;arena_base&#45;&#62;num_sized; Small_Object_Pool **sized_pools = interp&#45;&#62;arena_base&#45;&#62;sized_header_pools;</p>

<pre lang='und' xml:lang='und'>    const UINTVAL idx = (buffer_size &#45; sizeof (Buffer)) / sizeof (void *);

    /* Expand the array of sized resource pools, if necessary */
    if (num_old &#60;= idx) {
        const UINTVAL num_new = idx + 1;
        sized_pools = (Small_Object_Pool **)mem_internal_realloc(sized_pools,
                                           num_new * sizeof (void *));
        memset(sized_pools + num_old, 0, sizeof (void *) * (num_new &#45; num_old));

        interp&#45;&#62;arena_base&#45;&#62;sized_header_pools = sized_pools;
        interp&#45;&#62;arena_base&#45;&#62;num_sized = num_new;
    }

    if (sized_pools[idx] == NULL) {
        sized_pools[idx] = new_bufferlike_pool(interp, buffer_size);
    }

    return sized_pools[idx];
}</pre>

<p>/*</p>

<p>FUNCDOC: get_bufferlike_pool</p>

<p>Return a bufferlike header pool, it must exist.</p>

<p>*/</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL Small_Object_Pool * get_bufferlike_pool(PARROT_INTERP, size_t buffer_size) { Small_Object_Pool ** const sized_pools = interp&#45;&#62;arena_base&#45;&#62;sized_header_pools;</p>

<pre lang='und' xml:lang='und'>    return sized_pools[ (buffer_size &#45; sizeof (Buffer)) / sizeof (void *) ];
}</pre>

<p>/*</p>

<p>FUNCDOC: new_pmc_header</p>

<p>Get a header.</p>

<p>*/</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL PMC * new_pmc_header(PARROT_INTERP, UINTVAL flags) { Small_Object_Pool * const pool = flags &#38; PObj_constant_FLAG ? interp&#45;&#62;arena_base&#45;&#62;constant_pmc_pool : interp&#45;&#62;arena_base&#45;&#62;pmc_pool; PMC * const pmc = (PMC *)pool&#45;&#62;get_free_object(interp, pool);</p>

<pre lang='und' xml:lang='und'>    /* clear flags, set is_PMC_FLAG */
    if (flags &#38; PObj_is_PMC_EXT_FLAG) {
        flags |= PObj_is_special_PMC_FLAG;
        pmc&#45;&#62;pmc_ext = new_pmc_ext(interp);
        if (flags &#38; PObj_is_PMC_shared_FLAG) {
            add_pmc_sync(interp, pmc);
        }
    }
    else
        pmc&#45;&#62;pmc_ext = NULL;
    PObj_get_FLAGS(pmc) = PObj_is_PMC_FLAG|flags;
    pmc&#45;&#62;vtable = NULL;
#if ! PMC_DATA_IN_EXT
    PMC_data(pmc) = NULL;
#endif
    return pmc;
}</pre>

<p>/*</p>

<p>FUNCDOC: new_pmc_ext</p>

<p>Creates a new <code lang='und' xml:lang='und'>PMC_EXT</code> and returns it.</p>

<p>*/</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL static PMC_EXT * new_pmc_ext(PARROT_INTERP) { Small_Object_Pool * const pool = interp&#45;&#62;arena_base&#45;&#62;pmc_ext_pool; PMC_EXT *ptr; /* * can&#39;t use normal get_free_object&#45;&#45;PMC_EXT doesn&#39;t have flags * it isn&#39;t a Buffer */ if (!pool&#45;&#62;free_list) (*pool&#45;&#62;more_objects) (interp, pool); ptr = (PMC_EXT *)pool&#45;&#62;free_list; pool&#45;&#62;free_list = *(void **)ptr; memset(ptr, 0, sizeof(*ptr)); return ptr; }</p>

<p>/*</p>

<p>FUNCDOC: add_pmc_ext</p>

<p>Adds a new <code lang='und' xml:lang='und'>PMC_EXT</code> to <code lang='und' xml:lang='und'>pmc</code>.</p>

<p>*/</p>

<p>void add_pmc_ext(PARROT_INTERP, NOTNULL(PMC *pmc)) { pmc&#45;&#62;pmc_ext = new_pmc_ext(interp); PObj_is_PMC_EXT_SET(pmc); #ifdef PARROT_GC_IMS /* * preserve DDD color: a simple PMC live = black * an aggregate live = grey * set&#39;em black */ if (PObj_live_TEST(pmc)) PObj_get_FLAGS(pmc) |= PObj_custom_GC_FLAG; #endif PMC_next_for_GC(pmc) = PMCNULL; }</p>

<p>/*</p>

<p>FUNCDOC: add_pmc_sync</p>

<p>Adds a PMC_sync field to <code lang='und' xml:lang='und'>pmc</code>.</p>

<p>*/</p>

<p>void add_pmc_sync(PARROT_INTERP, NOTNULL(PMC *pmc)) { if (!PObj_is_PMC_EXT_TEST(pmc)) { add_pmc_ext(interp, pmc); } PMC_sync(pmc) = (Sync *)mem_internal_allocate(sizeof (*PMC_sync(pmc))); PMC_sync(pmc)&#45;&#62;owner = interp; MUTEX_INIT(PMC_sync(pmc)&#45;&#62;pmc_lock); }</p>

<p>/*</p>

<p>FUNCDOC: new_string_header</p>

<p>Returns a new <code lang='und' xml:lang='und'>STRING</code> header.</p>

<p>*/</p>

<p>PARROT_CANNOT_RETURN_NULL PARROT_WARN_UNUSED_RESULT STRING * new_string_header(PARROT_INTERP, UINTVAL flags) { STRING * const string = (STRING *)get_free_buffer(interp, (flags &#38; PObj_constant_FLAG) ? interp&#45;&#62;arena_base&#45;&#62;constant_string_header_pool : interp&#45;&#62;arena_base&#45;&#62;string_header_pool);</p>

<pre lang='und' xml:lang='und'>    PObj_get_FLAGS(string) |=
        flags | PObj_is_string_FLAG | PObj_is_COWable_FLAG | PObj_live_FLAG;

    string&#45;&#62;strstart        = NULL;

    return string;
}</pre>

<p>/*</p>

<p>FUNCDOC: new_buffer_header</p>

<p>Creates and returns a new <code lang='und' xml:lang='und'>Buffer</code>.</p>

<p>*/</p>

<p>PARROT_CANNOT_RETURN_NULL PARROT_WARN_UNUSED_RESULT Buffer * new_buffer_header(PARROT_INTERP) { return (Buffer *)get_free_buffer(interp, interp&#45;&#62;arena_base&#45;&#62;buffer_header_pool); }</p>

<p>/*</p>

<p>FUNCDOC: new_bufferlike_header</p>

<p>Creates and returns a new buffer&#45;like header.</p>

<p>*/</p>

<p>PARROT_CANNOT_RETURN_NULL PARROT_WARN_UNUSED_RESULT void * new_bufferlike_header(PARROT_INTERP, size_t size) { Small_Object_Pool * const pool = get_bufferlike_pool(interp, size);</p>

<pre lang='und' xml:lang='und'>    return get_free_buffer(interp, pool);
}</pre>

<p>/*</p>

<p>FUNCDOC: get_max_buffer_address</p>

<p>Calculates the maximum buffer address and returns it.</p>

<p>*/</p>

<p>PARROT_WARN_UNUSED_RESULT size_t get_max_buffer_address(PARROT_INTERP) { UINTVAL i; size_t max = 0; Arenas * const arena_base = interp&#45;&#62;arena_base;</p>

<pre lang='und' xml:lang='und'>    for (i = 0; i &#60; arena_base&#45;&#62;num_sized; i++) {
        if (arena_base&#45;&#62;sized_header_pools[i]) {
            if (arena_base&#45;&#62; sized_header_pools[i]&#45;&#62;end_arena_memory &#62; max)
                max = arena_base&#45;&#62;sized_header_pools[i]&#45;&#62;end_arena_memory;
        }
    }

    return max;
}</pre>

<p>/*</p>

<p>FUNCDOC: get_min_buffer_address</p>

<p>Calculates the minimum buffer address and returns it.</p>

<p>*/</p>

<p>PARROT_WARN_UNUSED_RESULT size_t get_min_buffer_address(PARROT_INTERP) { UINTVAL i; Arenas * const arena_base = interp&#45;&#62;arena_base; size_t min = (size_t) &#45;1;</p>

<pre lang='und' xml:lang='und'>    for (i = 0; i &#60; arena_base&#45;&#62;num_sized; i++) {
        if (arena_base&#45;&#62;sized_header_pools[i] &#38;&#38;
            arena_base&#45;&#62;sized_header_pools[i]&#45;&#62;start_arena_memory) {
            if (arena_base&#45;&#62;sized_header_pools[i]&#45;&#62;start_arena_memory &#60; min)
                min = arena_base&#45;&#62;sized_header_pools[i]&#45;&#62;start_arena_memory;
        }
    }
    return min;
}</pre>

<p>/*</p>

<p>FUNCDOC: get_max_pmc_address</p>

<p>Calculates the maximum PMC address and returns it.</p>

<p>*/</p>

<p>PARROT_WARN_UNUSED_RESULT size_t get_max_pmc_address(PARROT_INTERP) { return interp&#45;&#62;arena_base&#45;&#62;pmc_pool&#45;&#62;end_arena_memory; }</p>

<p>/*</p>

<p>FUNCDOC: get_min_pmc_address</p>

<p>Calculates the maximum PMC address and returns it.</p>

<p>*/</p>

<p>PARROT_WARN_UNUSED_RESULT size_t get_min_pmc_address(PARROT_INTERP) { return interp&#45;&#62;arena_base&#45;&#62;pmc_pool&#45;&#62;start_arena_memory; }</p>

<p>/*</p>

<p>FUNCDOC: is_buffer_ptr</p>

<p>Checks that <code lang='und' xml:lang='und'>ptr</code> is actually a <code lang='und' xml:lang='und'>Buffer</code>.</p>

<p>*/</p>

<p>PARROT_WARN_UNUSED_RESULT int is_buffer_ptr(PARROT_INTERP, NOTNULL(const void *ptr)) { UINTVAL i; Arenas * const arena_base = interp&#45;&#62;arena_base;</p>

<pre lang='und' xml:lang='und'>    for (i = 0; i &#60; arena_base&#45;&#62;num_sized; i++) {
        if (arena_base&#45;&#62;sized_header_pools[i] &#38;&#38;
                contained_in_pool(arena_base&#45;&#62;sized_header_pools[i], ptr))
            return 1;
    }

    return 0;
}</pre>

<p>/*</p>

<p>FUNCDOC: is_pmc_ptr</p>

<p>Checks that <code lang='und' xml:lang='und'>ptr</code> is actually a PMC.</p>

<p>*/</p>

<p>PARROT_WARN_UNUSED_RESULT int is_pmc_ptr(PARROT_INTERP, NOTNULL(const void *ptr)) { return contained_in_pool(interp&#45;&#62;arena_base&#45;&#62;pmc_pool, ptr); }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_initialize_header_pools</p>

<p>Initialize the pools for the tracked resources.</p>

<p>*/</p>

<p>void Parrot_initialize_header_pools(PARROT_INTERP) { Arenas * const arena_base = interp&#45;&#62;arena_base;</p>

<pre lang='und' xml:lang='und'>    /* Init the constant string header pool */
    arena_base&#45;&#62;constant_string_header_pool = new_string_pool(interp, 1);
    arena_base&#45;&#62;constant_string_header_pool&#45;&#62;name = &#34;constant_string_header&#34;;

    /* Init the buffer header pool
     *
     * note: the buffer_header_pool and the string_header_pool are actually
     * living in the sized_header_pools, this pool pointers are only
     * here for faster access in new_*_header
     */
    arena_base&#45;&#62;buffer_header_pool = new_buffer_pool(interp);
    arena_base&#45;&#62;buffer_header_pool&#45;&#62;name = &#34;buffer_header&#34;;

    /* Init the string header pool */
    arena_base&#45;&#62;string_header_pool = new_string_pool(interp, 0);
    arena_base&#45;&#62;string_header_pool&#45;&#62;name = &#34;string_header&#34;;

    /* Init the PMC header pool */
    arena_base&#45;&#62;pmc_pool = new_pmc_pool(interp);
    arena_base&#45;&#62;pmc_pool&#45;&#62;name = &#34;pmc&#34;;

    /* pmc extension buffer */
    arena_base&#45;&#62;pmc_ext_pool =
        new_small_object_pool(sizeof (PMC_EXT), 1024);
    /*
     * pmc_ext isn&#39;t a managed item. If a PMC has a pmc_ext structure
     * it is returned to the pool instantly &#45; the structure is never
     * marked.
     * Use GS MS pool functions
     */
    gc_pmc_ext_pool_init(arena_base&#45;&#62;pmc_ext_pool);
    arena_base&#45;&#62;pmc_ext_pool&#45;&#62;name = &#34;pmc_ext&#34;;

    /* constant PMCs */
    arena_base&#45;&#62;constant_pmc_pool = new_pmc_pool(interp);
    arena_base&#45;&#62;constant_pmc_pool&#45;&#62;name = &#34;constant_pmc&#34;;
    arena_base&#45;&#62;constant_pmc_pool&#45;&#62;objects_per_alloc =
       CONSTANT_PMC_HEADERS_PER_ALLOC;
}</pre>

<p>/*</p>

<p>FUNCDOC: Parrot_forall_header_pools</p>

<p>Iterate through all header pools by calling the passed function. Returns zero if the iteration didn&#39;t stop or the returned value.</p>

<dl>
<dt><a name="flag_is_one_of"
>flag is one of</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  POOL_PMC
  POOL_BUFFER
  POOL_CONST
  POOL_ALL</pre>

<dd>Only matching pools will be used.</dd><p class="pad"></p>

<dt><a name="arg"
>arg</a></dt><p class="pad"></p>

<dd>This argument is passed on to the iteration function.</dd><p class="pad"></p>

<dt><a name="pool_iter_fn"
>pool_iter_fn</a></dt><p class="pad"></p>

<dd>It is called with <code lang='und' xml:lang='und'>Interp*, Small_Object_Pool *, int flag, void *arg)</code> If the function returns a non&#45;zero value iteration will stop.</dd><p class="pad"></p>
</dl>

<p>*/</p>

<p>PARROT_WARN_UNUSED_RESULT int Parrot_forall_header_pools(PARROT_INTERP, int flag, NULLOK(void *arg), NOTNULL(pool_iter_fn func)) { Arenas * const arena_base = interp&#45;&#62;arena_base; int i;</p>

<pre lang='und' xml:lang='und'>    if ((flag &#38; (POOL_PMC | POOL_CONST)) == (POOL_PMC | POOL_CONST)) {
        const int ret_val = (func)(interp, arena_base&#45;&#62;constant_pmc_pool,
                POOL_PMC | POOL_CONST, arg);
        if (ret_val)
            return ret_val;
    }
    if (flag &#38; POOL_PMC) {
        const int ret_val = (func)(interp, arena_base&#45;&#62;pmc_pool, POOL_PMC, arg);
        if (ret_val)
            return ret_val;
    }
    if ((flag &#38; (POOL_BUFFER | POOL_CONST)) == (POOL_BUFFER | POOL_CONST)) {
        const int ret_val = (func)(interp, arena_base&#45;&#62;constant_string_header_pool,
                POOL_BUFFER | POOL_CONST, arg);
        if (ret_val)
            return ret_val;
    }
    if (!(flag &#38; POOL_BUFFER))
        return 0;
    for (i = 0; i &#60; (INTVAL)interp&#45;&#62;arena_base&#45;&#62;num_sized; i++) {
        Small_Object_Pool * const pool = arena_base&#45;&#62;sized_header_pools[i];
        if (pool) {
            const int ret_val = (func)(interp, pool, POOL_BUFFER, arg);
            if (ret_val)
                return ret_val;
        }
    }
    return 0;
}</pre>

<p>/*</p>

<p>FUNCDOC: Parrot_destroy_header_pools</p>

<p>Destroys the header pools.</p>

<p>*/</p>

<p>static void free_pool(NOTNULL(Small_Object_Pool *pool)) { Small_Object_Arena *cur_arena;</p>

<pre lang='und' xml:lang='und'>    for (cur_arena = pool&#45;&#62;last_Arena; cur_arena;) {
        Small_Object_Arena * const next = cur_arena&#45;&#62;prev;
        mem_internal_free(cur_arena&#45;&#62;start_objects);
        mem_internal_free(cur_arena);
        cur_arena = next;
    }
    mem_internal_free(pool);
}</pre>

<p>static int sweep_cb_buf(PARROT_INTERP, NOTNULL(Small_Object_Pool *pool), SHIM(int flag), NOTNULL(void *arg)) { #ifdef GC_IS_MALLOC const int pass = (int)(INTVAL)arg;</p>

<pre lang='und' xml:lang='und'>    if (pass == 0)
        clear_cow(interp, pool, 1);
    else if (pass == 1)
        used_cow(interp, pool, 1);
    else
#endif
    {
        UNUSED(arg);

        Parrot_dod_sweep(interp, pool);
        free_pool(pool);
    }
    return 0;</pre>

<p>}</p>

<p>static int sweep_cb_pmc(PARROT_INTERP, NOTNULL(Small_Object_Pool *pool), int flag, NOTNULL(void *arg)) { UNUSED(flag); UNUSED(arg);</p>

<pre lang='und' xml:lang='und'>    Parrot_dod_sweep(interp, pool);
    free_pool(pool);
    return 0;
}</pre>

<p>void Parrot_destroy_header_pools(PARROT_INTERP) { INTVAL pass, start, ignored;</p>

<pre lang='und' xml:lang='und'>    /* const/non const COW strings life in different pools
     * so in first pass
     * COW refcount is done, in 2. refcounting
     * in 3rd freeing
     */
#ifdef GC_IS_MALLOC
    start = 0;
#else
    start = 2;
#endif
    ignored = Parrot_forall_header_pools(interp, POOL_PMC | POOL_CONST, NULL,
            sweep_cb_pmc);
    UNUSED(ignored);

    for (pass = start; pass &#60;= 2; pass++) {
        ignored = Parrot_forall_header_pools(interp, POOL_BUFFER | POOL_CONST,
                (void *)pass, sweep_cb_buf);
    }

    free_pool(interp&#45;&#62;arena_base&#45;&#62;pmc_ext_pool);
    mem_internal_free(interp&#45;&#62;arena_base&#45;&#62;sized_header_pools);
}</pre>

<p>static void fix_pmc_syncs(NOTNULL(Interp *dest_interp), NOTNULL(Small_Object_Pool *pool)) { /* XXX largely copied from dod_sweep */ Small_Object_Arena *cur_arena; const UINTVAL object_size = pool&#45;&#62;object_size;</p>

<pre lang='und' xml:lang='und'>    for (cur_arena = pool&#45;&#62;last_Arena; cur_arena; cur_arena = cur_arena&#45;&#62;prev) {
        Buffer *b = (Buffer *)cur_arena&#45;&#62;start_objects;
        size_t i;

        for (i = 0; i &#60; cur_arena&#45;&#62;used; i++) {
            if (PObj_on_free_list_TEST(b))
                ; /* if it&#39;s on free list, do nothing */
            else {
                if (PObj_is_PMC_TEST(b)) {
                    PMC * const p = (PMC *)b;
                    if (PObj_is_PMC_shared_TEST(p)) {
                        PMC_sync(p)&#45;&#62;owner = dest_interp;
                    }
                    else {
                        /* fprintf(stderr, &#34;BAD PMC: address=%p,
                                   base_type=%d\n&#34;,
                                   p, p&#45;&#62;vtable&#45;&#62;base_type); */
                        PARROT_ASSERT(0);
                    }
                }
            }

            b = (Buffer *)((char *)b + object_size);
        }
    }
}</pre>

<p>/*</p>

<p>FUNCDOC: Parrot_merge_header_pools</p>

<p>Merge the header pools of <code lang='und' xml:lang='und'>source_interp</code> into those of <code lang='und' xml:lang='und'>dest_interp</code>. (Used to deal with shared objects left after interpreter destruction.)</p>

<p>*/</p>

<p>void Parrot_merge_header_pools(NOTNULL(Interp *dest_interp), NOTNULL(Interp *source_interp)) { UINTVAL i;</p>

<pre lang='und' xml:lang='und'>    Arenas * const dest_arena = dest_interp&#45;&#62;arena_base;
    Arenas * const source_arena = source_interp&#45;&#62;arena_base;

    /* heavily borrowed from forall_header_pools */

    fix_pmc_syncs(dest_interp, source_arena&#45;&#62;constant_pmc_pool);
    Parrot_small_object_pool_merge(dest_interp, dest_arena&#45;&#62;constant_pmc_pool,
            source_arena&#45;&#62;constant_pmc_pool);
    fix_pmc_syncs(dest_interp, source_arena&#45;&#62;pmc_pool);
    Parrot_small_object_pool_merge(dest_interp, dest_arena&#45;&#62;pmc_pool,
            source_arena&#45;&#62;pmc_pool);
    Parrot_small_object_pool_merge(dest_interp,
            dest_arena&#45;&#62;constant_string_header_pool,
            source_arena&#45;&#62;constant_string_header_pool);
    Parrot_small_object_pool_merge(dest_interp,
            dest_arena&#45;&#62;pmc_ext_pool,
            source_arena&#45;&#62;pmc_ext_pool);

    for (i = 0; i &#60; source_arena&#45;&#62;num_sized; ++i) {
        if (!source_arena&#45;&#62;sized_header_pools[i]) {
            continue;
        }

        if (i &#62;= dest_arena&#45;&#62;num_sized ||
            !dest_arena&#45;&#62;sized_header_pools[i]) {
            Small_Object_Pool *ignored = make_bufferlike_pool(dest_interp,
                    i * sizeof (void *) + sizeof (Buffer));
            UNUSED(ignored);
            PARROT_ASSERT(dest_arena&#45;&#62;sized_header_pools[i]);
        }

        Parrot_small_object_pool_merge(dest_interp,
            dest_arena&#45;&#62;sized_header_pools[i],
            source_arena&#45;&#62;sized_header_pools[i]);
    }
}</pre>

<p>#if 0</p>

<p>/*</p>

<p>Parrot_initialize_header_pool_names(PARROT_INTERP)&#62;</p>

<p>If we want these names, they must be added in DOD.</p>

<p>*/</p>

<p>void Parrot_initialize_header_pool_names(PARROT_INTERP) { interp&#45;&#62;arena_base&#45;&#62;string_header_pool&#45;&#62;name = string_make(interp, &#34;String Pool&#34;, strlen(&#34;String Pool&#34;), 0, PObj_constant_FLAG, 0); interp&#45;&#62;arena_base&#45;&#62;pmc_pool&#45;&#62;name = string_make(interp, &#34;PMC Pool&#34;, strlen(&#34;PMC Pool&#34;), 0, PObj_constant_FLAG, 0); /* Set up names for each header pool, * now that we have a constant string * * * pool available to us */ interp&#45;&#62;arena_base&#45;&#62;constant_string_header_pool&#45;&#62;name = string_make(interp, &#34;Constant String Pool&#34;, strlen(&#34;Constant String Pool&#34;), 0, PObj_constant_FLAG, 0); interp&#45;&#62;arena_base&#45;&#62;buffer_header_pool&#45;&#62;name = string_make(interp, &#34;Generic Header Pool&#34;, strlen(&#34;Generic Header Pool&#34;), 0, PObj_constant_FLAG, 0); }</p>

<p>#endif</p>

<p>/*</p>

<h1><a name="SEE_ALSO"
>SEE ALSO <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p><em lang='und' xml:lang='und'>include/parrot/headers.h</em>.</p>

<h1><a name="HISTORY"
>HISTORY <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>Initial version by Mike Lambert on 2002.05.27.</p>

<p>*/</p>

<p>/* * Local variables: * c&#45;file&#45;style: &#34;parrot&#34; * End: * vim: expandtab shiftwidth=4: */</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
