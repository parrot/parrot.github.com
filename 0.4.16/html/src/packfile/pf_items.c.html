<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Fetch/store packfile data</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Fetch/store packfile data</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../html/index.html">Contents</a> | <a href="../../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>src/packfile/pf_items.c &#45; Fetch/store packfile data</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Low level packfile functions to fetch and store Parrot data,
i.e.
<code lang='und' xml:lang='und'>INTVAL</code>,
<code lang='und' xml:lang='und'>FLOATVAL</code>,
<code lang='und' xml:lang='und'>STRING</code> ...</p>

<p><code lang='und' xml:lang='und'>PF_fetch_&#60;item&#62;()</code> functions retrieve the datatype item from the opcode stream and convert byteordering or binary format on the fly,
depending on the packfile header.</p>

<p><code lang='und' xml:lang='und'>PF_store_&#60;item&#62;()</code> functions write the datatype item to the stream as is.
These functions don&#39;t check the available size.</p>

<p><code lang='und' xml:lang='und'>PF_size_&#60;item&#62;()</code> functions return the store size of item in <code lang='und' xml:lang='und'>opcode_t</code> units.</p>

<h2><a name="Functions"
>Functions <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>*/</p>

<p>#include &#34;parrot/parrot.h&#34;</p>

<p>/* HEADERIZER HFILE: include/parrot/packfile.h */</p>

<p>/* HEADERIZER BEGIN: static */</p>

<p>static void cvt_num12_num8( NOTNULL(unsigned char *dest),
NOTNULL(const unsigned char *src) ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>static void cvt_num12_num8_be( NOTNULL(unsigned char *dest),
NOTNULL(const unsigned char *src) ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>static void cvt_num12_num8_le( NOTNULL(unsigned char *dest),
NOTNULL(unsigned char *src) ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>static opcode_t fetch_op_be_4( NOTNULL(unsigned char *b) ) __attribute__nonnull__(1);</p>

<p>static opcode_t fetch_op_be_8( NOTNULL(unsigned char *b) ) __attribute__nonnull__(1);</p>

<p>static opcode_t fetch_op_le_4( NOTNULL(unsigned char *b) ) __attribute__nonnull__(1);</p>

<p>static opcode_t fetch_op_le_8( NOTNULL(unsigned char *b) ) __attribute__nonnull__(1);</p>

<p>static opcode_t fetch_op_mixed_be( NOTNULL(unsigned char *b) ) __attribute__nonnull__(1);</p>

<p>static opcode_t fetch_op_mixed_le( NOTNULL(unsigned char *b) ) __attribute__nonnull__(1);</p>

<p>static opcode_t fetch_op_test( NOTNULL(unsigned char *b) ) __attribute__nonnull__(1);</p>

<p>/* HEADERIZER END: static */</p>

<p>#define TRACE_PACKFILE 0 #define TRACE_PACKFILE_PMC 0</p>

<p>/* * round val up to whole size,
return result in bytes */ #define ROUND_UP_B(val,size) ((((val) + (size &#45; 1))/(size)) * (size))</p>

<p>/* * round val up to whole opcode_t,
return result in opcodes */ #define ROUND_UP(val,size) (((val) + ((size) &#45; 1))/(size))</p>

<p>/* * low level FLOATVAL fetch and convert functions * * * convert i386 LE 12 byte long double to IEEE 754 8 byte double */ static void cvt_num12_num8(NOTNULL(unsigned char *dest),
NOTNULL(const unsigned char *src)) { int expo,
i,
s; #ifdef __LCC__ int expo2; #endif</p>

<pre lang='und' xml:lang='und'>    memset (dest, 0, 8);
    /* exponents 15 &#45;&#62; 11 bits */
    s = src[9] &#38; 0x80; /* sign */
    expo = ((src[9] &#38; 0x7f)&#60;&#60; 8 | src[8]);
    if (expo == 0) {
nul:
        if (s)
            dest[7] |= 0x80;
        return;
    }
#ifdef __LCC__
    /* Yet again, LCC blows up mysteriously until a temporary variable is
     * added. */
    expo2 = expo &#45; 16383;
    expo  = expo2;
#else
    expo &#45;= 16383;       /* &#45; bias */
#endif
    expo += 1023;       /* + bias 8byte */
    if (expo &#60;= 0)       /* underflow */
        goto nul;
    if (expo &#62; 0x7ff) {  /* inf/nan */
        dest[7] = 0x7f;
        dest[6] = src[7] == 0xc0 ? 0xf8 : 0xf0 ;
        goto nul;
    }
    expo &#60;&#60;= 4;
    dest[6] = (expo &#38; 0xff);
    dest[7] = (expo &#38; 0x7f00) &#62;&#62; 8;
    if (s)
        dest[7] |= 0x80;
    /* long double frac 63 bits =&#62; 52 bits
       src[7] &#38;= 0x7f; reset integer bit */
    for (i = 0; i &#60; 6; i++) {
        dest[i+1] |= (i==5 ? src[7]&#38;0x7f : src[i+2]) &#62;&#62; 3;
        dest[i] |= (src[i+2] &#38; 0x1f) &#60;&#60; 5;
    }
    dest[0] |= src[1] &#62;&#62; 3;
}</pre>

<p>static void cvt_num12_num8_be(NOTNULL(unsigned char *dest), NOTNULL(const unsigned char *src)) { cvt_num12_num8(dest, src); /* TODO endianize */ internal_exception(1, &#34;TODO cvt_num12_num8_be\n&#34;); }</p>

<p>static void cvt_num12_num8_le(NOTNULL(unsigned char *dest), NOTNULL(unsigned char *src)) { unsigned char b[8]; cvt_num12_num8(b, src); fetch_buf_le_8(dest, b); } static opcode_t fetch_op_test(NOTNULL(unsigned char *b)) { union { unsigned char buf[4]; opcode_t o; } u; fetch_buf_le_4(u.buf, b); return u.o; }</p>

<p>/* * opcode fetch helper function * * This is mostly wrong or at least untested * * Fetch an opcode and convert to LE */ static opcode_t fetch_op_mixed_le(NOTNULL(unsigned char *b)) { #if OPCODE_T_SIZE == 4 union { unsigned char buf[8]; opcode_t o[2]; } u; /* wordsize = 8 then */ fetch_buf_le_8(u.buf, (unsigned char *) b); return u.o[0]; /* or u.o[1] */ #else union { unsigned char buf[4]; opcode_t o; } u;</p>

<pre lang='und' xml:lang='und'>    /* wordsize = 4 */
    u.o = 0;
    fetch_buf_le_4(u.buf, b);
    return u.o;
#endif
}</pre>

<p>/* * Fetch an opcode and convert to BE */ static opcode_t fetch_op_mixed_be(NOTNULL(unsigned char *b)) { #if OPCODE_T_SIZE == 4 union { unsigned char buf[8]; opcode_t o[2]; } u; /* wordsize = 8 then */ fetch_buf_be_8(u.buf, (unsigned char *) b); return u.o[1]; /* or u.o[0] */ #else union { unsigned char buf[4]; opcode_t o; } u; /* wordsize = 4 */ u.o = 0; fetch_buf_be_4(u.buf, b); return u.o; #endif }</p>

<p>static opcode_t fetch_op_be_4(NOTNULL(unsigned char *b)) { union { unsigned char buf[4]; opcode_t o; } u; fetch_buf_be_4(u.buf, b); #if PARROT_BIGENDIAN # if OPCODE_T_SIZE == 8 return u.o &#62;&#62; 32; # else return u.o; # endif #else # if OPCODE_T_SIZE == 8 return (opcode_t)(fetch_iv_le((INTVAL)u.o) &#38; 0xffffffff); # else return (opcode_t) fetch_iv_le((INTVAL)u.o); # endif #endif }</p>

<p>static opcode_t fetch_op_be_8(NOTNULL(unsigned char *b)) { union { unsigned char buf[8]; opcode_t o[2]; } u; fetch_buf_be_8(u.buf, b); #if PARROT_BIGENDIAN # if OPCODE_T_SIZE == 8 return u.o[0]; # else return u.o[1]; # endif #else return (opcode_t)fetch_iv_le((INTVAL)u.o[0]); #endif }</p>

<p>static opcode_t fetch_op_le_4(NOTNULL(unsigned char *b)) { union { unsigned char buf[4]; opcode_t o; } u; fetch_buf_le_4(u.buf, b); #if PARROT_BIGENDIAN # if OPCODE_T_SIZE == 8 return u.o &#62;&#62; 32; # else return (opcode_t) fetch_iv_be((INTVAL)u.o); # endif #else # if OPCODE_T_SIZE == 8 return u.o &#38; 0xffffffff; # else return u.o; # endif #endif }</p>

<p>static opcode_t fetch_op_le_8(NOTNULL(unsigned char *b)) { union { unsigned char buf[8]; opcode_t o[2]; } u; fetch_buf_le_8(u.buf, b); #if PARROT_BIGENDIAN # if OPCODE_T_SIZE == 8 return u.o[0]; # else return (opcode_t)fetch_op_be((INTVAL)u.o[1]); # endif #else return u.o[0]; #endif }</p>

<p>/*</p>

<p>FUNCDOC: PF_fetch_opcode</p>

<p>Fetch an <code lang='und' xml:lang='und'>opcode_t</code> from the stream, converting byteorder if needed.</p>

<p>*/</p>

<p>PARROT_WARN_UNUSED_RESULT opcode_t PF_fetch_opcode(NULLOK(PackFile *pf), NOTNULL(opcode_t **stream)) { opcode_t o; if (!pf || !pf&#45;&#62;fetch_op) return *(*stream)++; #if TRACE_PACKFILE == 2 PIO_eprintf(NULL, &#34;PF_fetch_opcode: Reordering.\n&#34;); #endif o = (pf&#45;&#62;fetch_op)(*((unsigned char **)stream)); *((unsigned char **) (stream)) += pf&#45;&#62;header&#45;&#62;wordsize; return o; }</p>

<p>/*</p>

<p>FUNCDOC: PF_store_opcode</p>

<p>Store an <code lang='und' xml:lang='und'>opcode_t</code> to stream as is.</p>

<p>*/</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL opcode_t* PF_store_opcode(NOTNULL(opcode_t *cursor), opcode_t val) { *cursor++ = val; return cursor; }</p>

<p>/*</p>

<p>FUNCDOC: PF_size_opcode</p>

<p>Return size of an item in <code lang='und' xml:lang='und'>opcode_t</code> units, which is 1 <i>per definitionem</i>.</p>

<p>*/</p>

<p>PARROT_CONST_FUNCTION size_t PF_size_opcode(void) { return 1; }</p>

<p>/*</p>

<p>FUNCDOC: PF_fetch_integer</p>

<p>Fetch an <code lang='und' xml:lang='und'>INTVAL</code> from the stream, converting byteorder if needed.</p>

<p>XXX assumes <code lang='und' xml:lang='und'>sizeof (INTVAL) == sizeof (opcode_t)</code> &#45; we don&#39;t have <code lang='und' xml:lang='und'>INTVAL</code> size in the PackFile header.</p>

<p>*/</p>

<p>PARROT_WARN_UNUSED_RESULT INTVAL PF_fetch_integer(NULLOK(PackFile *pf), NOTNULL(opcode_t **stream)) { INTVAL i; if (!pf || pf&#45;&#62;fetch_iv == NULL) return *(*stream)++; i = (pf&#45;&#62;fetch_iv)(*((unsigned char **)stream)); /* XXX assume sizeof (opcode_t) == sizeof (INTVAL) on the * machine producing this PBC */ *((unsigned char **) (stream)) += pf&#45;&#62;header&#45;&#62;wordsize; return i; }</p>

<p>/*</p>

<p>FUNCDOC: PF_store_integer</p>

<p>Store an <code lang='und' xml:lang='und'>INTVAL</code> to stream as is.</p>

<p>*/</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL opcode_t* PF_store_integer(NOTNULL(opcode_t *cursor), INTVAL val) { *cursor++ = (opcode_t)val; /* XXX */ return cursor; }</p>

<p>/*</p>

<p>FUNCDOC: PF_size_integer</p>

<p>Return store size of <code lang='und' xml:lang='und'>INTVAL</code> in <code lang='und' xml:lang='und'>opcode_t</code> units.</p>

<p>*/</p>

<p>PARROT_CONST_FUNCTION size_t PF_size_integer(void) { const size_t s = sizeof (INTVAL) / sizeof (opcode_t); return s ? s : 1; }</p>

<p>/*</p>

<p>FUNCDOC: PF_fetch_number</p>

<p>Fetch a <code lang='und' xml:lang='und'>FLOATVAL</code> from the stream, converting byteorder if needed. Then advance stream pointer by amount of packfile float size.</p>

<p>*/</p>

<p>PARROT_WARN_UNUSED_RESULT FLOATVAL PF_fetch_number(NULLOK(PackFile *pf), NOTNULL(opcode_t **stream)) { /* When we have alignment all squared away we don&#39;t need * to use memcpy() for native byteorder. */ FLOATVAL f; double d; if (!pf || !pf&#45;&#62;fetch_nv) { #if TRACE_PACKFILE PIO_eprintf(NULL, &#34;PF_fetch_number: Native [%d bytes]\n&#34;, sizeof (FLOATVAL)); #endif memcpy(&#38;f, (char*)*stream, sizeof (FLOATVAL)); (*stream) += (sizeof (FLOATVAL) + sizeof (opcode_t) &#45; 1)/ sizeof (opcode_t); return f; } f = (FLOATVAL) 0; #if TRACE_PACKFILE PIO_eprintf(NULL, &#34;PF_fetch_number: Byteordering..\n&#34;); #endif /* Here is where the size transforms get messy */ if (NUMVAL_SIZE == 8 &#38;&#38; pf&#45;&#62;header&#45;&#62;floattype == 1) { (pf&#45;&#62;fetch_nv)((unsigned char *)&#38;f, (unsigned char *) *stream); *((unsigned char **) (stream)) += 12; } else { (pf&#45;&#62;fetch_nv)((unsigned char *)&#38;d, (unsigned char *) *stream); *((unsigned char **) (stream)) += 8; f = d; } return f; }</p>

<p>/*</p>

<p>FUNCDOC: PF_store_number</p>

<p>Write a <code lang='und' xml:lang='und'>FLOATVAL</code> to the opcode stream as is.</p>

<p>*/</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL opcode_t* PF_store_number(NOTNULL(opcode_t *cursor), NOTNULL(const FLOATVAL *val)) { opcode_t padded_size = (sizeof (FLOATVAL) + sizeof (opcode_t) &#45; 1) / sizeof (opcode_t); mem_sys_memcopy(cursor, val, sizeof (FLOATVAL)); cursor += padded_size; return cursor; }</p>

<p>/*</p>

<p>FUNCDOC: PF_size_number</p>

<p>Return store size of FLOATVAL in opcode_t units.</p>

<p>*/</p>

<p>PARROT_CONST_FUNCTION size_t PF_size_number(void) { return ROUND_UP(sizeof (FLOATVAL), sizeof (opcode_t)); }</p>

<p>/*</p>

<p>FUNCDOC: PF_fetch_string</p>

<p>Fetch a <code lang='und' xml:lang='und'>STRING</code> from bytecode and return a new <code lang='und' xml:lang='und'>STRING</code>.</p>

<p>Opcode format is:</p>

<pre lang='und' xml:lang='und'>    opcode_t flags
    opcode_t encoding
    opcode_t type
    opcode_t size
    * data</pre>

<p>*/</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL STRING * PF_fetch_string(PARROT_INTERP, NULLOK(PackFile *pf), NOTNULL(opcode_t **cursor)) { UINTVAL flags; opcode_t charset_nr; size_t size; STRING *s; const int wordsize = pf ? pf&#45;&#62;header&#45;&#62;wordsize : sizeof (opcode_t); const char *charset_name;</p>

<pre lang='und' xml:lang='und'>    flags = PF_fetch_opcode(pf, cursor);
    /* don&#39;t let PBC mess our internals &#45; only constant or not */
    flags &#38;= (PObj_constant_FLAG | PObj_private7_FLAG);
    charset_nr = PF_fetch_opcode(pf, cursor);

    /* These may need to be separate */
    size = (size_t)PF_fetch_opcode(pf, cursor);</pre>

<p>/* #define TRACE_PACKFILE 1 */ #if TRACE_PACKFILE PIO_eprintf(NULL, &#34;PF_fetch_string(): flags are 0x%04x...\n&#34;, flags); PIO_eprintf(NULL, &#34;PF_fetch_string(): charset_nr is %ld...\n&#34;, charset_nr); PIO_eprintf(NULL, &#34;PF_fetch_string(): size is %ld...\n&#34;, size); #endif</p>

<pre lang='und' xml:lang='und'>    charset_name = Parrot_charset_c_name(interp, charset_nr);
    s = string_make(interp, (char *)*cursor, size, charset_name, flags);</pre>

<p>#if TRACE_PACKFILE PIO_eprintf(NULL, &#34;PF_fetch_string(): string is: &#34;); PIO_putps(interp, PIO_STDERR(interp), s); PIO_eprintf(NULL, &#34;\n&#34;); #endif</p>

<p>/* s = string_make(interp, *cursor, size, encoding_lookup_index(encoding), flags); */</p>

<pre lang='und' xml:lang='und'>    size = ROUND_UP_B(size, wordsize);
    *((unsigned char **) (cursor)) += size;
    return s;
}</pre>

<p>/*</p>

<p>FUNCDOC: PF_store_string</p>

<p>Write a STRING to the opcode stream.</p>

<p>*/</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL opcode_t* PF_store_string(NOTNULL(opcode_t *cursor), NOTNULL(STRING *s)) { opcode_t padded_size = s&#45;&#62;bufused; char *charcursor; size_t i;</p>

<p>/* PIO_eprintf(NULL, &#34;PF_store_string(): size is %ld...\n&#34;, s&#45;&#62;bufused); */</p>

<pre lang='und' xml:lang='und'>    if (padded_size % sizeof (opcode_t)) {
        padded_size += sizeof (opcode_t) &#45; (padded_size % sizeof (opcode_t));
    }

    *cursor++ = PObj_get_FLAGS(s); /* only constant_FLAG and private7 */
    /*
     * TODO as soon as we have dynamically loadable charsets
     *      we have to store the charset name, not the number
     *
     * TODO encoding
     *
     * see also PF_fetch_string
     */
    *cursor++ = Parrot_charset_number_of_str(NULL, s);
    *cursor++ = s&#45;&#62;bufused;

    /* Switch to char * since rest of string is addressed by
     * characters to ensure padding.  */
    charcursor = (char *)cursor;

    if (s&#45;&#62;strstart) {
        mem_sys_memcopy(charcursor, s&#45;&#62;strstart, s&#45;&#62;bufused);
        charcursor += s&#45;&#62;bufused;

        if (s&#45;&#62;bufused % sizeof (opcode_t)) {
            for (i = 0; i &#60; (sizeof (opcode_t) &#45;
                        (s&#45;&#62;bufused % sizeof (opcode_t))); i++) {
                *charcursor++ = 0;
            }
        }
    }
    PARROT_ASSERT(((long)charcursor &#38; 3) == 0);
    cursor = (opcode_t *)charcursor;

    return cursor;
}</pre>

<p>/*</p>

<p>FUNCDOC: PF_size_string</p>

<p>Report store size of <code lang='und' xml:lang='und'>STRING</code> in <code lang='und' xml:lang='und'>opcode_t</code> units.</p>

<p>*/</p>

<p>PARROT_PURE_FUNCTION size_t PF_size_string(NOTNULL(const STRING *s)) { opcode_t padded_size = s&#45;&#62;bufused;</p>

<pre lang='und' xml:lang='und'>    if (padded_size % sizeof (opcode_t)) {
        padded_size += sizeof (opcode_t) &#45; (padded_size % sizeof (opcode_t));
    }

    /* Include space for flags, representation, and size fields.  */
    return 3 + (size_t)padded_size / sizeof (opcode_t);
}</pre>

<p>/*</p>

<p>FUNCDOC: PF_fetch_cstring</p>

<p>Fetch a cstring from bytecode and return an allocated copy</p>

<p>*/</p>

<p>PARROT_MALLOC PARROT_CANNOT_RETURN_NULL char * PF_fetch_cstring(NOTNULL(PackFile *pf), NOTNULL(opcode_t **cursor)) { const size_t str_len = strlen ((char *)(*cursor)) + 1; char * const p = (char *)mem_sys_allocate(str_len);</p>

<pre lang='und' xml:lang='und'>    const int wordsize = pf&#45;&#62;header&#45;&#62;wordsize;

    strcpy(p, (char*) (*cursor));
    *((unsigned char **) (cursor)) += ROUND_UP_B(str_len, wordsize);

    return p;
}</pre>

<p>/*</p>

<p>FUNCDOC: PF_store_cstring</p>

<p>Write a 0&#45;terminated string to the stream.</p>

<p>*/</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL opcode_t* PF_store_cstring(NOTNULL(opcode_t *cursor), NOTNULL(const char *s)) { strcpy((char *) cursor, s); return cursor + PF_size_cstring(s); }</p>

<p>/*</p>

<p>FUNCDOC: PF_size_cstring</p>

<p>Return store size of a C&#45;string in <code lang='und' xml:lang='und'>opcode_t</code> units.</p>

<p>*/</p>

<p>PARROT_PURE_FUNCTION size_t PF_size_cstring(NOTNULL(const char *s)) { size_t str_len;</p>

<pre lang='und' xml:lang='und'>    PARROT_ASSERT(s);
    str_len = strlen(s);
    return ROUND_UP(str_len + 1, sizeof (opcode_t));
}</pre>

<p>/*</p>

<p>FUNCDOC: PackFile_assign_transforms</p>

<p>Assign transform functions to vtable.</p>

<p>*/</p>

<p>void PackFile_assign_transforms(NOTNULL(PackFile *pf)) { const int need_endianize = pf&#45;&#62;header&#45;&#62;byteorder != PARROT_BIGENDIAN; const int need_wordsize = pf&#45;&#62;header&#45;&#62;wordsize != sizeof (opcode_t);</p>

<pre lang='und' xml:lang='und'>    pf&#45;&#62;need_endianize = need_endianize;
    pf&#45;&#62;need_wordsize  = need_wordsize;
#if PARROT_BIGENDIAN
    /*
     * this Parrot is on a BIG ENDIAN machine
     */
    if (need_endianize) {
        if (pf&#45;&#62;header&#45;&#62;wordsize == 4)
            pf&#45;&#62;fetch_op = fetch_op_le_4;
        else
            pf&#45;&#62;fetch_op = fetch_op_le_8;
        if (pf&#45;&#62;header&#45;&#62;floattype == 0)
            pf&#45;&#62;fetch_nv = fetch_buf_le_8;
        else if (pf&#45;&#62;header&#45;&#62;floattype == 1)
            pf&#45;&#62;fetch_nv = cvt_num12_num8_le;
    }
    else {
        if (pf&#45;&#62;header&#45;&#62;wordsize == 4)
            pf&#45;&#62;fetch_op = fetch_op_be_4;
        else
            pf&#45;&#62;fetch_op = fetch_op_be_8;
    }
#else
    /*
     * this Parrot is on a LITTLE ENDIAN machine
     */
    if (need_endianize) {
        if (pf&#45;&#62;header&#45;&#62;wordsize == 4)
            pf&#45;&#62;fetch_op = fetch_op_be_4;
        else
            pf&#45;&#62;fetch_op = fetch_op_be_8;
        if (pf&#45;&#62;header&#45;&#62;floattype == 0)
            pf&#45;&#62;fetch_nv = fetch_buf_be_8;
        else if (pf&#45;&#62;header&#45;&#62;floattype == 1)
            pf&#45;&#62;fetch_nv = cvt_num12_num8_be;
    }
    else {
        if (pf&#45;&#62;header&#45;&#62;wordsize == 4)
            pf&#45;&#62;fetch_op = fetch_op_le_4;
        else
            pf&#45;&#62;fetch_op = fetch_op_le_8;
        if (NUMVAL_SIZE == 8 &#38;&#38; pf&#45;&#62;header&#45;&#62;floattype == 1)
            pf&#45;&#62;fetch_nv = cvt_num12_num8;
        else if (NUMVAL_SIZE != 8 &#38;&#38; pf&#45;&#62;header&#45;&#62;floattype == 0)
            pf&#45;&#62;fetch_nv = fetch_buf_le_8;
    }
#endif
    pf&#45;&#62;fetch_iv = pf&#45;&#62;fetch_op;
}</pre>

<p>/*</p>

<h1><a name="HISTORY"
>HISTORY <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Initial review by leo 2003.11.21</p>

<p>Most routines moved from <em lang='und' xml:lang='und'><a href="../packfile.c.html">src/packfile.c</a></em>.</p>

<p>Renamed PackFile_* to PF_*</p>

<h1><a name="TODO"
>TODO <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p><code lang='und' xml:lang='und'>&#60;PF_store_&#60;type</code>()&#62;&#62; &#45; write an opcode_t stream to cursor in natural byte&#45;ordering.</p>

<p><code lang='und' xml:lang='und'>&#60;PF_fetch_&#60;type</code>()&#62;&#62; &#45; read items and possibly convert the foreign format.</p>

<p><code lang='und' xml:lang='und'>&#60;PF_size_&#60;type</code>()&#62;&#62; &#45; return the needed size in <code lang='und' xml:lang='und'>opcode_t</code> units.</p>

<p>*/</p>

<p>/* * Local variables: * c&#45;file&#45;style: &#34;parrot&#34; * End: * vim: expandtab shiftwidth=4: */</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
