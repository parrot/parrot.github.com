<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Parrot Interpreter</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Parrot Interpreter</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../html/index.html">Contents</a> | <a href="../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>src/interpreter.c &#45; Parrot Interpreter</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>The interpreter API handles running the operations.</p>

<p>The predereferenced code chunk is pre&#45;initialized with the opcode function pointers,
addresses,
or opnumbers of the <code lang='und' xml:lang='und'>prederef__</code> opcode.
This opcode then calls the <code lang='und' xml:lang='und'>do_prederef()</code> function,
which then fills in the real function,
address or op number.</p>

<p>Because the <code lang='und' xml:lang='und'>prederef__</code> opcode returns the same <code lang='und' xml:lang='und'>pc_prederef</code> it was passed,
the runops loop will re&#45;execute the same location,
which will then have the pointer to the real <code lang='und' xml:lang='und'>prederef</code> opfunc and <code lang='und' xml:lang='und'>prederef</code> args.</p>

<p>Pointer arithmetic is used to determine the index into the bytecode corresponding to the currect opcode.
The bytecode and prederef arrays have the same number of elements because there is a one&#45;to&#45;one mapping.</p>

<h2><a name="Functions"
>Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>*/</p>

<p>#include &#34;parrot/parrot.h&#34; #include &#34;interp_guts.h&#34; #include &#34;parrot/oplib/core_ops.h&#34; #include &#34;parrot/oplib/core_ops_switch.h&#34; #include &#34;parrot/oplib/ops.h&#34; #include &#34;runops_cores.h&#34; #if JIT_CAPABLE # include &#34;parrot/exec.h&#34; # include &#34;jit.h&#34; #endif #ifdef HAVE_COMPUTED_GOTO # include &#34;parrot/oplib/core_ops_cg.h&#34; # include &#34;parrot/oplib/core_ops_cgp.h&#34; #endif #include &#34;parrot/dynext.h&#34;</p>

<p>/* HEADERIZER HFILE: none */ /* XXX Needs to get done at the same time as the other interpreter files */</p>

<p>/* HEADERIZER BEGIN: static */</p>

<p>static void dynop_register_switch( size_t n_old,
size_t n_new ); static void dynop_register_xx( PARROT_INTERP,
size_t n_old,
size_t n_new,
oplib_init_f init_func ) __attribute__nonnull__(1);</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL static oplib_init_f get_op_lib_init( PARROT_INTERP,
int core_op,
int which,
NULLOK(PMC *lib) ) __attribute__nonnull__(1);</p>

<p>static void init_prederef( PARROT_INTERP,
int which ) __attribute__nonnull__(1);</p>

<p>static void load_prederef( PARROT_INTERP,
int which ) __attribute__nonnull__(1);</p>

<p>static void notify_func_table( PARROT_INTERP,
NOTNULL(op_func_t* table),
int on ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>static void prederef_args( NOTNULL(void **pc_prederef),
PARROT_INTERP,
NOTNULL(opcode_t *pc),
NOTNULL(const op_info_t *opinfo) ) __attribute__nonnull__(1) __attribute__nonnull__(2) __attribute__nonnull__(3) __attribute__nonnull__(4);</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL static opcode_t * runops_cgp( PARROT_INTERP,
NOTNULL(opcode_t *pc) ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CAN_RETURN_NULL static opcode_t * runops_exec( PARROT_INTERP,
NOTNULL(opcode_t *pc) ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CAN_RETURN_NULL static opcode_t * runops_jit( PARROT_INTERP,
NOTNULL(opcode_t *pc) ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL static opcode_t * runops_switch( PARROT_INTERP,
NOTNULL(opcode_t *pc) ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>static void stop_prederef( PARROT_INTERP ) __attribute__nonnull__(1);</p>

<p>static void turn_ev_check( PARROT_INTERP,
int on ) __attribute__nonnull__(1);</p>

<p>/* HEADERIZER END: static */</p>

<p>#if EXEC_CAPABLE extern int Parrot_exec_run; #endif</p>

<p>/*</p>

<p>FUNCDOC: prederef_args</p>

<p>Called from <code lang='und' xml:lang='und'>do_prederef()</code> to deal with any arguments.</p>

<p><code lang='und' xml:lang='und'>pc_prederef</code> is the current opcode.</p>

<p>*/</p>

<p>static void prederef_args(NOTNULL(void **pc_prederef),
PARROT_INTERP,
NOTNULL(opcode_t *pc),
NOTNULL(const op_info_t *opinfo)) { const PackFile_ConstTable * const const_table = interp&#45;&#62;code&#45;&#62;const_table;</p>

<pre lang='und' xml:lang='und'>    const int regs_n = CONTEXT(interp&#45;&#62;ctx)&#45;&#62;n_regs_used[REGNO_NUM];
    const int regs_i = CONTEXT(interp&#45;&#62;ctx)&#45;&#62;n_regs_used[REGNO_INT];
    const int regs_p = CONTEXT(interp&#45;&#62;ctx)&#45;&#62;n_regs_used[REGNO_PMC];
    const int regs_s = CONTEXT(interp&#45;&#62;ctx)&#45;&#62;n_regs_used[REGNO_STR];
    /* prederef var part too */
    const int m = opinfo&#45;&#62;op_count;
    int n = opinfo&#45;&#62;op_count;
    int i;

    ADD_OP_VAR_PART(interp, interp&#45;&#62;code, pc, n);
    for (i = 1; i &#60; n; i++) {
        const opcode_t arg = pc[i];
        int type;
        if (i &#62;= m) {
            PMC * const sig = (PMC*) pc_prederef[1];
            type = SIG_ITEM(sig, i &#45; m);
            type &#38;= (PARROT_ARG_TYPE_MASK | PARROT_ARG_CONSTANT);
        }
        else
            type = opinfo&#45;&#62;types[i &#45; 1];

        switch (type) {

        case PARROT_ARG_KI:
        case PARROT_ARG_I:
            if (arg &#60; 0 || arg &#62;= regs_i)
                real_exception(interp, NULL, INTERP_ERROR, &#34;Illegal register number&#34;);
            pc_prederef[i] = (void *)REG_OFFS_INT(arg);
            break;

        case PARROT_ARG_N:
            if (arg &#60; 0 || arg &#62;= regs_n)
                real_exception(interp, NULL, INTERP_ERROR, &#34;Illegal register number&#34;);
            pc_prederef[i] = (void *)REG_OFFS_NUM(arg);
            break;

        case PARROT_ARG_K:
        case PARROT_ARG_P:
            if (arg &#60; 0 || arg &#62;= regs_p)
                real_exception(interp, NULL, INTERP_ERROR, &#34;Illegal register number&#34;);
            pc_prederef[i] = (void *)REG_OFFS_PMC(arg);
            break;

        case PARROT_ARG_S:
            if (arg &#60; 0 || arg &#62;= regs_s)
                real_exception(interp, NULL, INTERP_ERROR, &#34;Illegal register number&#34;);
            pc_prederef[i] = (void *)REG_OFFS_STR(arg);
            break;

        case PARROT_ARG_KIC:
        case PARROT_ARG_IC:
            pc_prederef[i] = (void *)pc[i];
            break;

        case PARROT_ARG_NC:
            if (arg &#60; 0 || arg &#62;= const_table&#45;&#62;const_count)
                real_exception(interp, NULL, INTERP_ERROR, &#34;Illegal constant number&#34;);
            pc_prederef[i] = (void *) &#38;const_table&#45;&#62;constants[arg]&#45;&#62;u.number;
            break;

        case PARROT_ARG_SC:
            if (arg &#60; 0 || arg &#62;= const_table&#45;&#62;const_count)
                real_exception(interp, NULL, INTERP_ERROR, &#34;Illegal constant number&#34;);
            pc_prederef[i] = (void *)const_table&#45;&#62;constants[arg]&#45;&#62;u.string;
            break;

        case PARROT_ARG_PC:
        case PARROT_ARG_KC:
            if (arg &#60; 0 || arg &#62;= const_table&#45;&#62;const_count)
                real_exception(interp, NULL, INTERP_ERROR, &#34;Illegal constant number&#34;);
            pc_prederef[i] = (void *)const_table&#45;&#62;constants[arg]&#45;&#62;u.key;
            break;
        default:
            real_exception(interp, NULL, ARG_OP_NOT_HANDLED,
                               &#34;Unhandled argtype 0x%x\n&#34;, type);
            break;
        }
    }
}</pre>

<p>/*</p>

<p>FUNCDOC: do_prederef</p>

<p>This is called from within the run cores to predereference the current opcode.</p>

<p><code lang='und' xml:lang='und'>pc_prederef</code> is the current opcode, and <code lang='und' xml:lang='und'>type</code> is the run core type.</p>

<p>*/</p>

<p>void do_prederef(void **pc_prederef, PARROT_INTERP, int type) { const size_t offset = pc_prederef &#45; interp&#45;&#62;code&#45;&#62;prederef.code; opcode_t * const pc = ((opcode_t *)interp&#45;&#62;code&#45;&#62;base.data) + offset; const op_info_t *opinfo; size_t n;</p>

<pre lang='und' xml:lang='und'>    if (*pc &#60; 0 || *pc &#62;= (opcode_t)interp&#45;&#62;op_count)
        real_exception(interp, NULL, INTERP_ERROR, &#34;Illegal opcode&#34;);
    opinfo = &#38;interp&#45;&#62;op_info_table[*pc];
    /* first arguments &#45; PIC needs it */
    prederef_args(pc_prederef, interp, pc, opinfo);
    switch (type) {
        case PARROT_SWITCH_CORE:
        case PARROT_SWITCH_JIT_CORE:
        case PARROT_CGP_CORE:
        case PARROT_CGP_JIT_CORE:
            parrot_PIC_prederef(interp, *pc, pc_prederef, type);
            break;
        default:
            real_exception(interp, NULL, 1, &#34;Tried to prederef wrong core&#34;);
            break;
    }
    /*
     * now remember backward branches, invoke and similar opcodes
     */
    n = opinfo&#45;&#62;op_count;
    if (((opinfo&#45;&#62;jump &#38; PARROT_JUMP_RELATIVE) &#38;&#38;
            opinfo&#45;&#62;types[n &#45; 2] == PARROT_ARG_IC &#38;&#38;
            pc[n &#45; 1] &#60; 0) ||   /* relative backward branch */
            (opinfo&#45;&#62;jump &#38; PARROT_JUMP_ADDRESS)) {
        Prederef * const pi = &#38;interp&#45;&#62;code&#45;&#62;prederef;
        /*
         * first time prederef.branches == NULL:
         * estimate size to 1/16th of opcodes
         */
        if (!pi&#45;&#62;branches) {
            size_t nb = interp&#45;&#62;code&#45;&#62;base.size / 16;
            if (nb &#60; 8)
                nb = (size_t)8;
            pi&#45;&#62;branches = (Prederef_branch *)mem_sys_allocate(
                               sizeof (Prederef_branch) * nb);
            pi&#45;&#62;n_allocated = nb;
            pi&#45;&#62;n_branches = 0;
        }
        else if (pi&#45;&#62;n_branches &#62;= pi&#45;&#62;n_allocated) {
            pi&#45;&#62;n_allocated = (size_t) (pi&#45;&#62;n_allocated * 1.5);
            pi&#45;&#62;branches = (Prederef_branch *)mem_sys_realloc(pi&#45;&#62;branches,
                    sizeof (Prederef_branch) * pi&#45;&#62;n_allocated);
        }
        pi&#45;&#62;branches[pi&#45;&#62;n_branches].offs = offset;
        pi&#45;&#62;branches[pi&#45;&#62;n_branches].op = *pc_prederef;
        ++pi&#45;&#62;n_branches;
    }
}</pre>

<p>/*</p>

<p>FUNCDOC: turn_ev_check</p>

<p>Turn on or off event checking for prederefed cores.</p>

<p>Fills in the <code lang='und' xml:lang='und'>event_checker</code> opcode, or restores original ops in all branch locations of the opcode stream.</p>

<p>Note that when <code lang='und' xml:lang='und'>on</code> is true, this is being called from the event handler thread.</p>

<p>*/</p>

<p>static void turn_ev_check(PARROT_INTERP, int on) { const Prederef * const pi = &#38;interp&#45;&#62;code&#45;&#62;prederef; size_t i;</p>

<pre lang='und' xml:lang='und'>    if (!pi&#45;&#62;branches)
        return;
    for (i = 0; i &#60; pi&#45;&#62;n_branches; ++i) {
        const size_t offs = pi&#45;&#62;branches[i].offs;
        if (on) {
            interp&#45;&#62;code&#45;&#62;prederef.code[offs] =
                ((void **)interp&#45;&#62;op_lib&#45;&#62;op_func_table)
                            [CORE_OPS_check_events__];
        }
        else
            interp&#45;&#62;code&#45;&#62;prederef.code[offs] = pi&#45;&#62;branches[i].op;
    }
}</pre>

<p>/*</p>

<p>FUNCDOC: get_op_lib_init</p>

<p>Returns an opcode&#39;s library <code lang='und' xml:lang='und'>op_lib</code> init function.</p>

<p><code lang='und' xml:lang='und'>core_op</code> indicates whether the opcode represents a core Parrot operation.</p>

<p><code lang='und' xml:lang='und'>which</code> is the run core type.</p>

<p>For dynamic oplibs <code lang='und' xml:lang='und'>core_op</code> will be 0 and <code lang='und' xml:lang='und'>lib</code> will be a <code lang='und' xml:lang='und'>ParrotLibrary</code> PMC.</p>

<p>*/</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL static oplib_init_f get_op_lib_init(PARROT_INTERP, int core_op, int which, NULLOK(PMC *lib)) { if (core_op) { oplib_init_f init_func; switch (which) { case PARROT_SWITCH_CORE: case PARROT_SWITCH_JIT_CORE: init_func = PARROT_CORE_SWITCH_OPLIB_INIT; break; #ifdef HAVE_COMPUTED_GOTO case PARROT_CGP_CORE: case PARROT_CGP_JIT_CORE: init_func = PARROT_CORE_CGP_OPLIB_INIT; break; case PARROT_CGOTO_CORE: init_func = PARROT_CORE_CG_OPLIB_INIT; break; #endif case PARROT_EXEC_CORE: /* normal func core */ case PARROT_JIT_CORE: /* normal func core */ case PARROT_SLOW_CORE: /* normal func core */ case PARROT_FAST_CORE: /* normal func core */ init_func = PARROT_CORE_OPLIB_INIT; break; default: real_exception(interp, NULL, 1, &#34;Couldn&#39;t find init_func for core %d&#34;, which); } return init_func; } return (oplib_init_f) D2FPTR(PMC_struct_val(lib)); }</p>

<p>/*</p>

<p>FUNCDOC: load_prederef</p>

<p><code lang='und' xml:lang='und'>interp&#45;&#62;op_lib</code> = prederefed oplib.</p>

<p>*/</p>

<p>static void load_prederef(PARROT_INTERP, int which) { const oplib_init_f init_func = get_op_lib_init(interp, 1, which, NULL); int (*get_op)(const char * name, int full);</p>

<pre lang='und' xml:lang='und'>    get_op = interp&#45;&#62;op_lib&#45;&#62;op_code;
    interp&#45;&#62;op_lib = init_func(1);
    /* preserve the get_op function */
    interp&#45;&#62;op_lib&#45;&#62;op_code = get_op;
    if (interp&#45;&#62;op_lib&#45;&#62;op_count != interp&#45;&#62;op_count)
        real_exception(interp, NULL, PREDEREF_LOAD_ERROR,
                &#34;Illegal op count (%d) in prederef oplib\n&#34;,
                (int)interp&#45;&#62;op_lib&#45;&#62;op_count);
}</pre>

<p>/*</p>

<p>FUNCDOC: init_prederef</p>

<p>Initialize: load prederef <code lang='und' xml:lang='und'>func_table</code>, file prederef.code.</p>

<p>*/</p>

<p>static void init_prederef(PARROT_INTERP, int which) { load_prederef(interp, which); if (!interp&#45;&#62;code&#45;&#62;prederef.code) { const size_t N = interp&#45;&#62;code&#45;&#62;base.size; opcode_t *pc = interp&#45;&#62;code&#45;&#62;base.data; size_t i, n_pics; void *pred_func; /* Parrot_memalign_if_possible in OpenBSD allocates 256 if you ask for 312 &#45;&#45; Need to verify this, it may have been a bug elsewhere. If it works now, we can remove the mem_sys_allocate_zeroed line below. */ #if 0 void **temp = (void **)mem_sys_allocate_zeroed(N * sizeof (void *)); #else void **temp = (void **)Parrot_memalign_if_possible(256, N * sizeof (void *)); #endif /* * calc and remember pred_offset */ CONTEXT(interp&#45;&#62;ctx)&#45;&#62;pred_offset = pc &#45; (opcode_t*)temp;</p>

<pre lang='und' xml:lang='und'>        /* fill with the prederef__ opcode function */
        if (which == PARROT_SWITCH_CORE || which == PARROT_SWITCH_JIT_CORE)
            pred_func = (void*) CORE_OPS_prederef__;
        else
            pred_func = ((void **)
                    interp&#45;&#62;op_lib&#45;&#62;op_func_table)[CORE_OPS_prederef__];
        for (i = n_pics = 0; i &#60; N;) {
            op_info_t * const opinfo = &#38;interp&#45;&#62;op_info_table[*pc];
            size_t n;

            temp[i] = pred_func;
            n = opinfo&#45;&#62;op_count;
            ADD_OP_VAR_PART(interp, interp&#45;&#62;code, pc, n);
            /* count ops that need a PIC */
            if (parrot_PIC_op_is_cached(*pc))
                n_pics++;
            pc += n;
            i += n;
        }

        interp&#45;&#62;code&#45;&#62;prederef.code = temp;
        /* allocate pic store */
        if (n_pics) {
            /* pic_index is starting from 1 */
            parrot_PIC_alloc_store(interp&#45;&#62;code, n_pics + 1);
        }
    }
}</pre>

<p>/*</p>

<p>FUNCDOC: stop_prederef</p>

<p>Restore the interpreter&#39;s op function tables to their initial state. Also recreate the event function pointers. This is only necessary for run&#45;core changes, but we don&#39;t know the old run core.</p>

<p>*/</p>

<p>static void stop_prederef(PARROT_INTERP) { interp&#45;&#62;op_func_table = PARROT_CORE_OPLIB_INIT(1)&#45;&#62;op_func_table; if (interp&#45;&#62;evc_func_table) { mem_sys_free(interp&#45;&#62;evc_func_table); interp&#45;&#62;evc_func_table = NULL; } Parrot_setup_event_func_ptrs(interp); }</p>

<p>#if EXEC_CAPABLE</p>

<p>/*</p>

<p>FUNCDOC: exec_init_prederef</p>

<p><code lang='und' xml:lang='und'>interp&#45;&#62;op_lib</code> = prederefed oplib</p>

<p>The &#34;normal&#34; <code lang='und' xml:lang='und'>op_lib</code> has a copy in the interpreter structure &#45; but get the <code lang='und' xml:lang='und'>op_code</code> lookup function from standard core prederef has no <code lang='und' xml:lang='und'>op_info_table</code></p>

<p>*/</p>

<p>void exec_init_prederef(PARROT_INTERP, void *prederef_arena) { load_prederef(interp, PARROT_CGP_CORE);</p>

<pre lang='und' xml:lang='und'>    if (!interp&#45;&#62;code&#45;&#62;prederef.code) {
        void **temp = (void **)prederef_arena;

        interp&#45;&#62;code&#45;&#62;prederef.code = temp;
        /* TODO */
    }
}
#endif</pre>

<p>/*</p>

<p>FUNCDOC: init_jit</p>

<p>Initializes JIT function for the specified opcode and returns it.</p>

<p>*/</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL void * init_jit(PARROT_INTERP, NULLOK(opcode_t *pc)) { #if JIT_CAPABLE opcode_t *code_start; UINTVAL code_size; /* in opcodes */ opcode_t *code_end; Parrot_jit_info_t *jit_info;</p>

<pre lang='und' xml:lang='und'>    if (interp&#45;&#62;code&#45;&#62;jit_info)
        return ((Parrot_jit_info_t *)interp&#45;&#62;code&#45;&#62;jit_info)&#45;&#62;arena.start;

    code_start = interp&#45;&#62;code&#45;&#62;base.data;
    code_size  = interp&#45;&#62;code&#45;&#62;base.size;
    code_end   = code_start + code_size;</pre>

<p># if defined HAVE_COMPUTED_GOTO &#38;&#38; PARROT_I386_JIT_CGP # ifdef __GNUC__ # ifdef PARROT_I386 init_prederef(interp, PARROT_CGP_CORE); # endif # endif # endif</p>

<pre lang='und' xml:lang='und'>    interp&#45;&#62;code&#45;&#62;jit_info =
        jit_info = parrot_build_asm(interp, code_start, code_end,
            NULL, JIT_CODE_FILE);

    return jit_info&#45;&#62;arena.start;
#else
    UNUSED(interp);
    UNUSED(pc);
    return NULL;
#endif
}</pre>

<p>/*</p>

<p>FUNCDOC: prepare_for_run</p>

<p>Prepares to run the interpreter&#39;s run core.</p>

<p>*/</p>

<p>void prepare_for_run(PARROT_INTERP) { void *ignored; switch (interp&#45;&#62;run_core) { case PARROT_JIT_CORE: ignored = init_jit(interp, interp&#45;&#62;code&#45;&#62;base.data); break; case PARROT_SWITCH_CORE: case PARROT_SWITCH_JIT_CORE: case PARROT_CGP_CORE: case PARROT_CGP_JIT_CORE: init_prederef(interp, interp&#45;&#62;run_core); break; default: break; } }</p>

<p>#ifdef PARROT_EXEC_OS_AIX extern void* aix_get_toc(); #endif</p>

<p>/*</p>

<p>FUNCDOC: runops_jit</p>

<p>Runs the JIT code for the specified opcode.</p>

<p>*/</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CAN_RETURN_NULL static opcode_t * runops_jit(PARROT_INTERP, NOTNULL(opcode_t *pc)) { #if JIT_CAPABLE # ifdef PARROT_EXEC_OS_AIX /* AIX calling convention requires that function&#45;call&#45;by&#45;ptr be made through the following struct: */ struct ptrgl_t { jit_f functPtr; void *toc; void *env; } ptrgl_t; ptrgl_t.functPtr = (jit_f) D2FPTR(init_jit(interp, pc)); ptrgl_t.env = NULL;</p>

<pre lang='und' xml:lang='und'>    /* r2 (TOC) needs to point back here so we can return from non&#45;JIT
       functions */
    ptrgl_t.toc = aix_get_toc();

    ((jit_f) D2FPTR(&#38;ptrgl_t)) (interp, pc);
#  else
    jit_f jit_code = (jit_f)(init_jit(interp, pc));
    (jit_code) (interp, pc);
#  endif
#else
    UNUSED(interp);
    UNUSED(pc);
#endif
    return NULL;
}</pre>

<p>/*</p>

<p>FUNCDOC: runops_exec</p>

<p>Runs the native executable version of the specified opcode.</p>

<p>*/</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CAN_RETURN_NULL static opcode_t * runops_exec(PARROT_INTERP, NOTNULL(opcode_t *pc)) { #if EXEC_CAPABLE opcode_t *code_start; UINTVAL code_size; /* in opcodes */ opcode_t *code_end;</p>

<pre lang='und' xml:lang='und'>    code_start = interp&#45;&#62;code&#45;&#62;base.data;
    code_size = interp&#45;&#62;code&#45;&#62;base.size;
    code_end = code_start + code_size;
#  if defined HAVE_COMPUTED_GOTO &#38;&#38; defined USE_CGP
#    ifdef __GNUC__
#      ifdef PARROT_I386
    init_prederef(interp, PARROT_CGP_CORE);
#      endif
#    endif
#  endif
    if (Parrot_exec_run == 2) {
        void *ignored;
        Parrot_exec_run = 0;
        Interp_core_SET(interp, PARROT_JIT_CORE);
        ignored = runops_jit(interp, pc);
        Interp_core_SET(interp, PARROT_EXEC_CORE);
    }
    else if (Parrot_exec_run == 1) {
        Parrot_exec(interp, pc, code_start, code_end);
    }
    else
        run_native(interp, pc, code_start);</pre>

<p>#else UNUSED(interp); UNUSED(pc); #endif return NULL; }</p>

<p>/*</p>

<p>FUNCDOC: runops_cgp</p>

<p>Runs the C <code lang='und' xml:lang='und'>goto</code>, predereferenced core.</p>

<p>*/</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL static opcode_t * runops_cgp(PARROT_INTERP, NOTNULL(opcode_t *pc)) { #ifdef HAVE_COMPUTED_GOTO opcode_t * const code_start = (opcode_t *)interp&#45;&#62;code&#45;&#62;base.data; opcode_t *pc_prederef; init_prederef(interp, PARROT_CGP_CORE); pc_prederef = (opcode_t*)interp&#45;&#62;code&#45;&#62;prederef.code + (pc &#45; code_start); pc = cgp_core(pc_prederef, interp); return pc; #else PIO_eprintf(interp, &#34;Computed goto unavailable in this configuration.\n&#34;); Parrot_exit(interp, 1); #endif }</p>

<p>/*</p>

<p>FUNCDOC: runops_switch</p>

<p>Runs the <code lang='und' xml:lang='und'>switch</code> core.</p>

<p>*/</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL static opcode_t * runops_switch(PARROT_INTERP, NOTNULL(opcode_t *pc)) { opcode_t * const code_start = (opcode_t *)interp&#45;&#62;code&#45;&#62;base.data; opcode_t *pc_prederef; init_prederef(interp, PARROT_SWITCH_CORE); pc_prederef = (opcode_t*)interp&#45;&#62;code&#45;&#62;prederef.code + (pc &#45; code_start); pc = switch_core(pc_prederef, interp); return pc; }</p>

<p>/*</p>

<p>FUNCDOC: runops_int</p>

<p>Run Parrot operations of loaded code segment until an end opcode is reached. Run core is selected depending on the <code lang='und' xml:lang='und'>Interp_flags</code>. When a <code lang='und' xml:lang='und'>restart</code> opcode is encountered, a different core may be selected and evaluation of opcode continues.</p>

<p>*/</p>

<p>void runops_int(PARROT_INTERP, size_t offset) { int lo_var_ptr; opcode_t *(*core) (PARROT_INTERP, opcode_t *) = NULL;</p>

<pre lang='und' xml:lang='und'>    if (!interp&#45;&#62;lo_var_ptr) {
        /*
         * if we are entering the run loop the first time
         */
        interp&#45;&#62;lo_var_ptr = (void *)&#38;lo_var_ptr;
    }

    /*
     * setup event function ptrs
     */
    if (!interp&#45;&#62;save_func_table) {
        Parrot_setup_event_func_ptrs(interp);
    }

    interp&#45;&#62;resume_offset = offset;
    interp&#45;&#62;resume_flag |= RESUME_RESTART;

    while (interp&#45;&#62;resume_flag &#38; RESUME_RESTART) {
        opcode_t * const pc = (opcode_t *)
            interp&#45;&#62;code&#45;&#62;base.data + interp&#45;&#62;resume_offset;

        interp&#45;&#62;resume_offset = 0;
        interp&#45;&#62;resume_flag &#38;= ~(RESUME_RESTART | RESUME_INITIAL);
        switch (interp&#45;&#62;run_core) {
            case PARROT_SLOW_CORE:

                core = runops_slow_core;

                if (Interp_flags_TEST(interp, PARROT_PROFILE_FLAG)) {
                    core = runops_profile_core;
                    if (interp&#45;&#62;profile == NULL) {
                        interp&#45;&#62;profile = mem_allocate_zeroed_typed(RunProfile);
                        interp&#45;&#62;profile&#45;&#62;data = (ProfData *)
                            mem_sys_allocate_zeroed((interp&#45;&#62;op_count +
                                        PARROT_PROF_EXTRA) * sizeof (ProfData));
                    }
                }
                break;
            case PARROT_FAST_CORE:
                core = runops_fast_core;
                break;
            case PARROT_CGOTO_CORE:
#ifdef HAVE_COMPUTED_GOTO
                core = runops_cgoto_core;
#else
                real_exception(interp, NULL, 1, &#34;Error: PARROT_CGOTO_CORE not available&#34;);
#endif
                break;
            case PARROT_CGP_CORE:
            case PARROT_CGP_JIT_CORE:
#ifdef HAVE_COMPUTED_GOTO
                core = runops_cgp;
#else
                real_exception(interp, NULL, 1, &#34;Error: PARROT_CGP_CORE not available&#34;);
#endif
                break;
            case PARROT_SWITCH_CORE:
            case PARROT_SWITCH_JIT_CORE:
                core = runops_switch;
                break;
            case PARROT_JIT_CORE:
#if !JIT_CAPABLE
                real_exception(interp, NULL, JIT_UNAVAILABLE,
                        &#34;Error: PARROT_JIT_FLAG is set, &#34;
                        &#34;but interpreter is not JIT_CAPABLE!\n&#34;);
#endif
                core = runops_jit;
                break;
            case PARROT_EXEC_CORE:
#if !EXEC_CAPABLE
                real_exception(interp, NULL, EXEC_UNAVAILABLE,
                        &#34;Error: PARROT_EXEC_FLAG is set, &#34;
                        &#34;but interpreter is not EXEC_CAPABLE!\n&#34;);
#endif
                core = runops_exec;
                break;
            default:
                real_exception(interp, NULL, UNIMPLEMENTED,
                        &#34;ambigious runcore switch used&#34;);
                break;
        }


        /* run it finally */
        core(interp, pc);
        /* if we have fallen out with resume and we were running CGOTO, set
         * the stacktop again to a sane value, so that restarting the runloop
         * is ok.
         */
        if (interp&#45;&#62;resume_flag &#38; RESUME_RESTART) {
            if ((int)interp&#45;&#62;resume_offset &#60; 0)
                real_exception(interp, NULL, 1, &#34;branch_cs: illegal resume offset&#34;);
            stop_prederef(interp);
        }
    }
}</pre>

<p>/*</p>

<p>FUNCDOC: Parrot_setup_event_func_ptrs</p>

<p>Setup a <code lang='und' xml:lang='und'>func_table</code> containing pointers (or addresses) of the <code lang='und' xml:lang='und'>check_event__</code> opcode.</p>

<p>TODO: Free it at destroy. Handle run&#45;core changes.</p>

<p>*/</p>

<p>void Parrot_setup_event_func_ptrs(PARROT_INTERP) { const size_t n = interp&#45;&#62;op_count; const oplib_init_f init_func = get_op_lib_init(interp, 1, interp&#45;&#62;run_core, NULL); op_lib_t * const lib = init_func(1); /* * remember op_func_table */ interp&#45;&#62;save_func_table = lib&#45;&#62;op_func_table; if (!lib&#45;&#62;op_func_table) return; /* function or CG core &#45; prepare func_table */ if (!interp&#45;&#62;evc_func_table) { size_t i;</p>

<pre lang='und' xml:lang='und'>        interp&#45;&#62;evc_func_table = (op_func_t *)mem_sys_allocate(
                                     sizeof (op_func_t) * n);
        for (i = 0; i &#60; n; ++i)
            interp&#45;&#62;evc_func_table[i] = (op_func_t)
                D2FPTR(((void**)lib&#45;&#62;op_func_table)[CORE_OPS_check_events__]);
    }
}</pre>

<p>/*</p>

<h2><a name="Dynamic_Loading_Functions"
>Dynamic Loading Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>FUNCDOC: dynop_register</p>

<p>Register a dynamic oplib.</p>

<p>*/</p>

<p>void dynop_register(PARROT_INTERP, PMC* lib_pmc) { op_lib_t *lib, *core; oplib_init_f init_func; op_func_t *new_func_table, *new_evc_func_table; op_info_t *new_info_table; size_t i, n_old, n_new, n_tot;</p>

<pre lang='und' xml:lang='und'>    if (n_interpreters &#62; 1) {
        /* This is not supported because oplibs are always shared.
         * If we mem_sys_reallocate() the op_func_table while another
         * interpreter is running using that exact op_func_table,
         * this will cause problems
         * Also, the mapping from op name to op number is global even for
         * dynops (!). The mapping is done by get_op in core_ops.c (even for
         * dynops) and uses a global hash as a cache and relies on modifications
         * to the static&#45;scoped core_op_lib data structure to see dynops.
         */
        real_exception(interp, NULL, 1, &#34;loading a new dynoplib while more than &#34;
            &#34;one thread is running is not supported.&#34;);
    }

    if (!interp&#45;&#62;all_op_libs)
        interp&#45;&#62;all_op_libs = (op_lib_t **)mem_sys_allocate(
                sizeof (op_lib_t *) * (interp&#45;&#62;n_libs + 1));
    else
        interp&#45;&#62;all_op_libs = (op_lib_t **)mem_sys_realloc(interp&#45;&#62;all_op_libs,
                sizeof (op_lib_t *) * (interp&#45;&#62;n_libs + 1));

    init_func = get_op_lib_init(interp, 0, 0, lib_pmc);
    lib = init_func(1);

    interp&#45;&#62;all_op_libs[interp&#45;&#62;n_libs++] = lib;
    /*
     * if we are registering an op_lib variant, called from below
     * the base names of this lib and the previous one are the same
     */
    if (interp&#45;&#62;n_libs &#62;= 2 &#38;&#38;
            (strcmp(interp&#45;&#62;all_op_libs[interp&#45;&#62;n_libs&#45;2]&#45;&#62;name,
                lib&#45;&#62;name) == 0) ) {
        /* registering is handled below */
        return;
    }
    /*
     * when called from yyparse, we have to set up the evc_func_table
     */
    Parrot_setup_event_func_ptrs(interp);

    n_old = interp&#45;&#62;op_count;
    n_new = lib&#45;&#62;op_count;
    n_tot = n_old + n_new;
    core = PARROT_CORE_OPLIB_INIT(1);

    PARROT_ASSERT(interp&#45;&#62;op_count == core&#45;&#62;op_count);
    new_evc_func_table = (op_func_t *)mem__sys_realloc(interp&#45;&#62;evc_func_table,
            sizeof (op_func_t) * n_tot);
    if (core&#45;&#62;flags &#38; OP_FUNC_IS_ALLOCATED) {
        new_func_table = (op_func_t *)mem_sys_realloc(core&#45;&#62;op_func_table,
                sizeof (op_func_t) * n_tot);
        new_info_table = (op_info_t *)mem_sys_realloc(core&#45;&#62;op_info_table,
                sizeof (op_info_t) * n_tot);
    }
    else {
        /*
         * allocate new op_func and info tables
         */
        new_func_table = (op_func_t *)mem_sys_allocate(sizeof (op_func_t) * n_tot);
        new_info_table = (op_info_t *)mem_sys_allocate(sizeof (op_info_t) * n_tot);
        /* copy old */
        for (i = 0; i &#60; n_old; ++i) {
            new_func_table[i] = interp&#45;&#62;op_func_table[i];
            new_info_table[i] = interp&#45;&#62;op_info_table[i];
        }
    }
    /* add new */
    for (i = n_old; i &#60; n_tot; ++i) {
        new_func_table[i] = ((op_func_t*)lib&#45;&#62;op_func_table)[i &#45; n_old];
        new_info_table[i] = lib&#45;&#62;op_info_table[i &#45; n_old];
        /*
         * fill new ops of event checker func table
         * if we are running a different core, entries are
         * changed below
         */
        new_evc_func_table[i] =
            interp&#45;&#62;op_func_table[CORE_OPS_check_events__];
    }
    interp&#45;&#62;evc_func_table = new_evc_func_table;
    interp&#45;&#62;save_func_table = new_func_table;
    /*
     * deinit core, so that it gets rehashed
     */
    (void) PARROT_CORE_OPLIB_INIT(0);
    /* set table */
    core&#45;&#62;op_func_table = interp&#45;&#62;op_func_table = new_func_table;
    core&#45;&#62;op_info_table = interp&#45;&#62;op_info_table = new_info_table;
    core&#45;&#62;op_count = interp&#45;&#62;op_count = n_tot;
    core&#45;&#62;flags = OP_FUNC_IS_ALLOCATED | OP_INFO_IS_ALLOCATED;
    /* done for plain core */
#if defined HAVE_COMPUTED_GOTO
    dynop_register_xx(interp, n_old, n_new,
            PARROT_CORE_CGP_OPLIB_INIT);
    dynop_register_xx(interp, n_old, n_new,
            PARROT_CORE_CG_OPLIB_INIT);
#endif
    dynop_register_switch(n_old, n_new);
}</pre>

<p>/*</p>

<p>FUNCDOC: dynop_register_xx</p>

<p>Register <code lang='und' xml:lang='und'>op_lib</code> with other cores.</p>

<p>*/</p>

<p>static void dynop_register_xx(PARROT_INTERP, size_t n_old, size_t n_new, oplib_init_f init_func) { op_lib_t *cg_lib, *new_lib; op_func_t *ops_addr = NULL; size_t n_tot; #if 0 /* related to CG and CGP ops issue below */ STRING *op_variant; #endif oplib_init_f new_init_func; PMC *lib_variant;</p>

<pre lang='und' xml:lang='und'>    n_tot = n_old + n_new;
    cg_lib = init_func(1);

    if (cg_lib&#45;&#62;flags &#38; OP_FUNC_IS_ALLOCATED) {
        ops_addr = (op_func_t *)mem_sys_realloc(cg_lib&#45;&#62;op_func_table,
                n_tot * sizeof (op_func_t));
    }
    else {
        size_t i;

        ops_addr = (op_func_t *)mem_sys_allocate(n_tot * sizeof (op_func_t));
        cg_lib&#45;&#62;flags = OP_FUNC_IS_ALLOCATED;
        for (i = 0; i &#60; n_old; ++i)
            ops_addr[i] = cg_lib&#45;&#62;op_func_table[i];
    }
    /*
     * XXX running CG and CGP ops currently works only via the wrapper
     *
     * the problem is:
     *  The actual runcores cg_core and cgp_core are very big functions.
     *  The C compiler usually addresses &#34;spilled&#34; registers in the C stack.
     *  The loaded opcode lib is another possibly big function, but with
     *  a likely different stack layout. Directly jumping around between
     *  code locations in these two opcode functions works, but access
     *  to stack&#45;ed (or spilled) variables fails badly.
     *
     *  We would need to prepare the assembly source of the opcode
     *  lib so that all variable access on the stack has the same
     *  layout and compile the prepared assembly to ops_cgp?.o
     *
     *  The switched core is different anyway, as we can&#39;t extend the
     *  compiled big switch statement with the new cases. We have
     *  always to use the wrapper__ opcode called from the default case.
     */
#if 0
    /* check if the lib_pmc exists with a _xx flavor */
    new_init_func = get_op_lib_init(0, 0, lib_pmc);
    new_lib = new_init_func(1);
    op_variant = Parrot_sprintf_c(interp, &#34;%s_ops%s&#34;,
            new_lib&#45;&#62;name, cg_lib&#45;&#62;suffix);
    lib_variant = Parrot_load_lib(interp, op_variant, NULL);
#endif
    /*
     * XXX running CG and CGP ops currently works only via the wrapper
     */
    if (0 /*lib_variant */) {
        size_t i;

        new_init_func = get_op_lib_init(interp, 0, 0, lib_variant);
        new_lib = new_init_func(1);
        for (i = n_old; i &#60; n_tot; ++i)
            ops_addr[i] = (new_lib&#45;&#62;op_func_table)[i &#45; n_old];
        new_lib&#45;&#62;op_func_table = ops_addr;
        new_lib&#45;&#62;op_count = n_tot;
        new_init_func((long) ops_addr);
    }
    else {
        size_t i;
        /* if not install wrappers */
        /* fill new entries with the wrapper op */
        for (i = n_old; i &#60; n_tot; ++i)
            ops_addr[i] = (cg_lib&#45;&#62;op_func_table)[CORE_OPS_wrapper__];
    }
    /*
     * if we are running this core, update event check ops
     */
    if ((int)interp&#45;&#62;run_core == cg_lib&#45;&#62;core_type) {
        size_t i;

        for (i = n_old; i &#60; n_tot; ++i)
            interp&#45;&#62;evc_func_table[i] =
                (op_func_t)ops_addr[CORE_OPS_check_events__];
        interp&#45;&#62;save_func_table = ops_addr;
    }
    /*
     * tell the cg_core about the new jump table
     */
    cg_lib&#45;&#62;op_func_table = ops_addr;
    cg_lib&#45;&#62;op_count = n_tot;
    init_func((long) ops_addr);
}</pre>

<p>static void dynop_register_switch(size_t n_old, size_t n_new) { op_lib_t * const lib = PARROT_CORE_SWITCH_OPLIB_INIT(1); lib&#45;&#62;op_count = n_old + n_new; }</p>

<p>/*</p>

<p>FUNCDOC: notify_func_table</p>

<p>Tell the interpreter&#39;s running core about the new function table.</p>

<p>*/</p>

<p>static void notify_func_table(PARROT_INTERP, NOTNULL(op_func_t* table), int on) { const oplib_init_f init_func = get_op_lib_init(interp, 1, interp&#45;&#62;run_core, NULL);</p>

<pre lang='und' xml:lang='und'>    init_func((long) table);
    switch (interp&#45;&#62;run_core) {
        case PARROT_SLOW_CORE:      /* normal func core */
        case PARROT_FAST_CORE:      /* normal func core */
        case PARROT_CGOTO_CORE:      /* cgoto address list  */
            PARROT_ASSERT(table);
            interp&#45;&#62;op_func_table = table;
            break;
        case PARROT_CGP_CORE:
        case PARROT_CGP_JIT_CORE:
            turn_ev_check(interp, on);
            break;
        default:
            break;
    }
}</pre>

<p>/*</p>

<p>FUNCDOC: disable_event_checking</p>

<p>Restore old function table.</p>

<p>XXX This is only implemented for the function core at present.</p>

<p>*/</p>

<p>PARROT_API void disable_event_checking(PARROT_INTERP) { /* * restore func table */ PARROT_ASSERT(interp&#45;&#62;save_func_table); notify_func_table(interp, interp&#45;&#62;save_func_table, 0); }</p>

<p>/*</p>

<p>FUNCDOC: enable_event_checking</p>

<p>Replace func table with one that does event checking for all opcodes.</p>

<p>NOTE: <code lang='und' xml:lang='und'>enable_event_checking()</code> is called async by the event handler thread. All action done from here has to be async safe.</p>

<p>XXX This is only implemented for the function core at present.</p>

<p>*/</p>

<p>PARROT_API void enable_event_checking(PARROT_INTERP) { /* * put table in place */ notify_func_table(interp, interp&#45;&#62;evc_func_table, 1); }</p>

<p>/*</p>

<h1><a name="SEE_ALSO"
>SEE ALSO <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p><em lang='und' xml:lang='und'>include/parrot/interpreter.h</em>, <em lang='und' xml:lang='und'><a href="inter_cb.c.html">src/inter_cb.c</a></em>, <em lang='und' xml:lang='und'><a href="inter_create.c.html">src/inter_create.c</a></em>, <em lang='und' xml:lang='und'><a href="inter_misc.c.html">src/inter_misc.c</a></em>, <em lang='und' xml:lang='und'><a href="inter_run.c.html">src/inter_run.c</a></em>.</p>

<p>*/</p>

<p>/* * Local variables: * c&#45;file&#45;style: &#34;parrot&#34; * End: * vim: expandtab shiftwidth=4: */</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
