<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Parrot Interpreter miscellaneous functions</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Parrot Interpreter miscellaneous functions</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../html/index.html">Contents</a> | <a href="../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>src/inter_misc.c &#45; Parrot Interpreter miscellaneous functions</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>NCI function setup,
compiler registration,
<code lang='und' xml:lang='und'>interpinfo</code>,
and <code lang='und' xml:lang='und'>sysinfo</code> opcodes.</p>

<h2><a name="Functions"
>Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>*/</p>

<p>#include &#34;parrot/parrot.h&#34; #include &#34;inter_misc.str&#34; #include &#34;../compilers/imcc/imc.h&#34;</p>

<p>/* XXX Put me somewhere else */ void Parrot_NCI_nci_make_raw_nci(PARROT_INTERP,
PMC *method,
void *func);</p>

<p>/* HEADERIZER HFILE: include/parrot/interpreter.h */</p>

<p>/*</p>

<p>FUNCDOC: register_nci_method</p>

<p>Create an entry in the <code lang='und' xml:lang='und'>nci_method_table</code> for the given NCI method of PMC class <code lang='und' xml:lang='und'>type</code>.</p>

<p>*/</p>

<p>PARROT_API void register_nci_method(PARROT_INTERP,
const int type,
void *func,
const char *name,
const char *proto) { PMC * const method = pmc_new(interp,
enum_class_NCI); STRING * const method_name = string_make(interp,
name,
strlen(name),
NULL,
PObj_constant_FLAG|PObj_external_FLAG); PMC *proxy;</p>

<pre lang='und' xml:lang='und'>    /* create call func */
    VTABLE_set_pointer_keyed_str(interp, method,
            string_make(interp, proto, strlen(proto), NULL,
                PObj_constant_FLAG|PObj_external_FLAG),
            func);

    /* insert it into namespace */
    VTABLE_set_pmc_keyed_str(interp, interp&#45;&#62;vtables[type]&#45;&#62;_namespace,
            method_name, method);

    /* Also need to list the method in the PMCProxy PMC&#39;s method list, so it
     * can be introspected. */
    proxy = VTABLE_get_pmc_keyed_int(interp, interp&#45;&#62;pmc_proxies, type);
    VTABLE_set_pmc_keyed_str(interp, PARROT_PMCPROXY(proxy)&#45;&#62;methods,
            method_name, method);
}</pre>

<p>PARROT_API void register_raw_nci_method_in_ns(PARROT_INTERP, const int type, void *func, const char *name) { PMC * const method = pmc_new(interp, enum_class_NCI); STRING * const method_name = string_make(interp, name, strlen(name), NULL, PObj_constant_FLAG|PObj_external_FLAG); PMC *proxy;</p>

<pre lang='und' xml:lang='und'>    /* setup call func */
    Parrot_NCI_nci_make_raw_nci(interp, method, func);

    /* insert it into namespace */
    VTABLE_set_pmc_keyed_str(interp, interp&#45;&#62;vtables[type]&#45;&#62;_namespace,
            method_name, method);

    /* Also need to list the method in the PMCProxy PMC&#39;s method list, so it
     * can be introspected. */
    proxy = VTABLE_get_pmc_keyed_int(interp, interp&#45;&#62;pmc_proxies, type);
    VTABLE_set_pmc_keyed_str(interp, PARROT_PMCPROXY(proxy)&#45;&#62;methods,
            method_name, method);
}</pre>

<p>/*</p>

<p>FUNCDOC: Parrot_mark_method_writes</p>

<p>Mark the method <code lang='und' xml:lang='und'>name</code> on PMC type <code lang='und' xml:lang='und'>type</code> as one that modifies the PMC.</p>

<p>*/</p>

<p>PARROT_API void Parrot_mark_method_writes(PARROT_INTERP, int type, NOTNULL(const char *name)) { STRING *const str_name = const_string(interp, name); PMC *const pmc_true = pmc_new(interp, enum_class_Integer); PMC *const method = VTABLE_get_pmc_keyed_str( interp, interp&#45;&#62;vtables[type]&#45;&#62;_namespace, str_name); VTABLE_set_integer_native(interp, pmc_true, 1); VTABLE_setprop(interp, method, const_string(interp, &#34;write&#34;), pmc_true); }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_compreg</p>

<p>Register a parser/compiler function.</p>

<p>*/</p>

<p>PARROT_API void Parrot_compreg(PARROT_INTERP, STRING *type, Parrot_compiler_func_t func) { PMC* const iglobals = interp&#45;&#62;iglobals; PMC *hash, *nci; STRING *sc;</p>

<pre lang='und' xml:lang='und'>    hash = VTABLE_get_pmc_keyed_int(interp, interp&#45;&#62;iglobals,
            IGLOBALS_COMPREG_HASH);
    if (!hash) {
        hash = pmc_new_noinit(interp, enum_class_Hash);
        VTABLE_init(interp, hash);
        VTABLE_set_pmc_keyed_int(interp, iglobals,
                (INTVAL)IGLOBALS_COMPREG_HASH, hash);
    }
    nci = pmc_new(interp, enum_class_Compiler);
    VTABLE_set_pmc_keyed_str(interp, hash, type, nci);
    /* build native call interface for the C sub in &#34;func&#34; */
    sc = CONST_STRING(interp, &#34;PJt&#34;);
    VTABLE_set_pointer_keyed_str(interp, nci, sc, (void*)func);
}</pre>

<p>/*</p>

<p>FUNCDOC: Parrot_compile_string</p>

<p>Compile code string.</p>

<p>*/</p>

<p>PARROT_API PARROT_WARN_UNUSED_RESULT PARROT_CAN_RETURN_NULL PMC * Parrot_compile_string(PARROT_INTERP, NOTNULL(STRING *type), NOTNULL(const char *code), NOTNULL(STRING **error)) { if (string_compare(interp, const_string(interp, &#34;PIR&#34;), type) == 0) return IMCC_compile_pir_s(interp, code, error);</p>

<pre lang='und' xml:lang='und'>    if (string_compare(interp,const_string(interp, &#34;PASM&#34;), type) == 0)
        return IMCC_compile_pasm_s(interp, code, error);

    *error=const_string(interp, &#34;Invalid interpreter type&#34;);
    return NULL;
}</pre>

<p>/*</p>

<p>FUNCDOC: Parrot_compile_file</p>

<p>Compile code file.</p>

<p>*/</p>

<p>PARROT_API PARROT_CANNOT_RETURN_NULL void * Parrot_compile_file(PARROT_INTERP, NOTNULL(const char *fullname), NOTNULL(STRING **error)) { return IMCC_compile_file_s(interp, fullname, error); }</p>

<p>#ifdef GC_IS_MALLOC # if 0 struct mallinfo { int arena; /* non&#45;mmapped space allocated from system */ int ordblks; /* number of free chunks */ int smblks; /* number of fastbin blocks */ int hblks; /* number of mmapped regions */ int hblkhd; /* space in mmapped regions */ int usmblks; /* maximum total allocated space */ int fsmblks; /* space available in freed fastbin blocks */ int uordblks; /* total allocated space */ int fordblks; /* total free space */ int keepcost; /* top&#45;most, releasable (via malloc_trim) * space */ }; # endif extern struct mallinfo mallinfo(void); #endif /* GC_IS_MALLOC */</p>

<p>/*</p>

<p>FUNCDOC: interpinfo</p>

<p><code lang='und' xml:lang='und'>what</code> specifies the type of information you want about the interpreter.</p>

<p>FUNCDOC: interpinfo_p</p>

<p><code lang='und' xml:lang='und'>what</code> specifies the type of information you want about the interpreter.</p>

<p>*/</p>

<p>PARROT_API INTVAL interpinfo(PARROT_INTERP, INTVAL what) { INTVAL ret = 0; int j; Arenas *arena_base = interp&#45;&#62;arena_base;</p>

<pre lang='und' xml:lang='und'>    switch (what) {
        case TOTAL_MEM_ALLOC:
#ifdef GC_IS_MALLOC
#  if 0
            interp&#45;&#62;memory_allocated = mallinfo().uordblks;
#  endif
#endif
            ret = arena_base&#45;&#62;memory_allocated;
            break;
        case DOD_RUNS:
            ret = arena_base&#45;&#62;dod_runs;
            break;
        case LAZY_DOD_RUNS:
            ret = arena_base&#45;&#62;lazy_dod_runs;
            break;
        case COLLECT_RUNS:
            ret = arena_base&#45;&#62;collect_runs;
            break;
        case ACTIVE_PMCS:
            ret = arena_base&#45;&#62;pmc_pool&#45;&#62;total_objects &#45;
                arena_base&#45;&#62;pmc_pool&#45;&#62;num_free_objects;
            break;
        case ACTIVE_BUFFERS:
            ret = 0;
            for (j = 0; j &#60; (INTVAL)arena_base&#45;&#62;num_sized; j++) {
                Small_Object_Pool * const header_pool =
                    arena_base&#45;&#62;sized_header_pools[j];
                if (header_pool)
                    ret += header_pool&#45;&#62;total_objects &#45;
                        header_pool&#45;&#62;num_free_objects;
            }
            break;
        case TOTAL_PMCS:
            ret = arena_base&#45;&#62;pmc_pool&#45;&#62;total_objects;
            break;
        case TOTAL_BUFFERS:
            ret = 0;
            for (j = 0; j &#60; (INTVAL)arena_base&#45;&#62;num_sized; j++) {
                Small_Object_Pool * const header_pool =
                    arena_base&#45;&#62;sized_header_pools[j];
                if (header_pool)
                    ret += header_pool&#45;&#62;total_objects;
            }
            break;
        case HEADER_ALLOCS_SINCE_COLLECT:
            ret = arena_base&#45;&#62;header_allocs_since_last_collect;
            break;
        case MEM_ALLOCS_SINCE_COLLECT:
            ret = arena_base&#45;&#62;mem_allocs_since_last_collect;
            break;
        case TOTAL_COPIED:
            ret = arena_base&#45;&#62;memory_collected;
            break;
        case IMPATIENT_PMCS:
            ret = arena_base&#45;&#62;num_early_DOD_PMCs;
            break;
        case EXTENDED_PMCS:
            ret = arena_base&#45;&#62;num_extended_PMCs;
            break;
        default:        /* or a warning only? */
            real_exception(interp, NULL, UNIMPLEMENTED,
                    &#34;illegal argument in interpinfo&#34;);
    }
    return ret;
}</pre>

<p>PARROT_API PARROT_WARN_UNUSED_RESULT PARROT_CAN_RETURN_NULL PMC* interpinfo_p(PARROT_INTERP, INTVAL what) { switch (what) { case CURRENT_SUB: return CONTEXT(interp&#45;&#62;ctx)&#45;&#62;current_sub; case CURRENT_CONT: { PMC * const cont = CONTEXT(interp&#45;&#62;ctx)&#45;&#62;current_cont; if (!PMC_IS_NULL(cont) &#38;&#38; cont&#45;&#62;vtable&#45;&#62;base_type == enum_class_RetContinuation) return VTABLE_clone(interp, cont); return cont; } case CURRENT_OBJECT: return CONTEXT(interp&#45;&#62;ctx)&#45;&#62;current_object; case CURRENT_LEXPAD: return CONTEXT(interp&#45;&#62;ctx)&#45;&#62;lex_pad; default: /* or a warning only? */ real_exception(interp, NULL, UNIMPLEMENTED, &#34;illegal argument in interpinfo&#34;); } }</p>

<p>PARROT_API PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL STRING* interpinfo_s(PARROT_INTERP, INTVAL what) { STRING *fullname, *basename; char *fullname_c; int pos;</p>

<pre lang='und' xml:lang='und'>    switch (what) {
        case EXECUTABLE_FULLNAME:
            return VTABLE_get_string(interp,
                VTABLE_get_pmc_keyed_int(interp, interp&#45;&#62;iglobals,
                    IGLOBALS_EXECUTABLE));
        case EXECUTABLE_BASENAME:
            /* Need to strip back to what follows the final / or \. */
            fullname = VTABLE_get_string(interp,
                VTABLE_get_pmc_keyed_int(interp, interp&#45;&#62;iglobals,
                    IGLOBALS_EXECUTABLE));
            fullname_c = string_to_cstring(interp, fullname);
            pos = strlen(fullname_c) &#45; 1;
            while (pos &#62; 0 &#38;&#38; fullname_c[pos] != &#39;/&#39; &#38;&#38; fullname_c[pos] != &#39;\\&#39;)
                pos&#45;&#45;;
            if (pos &#62; 0)
                pos++;
            basename = string_from_cstring(interp, fullname_c + pos, 0);
            mem_sys_free(fullname_c);
            return basename;

        case RUNTIME_PREFIX:
            fullname_c = Parrot_get_runtime_prefix(interp, NULL);
            fullname = string_from_cstring(interp, fullname_c, 0);
            mem_sys_free(fullname_c);
            return fullname;
    } /* switch */

    real_exception(interp, NULL, UNIMPLEMENTED,
            &#34;illegal argument in interpinfo&#34;);
}</pre>

<p>/*</p>

<p>FUNCDOC: sysinfo_i</p>

<p>Returns the system info.</p>

<p><code lang='und' xml:lang='und'>info_wanted</code> is one of:</p>

<pre lang='und' xml:lang='und'>    PARROT_INTSIZE
    PARROT_FLOATSIZE
    PARROT_POINTERSIZE</pre>

<p>In unknown info is requested then &#45;1 is returned.</p>

<p>*/</p>

<p>PARROT_WARN_UNUSED_RESULT INTVAL sysinfo_i(SHIM_INTERP, INTVAL info_wanted) { switch (info_wanted) { case PARROT_INTSIZE: return sizeof (INTVAL); case PARROT_FLOATSIZE: return sizeof (FLOATVAL); case PARROT_POINTERSIZE: return sizeof (void *); default: return &#45;1; } }</p>

<p>/*</p>

<p>FUNCDOC: sysinfo_s</p>

<p>Returns the system info string.</p>

<p><code lang='und' xml:lang='und'>info_wanted</code> is one of:</p>

<pre lang='und' xml:lang='und'>    PARROT_OS
    PARROT_OS_VERSION
    PARROT_OS_VERSION_NUMBER
    CPU_ARCH
    CPU_TYPE</pre>

<p>If unknown info is requested then and empty string is returned.</p>

<p>*/</p>

<p>PARROT_CANNOT_RETURN_NULL PARROT_WARN_UNUSED_RESULT STRING * sysinfo_s(PARROT_INTERP, INTVAL info_wanted) { switch (info_wanted) { case PARROT_OS: return string_from_literal(interp, BUILD_OS_NAME); case PARROT_OS_VERSION: case PARROT_OS_VERSION_NUMBER: case CPU_ARCH: case CPU_TYPE: default: return CONST_STRING(interp, &#34;&#34;); } }</p>

<p>/* * Local variables: * c&#45;file&#45;style: &#34;parrot&#34; * End: * vim: expandtab shiftwidth=4: */</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
