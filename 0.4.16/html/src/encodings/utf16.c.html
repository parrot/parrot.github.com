<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>UTF&#45;16 encoding</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">UTF&#45;16 encoding</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../html/index.html">Contents</a> | <a href="../../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>src/encodings/utf16.c &#45; UTF&#45;16 encoding</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>UTF&#45;16 encoding with the help of the ICU library.</p>

<h2><a name="Functions"
>Functions <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>*/</p>

<p>#include &#34;parrot/parrot.h&#34; #include &#34;../unicode.h&#34;</p>

<p>/* HEADERIZER HFILE: src/encodings/utf16.h */</p>

<p>/* HEADERIZER BEGIN: static */</p>

<p>static void become_encoding( PARROT_INTERP,
SHIM(STRING *src) ) __attribute__nonnull__(1);</p>

<p>static UINTVAL bytes( PARROT_INTERP,
NOTNULL(STRING *src) ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>static UINTVAL codepoints( PARROT_INTERP,
NOTNULL(STRING *src) ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>static UINTVAL get_byte( PARROT_INTERP,
NOTNULL(const STRING *src),
UINTVAL offset ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>static STRING * get_bytes( PARROT_INTERP,
SHIM(STRING *src),
UINTVAL offset,
UINTVAL count ) __attribute__nonnull__(1);</p>

<p>static STRING * get_bytes_inplace( PARROT_INTERP,
SHIM(STRING *src),
UINTVAL offset,
UINTVAL count,
SHIM(STRING *return_string) ) __attribute__nonnull__(1);</p>

<p>static UINTVAL get_codepoint( PARROT_INTERP,
NOTNULL(const STRING *src),
UINTVAL offset ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>static STRING * get_codepoints( PARROT_INTERP,
NOTNULL(STRING *src),
UINTVAL offset,
UINTVAL count ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>static STRING * get_codepoints_inplace( PARROT_INTERP,
NOTNULL(STRING *src),
UINTVAL offset,
UINTVAL count,
NOTNULL(STRING *return_string) ) __attribute__nonnull__(1) __attribute__nonnull__(2) __attribute__nonnull__(5);</p>

<p>static void iter_init( PARROT_INTERP,
NOTNULL(const STRING *src),
NOTNULL(String_iter *iter) ) __attribute__nonnull__(1) __attribute__nonnull__(2) __attribute__nonnull__(3);</p>

<p>static void set_byte( PARROT_INTERP,
NOTNULL(const STRING *src),
UINTVAL offset,
UINTVAL byte ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>static void set_bytes( PARROT_INTERP,
SHIM(STRING *src),
UINTVAL offset,
UINTVAL count,
SHIM(STRING *new_bytes) ) __attribute__nonnull__(1);</p>

<p>static void set_codepoint( PARROT_INTERP,
NOTNULL(STRING *src),
UINTVAL offset,
UINTVAL codepoint ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>static void set_codepoints( PARROT_INTERP,
SHIM(STRING *src),
UINTVAL offset,
UINTVAL count,
SHIM(STRING *new_codepoints) ) __attribute__nonnull__(1);</p>

<p>PARROT_WARN_UNUSED_RESULT static STRING * to_encoding( PARROT_INTERP,
NOTNULL(STRING *src),
NULLOK(STRING *dest) ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>static UINTVAL utf16_decode_and_advance( PARROT_INTERP,
NOTNULL(String_iter *i) ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>static void utf16_encode_and_advance( PARROT_INTERP,
NOTNULL(String_iter *i),
UINTVAL c ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>static void utf16_set_position( PARROT_INTERP,
NOTNULL(String_iter *i),
UINTVAL n ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>/* HEADERIZER END: static */</p>

<p>#include &#34;utf16.h&#34;</p>

<p>#if PARROT_HAS_ICU # include &#60;unicode/utf16.h&#62; # include &#60;unicode/ustring.h&#62; #endif</p>

<p>#define UNIMPL real_exception(interp,
NULL,
UNIMPLEMENTED,
&#34;unimpl utf16&#34;)</p>

<p>static void iter_init(Interp *,
const STRING *src,
String_iter *iter);</p>

<p>/*</p>

<p>FUNCDOC: to_encoding</p>

<p>Convert string <code lang='und' xml:lang='und'>src</code> to this encoding.
If <code lang='und' xml:lang='und'>dest</code> is set fill it with the converted result,
else operate inplace.</p>

<p>*/</p>

<p>PARROT_WARN_UNUSED_RESULT static STRING * to_encoding(PARROT_INTERP,
NOTNULL(STRING *src),
NULLOK(STRING *dest)) { #if PARROT_HAS_ICU UErrorCode err; int dest_len; UChar *p; #endif int src_len; int in_place = dest == NULL; STRING *result;</p>

<pre lang='und' xml:lang='und'>    if (src&#45;&#62;encoding == Parrot_utf16_encoding_ptr ||
            src&#45;&#62;encoding == Parrot_ucs2_encoding_ptr)
        return in_place ? src : string_copy(interp, src);
    /*
     * TODO adapt string creation functions
     */
    src_len = src&#45;&#62;strlen;
    if (in_place) {
        result = src;
    }
    else {
        result = dest;
    }
    if (!src_len) {
        result&#45;&#62;charset  = Parrot_unicode_charset_ptr;
        result&#45;&#62;encoding = Parrot_ucs2_encoding_ptr;
        result&#45;&#62;strlen = result&#45;&#62;bufused = 0;
        return result;
    }
    /*
       u_strFromUTF8(UChar *dest,
       int32_t destCapacity,
       int32_t *pDestLength,
       const char *src,
       int32_t srcLength,
       UErrorCode *pErrorCode);
       */
#if PARROT_HAS_ICU
    if (in_place) {
        /* need intermediate memory */
        p = mem_sys_allocate(src_len * sizeof (UChar));
    }
    else {
        Parrot_reallocate_string(interp, dest, sizeof (UChar) * src_len);
        p = (UChar *)dest&#45;&#62;strstart;
    }
    if (src&#45;&#62;charset == Parrot_iso_8859_1_charset_ptr ||
            src&#45;&#62;charset == Parrot_ascii_charset_ptr) {
        for (dest_len = 0; dest_len &#60; (int)src&#45;&#62;strlen; ++dest_len) {
            p[dest_len] = (UChar)((unsigned char*)src&#45;&#62;strstart)[dest_len];
        }
    }
    else {
        err = U_ZERO_ERROR;
        u_strFromUTF8(p, src_len,
                &#38;dest_len, src&#45;&#62;strstart, src&#45;&#62;bufused, &#38;err);
        if (!U_SUCCESS(err)) {
            /*
             * have to resize &#45; required len in UChars is in dest_len
             */
            if (in_place)
                p = mem_sys_realloc(p, dest_len * sizeof (UChar));
            else {
                result&#45;&#62;bufused = dest_len * sizeof (UChar);
                Parrot_reallocate_string(interp, dest,
                                         sizeof (UChar) * dest_len);
                p = (UChar *)dest&#45;&#62;strstart;
            }
            u_strFromUTF8(p, dest_len,
                    &#38;dest_len, src&#45;&#62;strstart, src&#45;&#62;bufused, &#38;err);
            PARROT_ASSERT(U_SUCCESS(err));
        }
    }
    result&#45;&#62;bufused = dest_len * sizeof (UChar);
    if (in_place) {
        Parrot_reallocate_string(interp, src, src&#45;&#62;bufused);
        memcpy(src&#45;&#62;strstart, p, src&#45;&#62;bufused);
        mem_sys_free(p);
    }
    result&#45;&#62;charset  = Parrot_unicode_charset_ptr;
    result&#45;&#62;encoding = Parrot_utf16_encoding_ptr;
    result&#45;&#62;strlen = src_len;

    /* downgrade if possible */
    if (dest_len == (int)src&#45;&#62;strlen)
        result&#45;&#62;encoding = Parrot_ucs2_encoding_ptr;
    return result;
#else
    real_exception(interp, NULL, E_LibraryNotLoadedError,
            &#34;no ICU lib loaded&#34;);
#endif
}</pre>

<p>static UINTVAL get_codepoint(PARROT_INTERP, NOTNULL(const STRING *src), UINTVAL offset) { #if PARROT_HAS_ICU UChar * const s = (UChar*) src&#45;&#62;strstart; UINTVAL c, pos;</p>

<pre lang='und' xml:lang='und'>    pos = 0;
    U16_FWD_N_UNSAFE(s, pos, offset);
    U16_GET_UNSAFE(s, pos, c);
    return c;
#else
    real_exception(interp, NULL, E_LibraryNotLoadedError,
            &#34;no ICU lib loaded&#34;);
#endif
}</pre>

<p>static void set_codepoint(PARROT_INTERP, NOTNULL(STRING *src), UINTVAL offset, UINTVAL codepoint) { UNIMPL; }</p>

<p>static UINTVAL get_byte(PARROT_INTERP, NOTNULL(const STRING *src), UINTVAL offset) { unsigned char *contents = (unsigned char *)src&#45;&#62;strstart; if (offset &#62;= src&#45;&#62;bufused) { /* real_exception(interp, NULL, 0, &#34;get_byte past the end of the buffer (%i of %i)&#34;, offset, src&#45;&#62;bufused);*/ return 0; } return contents[offset]; }</p>

<p>static void set_byte(PARROT_INTERP, NOTNULL(const STRING *src), UINTVAL offset, UINTVAL byte) { unsigned char *contents; if (offset &#62;= src&#45;&#62;bufused) { real_exception(interp, NULL, 0, &#34;set_byte past the end of the buffer&#34;); } contents = (unsigned char *)src&#45;&#62;strstart; contents[offset] = (unsigned char)byte; }</p>

<p>static STRING * get_codepoints(PARROT_INTERP, NOTNULL(STRING *src), UINTVAL offset, UINTVAL count) { String_iter iter; UINTVAL start; STRING * const return_string = Parrot_make_COW_reference(interp, src);</p>

<pre lang='und' xml:lang='und'>    iter_init(interp, src, &#38;iter);
    iter.set_position(interp, &#38;iter, offset);
    start = iter.bytepos;
    return_string&#45;&#62;strstart = (char *)return_string&#45;&#62;strstart + start ;
    iter.set_position(interp, &#38;iter, offset + count);
    return_string&#45;&#62;bufused = iter.bytepos &#45; start;
    return_string&#45;&#62;strlen = count;
    return_string&#45;&#62;hashval = 0;
    return return_string;
}</pre>

<p>static STRING * get_codepoints_inplace(PARROT_INTERP, NOTNULL(STRING *src), UINTVAL offset, UINTVAL count, NOTNULL(STRING *return_string)) { String_iter iter; UINTVAL start; Parrot_reuse_COW_reference(interp, src, return_string); iter_init(interp, src, &#38;iter); iter.set_position(interp, &#38;iter, offset); start = iter.bytepos; return_string&#45;&#62;strstart = (char *)return_string&#45;&#62;strstart + start ; iter.set_position(interp, &#38;iter, offset + count); return_string&#45;&#62;bufused = iter.bytepos &#45; start; return_string&#45;&#62;strlen = count; return_string&#45;&#62;hashval = 0; return return_string; }</p>

<p>static STRING * get_bytes(PARROT_INTERP, SHIM(STRING *src), UINTVAL offset, UINTVAL count) { UNIMPL; }</p>

<p>static STRING * get_bytes_inplace(PARROT_INTERP, SHIM(STRING *src), UINTVAL offset, UINTVAL count, SHIM(STRING *return_string)) { UNIMPL; }</p>

<p>static void set_codepoints(PARROT_INTERP, SHIM(STRING *src), UINTVAL offset, UINTVAL count, SHIM(STRING *new_codepoints)) { UNIMPL; }</p>

<p>static void set_bytes(PARROT_INTERP, SHIM(STRING *src), UINTVAL offset, UINTVAL count, SHIM(STRING *new_bytes)) { UNIMPL; }</p>

<p>/* Unconditionally makes the string be in this encoding, if that&#39;s valid */ static void become_encoding(PARROT_INTERP, SHIM(STRING *src)) { UNIMPL; }</p>

<p>static UINTVAL codepoints(PARROT_INTERP, NOTNULL(STRING *src)) { String_iter iter; /* * this is used to initially calculate src&#45;&#62;strlen, * therefore we must scan the whole string */ iter_init(interp, src, &#38;iter); while (iter.bytepos &#60; src&#45;&#62;bufused) iter.get_and_advance(interp, &#38;iter); return iter.charpos; }</p>

<p>static UINTVAL bytes(PARROT_INTERP, NOTNULL(STRING *src)) { return src&#45;&#62;bufused; }</p>

<p>#if PARROT_HAS_ICU static UINTVAL utf16_decode_and_advance(PARROT_INTERP, NOTNULL(String_iter *i)) { UChar *s = (UChar*) i&#45;&#62;str&#45;&#62;strstart; UINTVAL c, pos; pos = i&#45;&#62;bytepos / sizeof (UChar); /* TODO either make sure that we don&#39;t go past end or use SAFE * iter versions */ U16_NEXT_UNSAFE(s, pos, c); i&#45;&#62;charpos++; i&#45;&#62;bytepos = pos * sizeof (UChar); return c; }</p>

<p>static void utf16_encode_and_advance(PARROT_INTERP, NOTNULL(String_iter *i), UINTVAL c) { UChar *s = (UChar*) i&#45;&#62;str&#45;&#62;strstart; UINTVAL pos; pos = i&#45;&#62;bytepos / sizeof (UChar); U16_APPEND_UNSAFE(s, pos, c); i&#45;&#62;charpos++; i&#45;&#62;bytepos = pos * sizeof (UChar); }</p>

<p>static void utf16_set_position(PARROT_INTERP, NOTNULL(String_iter *i), UINTVAL n) { UChar *s = (UChar*) i&#45;&#62;str&#45;&#62;strstart; UINTVAL pos; pos = 0; U16_FWD_N_UNSAFE(s, pos, n); i&#45;&#62;charpos = n; i&#45;&#62;bytepos = pos * sizeof (UChar); }</p>

<p>#endif static void iter_init(PARROT_INTERP, NOTNULL(const STRING *src), NOTNULL(String_iter *iter)) { iter&#45;&#62;str = src; iter&#45;&#62;bytepos = iter&#45;&#62;charpos = 0; #if PARROT_HAS_ICU iter&#45;&#62;get_and_advance = utf16_decode_and_advance; iter&#45;&#62;set_and_advance = utf16_encode_and_advance; iter&#45;&#62;set_position = utf16_set_position; #else real_exception(interp, NULL, E_LibraryNotLoadedError, &#34;no ICU lib loaded&#34;); #endif }</p>

<p>ENCODING * Parrot_encoding_utf16_init(PARROT_INTERP) { ENCODING * const return_encoding = Parrot_new_encoding(interp);</p>

<pre lang='und' xml:lang='und'>    static const ENCODING base_encoding = {
        &#34;utf16&#34;,
        4, /* Max bytes per codepoint 0 .. 0x10ffff */
        to_encoding,
        get_codepoint,
        set_codepoint,
        get_byte,
        set_byte,
        get_codepoints,
        get_codepoints_inplace,
        get_bytes,
        get_bytes_inplace,
        set_codepoints,
        set_bytes,
        become_encoding,
        codepoints,
        bytes,
        iter_init
    };
    STRUCT_COPY(return_encoding, &#38;base_encoding);
    Parrot_register_encoding(interp, &#34;utf16&#34;, return_encoding);
    return return_encoding;
}</pre>

<p>/*</p>

<h1><a name="SEE_ALSO"
>SEE ALSO <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p><em lang='und' xml:lang='und'><a href="fixed_8.c.html">src/encodings/fixed_8.c</a></em>, <em lang='und' xml:lang='und'><a href="utf8.c.html">src/encodings/utf8.c</a></em>, <em lang='und' xml:lang='und'><a href="../string.c.html">src/string.c</a></em>, <em lang='und' xml:lang='und'>include/parrot/string.h</em>, <em lang='und' xml:lang='und'>docs/string.pod</em>.</p>

<p>*/</p>

<p>/* * Local variables: * c&#45;file&#45;style: &#34;parrot&#34; * End: * vim: expandtab shiftwidth=4: */</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
