<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>String Primitives</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">String Primitives</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../html/index.html">Contents</a> | <a href="../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>src/string_primitives.c &#45; String Primitives</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>This file collects together all the functions that call into the ICU API.</p>

<h2><a name="Functions"
>Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>*/</p>

<p>/* HEADERIZER HFILE: include/parrot/string_primitives.h */</p>

<p>#include &#34;parrot/parrot.h&#34; #if PARROT_HAS_ICU # include &#60;unicode/ucnv.h&#62; # include &#60;unicode/utypes.h&#62; # include &#60;unicode/uchar.h&#62; # include &#60;unicode/ustring.h&#62; #else # include &#60;ctype.h&#62; #endif</p>

<p>/*</p>

<p>FUNCDOC: string_set_data_directory</p>

<p>Set the directory where ICU finds its data files (encodings,
locales,
etc.).</p>

<p>*/</p>

<p>PARROT_API void string_set_data_directory(PARROT_INTERP,
NOTNULL(const char *dir)) { #if PARROT_HAS_ICU u_setDataDirectory(dir);</p>

<pre lang='und' xml:lang='und'>    /* Since u_setDataDirectory doesn&#39;t have a result code, we&#39;ll spot
       check that everything is okay by making sure that &#39;9&#39; had decimal
       value 9. Using 57 rather than &#39;9&#39; so that the encoding of this
       source code file isn&#39;t an issue.... (Don&#39;t want to get bitten by
       EBCDIC.) */

    if (!u_isdigit(57) || (u_charDigitValue(57) != 9)) {
            real_exception(interp, NULL, ICU_ERROR,
                &#34;string_set_data_directory: ICU data files not found&#34;
                &#34;(apparently) for directory [%s]&#34;, dir);
    }
#else
    UNUSED(dir);

    real_exception(interp, NULL, ICU_ERROR,
        &#34;string_set_data_directory: parrot compiled without ICU support&#34;);
#endif
}</pre>

<p>/* Unescape a single character. We assume that we&#39;re at the start of a sequence, right after the \ */ PARROT_API Parrot_UInt4 string_unescape_one(PARROT_INTERP, NOTNULL(UINTVAL *offset), NOTNULL(STRING *string)) { UINTVAL workchar = 0; UINTVAL charcount = 0; const UINTVAL len = string_length(interp, string); /* Well, not right now */ UINTVAL codepoint = CHARSET_GET_BYTE(interp, string, *offset); ++*offset; switch (codepoint) { case &#39;x&#39;: codepoint = CHARSET_GET_BYTE(interp, string, *offset); if (codepoint &#62;= &#39;0&#39; &#38;&#38; codepoint &#60;= &#39;9&#39;) { workchar = codepoint &#45; &#39;0&#39;; } else if (codepoint &#62;= &#39;a&#39; &#38;&#38; codepoint &#60;= &#39;f&#39;) { workchar = codepoint &#45; &#39;a&#39; + 10; } else if (codepoint &#62;= &#39;A&#39; &#38;&#38; codepoint &#60;= &#39;F&#39;) { workchar = codepoint &#45; &#39;A&#39; + 10; } else if (codepoint == &#39;{&#39;) { int i; ++*offset; workchar = 0; for (i = 0; i &#60; 8 &#38;&#38; *offset &#60; len; ++i, ++*offset) { codepoint = CHARSET_GET_BYTE(interp, string, *offset); if (codepoint == &#39;}&#39;) { ++*offset; return workchar; } workchar *= 16; if (codepoint &#62;= &#39;0&#39; &#38;&#38; codepoint &#60;= &#39;9&#39;) { workchar += codepoint &#45; &#39;0&#39;; } else if (codepoint &#62;= &#39;a&#39; &#38;&#38; codepoint &#60;= &#39;f&#39;) { workchar += codepoint &#45; &#39;a&#39; + 10; } else if (codepoint &#62;= &#39;A&#39; &#38;&#38; codepoint &#60;= &#39;F&#39;) { workchar += codepoint &#45; &#39;A&#39; + 10; } else { real_exception(interp, NULL, UNIMPLEMENTED, &#34;Illegal escape sequence inside {}&#34;); } } if (*offset == len) real_exception(interp, NULL, UNIMPLEMENTED, &#34;Illegal escape sequence no &#39;}&#39;&#34;); } else { real_exception(interp, NULL, UNIMPLEMENTED, &#34;Illegal escape sequence in&#34;); } ++*offset; if (*offset &#60; len) { workchar *= 16; codepoint = CHARSET_GET_BYTE(interp, string, *offset); if (codepoint &#62;= &#39;0&#39; &#38;&#38; codepoint &#60;= &#39;9&#39;) { workchar += codepoint &#45; &#39;0&#39;; } else if (codepoint &#62;= &#39;a&#39; &#38;&#38; codepoint &#60;= &#39;f&#39;) { workchar += codepoint &#45; &#39;a&#39; + 10; } else if (codepoint &#62;= &#39;A&#39; &#38;&#38; codepoint &#60;= &#39;F&#39;) { workchar += codepoint &#45; &#39;A&#39; + 10; } else { return workchar; } } else { return workchar; } ++*offset; return workchar; case &#39;c&#39;: codepoint = CHARSET_GET_BYTE(interp, string, *offset); if (codepoint &#62;= &#39;A&#39; &#38;&#38; codepoint &#60;= &#39;Z&#39;) { workchar = codepoint &#45; &#39;A&#39; + 1; } else { real_exception(interp, NULL, UNIMPLEMENTED, &#34;Illegal escape sequence&#34;); } ++*offset; return workchar; case &#39;u&#39;: workchar = 0; for (charcount = 0; charcount &#60; 4; charcount++) { if (*offset &#60; len) { workchar *= 16; codepoint = CHARSET_GET_BYTE(interp, string, *offset); if (codepoint &#62;= &#39;0&#39; &#38;&#38; codepoint &#60;= &#39;9&#39;) { workchar += codepoint &#45; &#39;0&#39;; } else if (codepoint &#62;= &#39;a&#39; &#38;&#38; codepoint &#60;= &#39;f&#39;) { workchar += codepoint &#45; &#39;a&#39; + 10; } else if (codepoint &#62;= &#39;A&#39; &#38;&#38; codepoint &#60;= &#39;F&#39;) { workchar += codepoint &#45; &#39;A&#39; + 10; } else { real_exception(interp, NULL, UNIMPLEMENTED, &#34;Illegal escape sequence in uxxx escape&#34;); } } else { real_exception(interp, NULL, UNIMPLEMENTED, &#34;Illegal escape sequence in uxxx escape &#45; too short&#34;); } ++*offset; } return workchar; case &#39;U&#39;: workchar = 0; for (charcount = 0; charcount &#60; 8; charcount++) { if (*offset &#60; len) { workchar *= 16; codepoint = CHARSET_GET_BYTE(interp, string, *offset); if (codepoint &#62;= &#39;0&#39; &#38;&#38; codepoint &#60;= &#39;9&#39;) { workchar += codepoint &#45; &#39;0&#39;; } else if (codepoint &#62;= &#39;a&#39; &#38;&#38; codepoint &#60;= &#39;f&#39;) { workchar += codepoint &#45; &#39;a&#39; + 10; } else if (codepoint &#62;= &#39;A&#39; &#38;&#38; codepoint &#60;= &#39;F&#39;) { workchar += codepoint &#45; &#39;A&#39; + 10; } else { real_exception(interp, NULL, UNIMPLEMENTED, &#34;Illegal escape sequence in Uxxx escape&#34;); } } else { real_exception(interp, NULL, UNIMPLEMENTED, &#34;Illegal escape sequence in uxxx escape &#45; too short&#34;); } ++*offset; } return workchar; case &#39;0&#39;: case &#39;1&#39;: case &#39;2&#39;: case &#39;3&#39;: case &#39;4&#39;: case &#39;5&#39;: case &#39;6&#39;: case &#39;7&#39;: workchar = codepoint &#45; &#39;0&#39;; if (*offset &#60; len) { workchar *= 8; codepoint = CHARSET_GET_BYTE(interp, string, *offset); if (codepoint &#62;= &#39;0&#39; &#38;&#38; codepoint &#60;= &#39;7&#39;) { workchar += codepoint &#45; &#39;0&#39;; } else { return workchar; } } else { return workchar; } ++*offset; if (*offset &#60; len) { workchar *= 8; codepoint = CHARSET_GET_BYTE(interp, string, *offset); if (codepoint &#62;= &#39;0&#39; &#38;&#38; codepoint &#60;= &#39;7&#39;) { workchar += codepoint &#45; &#39;0&#39;; } else { return workchar; } } else { return workchar; } ++*offset; return workchar; case &#39;a&#39;: return 7; /* bell */ case &#39;b&#39;: return 8; /* bs */ case &#39;t&#39;: return 9; case &#39;n&#39;: return 10; case &#39;v&#39;: return 11; case &#39;f&#39;: return 12; case &#39;r&#39;: return 13; case &#39;e&#39;: return 27; case 92: /* \ */ return 92; case &#39;&#34;&#39;: return &#39;&#34;&#39;; }</p>

<pre lang='und' xml:lang='und'>    return codepoint;  /* any not special return the char */
}</pre>

<p>/*</p>

<h2><a name="Character_Property_Functions"
>Character Property Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>FUNCDOC: Parrot_char_digit_value</p>

<p>Returns the decimal digit value of the specified character if it is a decimal digit character. If not, then &#45;1 is returned.</p>

<p>Note that as currently written, <code lang='und' xml:lang='und'>Parrot_char_digit_value()</code> can correctly return the decimal digit value of characters for which <code lang='und' xml:lang='und'>Parrot_char_is_digit()</code> returns false.</p>

<p>*/</p>

<p>PARROT_API PARROT_CONST_FUNCTION UINTVAL Parrot_char_digit_value(SHIM_INTERP, UINTVAL character) { #if PARROT_HAS_ICU return u_charDigitValue(character); #else if ((character &#62;= 0x30) || (character &#60;= 0x39)) return character &#45; 0x30; return &#45;1; #endif }</p>

<p>/*</p>

<h1><a name="SEE_ALSO"
>SEE ALSO <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<dl>
<dt><a name="include/parrot/string_primitives.h"
><em lang='und' xml:lang='und'>include/parrot/string_primitives.h</em></a></dt><p class="pad"></p>

<dt><a name="include/parrot/string.h"
><em lang='und' xml:lang='und'>include/parrot/string.h</em></a></dt><p class="pad"></p>

<dt><a name="src/string.c"
><em lang='und' xml:lang='und'><a href="string.c.html">src/string.c</a></em></a></dt><p class="pad"></p>
</dl>

<p>*/</p>

<p>/* * Local variables: * c&#45;file&#45;style: &#34;parrot&#34; * End: * vim: expandtab shiftwidth=4: */</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
