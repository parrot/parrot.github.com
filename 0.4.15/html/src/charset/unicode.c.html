<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>src/charset/unicode.c</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">src/charset/unicode.c</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../html/index.html">Contents</a> | <a href="../../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>src/charset/unicode.c</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>This file implements the charset functions for unicode data</p>

<p>*/</p>

<p>#include &#34;parrot/parrot.h&#34; #include &#34;unicode.h&#34; #include &#34;ascii.h&#34; #include &#34;tables.h&#34;</p>

<p>/* HEADERIZER HFILE: src/charset/unicode.h */</p>

<p>/* HEADERIZER BEGIN: static */</p>

<p>static INTVAL compare( PARROT_INTERP,
NOTNULL(const STRING *lhs),
NOTNULL(const STRING *rhs) ) __attribute__nonnull__(1) __attribute__nonnull__(2) __attribute__nonnull__(3);</p>

<p>static STRING* compose( PARROT_INTERP,
NOTNULL(STRING *src) ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>static size_t compute_hash( PARROT_INTERP,
NOTNULL(const STRING *src),
size_t seed ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>static INTVAL cs_rindex( PARROT_INTERP,
NOTNULL(STRING *source_string),
SHIM(STRING *search_string),
UINTVAL offset ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>static STRING* decompose( PARROT_INTERP,
SHIM(STRING *src) ) __attribute__nonnull__(1);</p>

<p>static void downcase( PARROT_INTERP,
NOTNULL(STRING *src) ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>static void downcase_first( PARROT_INTERP,
NOTNULL(STRING *source_string) ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>static INTVAL find_cclass( PARROT_INTERP,
INTVAL flags,
NOTNULL(STRING *source_string),
UINTVAL offset,
UINTVAL count ) __attribute__nonnull__(1) __attribute__nonnull__(3);</p>

<p>static INTVAL find_not_cclass( PARROT_INTERP,
INTVAL flags,
NOTNULL(STRING *source_string),
UINTVAL offset,
UINTVAL count ) __attribute__nonnull__(1) __attribute__nonnull__(3);</p>

<p>static STRING * get_graphemes( PARROT_INTERP,
NOTNULL(STRING *source_string),
UINTVAL offset,
UINTVAL count ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>static STRING * get_graphemes_inplace( PARROT_INTERP,
NOTNULL(STRING *source_string),
UINTVAL offset,
UINTVAL count,
NOTNULL(STRING *dest_string) ) __attribute__nonnull__(1) __attribute__nonnull__(2) __attribute__nonnull__(5);</p>

<p>static INTVAL is_cclass( PARROT_INTERP,
INTVAL flags,
NOTNULL(STRING *source_string),
UINTVAL offset ) __attribute__nonnull__(1) __attribute__nonnull__(3);</p>

<p>static void set_graphemes( PARROT_INTERP,
NOTNULL(STRING *source_string),
UINTVAL offset,
UINTVAL replace_count,
NOTNULL(STRING *insert_string) ) __attribute__nonnull__(1) __attribute__nonnull__(2) __attribute__nonnull__(5);</p>

<p>static STRING * string_from_codepoint( PARROT_INTERP,
UINTVAL codepoint ) __attribute__nonnull__(1);</p>

<p>static void titlecase( PARROT_INTERP,
NOTNULL(STRING *src) ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>static void titlecase_first( PARROT_INTERP,
NOTNULL(STRING *source_string) ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>static STRING* to_charset( PARROT_INTERP,
NOTNULL(STRING *src),
NOTNULL(STRING *dest) ) __attribute__nonnull__(1) __attribute__nonnull__(2) __attribute__nonnull__(3);</p>

<p>static int u_iscclass( PARROT_INTERP,
UINTVAL codepoint,
INTVAL flags ) __attribute__nonnull__(1);</p>

<p>static void upcase( PARROT_INTERP,
NOTNULL(STRING *src) ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>static void upcase_first( PARROT_INTERP,
NOTNULL(STRING *source_string) ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>static UINTVAL validate( PARROT_INTERP,
NOTNULL(STRING *src) ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>/* HEADERIZER END: static */</p>

<p>#ifdef EXCEPTION # undef EXCEPTION #endif</p>

<p>#if PARROT_HAS_ICU # include &#60;unicode/ucnv.h&#62; # include &#60;unicode/utypes.h&#62; # include &#60;unicode/uchar.h&#62; # include &#60;unicode/ustring.h&#62; # include &#60;unicode/unorm.h&#62; #endif #define EXCEPTION(err,
str) \ real_exception(interp,
NULL,
err,
str)</p>

<p>#define UNIMPL EXCEPTION(UNIMPLEMENTED,
&#34;unimplemented unicode&#34;)</p>

<p>static void set_graphemes(PARROT_INTERP,
NOTNULL(STRING *source_string),
UINTVAL offset,
UINTVAL replace_count,
NOTNULL(STRING *insert_string)) { ENCODING_SET_CODEPOINTS(interp,
source_string,
offset,
replace_count,
insert_string); }</p>

<p>static STRING * get_graphemes(PARROT_INTERP,
NOTNULL(STRING *source_string),
UINTVAL offset,
UINTVAL count) { return ENCODING_GET_CODEPOINTS(interp,
source_string,
offset,
count); }</p>

<p>static STRING * get_graphemes_inplace(PARROT_INTERP,
NOTNULL(STRING *source_string),
UINTVAL offset,
UINTVAL count,
NOTNULL(STRING *dest_string)) { return ENCODING_GET_CODEPOINTS_INPLACE(interp,
source_string,
offset,
count,
dest_string); }</p>

<p>static STRING* to_charset(PARROT_INTERP,
NOTNULL(STRING *src),
NOTNULL(STRING *dest)) { charset_converter_t conversion_func;</p>

<pre lang='und' xml:lang='und'>    if ((conversion_func = Parrot_find_charset_converter(interp,
                    src&#45;&#62;charset, Parrot_unicode_charset_ptr))) {
         return conversion_func(interp, src, dest);
    }
    return Parrot_utf8_encoding_ptr&#45;&#62;to_encoding(interp, src, dest);
}</pre>

<p>static STRING* compose(PARROT_INTERP, NOTNULL(STRING *src)) { #if PARROT_HAS_ICU STRING *dest; int src_len, dest_len; UErrorCode err; /* U_STABLE int32_t U_EXPORT2 unorm_normalize(const UChar *source, int32_t sourceLength, UNormalizationMode mode, int32_t options, UChar *result, int32_t resultLength, UErrorCode *status); */ dest_len = src_len = src&#45;&#62;strlen; dest = string_make_direct(interp, NULL, src_len * sizeof (UChar), src&#45;&#62;encoding, src&#45;&#62;charset, 0); err = U_ZERO_ERROR; dest_len = unorm_normalize((UChar *)src&#45;&#62;strstart, src_len, UNORM_DEFAULT, /* default is NFC */ 0, /* options 0 default &#45; no specific icu * version */ (UChar *)dest&#45;&#62;strstart, dest_len, &#38;err); dest&#45;&#62;bufused = dest_len * sizeof (UChar); if (!U_SUCCESS(err)) { err = U_ZERO_ERROR; Parrot_reallocate_string(interp, dest, dest&#45;&#62;bufused); dest_len = unorm_normalize((UChar *)src&#45;&#62;strstart, src_len, UNORM_DEFAULT, /* default is NFC */ 0, /* options 0 default &#45; no specific * icu version */ (UChar *)dest&#45;&#62;strstart, dest_len, &#38;err); PARROT_ASSERT(U_SUCCESS(err)); dest&#45;&#62;bufused = dest_len * sizeof (UChar); } dest&#45;&#62;strlen = dest_len; return dest; #else real_exception(interp, NULL, E_LibraryNotLoadedError, &#34;no ICU lib loaded&#34;); #endif }</p>

<p>static STRING* decompose(PARROT_INTERP, SHIM(STRING *src)) { UNIMPL; }</p>

<p>static void upcase(PARROT_INTERP, NOTNULL(STRING *src)) { #if PARROT_HAS_ICU</p>

<pre lang='und' xml:lang='und'>    UErrorCode err;
    int dest_len, src_len, needed;

    if (src&#45;&#62;bufused == src&#45;&#62;strlen &#38;&#38;
            src&#45;&#62;encoding == Parrot_utf8_encoding_ptr) {
        Parrot_ascii_charset_ptr&#45;&#62;upcase(interp, src);
        return;
    }
    src = Parrot_utf16_encoding_ptr&#45;&#62;to_encoding(interp, src, NULL);
    /*
       U_CAPI int32_t U_EXPORT2
       u_strToUpper(UChar *dest, int32_t destCapacity,
       const UChar *src, int32_t srcLength,
       const char *locale,
       UErrorCode *pErrorCode);
       */
    err = U_ZERO_ERROR;
    /* use all available space &#45; see below XXX */
    /* TODO downcase, titlecase too */
    dest_len = PObj_buflen(src) / sizeof (UChar);
    src_len = src&#45;&#62;bufused / sizeof (UChar);
    /*
     * XXX troubles:
     *   t/op/string_cs_45  upcase unicode:&#34;\u01f0&#34;
     *   this creates \u004a \u030c J+NON&#45;SPACING HACEK
     *   the string needs resizing, *if* the src buffer is
     *   too short. *But* with icu 3.2/3.4 the src string is
     *   overwritten with partial result, despite the icu docs sayeth:
     *
     *      The source string and the destination buffer
     *      are allowed to overlap.
     *
     *  Workaround:  &#39;preflighting&#39; returns needed length
     *  Alternative: forget about inplace operation &#45; create new result
     *
     *  TODO downcase, titlecase
     */
    needed = u_strToUpper(NULL, 0,
            (UChar *)src&#45;&#62;strstart, src_len,
            NULL,       /* locale = default */
            &#38;err);
    if (needed &#62; dest_len) {
        Parrot_reallocate_string(interp, src, needed * sizeof (UChar));
        dest_len = needed;
    }
    err = U_ZERO_ERROR;
    dest_len = u_strToUpper((UChar *)src&#45;&#62;strstart, dest_len,
            (UChar *)src&#45;&#62;strstart, src_len,
            NULL,       /* locale = default */
            &#38;err);
    PARROT_ASSERT(U_SUCCESS(err));
    src&#45;&#62;bufused = dest_len * sizeof (UChar);
    /* downgrade if possible */
    if (dest_len == (int)src&#45;&#62;strlen)
        src&#45;&#62;encoding = Parrot_ucs2_encoding_ptr;
    else {
        /* string is likely still ucs2 if it was earlier
         * but strlen changed tue to combining char
         */
        src&#45;&#62;strlen = dest_len;
    }
#else
    real_exception(interp, NULL, E_LibraryNotLoadedError,
            &#34;no ICU lib loaded&#34;);
#endif
}</pre>

<p>static void downcase(PARROT_INTERP, NOTNULL(STRING *src)) { #if PARROT_HAS_ICU</p>

<pre lang='und' xml:lang='und'>    UErrorCode err;
    int dest_len, src_len;

    if (src&#45;&#62;bufused == src&#45;&#62;strlen &#38;&#38;
            src&#45;&#62;encoding == Parrot_utf8_encoding_ptr) {
        Parrot_ascii_charset_ptr&#45;&#62;downcase(interp, src);
        return;
    }

    src = Parrot_utf16_encoding_ptr&#45;&#62;to_encoding(interp, src, NULL);
    /*
U_CAPI int32_t U_EXPORT2
u_strToLower(UChar *dest, int32_t destCapacity,
             const UChar *src, int32_t srcLength,
             const char *locale,
             UErrorCode *pErrorCode);
     */
    err = U_ZERO_ERROR;
    src_len = src&#45;&#62;bufused / sizeof (UChar);
    dest_len = u_strToLower((UChar *)src&#45;&#62;strstart, src_len,
            (UChar *)src&#45;&#62;strstart, src_len,
            NULL,       /* locale = default */
            &#38;err);
    src&#45;&#62;bufused = dest_len * sizeof (UChar);
    if (!U_SUCCESS(err)) {
        err = U_ZERO_ERROR;
        Parrot_reallocate_string(interp, src, src&#45;&#62;bufused);
        dest_len = u_strToLower((UChar *)src&#45;&#62;strstart, dest_len,
                (UChar *)src&#45;&#62;strstart, src_len,
                NULL,       /* locale = default */
                &#38;err);
        PARROT_ASSERT(U_SUCCESS(err));
    }
    /* downgrade if possible */
    if (dest_len == (int)src&#45;&#62;strlen)
        src&#45;&#62;encoding = Parrot_ucs2_encoding_ptr;
#else
    real_exception(interp, NULL, E_LibraryNotLoadedError,
            &#34;no ICU lib loaded&#34;);
#endif
}</pre>

<p>static void titlecase(PARROT_INTERP, NOTNULL(STRING *src)) { #if PARROT_HAS_ICU</p>

<pre lang='und' xml:lang='und'>    UErrorCode err;
    int dest_len, src_len;

    if (src&#45;&#62;bufused == src&#45;&#62;strlen &#38;&#38;
            src&#45;&#62;encoding == Parrot_utf8_encoding_ptr) {
        Parrot_ascii_charset_ptr&#45;&#62;titlecase(interp, src);
        return;
    }
    src = Parrot_utf16_encoding_ptr&#45;&#62;to_encoding(interp, src, NULL);
    /*
U_CAPI int32_t U_EXPORT2
u_strToTitle(UChar *dest, int32_t destCapacity,
             const UChar *src, int32_t srcLength,
             UBreakIterator *titleIter,
             const char *locale,
             UErrorCode *pErrorCode);
     */
    err = U_ZERO_ERROR;
    src_len = src&#45;&#62;bufused / sizeof (UChar);
    dest_len = u_strToTitle((UChar *)src&#45;&#62;strstart, src_len,
            (UChar *)src&#45;&#62;strstart, src_len,
            NULL,       /* default titleiter */
            NULL,       /* locale = default */
            &#38;err);
    src&#45;&#62;bufused = dest_len * sizeof (UChar);
    if (!U_SUCCESS(err)) {
        err = U_ZERO_ERROR;
        Parrot_reallocate_string(interp, src, src&#45;&#62;bufused);
        dest_len = u_strToTitle((UChar *)src&#45;&#62;strstart, dest_len,
                (UChar *)src&#45;&#62;strstart, src_len,
                NULL, NULL,
                &#38;err);
        PARROT_ASSERT(U_SUCCESS(err));
    }
    /* downgrade if possible */
    if (dest_len == (int)src&#45;&#62;strlen)
        src&#45;&#62;encoding = Parrot_ucs2_encoding_ptr;
#else
    real_exception(interp, NULL, E_LibraryNotLoadedError,
            &#34;no ICU lib loaded&#34;);
#endif
}</pre>

<p>static void upcase_first(PARROT_INTERP, NOTNULL(STRING *source_string)) { UNIMPL; }</p>

<p>static void downcase_first(PARROT_INTERP, NOTNULL(STRING *source_string)) { UNIMPL; }</p>

<p>static void titlecase_first(PARROT_INTERP, NOTNULL(STRING *source_string)) { UNIMPL; }</p>

<p>static INTVAL compare(PARROT_INTERP, NOTNULL(const STRING *lhs), NOTNULL(const STRING *rhs)) { String_iter l_iter, r_iter; UINTVAL offs, cl, cr, min_len, l_len, r_len;</p>

<pre lang='und' xml:lang='und'>    /* TODO make optimized equal &#45; strings are equal length then already */
    ENCODING_ITER_INIT(interp, lhs, &#38;l_iter);
    ENCODING_ITER_INIT(interp, rhs, &#38;r_iter);
    l_len = lhs&#45;&#62;strlen;
    r_len = rhs&#45;&#62;strlen;
    min_len = l_len &#62; r_len ? r_len : l_len;
    for (offs = 0; offs &#60; min_len; ++offs) {
        cl = l_iter.get_and_advance(interp, &#38;l_iter);
        cr = r_iter.get_and_advance(interp, &#38;r_iter);
        if (cl != cr)
            return cl &#60; cr ? &#45;1 : 1;
    }
    if (l_len &#60; r_len) {
        return &#45;1;
    }
    if (l_len &#62; r_len) {
        return 1;
    }
    return 0;
}</pre>

<p>static INTVAL cs_rindex(PARROT_INTERP, NOTNULL(STRING *source_string), SHIM(STRING *search_string), UINTVAL offset) { UNIMPL; }</p>

<p>static UINTVAL validate(PARROT_INTERP, NOTNULL(STRING *src)) { UINTVAL offset;</p>

<pre lang='und' xml:lang='und'>    for (offset = 0; offset &#60; string_length(interp, src); ++offset) {
        const UINTVAL codepoint = ENCODING_GET_CODEPOINT(interp, src, offset);
        /* Check for Unicode non&#45;characters */
        if (codepoint &#62;= 0xfdd0 &#38;&#38;
            (codepoint &#60;= 0xfdef || (codepoint &#38; 0xfffe) == 0xfffe) &#38;&#38;
                codepoint &#60;= 0x10ffff)
                    return 0;
    }
    return 1;
}</pre>

<p>static int u_iscclass(PARROT_INTERP, UINTVAL codepoint, INTVAL flags) { #if PARROT_HAS_ICU /* XXX which one return u_charDigitValue(codepoint); */ if ((flags &#38; enum_cclass_uppercase) &#38;&#38; u_isupper(codepoint)) return 1; if ((flags &#38; enum_cclass_lowercase) &#38;&#38; u_islower(codepoint)) return 1; if ((flags &#38; enum_cclass_alphabetic) &#38;&#38; u_isalpha(codepoint)) return 1; if ((flags &#38; enum_cclass_numeric) &#38;&#38; u_isdigit(codepoint)) return 1; if ((flags &#38; enum_cclass_hexadecimal) &#38;&#38; u_isxdigit(codepoint)) return 1; if ((flags &#38; enum_cclass_whitespace) &#38;&#38; u_isspace(codepoint)) return 1; if ((flags &#38; enum_cclass_printing) &#38;&#38; u_isprint(codepoint)) return 1; if ((flags &#38; enum_cclass_graphical) &#38;&#38; u_isgraph(codepoint)) return 1; if ((flags &#38; enum_cclass_blank) &#38;&#38; u_isblank(codepoint)) return 1; if ((flags &#38; enum_cclass_control) &#38;&#38; u_iscntrl(codepoint)) return 1; if ((flags &#38; enum_cclass_alphanumeric) &#38;&#38; u_isalnum(codepoint)) return 1; if ((flags &#38; enum_cclass_word) &#38;&#38; (u_isalnum(codepoint) || codepoint == &#39;_&#39;)) return 1; return 0; #else if (codepoint &#60; 256) { return (Parrot_iso_8859_1_typetable[codepoint] &#38; flags) ? 1 : 0; } if (flags &#38; enum_cclass_whitespace) { /* from <a href="http://www.unicode.org/Public/UNIDATA/PropList.txt">http://www.unicode.org/Public/UNIDATA/PropList.txt</a> */ switch (codepoint) { case 0x1680: case 0x180e: case 0x2000: case 0x2001: case 0x2002: case 0x2003: case 0x2004: case 0x2005: case 0x2006: case 0x2007: case 0x2008: case 0x2009: case 0x200a: case 0x202f: case 0x205f: case 0x3000: return 1; } } if (flags &#38; enum_cclass_numeric) { /* from <a href="http://www.unicode.org/Public/UNIDATA/UnicodeData.txt">http://www.unicode.org/Public/UNIDATA/UnicodeData.txt</a> */ if (codepoint &#62;= 0x0660 &#38;&#38; codepoint &#60;= 0x0669) return 1; if (codepoint &#62;= 0x06f0 &#38;&#38; codepoint &#60;= 0x06f9) return 1; if (codepoint &#62;= 0x07c0 &#38;&#38; codepoint &#60;= 0x07c9) return 1; if (codepoint &#62;= 0x0966 &#38;&#38; codepoint &#60;= 0x096f) return 1; if (codepoint &#62;= 0x09e6 &#38;&#38; codepoint &#60;= 0x09ef) return 1; if (codepoint &#62;= 0x0a66 &#38;&#38; codepoint &#60;= 0x0a6f) return 1; if (codepoint &#62;= 0x0ae6 &#38;&#38; codepoint &#60;= 0x0aef) return 1; if (codepoint &#62;= 0x0b66 &#38;&#38; codepoint &#60;= 0x0b6f) return 1; if (codepoint &#62;= 0x0be6 &#38;&#38; codepoint &#60;= 0x0bef) return 1; if (codepoint &#62;= 0x0c66 &#38;&#38; codepoint &#60;= 0x0c6f) return 1; if (codepoint &#62;= 0x0ce6 &#38;&#38; codepoint &#60;= 0x0cef) return 1; if (codepoint &#62;= 0x0d66 &#38;&#38; codepoint &#60;= 0x0d6f) return 1; if (codepoint &#62;= 0x0e50 &#38;&#38; codepoint &#60;= 0x0e59) return 1; if (codepoint &#62;= 0x0ed0 &#38;&#38; codepoint &#60;= 0x0ed9) return 1; if (codepoint &#62;= 0x0f20 &#38;&#38; codepoint &#60;= 0x0f29) return 1; if (codepoint &#62;= 0x1040 &#38;&#38; codepoint &#60;= 0x1049) return 1; if (codepoint &#62;= 0x17e0 &#38;&#38; codepoint &#60;= 0x17e9) return 1; if (codepoint &#62;= 0x1810 &#38;&#38; codepoint &#60;= 0x1819) return 1; if (codepoint &#62;= 0x1946 &#38;&#38; codepoint &#60;= 0x194f) return 1; if (codepoint &#62;= 0x19d0 &#38;&#38; codepoint &#60;= 0x19d9) return 1; if (codepoint &#62;= 0x1b50 &#38;&#38; codepoint &#60;= 0x1b59) return 1; if (codepoint &#62;= 0xff10 &#38;&#38; codepoint &#60;= 0xff19) return 1; } if (flags &#38; ~(enum_cclass_whitespace | enum_cclass_numeric)) real_exception(interp, NULL, E_LibraryNotLoadedError, &#34;no ICU lib loaded&#34;); return 0; #endif }</p>

<p>static INTVAL is_cclass(PARROT_INTERP, INTVAL flags, NOTNULL(STRING *source_string), UINTVAL offset) { UINTVAL codepoint;</p>

<pre lang='und' xml:lang='und'>    if (offset &#62;= source_string&#45;&#62;strlen)
        return 0;
    codepoint = ENCODING_GET_CODEPOINT(interp, source_string, offset);
    if (codepoint &#62;= 256) {
        return u_iscclass(interp, codepoint, flags) != 0;
    }
    return (Parrot_iso_8859_1_typetable[codepoint] &#38; flags) ? 1 : 0;
}</pre>

<p>static INTVAL find_cclass(PARROT_INTERP, INTVAL flags, NOTNULL(STRING *source_string), UINTVAL offset, UINTVAL count) { UINTVAL pos = offset; UINTVAL end = offset + count; UINTVAL codepoint;</p>

<pre lang='und' xml:lang='und'>    PARROT_ASSERT(source_string != 0);
    end = source_string&#45;&#62;strlen &#60; end ? source_string&#45;&#62;strlen : end;
    for (; pos &#60; end; ++pos) {
        codepoint = ENCODING_GET_CODEPOINT(interp, source_string, pos);
        if (codepoint &#62;= 256) {
            if (u_iscclass(interp, codepoint, flags))
                    return pos;
        }
        else {
            if (Parrot_iso_8859_1_typetable[codepoint] &#38; flags) {
                return pos;
            }
        }
    }
    return end;
}</pre>

<p>static INTVAL find_not_cclass(PARROT_INTERP, INTVAL flags, NOTNULL(STRING *source_string), UINTVAL offset, UINTVAL count) { UINTVAL pos = offset; UINTVAL end = offset + count; UINTVAL codepoint; int bit;</p>

<pre lang='und' xml:lang='und'>    PARROT_ASSERT(source_string);
    end = source_string&#45;&#62;strlen &#60; end ? source_string&#45;&#62;strlen : end;
    for (; pos &#60; end; ++pos) {
        codepoint = ENCODING_GET_CODEPOINT(interp, source_string, pos);
        if (codepoint &#62;= 256) {
            for (bit = enum_cclass_uppercase;
                    bit &#60;= enum_cclass_word ; bit &#60;&#60;= 1) {
                if ((bit &#38; flags) &#38;&#38; !u_iscclass(interp, codepoint, bit))
                    return pos;
            }
        }
        else {
            if (!(Parrot_iso_8859_1_typetable[codepoint] &#38; flags)) {
                return pos;
            }
        }
    }
    return end;
}</pre>

<p>static STRING * string_from_codepoint(PARROT_INTERP, UINTVAL codepoint) { String_iter iter; STRING * const dest = string_make(interp, &#34;&#34;, 1, &#34;unicode&#34;, 0);</p>

<pre lang='und' xml:lang='und'>    dest&#45;&#62;strlen = 1;
    ENCODING_ITER_INIT(interp, dest, &#38;iter);
    iter.set_and_advance(interp, &#38;iter, codepoint);
    dest&#45;&#62;bufused = iter.bytepos;

    return dest;
}</pre>

<p>static size_t compute_hash(PARROT_INTERP, NOTNULL(const STRING *src), size_t seed) { String_iter iter; size_t hashval = seed; UINTVAL offs;</p>

<pre lang='und' xml:lang='und'>    ENCODING_ITER_INIT(interp, src, &#38;iter);
    for (offs = 0; offs &#60; src&#45;&#62;strlen; ++offs) {
        const UINTVAL c = iter.get_and_advance(interp, &#38;iter);
        hashval += hashval &#60;&#60; 5;
        hashval += c;
    }
    return hashval;
}</pre>

<p>PARROT_CANNOT_RETURN_NULL const CHARSET * Parrot_charset_unicode_init(PARROT_INTERP) { CHARSET * const return_set = Parrot_new_charset(interp); static const CHARSET base_set = { &#34;unicode&#34;, get_graphemes, get_graphemes_inplace, set_graphemes, to_charset, compose, decompose, upcase, downcase, titlecase, upcase_first, downcase_first, titlecase_first, compare, mixed_cs_index, cs_rindex, validate, is_cclass, find_cclass, find_not_cclass, string_from_codepoint, compute_hash, NULL };</p>

<pre lang='und' xml:lang='und'>    STRUCT_COPY(return_set, &#38;base_set);
    /*
     * for now use utf8
     * TODO replace it with a fixed uint_16 or uint_32 encoding
     *      XXX if this is changed, modify string_make so it
     *          still takes &#34;utf8&#34; when fed &#34;unicode&#34; as charset!
     */
    return_set&#45;&#62;preferred_encoding = Parrot_utf8_encoding_ptr;
    Parrot_register_charset(interp, &#34;unicode&#34;, return_set);
    return return_set;
}</pre>

<p>/* * Local variables: * c&#45;file&#45;style: &#34;parrot&#34; * End: * vim: expandtab shiftwidth=4: */</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
