<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Untitled</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Untitled</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../html/index.html">Contents</a> | <a href="../../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>src/charset/iso&#45;8859&#45;1.c</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>This file implements the charset functions for iso&#45;8859&#45;1 data</p>

<p>*/</p>

<p>#include &#34;parrot/parrot.h&#34; #include &#34;iso&#45;8859&#45;1.h&#34; #include &#34;ascii.h&#34;</p>

<p>/* HEADERIZER HFILE: src/charset/iso&#45;8859&#45;1.h */</p>

<p>/* HEADERIZER BEGIN: static */</p>

<p>PARROT_WARN_UNUSED_RESULT static STRING* compose( PARROT_INTERP,
NOTNULL(STRING *src) ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>static STRING* decompose( PARROT_INTERP,
SHIM(STRING *src) ) __attribute__nonnull__(1);</p>

<p>static void downcase( PARROT_INTERP,
NOTNULL(STRING *source_string) ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>static void downcase_first( PARROT_INTERP,
NOTNULL(STRING *source_string) ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>static INTVAL find_cclass( PARROT_INTERP,
INTVAL flags,
NOTNULL(STRING *source_string),
UINTVAL offset,
UINTVAL count ) __attribute__nonnull__(1) __attribute__nonnull__(3);</p>

<p>static INTVAL find_not_cclass( PARROT_INTERP,
INTVAL flags,
NOTNULL(STRING *source_string),
UINTVAL offset,
UINTVAL count ) __attribute__nonnull__(1) __attribute__nonnull__(3);</p>

<p>static INTVAL is_cclass( PARROT_INTERP,
INTVAL flags,
NOTNULL(STRING *source_string),
UINTVAL offset ) __attribute__nonnull__(1) __attribute__nonnull__(3);</p>

<p>static void set_graphemes( PARROT_INTERP,
NOTNULL(STRING *source_string),
UINTVAL offset,
UINTVAL replace_count,
NOTNULL(STRING *insert_string) ) __attribute__nonnull__(1) __attribute__nonnull__(2) __attribute__nonnull__(5);</p>

<p>static STRING * string_from_codepoint( PARROT_INTERP,
UINTVAL codepoint ) __attribute__nonnull__(1);</p>

<p>static void titlecase( PARROT_INTERP,
NOTNULL(STRING *source_string) ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>static void titlecase_first( PARROT_INTERP,
NOTNULL(STRING *source_string) ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>PARROT_WARN_UNUSED_RESULT static STRING * to_charset( PARROT_INTERP,
NOTNULL(STRING *src),
NOTNULL(STRING *dest) ) __attribute__nonnull__(1) __attribute__nonnull__(2) __attribute__nonnull__(3);</p>

<p>static STRING * to_latin1( PARROT_INTERP,
NOTNULL(STRING *src),
NULLOK(STRING *dest) ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>static STRING * to_unicode( PARROT_INTERP,
NOTNULL(STRING *src),
NULLOK(STRING *dest) ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>static void upcase( PARROT_INTERP,
NOTNULL(STRING *source_string) ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>static void upcase_first( PARROT_INTERP,
NOTNULL(STRING *source_string) ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>static UINTVAL validate( PARROT_INTERP,
NOTNULL(STRING *src) ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>/* HEADERIZER END: static */</p>

<p>#include &#34;tables.h&#34;</p>

<p>static void set_graphemes(PARROT_INTERP,
NOTNULL(STRING *source_string),
UINTVAL offset,
UINTVAL replace_count,
NOTNULL(STRING *insert_string)) { ENCODING_SET_BYTES(interp,
source_string,
offset,
replace_count,
insert_string); }</p>

<p>static STRING * to_latin1(PARROT_INTERP,
NOTNULL(STRING *src),
NULLOK(STRING *dest)) { UINTVAL offs,
src_len; String_iter iter;</p>

<pre lang='und' xml:lang='und'>    ENCODING_ITER_INIT(interp, src, &#38;iter);
    src_len = src&#45;&#62;strlen;
    if (dest) {
        Parrot_reallocate_string(interp, dest, src_len);
        dest&#45;&#62;strlen  = src_len;
    }
    else {
        /* latin1 is never bigger then source */
        dest = src;
    }
    dest&#45;&#62;bufused = src_len;
    dest&#45;&#62;charset = Parrot_iso_8859_1_charset_ptr;
    dest&#45;&#62;encoding = Parrot_fixed_8_encoding_ptr;
    for (offs = 0; offs &#60; src_len; ++offs) {
        const UINTVAL c = iter.get_and_advance(interp, &#38;iter);
        if (c &#62;= 0x100)
            real_exception(interp, NULL, LOSSY_CONVERSION, &#34;lossy conversion to ascii&#34;);
        ENCODING_SET_BYTE(interp, dest, offs, c);
    }
    return dest;
}</pre>

<p>static STRING * to_unicode(PARROT_INTERP, NOTNULL(STRING *src), NULLOK(STRING *dest)) { if (dest) { UINTVAL offs; String_iter iter;</p>

<pre lang='und' xml:lang='und'>        dest&#45;&#62;charset = Parrot_unicode_charset_ptr;
        dest&#45;&#62;encoding = CHARSET_GET_PREFERRED_ENCODING(interp, dest);
        Parrot_reallocate_string(interp, dest, src&#45;&#62;strlen);
        ENCODING_ITER_INIT(interp, dest, &#38;iter);
        for (offs = 0; offs &#60; src&#45;&#62;strlen; ++offs) {
            const UINTVAL c = ENCODING_GET_BYTE(interp, src, offs);

            if (iter.bytepos &#62;= PObj_buflen(dest) &#45; 4) {
                UINTVAL need = (UINTVAL)((src&#45;&#62;strlen &#45; offs) * 1.5);
                if (need &#60; 16)
                    need = 16;
                Parrot_reallocate_string(interp, dest,
                        PObj_buflen(dest) + need);
            }
            iter.set_and_advance(interp, &#38;iter, c);
        }
        dest&#45;&#62;bufused = iter.bytepos;
        dest&#45;&#62;strlen  = iter.charpos;
        return dest;
    }
    real_exception(interp, NULL, UNIMPLEMENTED,
            &#34;to_unicode inplace for iso&#45;8859&#45;1 not implemented&#34;);
}</pre>

<p>PARROT_WARN_UNUSED_RESULT static STRING * to_charset(PARROT_INTERP, NOTNULL(STRING *src), NOTNULL(STRING *dest)) { const charset_converter_t conversion_func = Parrot_find_charset_converter(interp, src&#45;&#62;charset, Parrot_iso_8859_1_charset_ptr);</p>

<pre lang='und' xml:lang='und'>    if (conversion_func)
         return conversion_func(interp, src, dest);
    else
        return to_latin1(interp, src, dest);
}</pre>

<p>/* A noop. can&#39;t compose iso&#45;8859&#45;1 */ PARROT_WARN_UNUSED_RESULT static STRING* compose(PARROT_INTERP, NOTNULL(STRING *src)) { return string_copy(interp, src); }</p>

<p>static STRING* decompose(PARROT_INTERP, SHIM(STRING *src)) { real_exception(interp, NULL, UNIMPLEMENTED, &#34;decompose for iso&#45;8859&#45;1 not implemented&#34;); }</p>

<p>static void upcase(PARROT_INTERP, NOTNULL(STRING *source_string)) { unsigned char *buffer; UINTVAL offset = 0;</p>

<pre lang='und' xml:lang='und'>    if (!source_string&#45;&#62;strlen)
        return;

    Parrot_unmake_COW(interp, source_string);
    buffer = (unsigned char *)source_string&#45;&#62;strstart;
    for (offset = 0; offset &#60; source_string&#45;&#62;strlen; offset++) {
        unsigned int c = buffer[offset]; /* XXX use encoding ? */
        if (c &#62;= 0xe0 &#38;&#38; c != 0xf7)
            c &#38;= ~0x20;
        else
            c = toupper((unsigned char)c);
        buffer[offset] = c;
    }
}</pre>

<p>static void downcase(PARROT_INTERP, NOTNULL(STRING *source_string)) { if (source_string&#45;&#62;strlen) { UINTVAL offset; unsigned char *buffer;</p>

<pre lang='und' xml:lang='und'>        Parrot_unmake_COW(interp, source_string);
        buffer = (unsigned char *)source_string&#45;&#62;strstart;
        for (offset = 0; offset &#60; source_string&#45;&#62;strlen; offset++) {
            unsigned int c = buffer[offset];
            if (c &#62;= 0xc0 &#38;&#38; c != 0xd7 &#38;&#38; c &#60;= 0xde)
                c |= 0x20;
            else
                c = tolower((unsigned char)c);
            buffer[offset] = c;
        }
    }
}</pre>

<p>static void titlecase(PARROT_INTERP, NOTNULL(STRING *source_string)) { unsigned char *buffer; unsigned int c; UINTVAL offset;</p>

<pre lang='und' xml:lang='und'>    if (!source_string&#45;&#62;strlen)
        return;

    Parrot_unmake_COW(interp, source_string);
    buffer = (unsigned char *)source_string&#45;&#62;strstart;
    c = buffer[0];
    if (c &#62;= 0xe0 &#38;&#38; c != 0xf7)
        c &#38;= ~0x20;
    else
        c = toupper((unsigned char)c);
    buffer[0] = c;

    for (offset = 1; offset &#60; source_string&#45;&#62;strlen; offset++) {
        c = buffer[offset];
        if (c &#62;= 0xc0 &#38;&#38; c != 0xd7 &#38;&#38; c &#60;= 0xde)
            c |= 0x20;
        else
            c = tolower((unsigned char)c);
        buffer[offset] = c;
    }
}</pre>

<p>static void upcase_first(PARROT_INTERP, NOTNULL(STRING *source_string)) { if (source_string&#45;&#62;strlen) { unsigned char *buffer; unsigned int c;</p>

<pre lang='und' xml:lang='und'>        Parrot_unmake_COW(interp, source_string);
        buffer = (unsigned char *)source_string&#45;&#62;strstart;
        c = buffer[0];
        if (c &#62;= 0xe0 &#38;&#38; c != 0xf7)
            c &#38;= ~0x20;
        else
            c = toupper((unsigned char)c);
        buffer[0] = c;
    }
}</pre>

<p>static void downcase_first(PARROT_INTERP, NOTNULL(STRING *source_string)) { if (source_string&#45;&#62;strlen) { unsigned char *buffer; unsigned int c;</p>

<pre lang='und' xml:lang='und'>        Parrot_unmake_COW(interp, source_string);
        buffer = (unsigned char *)source_string&#45;&#62;strstart;
        c = buffer[0];
        if (c &#62;= 0xc0 &#38;&#38; c != 0xd7 &#38;&#38; c &#60;= 0xde)
            c &#38;= ~0x20;
        else
            c = tolower((unsigned char)c);
        buffer[0] = c;
        buffer[0] = toupper((unsigned char)buffer[0]);
    }
}</pre>

<p>static void titlecase_first(PARROT_INTERP, NOTNULL(STRING *source_string)) { upcase_first(interp, source_string); }</p>

<p>static UINTVAL validate(PARROT_INTERP, NOTNULL(STRING *src)) { UINTVAL offset;</p>

<pre lang='und' xml:lang='und'>    for (offset = 0; offset &#60; string_length(interp, src); ++offset) {
        const UINTVAL codepoint = ENCODING_GET_CODEPOINT(interp, src, offset);
        if (codepoint &#62;= 0x100)
            return 0;
    }
    return 1;
}</pre>

<p>static INTVAL is_cclass(PARROT_INTERP, INTVAL flags, NOTNULL(STRING *source_string), UINTVAL offset) { UINTVAL codepoint;</p>

<pre lang='und' xml:lang='und'>    if (offset &#62;= source_string&#45;&#62;strlen) return 0;
    codepoint = ENCODING_GET_CODEPOINT(interp, source_string, offset);

    if (codepoint &#62;= sizeof (Parrot_ascii_typetable) /
                     sizeof (Parrot_ascii_typetable[0])) {
        return 0;
    }
    return (Parrot_iso_8859_1_typetable[codepoint] &#38; flags) ? 1 : 0;
}</pre>

<p>static INTVAL find_cclass(PARROT_INTERP, INTVAL flags, NOTNULL(STRING *source_string), UINTVAL offset, UINTVAL count) { UINTVAL pos = offset; UINTVAL end = offset + count; UINTVAL codepoint;</p>

<pre lang='und' xml:lang='und'>    PARROT_ASSERT(source_string != 0);
    end = source_string&#45;&#62;strlen &#60; end ? source_string&#45;&#62;strlen : end;
    for (; pos &#60; end; ++pos) {
        codepoint = ENCODING_GET_CODEPOINT(interp, source_string, pos);
        if ((Parrot_iso_8859_1_typetable[codepoint] &#38; flags) != 0) {
            return pos;
        }
    }
    return end;
}</pre>

<p>static INTVAL find_not_cclass(PARROT_INTERP, INTVAL flags, NOTNULL(STRING *source_string), UINTVAL offset, UINTVAL count) { UINTVAL pos = offset; UINTVAL end = offset + count;</p>

<pre lang='und' xml:lang='und'>    PARROT_ASSERT(source_string);
    end = source_string&#45;&#62;strlen &#60; end ? source_string&#45;&#62;strlen : end;
    for (; pos &#60; end; ++pos) {
        const UINTVAL codepoint = ENCODING_GET_CODEPOINT(interp, source_string, pos);
        if ((Parrot_iso_8859_1_typetable[codepoint] &#38; flags) == 0) {
            return pos;
        }
    }
    return end;
}</pre>

<p>static STRING * string_from_codepoint(PARROT_INTERP, UINTVAL codepoint) { char real_codepoint = (char)codepoint; STRING * const return_string = string_make(interp, &#38;real_codepoint, 1, &#34;iso&#45;8859&#45;1&#34;, 0); return return_string; }</p>

<p>PARROT_CANNOT_RETURN_NULL const CHARSET * Parrot_charset_iso_8859_1_init(PARROT_INTERP) { CHARSET * const return_set = Parrot_new_charset(interp); static const CHARSET base_set = { &#34;iso&#45;8859&#45;1&#34;, ascii_get_graphemes, ascii_get_graphemes_inplace, set_graphemes, to_charset, compose, decompose, upcase, downcase, titlecase, upcase_first, downcase_first, titlecase_first, ascii_compare, ascii_cs_index, ascii_cs_rindex, validate, is_cclass, find_cclass, find_not_cclass, string_from_codepoint, ascii_compute_hash, NULL };</p>

<pre lang='und' xml:lang='und'>    STRUCT_COPY(return_set, &#38;base_set);
    return_set&#45;&#62;preferred_encoding = Parrot_fixed_8_encoding_ptr;
    Parrot_register_charset(interp, &#34;iso&#45;8859&#45;1&#34;, return_set);
    return return_set;
}</pre>

<p>PARROT_WARN_UNUSED_RESULT STRING * charset_cvt_iso_8859_1_to_ascii(PARROT_INTERP, NOTNULL(STRING *src), NULLOK(STRING *dest)) { UINTVAL offs; if (dest) { Parrot_reallocate_string(interp, dest, src&#45;&#62;strlen); dest&#45;&#62;bufused = src&#45;&#62;bufused; dest&#45;&#62;strlen = src&#45;&#62;strlen; } for (offs = 0; offs &#60; src&#45;&#62;strlen; ++offs) { UINTVAL c = ENCODING_GET_BYTE(interp, src, offs); if (c &#62;= 0x80) real_exception(interp, NULL, LOSSY_CONVERSION, &#34;lossy conversion to ascii&#34;); if (dest) ENCODING_SET_BYTE(interp, dest, offs, c); } if (dest) return dest; src&#45;&#62;charset = Parrot_ascii_charset_ptr; return src; }</p>

<p>/* * Local variables: * c&#45;file&#45;style: &#34;parrot&#34; * End: * vim: expandtab shiftwidth=4: */</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
