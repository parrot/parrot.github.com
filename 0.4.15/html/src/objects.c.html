<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Class and object</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Class and object</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../html/index.html">Contents</a> | <a href="../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>objects.c &#45; Class and object</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>Handles class and object manipulation.</p>

<h2><a name="Functions"
>Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>*/</p>

<p>#define PARROT_IN_OBJECTS_C #include &#34;parrot/parrot.h&#34; #include &#34;parrot/objects.h&#34;</p>

<p>#include &#34;objects.str&#34;</p>

<p>/* HEADERIZER HFILE: include/parrot/objects.h */</p>

<p>/* HEADERIZER BEGIN: static */</p>

<p>static INTVAL attr_str_2_num( PARROT_INTERP,
NOTNULL(PMC *object),
NOTNULL(STRING *attr) ) __attribute__nonnull__(1) __attribute__nonnull__(2) __attribute__nonnull__(3);</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CAN_RETURN_NULL static PMC* C3_merge( PARROT_INTERP,
NOTNULL(PMC *merge_list) ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL static PMC* class_mro_merge( PARROT_INTERP,
NOTNULL(PMC *seqs) ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL static PMC* create_class_mro( PARROT_INTERP,
NOTNULL(PMC *_class) ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>static void create_deleg_pmc_vtable( PARROT_INTERP,
NOTNULL(PMC *_class),
int full ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>static void debug_trace_find_meth( PARROT_INTERP,
NOTNULL(PMC *_class),
NOTNULL(STRING *name),
NULLOK(PMC *sub) ) __attribute__nonnull__(1) __attribute__nonnull__(2) __attribute__nonnull__(3);</p>

<p>static void do_initcall( PARROT_INTERP,
NULLOK(PMC* _class),
NULLOK(PMC *object),
NULLOK(PMC *init) ) __attribute__nonnull__(1);</p>

<p>static void fail_if_exist( PARROT_INTERP,
NOTNULL(PMC *name) ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CAN_RETURN_NULL static PMC * find_method_direct_1( PARROT_INTERP,
NOTNULL(PMC *_class),
NOTNULL(STRING *method_name) ) __attribute__nonnull__(1) __attribute__nonnull__(2) __attribute__nonnull__(3);</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CAN_RETURN_NULL static PMC* find_vtable_meth_ns( PARROT_INTERP,
NOTNULL(PMC *ns),
INTVAL vtable_index ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CAN_RETURN_NULL static PMC* get_init_meth( PARROT_INTERP,
NOTNULL(PMC *_class),
NOTNULL(STRING *prop_str),
NOTNULL(STRING **meth_str) ) __attribute__nonnull__(1) __attribute__nonnull__(2) __attribute__nonnull__(3) __attribute__nonnull__(4);</p>

<p>static void instantiate_object( PARROT_INTERP,
NOTNULL(PMC *object),
NULLOK(PMC *init) ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>static void invalidate_all_caches( PARROT_INTERP ) __attribute__nonnull__(1);</p>

<p>static void invalidate_type_caches( PARROT_INTERP,
UINTVAL type ) __attribute__nonnull__(1);</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL static PMC* not_empty( PARROT_INTERP,
NOTNULL(PMC *seqs) ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>static void parrot_class_register( PARROT_INTERP,
NOTNULL(PMC *name),
NOTNULL(PMC *new_class),
NULLOK(PMC *parent),
NOTNULL(PMC *mro) ) __attribute__nonnull__(1) __attribute__nonnull__(2) __attribute__nonnull__(3) __attribute__nonnull__(5);</p>

<p>static void rebuild_attrib_stuff( PARROT_INTERP,
NOTNULL(PMC *_class) ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>PARROT_WARN_UNUSED_RESULT static INTVAL register_type( PARROT_INTERP,
NOTNULL(PMC *name) ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>/* HEADERIZER END: static */</p>

<p>/*</p>

<p>FUNCDOC: Parrot_get_vtable_index</p>

<p>Return index if <code lang='und' xml:lang='und'>name</code> is a valid vtable slot name.</p>

<p>*/</p>

<p>PARROT_API INTVAL Parrot_get_vtable_index(PARROT_INTERP,
NOTNULL(const STRING *name)) { char * const name_c = string_to_cstring(interp,
name);</p>

<pre lang='und' xml:lang='und'>    /* some of the first &#34;slots&#34; don&#39;t have names. skip &#39;em. */
    INTVAL low               = PARROT_VTABLE_LOW;
    INTVAL high              = NUM_VTABLE_FUNCTIONS + PARROT_VTABLE_LOW;

    while (low &#60; high) {
        const INTVAL       mid    = (low + high) / 2;
        const char * const meth_c = Parrot_vtable_slot_names[mid];

        /* XXX slot_names still have __ in front */
        const INTVAL cmp = strcmp(name_c, meth_c + 2);

        if (cmp == 0) {
            string_cstring_free(name_c);
            return mid;
        }
        else if (cmp &#62; 0)
            low  = mid + 1;
        else
            high = mid;
    }

    string_cstring_free(name_c);

    return &#45;1;
}</pre>

<p>/*</p>

<p>FUNCDOC: find_vtable_meth_ns</p>

<p>Return Sub PMC if a method with the vtable name exists in ns</p>

<p>*/</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CAN_RETURN_NULL static PMC* find_vtable_meth_ns(PARROT_INTERP, NOTNULL(PMC *ns), INTVAL vtable_index) { return VTABLE_get_pmc_keyed_int(interp, ns, vtable_index); }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_find_vtable_meth</p>

<p>Given pmc, run through its mro looking for the meth vtable method. Return the vtable method PMC if found.</p>

<p>*/</p>

<p>PARROT_API PARROT_CAN_RETURN_NULL PMC* Parrot_find_vtable_meth(PARROT_INTERP, NOTNULL(PMC *pmc), NOTNULL(STRING *meth)) { INTVAL i, n; PMC *ns, *mro; PMC *_class = pmc;</p>

<pre lang='und' xml:lang='und'>    /* Get index in Parrot_vtable_slot_names[]. */
    const INTVAL vtable_index = Parrot_get_vtable_index(interp, meth);

    if (vtable_index == &#45;1)
        return PMCNULL;

    /* Get class. */
    if (PObj_is_object_TEST(pmc))
        _class = GET_CLASS(PMC_data_typed(pmc, Buffer), pmc);

    /* Get MRO and iterate over it to find method with a matching
       vtable index or double&#45;underscored name. */
    mro = _class&#45;&#62;vtable&#45;&#62;mro;
    n   = VTABLE_elements(interp, mro);

    for (i = 0; i &#60; n; ++i) {
        _class = VTABLE_get_pmc_keyed_int(interp, mro, i);
        ns     = VTABLE_pmc_namespace(interp, _class);

        if (!PMC_IS_NULL(ns)) {
            PMC * const res = find_vtable_meth_ns(interp, ns, vtable_index);

            if (!PMC_IS_NULL(res))
                return res;
        }
    }

    /* If we get here, method is not overridden in the class. */
    return PMCNULL;
}</pre>

<p>/*</p>

<p>FUNCDOC: readable_name</p>

<p>Given a String or Key PMC return the STRING* representation</p>

<p>XXX this function, key_set_to_string, and the key PMC get_repr should be consolidated</p>

<p>*/</p>

<p>PARROT_API PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL STRING* readable_name(PARROT_INTERP, NOTNULL(PMC *name)) { STRING *join_on; PMC *array;</p>

<pre lang='und' xml:lang='und'>    if (name&#45;&#62;vtable&#45;&#62;base_type == enum_class_String)
        return VTABLE_get_string(interp, name);

    join_on = CONST_STRING(interp, &#34;;&#34;);
    array   = pmc_new(interp, enum_class_ResizableStringArray);

    PARROT_ASSERT(name&#45;&#62;vtable&#45;&#62;base_type == enum_class_Key);

    while (name) {
        VTABLE_push_string(interp, array, key_string(interp, name));
        name = key_next(interp, name);
    }

    return string_join(interp, join_on, array);
}</pre>

<p>/*</p>

<p>FUNCDOC: fail_if_exist</p>

<p>Throws an exception if a PMC or class with the same name already exists.</p>

<p>XXX uses global class registry</p>

<p>*/</p>

<p>static void fail_if_exist(PARROT_INTERP, NOTNULL(PMC *name)) { INTVAL type;</p>

<pre lang='und' xml:lang='und'>    PMC * const classname_hash = interp&#45;&#62;class_hash;
    PMC * const type_pmc       = (PMC *)VTABLE_get_pointer_keyed(interp,
                                        classname_hash, name);
    if (PMC_IS_NULL(type_pmc) ||
            type_pmc&#45;&#62;vtable&#45;&#62;base_type == enum_class_NameSpace)
        type = 0;
    else
        type = VTABLE_get_integer(interp, type_pmc);

    if (type &#62; enum_type_undef) {
        /* TODO get printable name */
        real_exception(interp, NULL, INVALID_OPERATION,
                &#34;Class %Ss already registered!\n&#34;,
                VTABLE_get_string(interp, name));
    }

    if (type &#60; enum_type_undef)
        real_exception(interp, NULL, INVALID_OPERATION,
                &#34;native type with name &#39;%s&#39; already exists &#45; &#34;
                &#34;can&#39;t register Class&#34;, data_types[type].name);
}</pre>

<p>/* Take the class and completely rebuild the attribute stuff for it. Horribly destructive, and definitely not a good thing to do if there are instantiated objects for the class */ static void rebuild_attrib_stuff(PARROT_INTERP, NOTNULL(PMC *_class)) { INTVAL attr_count, cur_offset, n_class, n_mro, offset; PMC *attr_offset_hash, *mro, *attribs; SLOTTYPE *class_slots;</p>

<p>#ifndef NDEBUG PMC * const orig_class = _class; #endif</p>

<pre lang='und' xml:lang='und'>    /* attrib count isn&#39;t set yet, a GC caused by concat could
     * corrupt data under construction
     */
    Parrot_block_DOD(interp);

    class_slots      = PMC_data_typed(_class, SLOTTYPE *);
    attr_offset_hash = pmc_new(interp, enum_class_Hash);
    set_attrib_num(_class, class_slots, PCD_ATTRIBUTES, attr_offset_hash);

    mro   = _class&#45;&#62;vtable&#45;&#62;mro;
    n_mro = VTABLE_elements(interp, mro);

    /* walk from oldest parent down to n_class == 0 which is this class */
    cur_offset = 0;

    for (n_class = n_mro &#45; 1; n_class &#62;= 0; &#45;&#45;n_class) {
        STRING *classname;

        _class = VTABLE_get_pmc_keyed_int(interp, mro, n_class);

        /* this Class isa PMC &#45; no attributes there */
        if (!PObj_is_class_TEST(_class))
            continue;

        class_slots = PMC_data_typed(_class, SLOTTYPE *);
        classname   = VTABLE_get_string(interp,
                    get_attrib_num(class_slots, PCD_CLASS_NAME));
        attribs    = get_attrib_num(class_slots, PCD_CLASS_ATTRIBUTES);
        attr_count = VTABLE_elements(interp, attribs);

        if (attr_count) {
            STRING * const partial_name = string_concat(interp, classname,
                    string_from_cstring(interp, &#34;\0&#34;, 1), 0);

            for (offset = 0; offset &#60; attr_count; offset++) {
               STRING * const attr_name = VTABLE_get_string_keyed_int(interp, attribs, offset);
               STRING * const full_name = string_concat(interp, partial_name, attr_name, 0);

                /* store this attribute with short and full name */

                VTABLE_set_integer_keyed_str(interp, attr_offset_hash,
                        attr_name, cur_offset);
                VTABLE_set_integer_keyed_str(interp, attr_offset_hash,
                        full_name, cur_offset);
                cur_offset++;
            }
        }
    }</pre>

<p>#ifndef NDEBUG PARROT_ASSERT(_class == orig_class); #endif</p>

<pre lang='und' xml:lang='und'>    /* And note the totals */
    CLASS_ATTRIB_COUNT(_class) = cur_offset;
    Parrot_unblock_DOD(interp);
}</pre>

<p>/*</p>

<p>FUNCDOC: create_deleg_pmc_vtable</p>

<p>Create a vtable that dispatches either to the contained PMC in the first attribute (deleg_pmc) or to an overridden method (delegate), depending on the existence of the method for this class.</p>

<p>*/</p>

<p>static void create_deleg_pmc_vtable(PARROT_INTERP, NOTNULL(PMC *_class), int full) { int i; const char *meth; STRING meth_str; DECL_CONST_CAST;</p>

<pre lang='und' xml:lang='und'>    PMC * const vtable_pmc          = get_attrib_num(PMC_data_typed(_class,
                                       SLOTTYPE *), PCD_OBJECT_VTABLE);
    VTABLE * const vtable           = (VTABLE *)PMC_struct_val(vtable_pmc);
    VTABLE * const ro_vtable        = vtable&#45;&#62;ro_variant_vtable;
    VTABLE * const deleg_pmc_vtable = interp&#45;&#62;vtables[enum_class_deleg_pmc];
    VTABLE * const object_vtable    = interp&#45;&#62;vtables[enum_class_ParrotObject];
    VTABLE * const ro_object_vtable = object_vtable&#45;&#62;ro_variant_vtable;
    VTABLE * const delegate_vtable  = interp&#45;&#62;vtables[enum_class_delegate];

    memset(&#38;meth_str, 0, sizeof (meth_str));

    meth_str.encoding = Parrot_fixed_8_encoding_ptr;
    meth_str.charset  = Parrot_default_charset_ptr;

    for (i = 0; (meth = Parrot_vtable_slot_names[i]) != NULL; ++i) {
        if (!*meth)
            continue;

        /* strip underscores from method name */
        meth_str.strstart = (char *)const_cast(meth + 2);
        meth_str.strlen   = meth_str.bufused = strlen(meth) &#45; 2;
        meth_str.hashval  = 0;

        if (!PMC_IS_NULL(Parrot_find_vtable_meth(interp, _class, &#38;meth_str))) {
            /* the method exists; keep the ParrotObject delegate vtable slot */
            ((void **)vtable)[i] = ((void**)object_vtable)[i];
            if (ro_vtable)
                ((void **)ro_vtable)[i] = ((void**)ro_object_vtable)[i];
        }
        else if (full) {
            /*
             * the method doesn&#39;t exist; put in the deleg_pmc vtable,
             * but only if ParrotObject hasn&#39;t overridden the method
             */
            if (((void **)delegate_vtable)[i] == ((void**)object_vtable)[i]) {
                if (ro_vtable)
                    ((void **)ro_vtable)[i] = ((void**)deleg_pmc_vtable)[i];
                ((void **)vtable)[i] = ((void**)deleg_pmc_vtable)[i];
            }
            else {
                ((void **)vtable)[i] = ((void**)object_vtable)[i];
                if (ro_vtable)
                    ((void **)ro_vtable)[i] = ((void**)ro_object_vtable)[i];

            }
        }
    }
}</pre>

<p>/*</p>

<p>FUNCDOC: Parrot_MMD_method_name</p>

<p>Return the method name for the given MMD enum.</p>

<p>*/</p>

<p>PARROT_API PARROT_PURE_FUNCTION PARROT_CAN_RETURN_NULL const char* Parrot_MMD_method_name(SHIM_INTERP, INTVAL idx) { PARROT_ASSERT(idx &#62;= 0);</p>

<pre lang='und' xml:lang='und'>    if (idx &#62;= MMD_USER_FIRST)
        return NULL;

    return Parrot_mmd_func_names[idx];
}</pre>

<p>/*</p>

<p>FUNCDOC: Parrot_MMD_method_idx Return the MMD function number for method name or &#45;1 on failure.</p>

<p>TODO allow dynamic expansion at runtime.</p>

<p>*/</p>

<p>PARROT_API PARROT_PURE_FUNCTION INTVAL Parrot_MMD_method_idx(SHIM_INTERP, NOTNULL(const char *name)) { INTVAL i;</p>

<pre lang='und' xml:lang='und'>    for (i = 0; i &#60; MMD_USER_FIRST; ++i) {
        if (strcmp(Parrot_mmd_func_names[i], name) == 0)
            return i;
    }

    return &#45;1;
}</pre>

<p>/*</p>

<p>FUNCDOC: Parrot_single_subclass</p>

<p>Subclass a class. Single parent class, nice and straightforward. If <code lang='und' xml:lang='und'>child_class</code> is <code lang='und' xml:lang='und'>NULL</code>, this is an anonymous subclass we&#39;re creating, function.</p>

<p>*/</p>

<p>PARROT_API PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL PMC * Parrot_single_subclass(PARROT_INTERP, NOTNULL(PMC *base_class), NULLOK(PMC *name)) { PMC *child_class, *parents, *temp_pmc, *mro; SLOTTYPE *child_class_array; int parent_is_class;</p>

<pre lang='und' xml:lang='und'>    /* Set the classname, if we have one */
    if (!PMC_IS_NULL(name)) {
        fail_if_exist(interp, name);
    }
    else {
        /* XXX not really threadsafe but good enough for now */
        static int anon_count;
        STRING * const child_class_name =
            Parrot_sprintf_c(interp, &#34;%c%canon_%d&#34;, 0, 0, ++anon_count);
        name             = pmc_new(interp, enum_class_String);
        VTABLE_set_string_native(interp, name, child_class_name);
    }

    /* ParrotClass is the baseclass anyway, so build just a new class */
    if (base_class == interp&#45;&#62;vtables[enum_class_ParrotClass]&#45;&#62;pmc_class)
        return pmc_new_init(interp, enum_class_ParrotClass, name);

    parent_is_class = PObj_is_class_TEST(base_class);
    child_class     = pmc_new(interp, enum_class_ParrotClass);

    /* Hang an array off the data pointer */
    set_attrib_array_size(child_class, PCD_MAX);
    child_class_array = PMC_data_typed(child_class, SLOTTYPE *);
    set_attrib_flags(child_class);

    /* We will have five entries in this array */

    /* We have the same number of attributes as our parent */
    CLASS_ATTRIB_COUNT(child_class) = parent_is_class ?
                                        CLASS_ATTRIB_COUNT(base_class) : 0;

    /* Our parent class array has a single member in it */
    parents = pmc_new(interp, enum_class_ResizablePMCArray);

    VTABLE_set_integer_native(interp, parents, 1);
    VTABLE_set_pmc_keyed_int(interp, parents, 0, base_class);

    set_attrib_num(child_class, child_class_array, PCD_PARENTS, parents);
    set_attrib_num(child_class, child_class_array, PCD_CLASS_NAME, name);

    /* Our mro list is a clone of our parent&#39;s mro list,
     * with our self unshifted onto the beginning */
    mro = VTABLE_clone(interp, base_class&#45;&#62;vtable&#45;&#62;mro);
    VTABLE_unshift_pmc(interp, mro, child_class);

    /* But we have no attributes of our own. Yet */
    temp_pmc = pmc_new(interp, enum_class_ResizablePMCArray);
    set_attrib_num(child_class, child_class_array, PCD_CLASS_ATTRIBUTES,
        temp_pmc);

    parrot_class_register(interp, name, child_class, base_class, mro);
    rebuild_attrib_stuff(interp, child_class);

    if (!parent_is_class) {
        /* we append one attribute to hold the PMC */
        Parrot_add_attribute(interp, child_class,
                CONST_STRING(interp, &#34;__value&#34;));
        /*
         * then create a vtable derived from ParrotObject and
         * deleg_pmc &#45; the ParrotObject vtable is already built
         */
        create_deleg_pmc_vtable(interp, child_class, 1);
    }
    else {
        /*
         * if any parent isa PMC, then still individual vtables might
         * be overridden in this subclass
         */
        int i, any_pmc_parent;

        const int n = VTABLE_elements(interp, mro);
        any_pmc_parent = 0;

        /* 0 = this, 1 = parent (handled above), 2 = grandpa */
        for (i = 2; i &#60; n; ++i) {
            const PMC * const parent = VTABLE_get_pmc_keyed_int(interp, mro, i);
            if (!PObj_is_class_TEST(parent)) {
                any_pmc_parent = 1;
                break;
            }
        }
        if (any_pmc_parent)
            create_deleg_pmc_vtable(interp, child_class, 0);
    }

    return child_class;
}</pre>

<p>/*</p>

<p>FUNCDOC: Parrot_new_class</p>

<p>Creates a new class, named <code lang='und' xml:lang='und'>class_name</code>.</p>

<p>*/</p>

<p>PARROT_API void Parrot_new_class(PARROT_INTERP, NOTNULL(PMC *_class), NOTNULL(PMC *name)) { SLOTTYPE *class_array; PMC *mro;</p>

<pre lang='und' xml:lang='und'>    /* check against duplicate newclasses */
    fail_if_exist(interp, name);

    /* Hang an array off the data pointer, empty of course */
    set_attrib_array_size(_class, PCD_MAX);
    class_array = PMC_data_typed(_class, SLOTTYPE *);

    /* set_attrib_flags(_class); init does it */

    /* Our parent class array has nothing in it */
    set_attrib_num(_class, class_array, PCD_PARENTS,
                   pmc_new(interp, enum_class_ResizablePMCArray));

    /* TODO create all class structures in constant PMC pool */

    /*
     * create MRO (method resolution order) array
     * first entry is this class itself
     */
    mro = pmc_new(interp, enum_class_ResizablePMCArray);
    VTABLE_push_pmc(interp, mro, _class);

    /* no attributes yet */
    set_attrib_num(_class, class_array, PCD_CLASS_ATTRIBUTES,
            pmc_new(interp, enum_class_ResizablePMCArray));

    /* Set the classname */
    set_attrib_num(_class, class_array, PCD_CLASS_NAME, name);

    parrot_class_register(interp, name, _class, NULL, mro);

    rebuild_attrib_stuff(interp, _class);
}</pre>

<p>/*</p>

<p>FUNCDOC: Parrot_class_lookup</p>

<p>Looks for the class named <code lang='und' xml:lang='und'>class_name</code> and returns it if it exists. Otherwise it returns <code lang='und' xml:lang='und'>PMCNULL</code>.</p>

<p>*/</p>

<p>PARROT_API PARROT_CAN_RETURN_NULL PARROT_WARN_UNUSED_RESULT PMC * Parrot_class_lookup(PARROT_INTERP, NOTNULL(STRING *class_name)) { const INTVAL type = pmc_type(interp, class_name); PMC *pmc;</p>

<pre lang='und' xml:lang='und'>    if (type &#60;= 0)
        return PMCNULL;

    pmc = interp&#45;&#62;vtables[type]&#45;&#62;pmc_class;
    PARROT_ASSERT(pmc);
    return pmc;
}</pre>

<p>/*</p>

<p>FUNCDOC: Parrot_class_lookup_p Looks for the class named <code lang='und' xml:lang='und'>class_name</code> and returns it if it exists. Otherwise it returns <code lang='und' xml:lang='und'>PMCNULL</code>.</p>

<p>*/</p>

<p>PARROT_CAN_RETURN_NULL PARROT_WARN_UNUSED_RESULT PMC * Parrot_class_lookup_p(PARROT_INTERP, NOTNULL(PMC *class_name)) { const INTVAL type = pmc_type_p(interp, class_name); PMC *pmc;</p>

<pre lang='und' xml:lang='und'>    if (type &#60;= 0)
        return PMCNULL;

    pmc = interp&#45;&#62;vtables[type]&#45;&#62;pmc_class;
    PARROT_ASSERT(pmc);
    return pmc;
}</pre>

<p>PARROT_WARN_UNUSED_RESULT static INTVAL register_type(PARROT_INTERP, NOTNULL(PMC *name)) { INTVAL type; PMC *classname_hash, *item;</p>

<pre lang='und' xml:lang='und'>    /* so pt_shared_fixup() can safely do a type lookup */
    LOCK_INTERPRETER(interp);
    classname_hash = interp&#45;&#62;class_hash;

    type = interp&#45;&#62;n_vtable_max++;

    /* Have we overflowed the table? */
    if (type &#62;= interp&#45;&#62;n_vtable_alloced)
        parrot_realloc_vtables(interp);

    /* set entry in name&#45;&#62;type hash */
    item              = pmc_new(interp, enum_class_Integer);
    PMC_int_val(item) = type;

    VTABLE_set_pmc_keyed(interp, classname_hash, name, item);
    UNLOCK_INTERPRETER(interp);

    return type;
}</pre>

<p>/*</p>

<p>FUNCDOC: This is the way to register a new Parrot class as an instantiable type. Doing this involves putting it in the class hash, setting its vtable so that the <code lang='und' xml:lang='und'>init</code> method initializes objects of the class rather than the class itself, and adding it to the interpreter&#39;s base type table so you can create a new <code lang='und' xml:lang='und'>foo</code> in PASM like this: <code lang='und' xml:lang='und'>new Px, foo</code>.</p>

<p>*/</p>

<p>static void parrot_class_register(PARROT_INTERP, NOTNULL(PMC *name), NOTNULL(PMC *new_class), NULLOK(PMC *parent), NOTNULL(PMC *mro)) { VTABLE *new_vtable, *parent_vtable; PMC *vtable_pmc, *ns, *top; const INTVAL new_type = register_type(interp, name);</p>

<pre lang='und' xml:lang='und'>    /* Build a new vtable for this class
     * The child class PMC gets the vtable of its parent class or
     * a ParrotClass vtable
     */
    if (parent &#38;&#38; PObj_is_class_TEST(parent))
        parent_vtable = parent&#45;&#62;vtable;
    else
        parent_vtable = new_class&#45;&#62;vtable;

    new_vtable = Parrot_clone_vtable(interp, parent_vtable);

    /* Set the vtable&#39;s type to the newly allocated type */
    new_vtable&#45;&#62;base_type = new_type;

    /* And cache our class PMC in the vtable so we can find it later */
    new_vtable&#45;&#62;pmc_class = new_class;
    new_vtable&#45;&#62;mro       = mro;

    if (parent_vtable&#45;&#62;ro_variant_vtable)
        new_vtable&#45;&#62;ro_variant_vtable =
            Parrot_clone_vtable(interp, parent_vtable&#45;&#62;ro_variant_vtable);

    /* Reset the init method to our instantiation method */
    new_vtable&#45;&#62;init          = Parrot_instantiate_object;
    new_vtable&#45;&#62;init_pmc      = Parrot_instantiate_object_init;
    new_class&#45;&#62;vtable         = new_vtable;

    /* Put our new vtable in the global table */
    interp&#45;&#62;vtables[new_type] = new_vtable;

    /* check if we already have a NameSpace */
    top = CONTEXT(interp&#45;&#62;ctx)&#45;&#62;current_namespace;
    ns  = VTABLE_get_pmc_keyed(interp, top, name);

    /* XXX nested, use current as base ? */
    if (PMC_IS_NULL(ns)) {
        /* XXX try HLL namespace too XXX */
        top = Parrot_get_ctx_HLL_namespace(interp);
        ns  = VTABLE_get_pmc_keyed(interp, top, name);
    }

    if (PMC_IS_NULL(ns)) {
        ns = pmc_new(interp, enum_class_NameSpace);
        VTABLE_set_pmc_keyed(interp, top, name, ns);
    }

    /* attach namespace to vtable */
    new_vtable&#45;&#62;_namespace = ns;

    if (new_vtable&#45;&#62;ro_variant_vtable) {
        VTABLE * const ro_vt = new_vtable&#45;&#62;ro_variant_vtable;

        ro_vt&#45;&#62;base_type  = new_vtable&#45;&#62;base_type;
        ro_vt&#45;&#62;pmc_class  = new_vtable&#45;&#62;pmc_class;
        ro_vt&#45;&#62;mro        = new_vtable&#45;&#62;mro;
        ro_vt&#45;&#62;_namespace = new_vtable&#45;&#62;_namespace;
    }

    /*
     * prepare object vtable &#45; again that of the parent or
     * a ParrotObject vtable
     */
    if (parent &#38;&#38; PObj_is_class_TEST(parent)) {
        vtable_pmc    =
            get_attrib_num((SLOTTYPE *)PMC_data(parent), PCD_OBJECT_VTABLE);
        parent_vtable = (VTABLE *)PMC_struct_val(vtable_pmc);
    }
    else
        parent_vtable = interp&#45;&#62;vtables[enum_class_ParrotObject];

    new_vtable = Parrot_clone_vtable(interp, parent_vtable);

    if (parent_vtable&#45;&#62;ro_variant_vtable)
        new_vtable&#45;&#62;ro_variant_vtable =
            Parrot_clone_vtable(interp, parent_vtable&#45;&#62;ro_variant_vtable);

    new_vtable&#45;&#62;base_type = new_type;
    new_vtable&#45;&#62;mro       = mro;
    new_vtable&#45;&#62;pmc_class =  new_class;

    set_attrib_num(new_class, (SLOTTYPE*)PMC_data(new_class), PCD_OBJECT_VTABLE,
            vtable_pmc = constant_pmc_new(interp, enum_class_VtableCache));
    PMC_struct_val(vtable_pmc) = new_vtable;

    /* attach namespace to object vtable too */
    new_vtable&#45;&#62;_namespace = ns;

    if (new_vtable&#45;&#62;ro_variant_vtable) {
        VTABLE * const ro_vt = new_vtable&#45;&#62;ro_variant_vtable;

        ro_vt&#45;&#62;base_type  = new_vtable&#45;&#62;base_type;
        ro_vt&#45;&#62;pmc_class  = new_vtable&#45;&#62;pmc_class;
        ro_vt&#45;&#62;mro        = new_vtable&#45;&#62;mro;
        ro_vt&#45;&#62;_namespace = new_vtable&#45;&#62;_namespace;
    }
}</pre>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CAN_RETURN_NULL static PMC* get_init_meth(PARROT_INTERP, NOTNULL(PMC *_class), NOTNULL(STRING *prop_str), NOTNULL(STRING **meth_str)) { STRING *meth; HashBucket *b; PMC *props, *ns, *method;</p>

<pre lang='und' xml:lang='und'>    *meth_str = NULL;
#if 0
    PMC *prop;
    prop = VTABLE_getprop(interp, _class, prop_str);
    if (!VTABLE_defined(interp, prop))
        return PMCNULL;
    meth = VTABLE_get_string(interp, prop);
#else
    props = PMC_metadata(_class);
    if (!props)
        return PMCNULL;
    b = parrot_hash_get_bucket(interp,
                (Hash*) PMC_struct_val(props), prop_str);
    if (!b)
        return PMCNULL;
    meth = PMC_str_val((PMC*) b&#45;&#62;value);
#endif

    *meth_str = meth;
    ns        = VTABLE_pmc_namespace(interp, _class);
    method    = VTABLE_get_pmc_keyed_str(interp, ns, meth);

    return method;
}</pre>

<p>static void do_initcall(PARROT_INTERP, NULLOK(PMC* _class), NULLOK(PMC *object), NULLOK(PMC *init)) { PMC * const classsearch_array = _class&#45;&#62;vtable&#45;&#62;mro; INTVAL i, nparents;</p>

<pre lang='und' xml:lang='und'>    /*
     * 1) if class has a CONSTRUCT property run it on the object
     *    no redispatch
     *
     * XXX isn&#39;t CONSTRUCT for creating new objects?
     */
    STRING *meth_str;
    PMC    *meth = get_init_meth(interp, _class,
            CONST_STRING(interp, &#34;CONSTRUCT&#34;), &#38;meth_str);
    int     default_meth;

    if (!PMC_IS_NULL(meth)) {
        if (init)
            Parrot_run_meth_fromc_args(interp, meth,
                    object, meth_str, &#34;vP&#34;, init);
        else
            Parrot_run_meth_fromc_args(interp, meth,
                    object, meth_str, &#34;v&#34;);
    }
    /*
     * 2. if class has a BUILD property call it for all classes
     *    in reverse search order &#45; this class last.
     *
     *    Note: mro contains this class as first element
     */
    nparents = VTABLE_elements(interp, classsearch_array);

    for (i = nparents &#45; 1; i &#62;= 0; &#45;&#45;i) {
        PMC * const parent_class =
            VTABLE_get_pmc_keyed_int(interp, classsearch_array, i);
        /* if it&#39;s a PMC, we put one PMC of that type into
         * the attribute slot #0 and call init() on that PMC
         */
        if (!PObj_is_class_TEST(parent_class)) {
            PMC *attr, *next_parent;
            SLOTTYPE *obj_data;

            /*
             * but only if init isn&#39;t inherited
             * or rather just on the last non&#45;class parent
             */
            PARROT_ASSERT(i &#62;= 1);
            next_parent = VTABLE_get_pmc_keyed_int(interp,
                    classsearch_array, i &#45; 1);
            if (!PObj_is_class_TEST(next_parent))
                continue;

            attr     = pmc_new_noinit(interp, parent_class&#45;&#62;vtable&#45;&#62;base_type);
            obj_data = PMC_data_typed(object, SLOTTYPE *);
            set_attrib_num(object, obj_data, 0, attr);
            VTABLE_init(interp, attr);
            continue;
        }
        meth = get_init_meth(interp, parent_class,
                CONST_STRING(interp, &#34;BUILD&#34;), &#38;meth_str);
        /* no method found and no BUILD property set? */
        if (PMC_IS_NULL(meth) &#38;&#38; meth_str == NULL) {
            PMC   *ns;
            INTVAL vtable_index;

            /* use __init or __init_pmc (depending on if an argument was passed)
             * as fallback constructor method, if it exists */
            if (init)
                meth_str = CONST_STRING(interp, &#34;init_pmc&#34;);
            else
                meth_str = CONST_STRING(interp, &#34;init&#34;);

            ns   = VTABLE_pmc_namespace(interp, parent_class);

            /* can&#39;t use find_method, it walks mro */
            vtable_index = Parrot_get_vtable_index(interp, meth_str);
            meth         = find_vtable_meth_ns(interp, ns, vtable_index);
            default_meth = 1;
        }
        else
            default_meth = 0;

        if (!PMC_IS_NULL(meth)) {
            if (init)
                Parrot_run_meth_fromc_args(interp, meth,
                        object, meth_str, &#34;vP&#34;, init);
            else
                Parrot_run_meth_fromc_args(interp, meth,
                        object, meth_str, &#34;v&#34;);
        }
        else if (meth_str != NULL &#38;&#38;
                string_length(interp, meth_str) != 0 &#38;&#38; !default_meth) {
            real_exception(interp, NULL, METH_NOT_FOUND,
                    &#34;Class BUILD method (&#39;%Ss&#39;) not found&#34;, meth_str);
        }
    }
}</pre>

<p>/*</p>

<p>FUNCDOC: Creates a Parrot object. Takes a passed&#45;in class PMC that has sufficient information to describe the layout of the object and makes the object.</p>

<p>*/</p>

<p>PARROT_API void Parrot_instantiate_object_init(PARROT_INTERP, NOTNULL(PMC *object), NOTNULL(PMC *init)) { instantiate_object(interp, object, init); }</p>

<p>PARROT_API void Parrot_instantiate_object(PARROT_INTERP, NOTNULL(PMC *object)) { instantiate_object(interp, object, NULL); }</p>

<p>static void instantiate_object(PARROT_INTERP, NOTNULL(PMC *object), NULLOK(PMC *init)) { SLOTTYPE *new_object_array; INTVAL attrib_count, i;</p>

<pre lang='und' xml:lang='und'>    PMC * const _class = object&#45;&#62;vtable&#45;&#62;pmc_class;
    /*
     * put in the real vtable
     */
    PMC * const vtable_pmc = get_attrib_num((SLOTTYPE *)PMC_data(_class),
                                            PCD_OBJECT_VTABLE);
    object&#45;&#62;vtable         = (VTABLE *)PMC_struct_val(vtable_pmc);

    /* Grab the attribute count from the class */
    attrib_count = CLASS_ATTRIB_COUNT(_class);

    /* Build the array that hangs off the new object */
    /* First presize it */
    set_attrib_array_size(object, attrib_count);
    new_object_array = PMC_data_typed(object, SLOTTYPE *);

    /* fill with PMCNULL, so that access doesn&#39;t segfault */
    for (i = 0; i &#60; attrib_count; ++i)
        set_attrib_num(object, new_object_array, i, PMCNULL);

    /* turn marking on */
    set_attrib_flags(object);

    /* We are an object now */
    PObj_is_object_SET(object);

    /* We really ought to call the class init routines here...
     * this assumes that an object isa delegate
     */
    do_initcall(interp, _class, object, init);
}</pre>

<p>/*</p>

<p>FUNCDOC: Add the parent class to the current class&#39; parent list. This also involved adding all the parent&#39;s parents, as well as all attributes of the parent classes that we&#39;re adding in.</p>

<p>The MRO (method resolution order) is the C3 algorithm used by Perl6 and Python (&#62;= 2.3). See also: <a href='http://pugs.blogs.com/pugs/2005/07/day_165_r5671_j.html'><a href="http://pugs.blogs.com/pugs/2005/07/day_165_r5671_j.html">http://pugs.blogs.com/pugs/2005/07/day_165_r5671_j.html</a></a></p>

<p>*/</p>

<p>/* create a list if non&#45;empty lists */ PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL static PMC* not_empty(PARROT_INTERP, NOTNULL(PMC *seqs)) { INTVAL i; PMC * const nseqs = pmc_new(interp, enum_class_ResizablePMCArray);</p>

<pre lang='und' xml:lang='und'>    for (i = 0; i &#60; VTABLE_elements(interp, seqs); ++i) {
        PMC * const list = VTABLE_get_pmc_keyed_int(interp, seqs, i);

        if (VTABLE_elements(interp, list))
            VTABLE_push_pmc(interp, nseqs, list);
    }

    return nseqs;
}</pre>

<p>/* merge the list if lists */ PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL static PMC* class_mro_merge(PARROT_INTERP, NOTNULL(PMC *seqs)) { /* silence compiler uninit warning */ PMC *cand = NULL; PMC * const res = pmc_new(interp, enum_class_ResizablePMCArray);</p>

<pre lang='und' xml:lang='und'>    while (1) {
        PMC * const nseqs = not_empty(interp, seqs);
        INTVAL i;

        if (!VTABLE_elements(interp, nseqs))
            break;

        for (i = 0; i &#60; VTABLE_elements(interp, nseqs); ++i) {
            PMC * const seq  = VTABLE_get_pmc_keyed_int(interp, nseqs, i);
            INTVAL j;

            cand = VTABLE_get_pmc_keyed_int(interp, seq, 0);

            /* check if candidate is valid */
            for (j = 0; j &#60; VTABLE_elements(interp, nseqs); ++j) {
                PMC * const s = VTABLE_get_pmc_keyed_int(interp, nseqs, j);
                INTVAL k;

                for (k = 1; k &#60; VTABLE_elements(interp, s); ++k)
                    if (VTABLE_get_pmc_keyed_int(interp, s, k) == cand) {
                        cand = NULL;
                        break;
                    }
            }
            if (cand)
                break;
        }
        if (!cand)
            real_exception(interp, NULL, E_TypeError,
                    &#34;inconsisten class hierarchy&#34;);

        /* push candidate onto mro result */
        VTABLE_push_pmc(interp, res, cand);

        /* remove candidate from head of lists */
        for (i = 0; i &#60; VTABLE_elements(interp, nseqs); ++i) {
            PMC * const seq = VTABLE_get_pmc_keyed_int(interp, nseqs, i);

            if (VTABLE_get_pmc_keyed_int(interp, seq, 0) == cand)
                VTABLE_shift_pmc(interp, seq);
        }
    }

    return res;
}</pre>

<p>/* create C3 MRO */ PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL static PMC* create_class_mro(PARROT_INTERP, NOTNULL(PMC *_class)) { PMC *lparents, *bases; INTVAL i;</p>

<pre lang='und' xml:lang='und'>    /* list of lists
     * [ [class] [mro of bases] [bases] ]
     */
    PMC * const lall = pmc_new(interp, enum_class_ResizablePMCArray);
    PMC * const lc   = pmc_new(interp, enum_class_ResizablePMCArray);

    VTABLE_push_pmc(interp, lc, _class);
    VTABLE_push_pmc(interp, lall, lc);

    bases = get_attrib_num(PMC_data(_class), PCD_PARENTS);

    for (i = 0; i &#60; VTABLE_elements(interp, bases); ++i) {
        PMC * const base = VTABLE_get_pmc_keyed_int(interp, bases, i);
        PMC * const lmap = PObj_is_class_TEST(base) ?
            create_class_mro(interp, base) : base&#45;&#62;vtable&#45;&#62;mro;
        VTABLE_push_pmc(interp, lall, lmap);
    }

    lparents = VTABLE_clone(interp, bases);
    VTABLE_push_pmc(interp, lall, lparents);

    return class_mro_merge(interp, lall);
}</pre>

<p>PARROT_API void Parrot_add_parent(PARROT_INTERP, NOTNULL(PMC *_class), NOTNULL(PMC *parent)) { PMC *current_parent_array;</p>

<pre lang='und' xml:lang='und'>    if (!PObj_is_class_TEST(_class))
        real_exception(interp, NULL, 1, &#34;Class isn&#39;t a ParrotClass&#34;);

    if (!PObj_is_class_TEST(parent) &#38;&#38; parent == parent&#45;&#62;vtable&#45;&#62;pmc_class) {
        /* Permit inserting non&#45;classes so at least thaw&#39;ing classes
         * is easy. Adding these parents after classes have been
         * subclassed is dangerous, however.
         */
        PMC *class_name;

        if (CLASS_ATTRIB_COUNT(_class) != 0)
            real_exception(interp, NULL, 1, &#34;Subclassing built&#45;in type too late&#34;);

        Parrot_add_attribute(interp, _class, CONST_STRING(interp, &#34;__value&#34;));

        class_name = pmc_new(interp, enum_class_String);

        VTABLE_set_string_native(interp, class_name,
            VTABLE_name(interp, _class));

        create_deleg_pmc_vtable(interp, _class, 1);
    }
    else if (!PObj_is_class_TEST(parent)) {
        real_exception(interp, NULL, 1, &#34;Parent isn&#39;t a ParrotClass&#34;);
    }

    current_parent_array = get_attrib_num(PMC_data(_class), PCD_PARENTS);
    VTABLE_push_pmc(interp, current_parent_array, parent);

    _class&#45;&#62;vtable&#45;&#62;mro  = create_class_mro(interp, _class);

    rebuild_attrib_stuff(interp, _class);
}</pre>

<p>/*</p>

<p>FUNCDOC: This currently does nothing but return <code lang='und' xml:lang='und'>PMCNULL</code>.</p>

<p>*/</p>

<p>PARROT_API PARROT_IGNORABLE_RESULT PARROT_CAN_RETURN_NULL PMC * Parrot_remove_parent(PARROT_INTERP, NOTNULL(PMC *removed_class), NOTNULL(PMC *existing_class)) { UNUSED(interp); UNUSED(removed_class); UNUSED(existing_class);</p>

<pre lang='und' xml:lang='und'>    return PMCNULL;
}</pre>

<p>/*</p>

<p>FUNCDOC: This currently does nothing but return <code lang='und' xml:lang='und'>PMCNULL</code>.</p>

<p>*/</p>

<p>PARROT_API PARROT_WARN_UNUSED_RESULT PARROT_CAN_RETURN_NULL PMC * Parrot_multi_subclass(PARROT_INTERP, NOTNULL(PMC *base_class_array), NOTNULL(STRING *child_class_name)) { UNUSED(interp); UNUSED(base_class_array); UNUSED(child_class_name);</p>

<pre lang='und' xml:lang='und'>    return PMCNULL;
}</pre>

<p>/*</p>

<p>FUNCDOC: Returns whether the object <code lang='und' xml:lang='und'>pmc</code> is an instance of class <code lang='und' xml:lang='und'>_class</code>.</p>

<p>*/</p>

<p>PARROT_API PARROT_WARN_UNUSED_RESULT INTVAL Parrot_object_isa(PARROT_INTERP, NOTNULL(PMC *pmc), NOTNULL(PMC *_class)) { PMC *mro; INTVAL i, classcount;</p>

<pre lang='und' xml:lang='und'>    /* if this is not a class */
    if (!PObj_is_class_TEST(pmc))
        pmc = VTABLE_get_class(interp, pmc);

    mro        = pmc&#45;&#62;vtable&#45;&#62;mro;
    classcount = VTABLE_elements(interp, mro);

    for (i = 0; i &#60; classcount; ++i) {
        if (VTABLE_get_pmc_keyed_int(interp, mro, i) == _class)
            return 1;
    }

    return 0;
}</pre>

<p>/*</p>

<p>FUNCDOC: This should create and return a new method cache PMC.</p>

<p>Currently it does nothing but return <code lang='und' xml:lang='und'>PMCNULL</code>.</p>

<p>*/</p>

<p>PARROT_API PARROT_WARN_UNUSED_RESULT PARROT_CAN_RETURN_NULL PMC * Parrot_new_method_cache(PARROT_INTERP) { UNUSED(interp);</p>

<pre lang='und' xml:lang='und'>    return PMCNULL;
}</pre>

<p>void mark_object_cache(PARROT_INTERP) { UNUSED(interp); }</p>

<p>void init_object_cache(PARROT_INTERP) { Caches * const mc = interp&#45;&#62;caches = mem_allocate_zeroed_typed(Caches); mc&#45;&#62;idx = NULL; }</p>

<p>void destroy_object_cache(PARROT_INTERP) { UINTVAL i; Caches * const mc = interp&#45;&#62;caches;</p>

<pre lang='und' xml:lang='und'>    /* mc&#45;&#62;idx[type][bits] = e; */
    for (i = 0; i &#60; mc&#45;&#62;mc_size; i++) {
        if (mc&#45;&#62;idx[i])
            invalidate_type_caches(interp, i);
    }

    mem_sys_free(mc&#45;&#62;idx);
    mem_sys_free(mc);
}</pre>

<p>#define TBL_SIZE_MASK 0x1ff /* x bits 2..10 */ #define TBL_SIZE (1 + TBL_SIZE_MASK)</p>

<p>static void invalidate_type_caches(PARROT_INTERP, UINTVAL type) { Caches * const mc = interp&#45;&#62;caches; INTVAL i;</p>

<pre lang='und' xml:lang='und'>    if (!mc)
        return;

    /* is it a valid entry */
    if (type &#62;= mc&#45;&#62;mc_size || !mc&#45;&#62;idx[type])
        return;

    for (i = 0; i &#60; TBL_SIZE; ++i) {
        Meth_cache_entry *e;
        for (e = mc&#45;&#62;idx[type][i]; e;) {
            Meth_cache_entry * const next = e&#45;&#62;next;
            mem_sys_free(e);
            e = next;
        }
    }

    mem_sys_free(mc&#45;&#62;idx[type]);
    mc&#45;&#62;idx[type] = NULL;
}</pre>

<p>static void invalidate_all_caches(PARROT_INTERP) { UINTVAL i; for (i = 1; i &#60; (UINTVAL)interp&#45;&#62;n_vtable_max; ++i) invalidate_type_caches(interp, i); }</p>

<p>/*</p>

<p>FUNCDOC: Clear method cache for the given class. If class is NULL, caches for all classes are invalidated.</p>

<p>*/</p>

<p>PARROT_API void Parrot_invalidate_method_cache(PARROT_INTERP, NULLOK(STRING *_class), NOTNULL(STRING *meth)) { INTVAL type;</p>

<pre lang='und' xml:lang='und'>    /* during interp creation and NCI registration the class_hash
     * isn&#39;t yet up */
    if (!interp&#45;&#62;class_hash)
        return;

    if (interp&#45;&#62;resume_flag &#38; RESUME_INITIAL)
        return;

    if (!_class) {
        invalidate_all_caches(interp);
        return;
    }

    type = pmc_type(interp, _class);

    if (type &#60; 0)
        return;

    if (type == 0) {
        invalidate_all_caches(interp);
        return;
    }

    invalidate_type_caches(interp, (UINTVAL)type);
}</pre>

<p>/* * quick&#39;n&#39;dirty method cache * TODO: use a hash if method_name is not constant * i.e. from obj.$Sreg(args) * If this hash is implemented mark it during DOD */</p>

<p>/*</p>

<p>FUNCDOC: Find a method PMC for a named method, given the class PMC, current interpreter, and name of the method. Don&#39;t use a possible method cache.</p>

<p>*/</p>

<p>PARROT_API PARROT_CAN_RETURN_NULL PARROT_WARN_UNUSED_RESULT PMC * Parrot_find_method_direct(PARROT_INTERP, NOTNULL(PMC *_class), NOTNULL(STRING *method_name)) { PMC * const found = find_method_direct_1(interp, _class, method_name); STRING *s1, *s2;</p>

<pre lang='und' xml:lang='und'>    if (!PMC_IS_NULL(found))
        return found;

    s1 = CONST_STRING(interp, &#34;__get_string&#34;);
    s2 = CONST_STRING(interp, &#34;__get_repr&#34;);

    if (string_equal(interp, method_name, s1) == 0)
        return find_method_direct_1(interp, _class, s2);

    return PMCNULL;
}</pre>

<p>/*</p>

<p>FUNCDOC: Find a method PMC for a named method, given the class PMC, current interp, and name of the method.</p>

<p>This routine should use the current scope&#39;s method cache, if there is one. If not, it creates a new method cache. Or, rather, it will when we&#39;ve got that bit working. For now it unconditionally goes and looks up the name in the global stash.</p>

<p>*/</p>

<p>PARROT_API PARROT_CAN_RETURN_NULL PARROT_WARN_UNUSED_RESULT PMC * Parrot_find_method_with_cache(PARROT_INTERP, NOTNULL(PMC *_class), NOTNULL(STRING *method_name)) { UINTVAL type, bits;</p>

<pre lang='und' xml:lang='und'>    Caches           *mc;
    Meth_cache_entry *e, *old;

    PARROT_ASSERT(method_name != 0);</pre>

<p>#if DISABLE_METH_CACHE return Parrot_find_method_direct(interp, _class, method_name); #endif</p>

<pre lang='und' xml:lang='und'>    if (! PObj_constant_TEST(method_name))
        return Parrot_find_method_direct(interp, _class, method_name);

    mc   = interp&#45;&#62;caches;
    type = _class&#45;&#62;vtable&#45;&#62;base_type;
    bits = (((UINTVAL) method_name&#45;&#62;strstart) &#62;&#62; 2) &#38; TBL_SIZE_MASK;

    if (type &#62;= mc&#45;&#62;mc_size) {
        if (mc&#45;&#62;idx) {
            mc&#45;&#62;idx = (Meth_cache_entry ***)mem_sys_realloc_zeroed(mc&#45;&#62;idx,
                sizeof (Meth_cache_entry ***) * (type + 1),
                sizeof (Meth_cache_entry ***) * mc&#45;&#62;mc_size);
        }
        else {
            mc&#45;&#62;idx = (Meth_cache_entry ***)mem_sys_allocate_zeroed(
                sizeof (Meth_cache_entry ***) * (type + 1));
        }
        mc&#45;&#62;mc_size = type + 1;
    }

    if (!mc&#45;&#62;idx[type]) {
        mc&#45;&#62;idx[type] = (Meth_cache_entry **)mem_sys_allocate_zeroed(
            sizeof (Meth_cache_entry *) * TBL_SIZE);
    }

    e   = mc&#45;&#62;idx[type][bits];
    old = NULL;

    while (e &#38;&#38; e&#45;&#62;strstart != method_name&#45;&#62;strstart) {
        old = e;
        e   = e&#45;&#62;next;
    }

    if (!e) {
        /* when here no or no correct entry was at [bits] */
        e     = mem_allocate_typed(Meth_cache_entry);

        if (old)
            old&#45;&#62;next = e;
        else
            mc&#45;&#62;idx[type][bits] = e;

        e&#45;&#62;pmc      = Parrot_find_method_direct(interp, _class, method_name);
        e&#45;&#62;next     = NULL;
        e&#45;&#62;strstart = method_name&#45;&#62;strstart;
    }

    return e&#45;&#62;pmc;
}</pre>

<p>#ifdef NDEBUG # define TRACE_FM(i, c, m, sub) #else static void debug_trace_find_meth(PARROT_INTERP, NOTNULL(PMC *_class), NOTNULL(STRING *name), NULLOK(PMC *sub)) { STRING *class_name; const char *result; Interp *tracer;</p>

<pre lang='und' xml:lang='und'>    if (!Interp_trace_TEST(interp, PARROT_TRACE_FIND_METH_FLAG))
        return;
    if (PObj_is_class_TEST(_class)) {
        SLOTTYPE * const class_array = PMC_data_typed(_class, SLOTTYPE *);
        PMC *const class_name_pmc = get_attrib_num(class_array, PCD_CLASS_NAME);
        class_name = PMC_str_val(class_name_pmc);
    }
    else
        class_name = _class&#45;&#62;vtable&#45;&#62;whoami;
    if (sub) {
        if (sub&#45;&#62;vtable&#45;&#62;base_type == enum_class_NCI)
            result = &#34;NCI&#34;;
        else
            result = &#34;Sub&#34;;
    }
    else
        result = &#34;no&#34;;
    tracer = interp&#45;&#62;debugger ?
        interp&#45;&#62;debugger : interp;
    PIO_eprintf(tracer,
            &#34;# find_method class &#39;%Ss&#39; method &#39;%Ss&#39;: %s\n&#34;,
            class_name, name, result);
}</pre>

<p># define TRACE_FM(i, c, m, sub) \ debug_trace_find_meth(i, c, m, sub) #endif</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CAN_RETURN_NULL static PMC * find_method_direct_1(PARROT_INTERP, NOTNULL(PMC *_class), NOTNULL(STRING *method_name)) { INTVAL i;</p>

<pre lang='und' xml:lang='und'>    PMC * const mro = _class&#45;&#62;vtable&#45;&#62;mro;
    const INTVAL n = VTABLE_elements(interp, mro);
    for (i = 0; i &#60; n; ++i) {
        PMC* method, *ns;

        _class = VTABLE_get_pmc_keyed_int(interp, mro, i);
        ns = VTABLE_pmc_namespace(interp, _class);
        method = VTABLE_get_pmc_keyed_str(interp, ns, method_name);
        TRACE_FM(interp, _class, method_name, method);
        if (!PMC_IS_NULL(method)) {
            return method;
        }
    }
    TRACE_FM(interp, _class, method_name, NULL);
    return PMCNULL;
}</pre>

<p>/*</p>

<p>FUNCDOC: Parrot_note_method</p>

<p>Notes where in the hierarchy we just found a method. Used so that we can do a next and continue the search through the hierarchy for the next instance of this method.</p>

<p>*/</p>

<p>PARROT_API void Parrot_note_method_offset(PARROT_INTERP, UINTVAL offset, NOTNULL(PMC *method)) { UNUSED(interp); UNUSED(offset); UNUSED(method); }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_add_attribute</p>

<p>Adds the attribute <code lang='und' xml:lang='und'>attr</code> to the class.</p>

<pre lang='und' xml:lang='und'>   Life is ever so much easier if a class keeps its attributes at the
   end of the attribute array, since we don&#39;t have to insert and
   reorder attributes. Inserting&#39;s no big deal, especially since we&#39;re
   going to break horribly if you insert into a class that&#39;s been
   subclassed, but it&#39;ll do for now.</pre>

<p>*/</p>

<p>PARROT_API INTVAL Parrot_add_attribute(PARROT_INTERP, NOTNULL(PMC *_class), NOTNULL(STRING *attr)) { STRING *full_attr_name; SLOTTYPE * const class_array = (SLOTTYPE *)PMC_data(_class); STRING * const class_name = VTABLE_get_string(interp, get_attrib_num(class_array, PCD_CLASS_NAME)); PMC * const attr_array = get_attrib_num(class_array, PCD_CLASS_ATTRIBUTES); PMC * const attr_hash = get_attrib_num(class_array, PCD_ATTRIBUTES); INTVAL idx = VTABLE_elements(interp, attr_array);</p>

<pre lang='und' xml:lang='und'>    VTABLE_set_integer_native(interp, attr_array, idx + 1);
    VTABLE_set_string_keyed_int(interp, attr_array, idx, attr);

    full_attr_name = string_concat(interp, class_name,
            string_from_cstring(interp, &#34;\0&#34;, 1), 0);

    full_attr_name = string_concat(interp, full_attr_name, attr, 0);

    /* TODO escape NUL char */
    if (VTABLE_exists_keyed_str(interp, attr_hash, full_attr_name)) {
        char * const c_error = string_to_cstring(interp, full_attr_name);
        real_exception(interp, NULL, 1, &#34;Attribute &#39;%s&#39; already exists&#34;, c_error);
        string_cstring_free(c_error);
    }

    /*
     * TODO check if someone is trying to add attributes to a parent class
     * while there are already child class attrs
     */
    idx = CLASS_ATTRIB_COUNT(_class)++;
    VTABLE_set_integer_keyed_str(interp, attr_hash, attr, idx);
    VTABLE_set_integer_keyed_str(interp, attr_hash, full_attr_name, idx);

    return idx;
}</pre>

<p>/*</p>

<p>FUNCDOC: Returns attribute number <code lang='und' xml:lang='und'>attrib</code> from <code lang='und' xml:lang='und'>object</code>. Presumably the code is asking for the correct attribute number.</p>

<p>*/</p>

<p>PARROT_API PARROT_CAN_RETURN_NULL PARROT_WARN_UNUSED_RESULT PMC * Parrot_get_attrib_by_num(PARROT_INTERP, NOTNULL(PMC *object), INTVAL attrib) { /* * this is called from ParrotObject&#39;s vtable now, so * there is no need for checking object being a valid object PMC */ SLOTTYPE * const attrib_array = PMC_data_typed(object, SLOTTYPE *); const INTVAL attrib_count = PMC_int_val(object);</p>

<pre lang='und' xml:lang='und'>    if (attrib &#62;= attrib_count || attrib &#60; 0)
        real_exception(interp, NULL, ATTRIB_NOT_FOUND,
                &#34;No such attribute #%d&#34;, (int)attrib);

    return get_attrib_num(attrib_array, attrib);
}</pre>

<p>static INTVAL attr_str_2_num(PARROT_INTERP, NOTNULL(PMC *object), NOTNULL(STRING *attr)) { PMC *_class, *attr_hash; SLOTTYPE *class_array; HashBucket *b; STRING *delimit, *attr_name, *obj_name; int idx, length;</p>

<pre lang='und' xml:lang='und'>    if (!PObj_is_object_TEST(object))
        real_exception(interp, NULL, INTERNAL_NOT_IMPLEMENTED,
                &#34;Can&#39;t set non&#45;core object attribs yet&#34;);

    _class = GET_CLASS((SLOTTYPE *)PMC_data(object), object);

    /* XXX Shared objects have the &#39;wrong&#39; class stored in them
    * (because of the reference to the namespace and because it
    * references PMCs that may go away),
    * since we actually want one from the current interpreter. */
    if (PObj_is_PMC_shared_TEST(object))
        _class = VTABLE_get_class(interp, object);

    class_array = PMC_data_typed(_class, SLOTTYPE *);
    attr_hash   = get_attrib_num(class_array, PCD_ATTRIBUTES);
    b           = parrot_hash_get_bucket(interp,
                (Hash*) PMC_struct_val(attr_hash), attr);

    if (b)
        return PMC_int_val((PMC *)b&#45;&#62;value);

    /* Create a delimiter for splitting up the Class\0attribute syntax. */
    delimit = string_from_cstring(interp, &#34;\0&#34;, 1);

    /* Calculate the offset and the length of the attribute string. */
    idx     = string_str_index(interp, attr, delimit, 0) + 1;

    if (!idx) {
        real_exception(interp, NULL, ATTRIB_NOT_FOUND,
                &#34;No such attribute &#39;%Ss&#39;&#34;, attr);
        return 0;
    }

    length = string_length(interp, attr) &#45; idx;

    /* Extract the attribute and object name. */
    attr_name = string_substr(interp, attr, idx,  length, 0, 0);
    obj_name  = string_substr(interp, attr,   0, idx &#45; 1, 0, 0);

    real_exception(interp, NULL, ATTRIB_NOT_FOUND,
            &#34;No such attribute &#39;%Ss\\0%Ss&#39;&#34;, obj_name, attr_name);

    return 0;
}</pre>

<p>/*</p>

<p>FUNCDOC: Returns attribute with full qualified name <code lang='und' xml:lang='und'>attr</code> from <code lang='und' xml:lang='und'>object</code>.</p>

<p>*/</p>

<p>PARROT_API PARROT_CAN_RETURN_NULL PARROT_WARN_UNUSED_RESULT PMC * Parrot_get_attrib_by_str(PARROT_INTERP, NOTNULL(PMC *object), NOTNULL(STRING *attr)) { return Parrot_get_attrib_by_num(interp, object, attr_str_2_num(interp, object, attr)); }</p>

<p>/*</p>

<p>FUNCDOC: Set attribute number <code lang='und' xml:lang='und'>attrib</code> from <code lang='und' xml:lang='und'>object</code> to <code lang='und' xml:lang='und'>value</code>. Presumably the code is asking for the correct attribute number.</p>

<p>*/</p>

<p>PARROT_API void Parrot_set_attrib_by_num(PARROT_INTERP, NOTNULL(PMC *object), INTVAL attrib, NOTNULL(PMC *value)) { SLOTTYPE * const attrib_array = PMC_data_typed(object, SLOTTYPE *); const INTVAL attrib_count = PMC_int_val(object);</p>

<pre lang='und' xml:lang='und'>    if (attrib &#62;= attrib_count || attrib &#60; 0)
        real_exception(interp, NULL, ATTRIB_NOT_FOUND,
                &#34;No such attribute #%d&#34;, (int)attrib);

    set_attrib_num(object, attrib_array, attrib, value);
}</pre>

<p>/*</p>

<p>FUNCDOC: Sets attribute with full qualified name <code lang='und' xml:lang='und'>attr</code> from <code lang='und' xml:lang='und'>object</code> to <code lang='und' xml:lang='und'>value</code>.</p>

<p>*/</p>

<p>PARROT_API void Parrot_set_attrib_by_str(PARROT_INTERP, NOTNULL(PMC *object), NOTNULL(STRING *attr), NOTNULL(PMC *value)) { Parrot_set_attrib_by_num(interp, object, attr_str_2_num(interp, object, attr), value); }</p>

<p>PARROT_API INTVAL Parrot_class_offset(PARROT_INTERP, NOTNULL(PMC *object), NOTNULL(STRING *_class)) { PMC *class_pmc, *mro, *attribs; INTVAL offset, i, n, attr_count;</p>

<pre lang='und' xml:lang='und'>    if (!PObj_is_object_TEST(object))
        real_exception(interp, NULL, 1, &#34;Not an object&#34;);

    class_pmc = GET_CLASS(PMC_data_typed(object, SLOTTYPE *), object);

    /* unroll common case &#45; object is this class */
    attribs    = get_attrib_num(PMC_data(class_pmc), PCD_CLASS_ATTRIBUTES);
    attr_count = VTABLE_elements(interp, attribs);
    offset     = PMC_int_val(object) &#45; attr_count;

    if (!string_equal(interp, VTABLE_name(interp, class_pmc), _class))
        return offset;

    /* now check mro */
    mro = class_pmc&#45;&#62;vtable&#45;&#62;mro;
    n   = VTABLE_elements(interp, mro);

    for (i = 1; i &#60; n; ++i) {
        class_pmc  = VTABLE_get_pmc_keyed_int(interp, mro, i);
        attribs    = get_attrib_num(PMC_data(class_pmc), PCD_CLASS_ATTRIBUTES);
        attr_count = VTABLE_elements(interp, attribs);
        offset    &#45;= attr_count;

        if (!string_equal(interp, VTABLE_name(interp, class_pmc), _class))
            return offset;
    }

    /* error caught in opcode */
    return &#45;1;
}</pre>

<p>/*</p>

<p>FUNCDOC: Find and return the constructor method PMC for the named sub. The classtoken is an identifier for the class used for fast lookup, or 0 if you don&#39;t have an identifier token (which, as they&#39;re currently undefined, is pretty likely).</p>

<p>*/</p>

<p>PARROT_API PARROT_CAN_RETURN_NULL PMC * Parrot_find_class_constructor(PARROT_INTERP, NOTNULL(STRING *_class), INTVAL classtoken) { UNUSED(interp); UNUSED(_class); UNUSED(classtoken);</p>

<pre lang='und' xml:lang='und'>    return PMCNULL;
}</pre>

<p>PARROT_API PARROT_CAN_RETURN_NULL PMC * Parrot_find_class_destructor(PARROT_INTERP, NOTNULL(STRING *_class), INTVAL classtoken) { UNUSED(interp); UNUSED(_class); UNUSED(classtoken);</p>

<pre lang='und' xml:lang='und'>    return PMCNULL;
}</pre>

<p>PARROT_API PARROT_CAN_RETURN_NULL PMC * Parrot_find_class_fallback(PARROT_INTERP, NOTNULL(STRING *_class), INTVAL classtoken) { UNUSED(interp); UNUSED(_class); UNUSED(classtoken);</p>

<pre lang='und' xml:lang='und'>    return PMCNULL;
}</pre>

<p>PARROT_API void Parrot_set_class_constructor(PARROT_INTERP, NOTNULL(STRING *_class), INTVAL classtoken, NOTNULL(STRING *method)) { UNUSED(interp); UNUSED(_class); UNUSED(classtoken); UNUSED(method); }</p>

<p>PARROT_API void Parrot_set_class_destructor(PARROT_INTERP, NOTNULL(STRING *_class), INTVAL classtoken, NOTNULL(STRING *method)) { UNUSED(interp); UNUSED(_class); UNUSED(classtoken); UNUSED(method); }</p>

<p>PARROT_API void Parrot_set_class_fallback(PARROT_INTERP, NOTNULL(STRING *_class), INTVAL classtoken, NOTNULL(STRING *method)) { UNUSED(interp); UNUSED(_class); UNUSED(classtoken); UNUSED(method); }</p>

<p>/* ************************************************************************ */ /* ********* BELOW HERE IS NEW PPD15 IMPLEMENTATION RELATED STUFF ********* */ /* ************************************************************************ */</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CAN_RETURN_NULL static PMC* C3_merge(PARROT_INTERP, NOTNULL(PMC *merge_list)) { PMC *result = pmc_new(interp, enum_class_ResizablePMCArray); const int list_count = VTABLE_elements(interp, merge_list); int cand_count = 0; int i; PMC *accepted = PMCNULL;</p>

<pre lang='und' xml:lang='und'>    /* Try and find something appropriate to add to the MRO &#45; basically, the
     * first list head that is not in the tail of all the other lists. */
    for (i = 0; i &#60; list_count; i++) {
        PMC * const cand_list = VTABLE_get_pmc_keyed_int(interp, merge_list, i);

        PMC *cand_class;
        int reject = 0;
        int j;

        if (VTABLE_elements(interp, cand_list) == 0)
            continue;

        cand_class = VTABLE_get_pmc_keyed_int(interp, cand_list, 0);
        cand_count++;

        for (j = 0; j &#60; list_count; j++) {
            /* Skip the current list. */
            if (j != i) {
                /* Is it in the tail? If so, reject. */
                PMC * const check_list = VTABLE_get_pmc_keyed_int(interp, merge_list, j);
                const int check_length = VTABLE_elements(interp, check_list);
                int k;

                for (k = 1; k &#60; check_length; k++) {
                    if (VTABLE_get_pmc_keyed_int(interp, check_list, k) ==
                        cand_class) {
                        reject = 1;
                        break;
                    }
                }
            }
        }

        /* If we didn&#39;t reject it, this candidate will do. */
        if (!reject) {
            accepted = cand_class;
            break;
        }
    }

    /* If we never found any candidates, return an empty list. */
    if (cand_count == 0)
        return pmc_new(interp, enum_class_ResizablePMCArray);

    /* If we didn&#39;t find anything to accept, error. */
    if (PMC_IS_NULL(accepted)) {
        real_exception(interp, NULL, ILL_INHERIT,
            &#34;Could not build C3 linearization: ambiguous hierarchy&#34;);
        return PMCNULL;
    }

    /* Otherwise, remove what was accepted from the merge lists. */
    for (i = 0; i &#60; list_count; i++) {
        int j;

        PMC * const list = VTABLE_get_pmc_keyed_int(interp, merge_list, i);
        const int list_count = VTABLE_elements(interp, list);

        for (j = 0; j &#60; list_count; j++) {
            if (VTABLE_get_pmc_keyed_int(interp, list, j) == accepted) {
                VTABLE_delete_keyed_int(interp, list, j);
                break;
            }
        }
    }

    /* Need to merge what remains of the list, then put what was accepted on
     * the start of the list, and we&#39;re done. */
    result = C3_merge(interp, merge_list);
    VTABLE_unshift_pmc(interp, result, accepted);

    return result;
}</pre>

<p>/*</p>

<p>FUNCDOC: Parrot_ComputeMRO_C3 Computes the C3 linearization for the given class.</p>

<p>*/</p>

<p>PARROT_API PARROT_WARN_UNUSED_RESULT PARROT_CAN_RETURN_NULL PMC* Parrot_ComputeMRO_C3(PARROT_INTERP, NOTNULL(PMC *_class)) { PMC *result; PMC * const merge_list = pmc_new(interp, enum_class_ResizablePMCArray); PMC *immediate_parents; int i, parent_count;</p>

<pre lang='und' xml:lang='und'>    /* Now get immediate parents list. */
    Parrot_PCCINVOKE(interp, _class,
         string_from_literal(interp, &#34;parents&#34;),
        &#34;&#45;&#62;P&#34;, &#38;immediate_parents);

    if (immediate_parents == NULL)
        real_exception(interp, NULL, METH_NOT_FOUND,
            &#34;Failed to get parents list from class!&#34;);

    parent_count = VTABLE_elements(interp, immediate_parents);

    if (parent_count == 0) {
        /* No parents &#45; MRO just contains this class. */
        result = pmc_new(interp, enum_class_ResizablePMCArray);
        VTABLE_push_pmc(interp, result, _class);
        return result;
    }

    /* Otherwise, need to do merge. For that, need linearizations of all of
     * our parents added to the merge list. */
    for (i = 0; i &#60; parent_count; i++) {
        PMC *lin;
        lin = Parrot_ComputeMRO_C3(interp,
            VTABLE_get_pmc_keyed_int(interp, immediate_parents, i));

        if (PMC_IS_NULL(lin))
            return PMCNULL;

        VTABLE_push_pmc(interp, merge_list, lin);
    }

    /* Finally, need list of direct parents on the end of the merge list, then
     * we can merge. */
    VTABLE_push_pmc(interp, merge_list, immediate_parents);
    result = C3_merge(interp, merge_list);

    if (PMC_IS_NULL(result))
        return PMCNULL;

    /* Merged result needs this class on the start, and then we&#39;re done. */
    VTABLE_unshift_pmc(interp, result, _class);

    return result;
}</pre>

<p>/*</p>

<p>FUNCDOC: Parrot_ComposeRole</p>

<p>Used by the Class and Object PMCs internally to compose a role into either of them. The <code lang='und' xml:lang='und'>role</code> parameter is the role that we are composing into the class or role. <code lang='und' xml:lang='und'>methods_hash</code> is the hash of method names to invokable PMCs that contains the methods the class or role has. <code lang='und' xml:lang='und'>roles_list</code> is the list of roles the the class or method does.</p>

<p>The <code lang='und' xml:lang='und'>role</code> parameter is only dealt with by its external interface. Whether this routine is usable by any other object system implemented in Parrot very much depends on how closely the role composition semantics they want are to the default implementation.</p>

<h1><a name="SEE_ALSO"
>SEE ALSO <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p><em lang='und' xml:lang='und'>include/parrot/objects.h</em>, <em lang='und' xml:lang='und'><a href="../docs/pdds/pdd15_objects.pod.html">docs/pdds/pdd15_objects.pod</a></em>.</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
