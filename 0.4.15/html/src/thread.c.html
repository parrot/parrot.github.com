<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Thread handling stuff</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Thread handling stuff</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../html/index.html">Contents</a> | <a href="../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>src/thread.c &#45; Thread handling stuff</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>Threads are created by creating new <code lang='und' xml:lang='und'>ParrotInterpreter</code> objects.</p>

<h2><a name="Functions"
>Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>*/</p>

<p>#include &#34;parrot/parrot.h&#34; #include &#34;parrot/atomic.h&#34;</p>

<p>/* HEADERIZER HFILE: include/parrot/thread.h */</p>

<p>/* HEADERIZER BEGIN: static */</p>

<p>static Parrot_Interp detach( UINTVAL tid ); static Shared_gc_info * get_pool( PARROT_INTERP ) __attribute__nonnull__(1);</p>

<p>static int is_suspended_for_gc( PARROT_INTERP ) __attribute__nonnull__(1);</p>

<p>PARROT_CAN_RETURN_NULL static PMC * make_local_args_copy( PARROT_INTERP,
Parrot_Interp old_interp,
PMC *args ) __attribute__nonnull__(1);</p>

<p>PARROT_CAN_RETURN_NULL static PMC * make_local_copy( PARROT_INTERP,
NOTNULL(Parrot_Interp from),
NULLOK(PMC *arg) ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>static void mutex_unlock( void *arg ); static Parrot_Interp pt_check_tid( UINTVAL tid,
NOTNULL(const char *from) ) __attribute__nonnull__(2);</p>

<p>static int pt_gc_count_threads( PARROT_INTERP ) __attribute__nonnull__(1);</p>

<p>static void pt_gc_wait_for_stage( PARROT_INTERP,
thread_gc_stage_enum from_stage,
thread_gc_stage_enum to_stage ) __attribute__nonnull__(1);</p>

<p>static void pt_gc_wakeup_check( PARROT_INTERP ) __attribute__nonnull__(1);</p>

<p>static void pt_ns_clone( Parrot_Interp d,
PMC *dest_ns,
Parrot_Interp s,
PMC *source_ns );</p>

<p>static void pt_suspend_all_for_gc( PARROT_INTERP ) __attribute__nonnull__(1);</p>

<p>static void pt_suspend_one_for_gc( PARROT_INTERP ) __attribute__nonnull__(1);</p>

<p>static void pt_thread_signal( NOTNULL(Parrot_Interp self),
PARROT_INTERP ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>static void pt_thread_wait( PARROT_INTERP ) __attribute__nonnull__(1);</p>

<p>static QUEUE_ENTRY * remove_queued_suspend_gc( PARROT_INTERP ) __attribute__nonnull__(1);</p>

<p>PARROT_CAN_RETURN_NULL static void* thread_func( void *arg );</p>

<p>/* HEADERIZER END: static */</p>

<p>#if defined THREAD_DEBUG &#38;&#38; THREAD_DEBUG # define DEBUG_ONLY(x) x #else # define DEBUG_ONLY(x) #endif</p>

<p>static int running_threads;</p>

<p>void Parrot_really_destroy(PARROT_INTERP,
int exit_code,
void *arg);</p>

<p>/*</p>

<p>FUNCDOC: make_local_copy</p>

<p>Create a local copy of the PMC if necessary.
(No copy is made if it is marked shared.) This includes workarounds for Parrot_clone() not doing the Right Thing with subroutines (specifically,
code segments aren&#39;t preserved and it is difficult to do so as long as Parrot_clone() depends on freezing).</p>

<p>*/</p>

<p>PARROT_CAN_RETURN_NULL static PMC * make_local_copy(PARROT_INTERP,
NOTNULL(Parrot_Interp from),
NULLOK(PMC *arg)) { PMC *ret_val; STRING * const _sub = interp&#45;&#62;vtables[enum_class_Sub]&#45;&#62;whoami; STRING * const _multi_sub = interp&#45;&#62;vtables[enum_class_MultiSub]&#45;&#62;whoami;</p>

<pre lang='und' xml:lang='und'>    if (PMC_IS_NULL(arg)) {
        ret_val = PMCNULL;
    }
    else if (PObj_is_PMC_shared_TEST(arg)) {
        ret_val = arg;
    }
    else if (VTABLE_isa(from, arg, _multi_sub)) {
        INTVAL i = 0;
        const INTVAL n = VTABLE_elements(from, arg);
        ret_val  = pmc_new(interp, enum_class_MultiSub);

        for (i = 0; i &#60; n; ++i) {
            PMC *const orig = VTABLE_get_pmc_keyed_int(from, arg, i);
            PMC *const copy = make_local_copy(interp, from, orig);
            VTABLE_push_pmc(interp, ret_val, copy);
        }
    }
    else if (VTABLE_isa(from, arg, _sub)) {
        /* this is a workaround for cloning subroutines not actually
         * working as one might expect mainly because the segment is
         * not correctly copied
         */
        ret_val               = Parrot_clone(interp, arg);
        PMC_sub(ret_val)&#45;&#62;seg = PMC_sub(arg)&#45;&#62;seg;
        Parrot_store_sub_in_namespace(interp, ret_val);
    }
    else {
        ret_val = Parrot_clone(interp, arg);
    }
    return ret_val;
}</pre>

<p>static Shared_gc_info * get_pool(PARROT_INTERP) { return shared_gc_info; }</p>

<p>/*</p>

<p>FUNCDOC: make_local_args_copy</p>

<p>Make a local copy of the corresponding array of arguments.</p>

<p>*/</p>

<p>PARROT_CAN_RETURN_NULL static PMC * make_local_args_copy(PARROT_INTERP, Parrot_Interp old_interp, PMC *args) { PMC *ret_val; INTVAL old_size; INTVAL i;</p>

<pre lang='und' xml:lang='und'>    if (PMC_IS_NULL(args))
        return PMCNULL;

    old_size = VTABLE_get_integer(old_interp, args);

    /* XXX should this be a different type? */
    ret_val = pmc_new(interp, enum_class_FixedPMCArray);
    VTABLE_set_integer_native(interp, ret_val, old_size);

    for (i = 0; i &#60; old_size; ++i) {
        PMC * const copy = make_local_copy(interp, old_interp,
                VTABLE_get_pmc_keyed_int(old_interp, args, i));

        VTABLE_set_pmc_keyed_int(interp, ret_val, i, copy);
    }

    return ret_val;
}</pre>

<p>/*</p>

<p>FUNCDOC: pt_shared_fixup</p>

<p>Fixup a PMC to be sharable. Right now, reassigns the vtable to one owned by some master interpreter, so the PMC can be safely reused after thread death.</p>

<p>In the future the PMC returned might be different than the one passed, e.g., if we need to reallocate the PMC in a different interpreter.</p>

<p>*/</p>

<p>PMC * pt_shared_fixup(PARROT_INTERP, PMC *pmc) { if (PObj_is_object_TEST(pmc)) { Parrot_Interp master = interpreter_array[0]; INTVAL type_num; PMC *vtable_cache;</p>

<pre lang='und' xml:lang='und'>        /* keep the original vtable from going away... */
        vtable_cache = ((PMC**)PMC_data(pmc&#45;&#62;vtable&#45;&#62;pmc_class))[PCD_OBJECT_VTABLE];
        PARROT_ASSERT(vtable_cache&#45;&#62;vtable&#45;&#62;base_type == enum_class_VtableCache);

        add_pmc_sync(interp, vtable_cache);
        PObj_is_PMC_shared_SET(vtable_cache);

        /* don&#39;t want the referenced class disappearing on us */
        LOCK_INTERPRETER(master);
        type_num = pmc&#45;&#62;vtable&#45;&#62;base_type;
        SET_CLASS((SLOTTYPE*) PMC_data(pmc), pmc,
                  master&#45;&#62;vtables[type_num]&#45;&#62;pmc_class);
        UNLOCK_INTERPRETER(master);
    }
    else {
        /* TODO this will need to change for thread pools
         * XXX should we have a separate interpreter for this?
         */
        INTVAL        type_num;
        Parrot_Interp master = interpreter_array[0];
        int           is_ro  = pmc&#45;&#62;vtable&#45;&#62;flags &#38; VTABLE_IS_READONLY_FLAG;

        /* This lock is paired with one in objects.c. It is necessary to protect
         * against the master interpreter adding classes and consequently
         * resizing its classname&#45;&#62;type_id hashtable and/or expanding its vtable
         * array.
         * TODO investigate if a read&#45;write lock results in substantially
         * better performance.
         */
        LOCK_INTERPRETER(master);
        type_num = pmc&#45;&#62;vtable&#45;&#62;base_type;

        if (type_num == enum_type_undef) {
            UNLOCK_INTERPRETER(master);
            real_exception(interp, NULL, 1, &#34;pt_shared_fixup: unsharable type&#34;);
            return PMCNULL;
        }

        pmc&#45;&#62;vtable = master&#45;&#62;vtables[type_num];

        UNLOCK_INTERPRETER(master);

        if (is_ro)
            pmc&#45;&#62;vtable = pmc&#45;&#62;vtable&#45;&#62;ro_variant_vtable;
    }

    add_pmc_sync(interp, pmc);

    PObj_is_PMC_shared_SET(pmc);

    /* make sure metadata doesn&#39;t go away unexpectedly */
    if (PMC_metadata(pmc))
        PMC_metadata(pmc) = pt_shared_fixup(interp, PMC_metadata(pmc));

    return pmc;
}</pre>

<p>/*</p>

<p>FUNCDOC: pt_thread_signal</p>

<p>Wakeup a <code lang='und' xml:lang='und'>interp</code> which should have called pt_thread_wait().</p>

<p>*/</p>

<p>static void pt_thread_signal(NOTNULL(Parrot_Interp self), PARROT_INTERP) { COND_SIGNAL(interp&#45;&#62;thread_data&#45;&#62;interp_cond); }</p>

<p>/*</p>

<p>FUNCDOC: pt_thread_wait_with</p>

<p>Wait for this interpreter to be signalled through its condition variable, dealing properly with GC issues. <code lang='und' xml:lang='und'>*mutex</code> is assumed locked on entry and will be locked on exit from this function. If a GC run occurs in the middle of this function, then a spurious wakeup may occur.</p>

<p>*/</p>

<p>void pt_thread_wait_with(PARROT_INTERP, Parrot_mutex *mutex) { LOCK(interpreter_array_mutex); if (interp&#45;&#62;thread_data&#45;&#62;state &#38; THREAD_STATE_SUSPEND_GC_REQUESTED) { interp&#45;&#62;thread_data&#45;&#62;state |= THREAD_STATE_SUSPENDED_GC; /* fprintf(stderr, &#34;%p: pt_thread_wait, before sleep, doing GC run\n&#34;, * interp); */ UNLOCK(interpreter_array_mutex); UNLOCK(*mutex);</p>

<pre lang='und' xml:lang='und'>        pt_suspend_self_for_gc(interp);

        LOCK(*mutex);
        /* since we unlocked the mutex something bad may have occured */
        return;
    }

    interp&#45;&#62;thread_data&#45;&#62;state |= THREAD_STATE_GC_WAKEUP;

    UNLOCK(interpreter_array_mutex);
    COND_WAIT(interp&#45;&#62;thread_data&#45;&#62;interp_cond, *mutex);
    LOCK(interpreter_array_mutex);

    interp&#45;&#62;thread_data&#45;&#62;state &#38;= ~THREAD_STATE_GC_WAKEUP;

    if (interp&#45;&#62;thread_data&#45;&#62;state &#38; THREAD_STATE_SUSPENDED_GC) {
        UNLOCK(*mutex);
        /* XXX loop needed? */
        do {
            UNLOCK(interpreter_array_mutex);
            /* fprintf(stderr, &#34;%p: woken up, doing GC run\n&#34;, interp); */
            pt_suspend_self_for_gc(interp);
            LOCK(interpreter_array_mutex);
        } while (interp&#45;&#62;thread_data&#45;&#62;state &#38; THREAD_STATE_SUSPENDED_GC);

        UNLOCK(interpreter_array_mutex);
        LOCK(*mutex);
    }
    else {
        UNLOCK(interpreter_array_mutex);
    }
}</pre>

<p>/*</p>

<p>FUNCDOC: pt_thread_wait</p>

<p>Wait for us to be signalled. GC matters are handled correctly. <code lang='und' xml:lang='und'>interpreter_array_mutex</code> is assumed held. Spurious wakeups may occur.</p>

<p>*/</p>

<p>static void pt_thread_wait(PARROT_INTERP) { if (interp&#45;&#62;thread_data&#45;&#62;state &#38; THREAD_STATE_SUSPEND_GC_REQUESTED) { interp&#45;&#62;thread_data&#45;&#62;state |= THREAD_STATE_SUSPENDED_GC; /* fprintf(stderr, &#34;%p: pt_thread_wait, before sleep, doing GC run\n&#34;, * interp); */</p>

<pre lang='und' xml:lang='und'>        UNLOCK(interpreter_array_mutex);
        pt_suspend_self_for_gc(interp);
        LOCK(interpreter_array_mutex);

        /* while we were GCing, whatever we were waiting on might have
         * changed */
        return;
    }

    interp&#45;&#62;thread_data&#45;&#62;state |= THREAD_STATE_GC_WAKEUP;

    COND_WAIT(interp&#45;&#62;thread_data&#45;&#62;interp_cond, interpreter_array_mutex);

    interp&#45;&#62;thread_data&#45;&#62;state &#38;= ~THREAD_STATE_GC_WAKEUP;

    while (interp&#45;&#62;thread_data&#45;&#62;state &#38; THREAD_STATE_SUSPENDED_GC) {
        UNLOCK(interpreter_array_mutex);
        /* fprintf(stderr, &#34;%p: woken up, doing GC run\n&#34;, interp); */
        pt_suspend_self_for_gc(interp);
        LOCK(interpreter_array_mutex);
    }
}</pre>

<p>/*</p>

<p>FUNCDOC: thread_func</p>

<p>The actual thread function.</p>

<p>*/</p>

<p>PARROT_CAN_RETURN_NULL static void* thread_func(void *arg) { Parrot_exception exp; int lo_var_ptr; UINTVAL tid; PMC *sub; PMC *sub_arg; PMC * const self = (PMC*) arg; PMC *ret_val = NULL; Parrot_Interp interp = (Parrot_Interp)PMC_data(self);</p>

<pre lang='und' xml:lang='und'>    Parrot_block_DOD(interp);
    Parrot_block_GC(interp);

    /* need to set it here because argument passing can trigger GC */
    interp&#45;&#62;lo_var_ptr = &#38;lo_var_ptr;
    sub                = (PMC *)PMC_struct_val(self);
    sub_arg            = PMC_pmc_val(self);

    if (setjmp(exp.destination)) {
        const Parrot_exception * const except = interp&#45;&#62;exceptions;
        /* caught exception */
        /* XXX what should we really do here */
        PIO_eprintf(interp,
                    &#34;Unhandled exception in thread with tid %d &#34;
                    &#34;(message=%Ss, number=%d)\n&#34;,
                    interp&#45;&#62;thread_data&#45;&#62;tid,
                    except&#45;&#62;msg,
                    except&#45;&#62;error);

        ret_val = PMCNULL;
    }
    else {
        /* run normally */
        push_new_c_exception_handler(interp, &#38;exp);
        Parrot_unblock_DOD(interp);
        Parrot_unblock_GC(interp);
        ret_val = Parrot_runops_fromc_args(interp, sub, &#34;PF&#34;, sub_arg);
    }
    /*
     * thread is finito
     */
    LOCK(interpreter_array_mutex);
    DEBUG_ONLY(fprintf(stderr,&#34;marking an thread as finished&#34;));

    interp&#45;&#62;thread_data&#45;&#62;state |= THREAD_STATE_FINISHED;
    tid                         = interp&#45;&#62;thread_data&#45;&#62;tid;

    if (interp != interpreter_array[tid]) {
        UNLOCK(interpreter_array_mutex);
        PANIC(interp, &#34;thread finished: interpreter mismatch&#34;);
    }
    if (interp&#45;&#62;thread_data&#45;&#62;state &#38; THREAD_STATE_DETACHED) {
        interpreter_array[tid] = NULL;
        DEBUG_ONLY(fprintf(stderr,&#34;really destroying an interpreter [exit while detached]&#34;));
        Parrot_really_destroy(interp, 0, NULL);
    }
    else if (interp&#45;&#62;thread_data&#45;&#62;state &#38; THREAD_STATE_JOINED) {
        pt_thread_signal(interp, interp&#45;&#62;thread_data&#45;&#62;joiner);
    }

    /* make sure we don&#39;t block a GC run */
    pt_gc_wakeup_check(interp);
    PARROT_ASSERT(interp&#45;&#62;thread_data&#45;&#62;state &#38; THREAD_STATE_FINISHED);

    UNLOCK(interpreter_array_mutex);

    return ret_val;
}</pre>

<p>/*</p>

<h2><a name="Helper_functions_used_also_for_running_plain_interpreters"
>Helper functions used also for running plain interpreters <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>FUNCDOC: pt_clone_code</p>

<p>Copy/clone the packfile/code from interpreter <code lang='und' xml:lang='und'>s</code> to <code lang='und' xml:lang='und'>d</code>. All resources are created in <code lang='und' xml:lang='und'>d</code>.</p>

<p>*/</p>

<p>void pt_clone_code(Parrot_Interp d, Parrot_Interp s) { Parrot_block_DOD(d); Interp_flags_SET(d, PARROT_EXTERN_CODE_FLAG); d&#45;&#62;code = NULL; Parrot_switch_to_cs(d, s&#45;&#62;code, 1); Parrot_unblock_DOD(d); }</p>

<p>/*</p>

<p>pt_clone_globals(Parrot_Interp d, Parrot_Interp s)&#62;</p>

<p>Clone all globals from <code lang='und' xml:lang='und'>s</code> to <code lang='und' xml:lang='und'>d</code>.</p>

<p>*/</p>

<p>static void pt_ns_clone(Parrot_Interp d, PMC *dest_ns, Parrot_Interp s, PMC *source_ns) { PMC * const iter = VTABLE_get_iter(s, source_ns); const INTVAL n = VTABLE_elements(s, source_ns); INTVAL i;</p>

<pre lang='und' xml:lang='und'>    for (i = 0; i &#60; n; ++i) {
        /* XXX what if &#39;key&#39; is a non&#45;constant&#45;pool string? */
        STRING * const key = VTABLE_shift_string(s, iter);
        PMC           *val;

        val = VTABLE_get_pmc_keyed_str(s, source_ns, key);

        if (val&#45;&#62;vtable&#45;&#62;base_type == enum_class_NameSpace) {
            PMC *sub_ns;
            sub_ns = VTABLE_get_pmc_keyed_str(d, dest_ns, key);
            if (PMC_IS_NULL(sub_ns) || sub_ns&#45;&#62;vtable&#45;&#62;base_type !=
                    enum_class_NameSpace) {
                sub_ns = pmc_new(d, enum_class_NameSpace);
                VTABLE_set_pmc_keyed_str(d, dest_ns, key, sub_ns);
            }
            pt_ns_clone(d, sub_ns, s, val);
        }
        else {
            PMC * const dval = VTABLE_get_pmc_keyed_str(d, dest_ns, key);

            if (PMC_IS_NULL(dval)) {
                PMC *copy;
                copy = make_local_copy(d, s, val);
                VTABLE_set_pmc_keyed_str(d, dest_ns, key, copy);
            }
        }
    }
}</pre>

<p>void pt_clone_globals(Parrot_Interp d, Parrot_Interp s) { Parrot_block_DOD(d); pt_ns_clone(d, d&#45;&#62;root_namespace, s, s&#45;&#62;root_namespace); Parrot_unblock_DOD(d); }</p>

<p>/*</p>

<p>FUNCDOC: pt_thread_prepare_for_run</p>

<p>Setup code, and TODO ...</p>

<p>*/ void pt_thread_prepare_for_run(Parrot_Interp d, Parrot_Interp s) { Parrot_setup_event_func_ptrs(d); }</p>

<p>/*</p>

<h2><a name="ParrotThread_methods"
>ParrotThread methods <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>FUNCDOC: pt_thread_run</p>

<p>Run the <code lang='und' xml:lang='und'>*sub</code> PMC in a separate thread using interpreter in <code lang='und' xml:lang='und'>*dest_interp</code>.</p>

<p><code lang='und' xml:lang='und'>arg</code> should be an array of arguments for the subroutine.</p>

<p>*/</p>

<p>/* create a clone of the sub suitable for the other interpreter */</p>

<p>PMC * pt_transfer_sub(Parrot_Interp d, Parrot_Interp s, NULLOK(PMC *sub)) { #if defined THREAD_DEBUG &#38;&#38; THREAD_DEBUG PIO_eprintf(s, &#34;copying over subroutine [%Ss]\n&#34;, Parrot_full_sub_name(s, sub)); #endif return make_local_copy(d, s, sub); }</p>

<p>int pt_thread_run(PARROT_INTERP, PMC* dest_interp, PMC* sub, PMC *arg) { PMC *old_dest_interp; PMC *parent; Interp * const interpreter = (Parrot_Interp)PMC_data(dest_interp);</p>

<pre lang='und' xml:lang='und'>    Parrot_block_GC(interpreter);
    Parrot_block_DOD(interpreter);
    Parrot_block_GC(interp);
    Parrot_block_DOD(interp);

    /* make a copy of the ParrotThread PMC so we can use it
     * to hold parameters to the new thread without it being
     * garbage collected or otherwise changed by the parent thread.
     * Also so the new thread&#39;s getinterp doesn&#39;t return an object
     * owned by the wrong interpreter &#45;&#45; which would be very bad
     * if the parent is destroyed before the child.
     * XXX FIXME move this elsewhere? at least the set_pmc_keyed_int
     */
    old_dest_interp = dest_interp;
    dest_interp     = pmc_new_noinit(interpreter, enum_class_ParrotThread);

    /* so it&#39;s not accidentally deleted */
    PMC_data(old_dest_interp) = NULL;
    PMC_data(dest_interp)     = interpreter;

    VTABLE_set_pmc_keyed_int(interpreter, interpreter&#45;&#62;iglobals,
        (INTVAL) IGLOBALS_INTERPRETER, dest_interp);

    parent = VTABLE_get_pmc_keyed_int(interp, interp&#45;&#62;iglobals,
                IGLOBALS_INTERPRETER);

    /*
     * TODO check if thread flags are consistent
     */
    if (interp&#45;&#62;flags &#38; PARROT_THR_COPY_INTERP)
        clone_interpreter(interpreter, (Parrot_Interp)PMC_data(parent), PARROT_CLONE_DEFAULT);
    /*
     * TODO thread pools
     */

    pt_thread_prepare_for_run(interpreter, interp);

    PMC_struct_val(dest_interp) = pt_transfer_sub(interpreter, interp, sub);
    PMC_pmc_val(dest_interp)    = make_local_args_copy(interpreter, interp,
                                                       arg);

    /*
     * set regs according to pdd03
     */
    interpreter&#45;&#62;current_object = dest_interp;
    /*
     * create a joinable thread
     */
    interpreter&#45;&#62;thread_data&#45;&#62;state = THREAD_STATE_JOINABLE;

    Parrot_unblock_GC(interpreter);
    Parrot_unblock_DOD(interpreter);
    Parrot_unblock_GC(interp);
    Parrot_unblock_DOD(interp);

    THREAD_CREATE_JOINABLE(interpreter&#45;&#62;thread_data&#45;&#62;thread,
            thread_func, dest_interp);

    /* check for pending GC */
    LOCK(interpreter_array_mutex);
    if (interp&#45;&#62;thread_data&#45;&#62;state &#38; THREAD_STATE_SUSPEND_GC_REQUESTED)
        pt_suspend_one_for_gc(interpreter);

    UNLOCK(interpreter_array_mutex);
    return 0;
}</pre>

<p>/*</p>

<p>FUNCDOC: pt_thread_run_1</p>

<p>Runs a type 1 thread. Nothing is shared, both interpreters are free running without any communication.</p>

<p>*/</p>

<p>int pt_thread_run_1(PARROT_INTERP, PMC* dest_interp, PMC* sub, PMC *arg) { interp&#45;&#62;flags |= PARROT_THR_TYPE_1; return pt_thread_run(interp, dest_interp, sub, arg); }</p>

<p>/*</p>

<p>FUNCDOC: pt_thread_run_2</p>

<p>Runs a type 2 thread. No shared variables, threads are communicating by sending messages.</p>

<p>*/</p>

<p>int pt_thread_run_2(PARROT_INTERP, PMC* dest_interp, PMC* sub, PMC *arg) { interp&#45;&#62;flags |= PARROT_THR_TYPE_2; return pt_thread_run(interp, dest_interp, sub, arg); }</p>

<p>/*</p>

<p>FUNCDOC: pt_thread_run_3</p>

<p>Run a type 3 thread. Threads may have shared variables and are managed in a thread pool.</p>

<p>*/</p>

<p>int pt_thread_run_3(PARROT_INTERP, PMC* dest_interp, PMC* sub, PMC *arg) { interp&#45;&#62;flags |= PARROT_THR_TYPE_3; return pt_thread_run(interp, dest_interp, sub, arg); }</p>

<p>/*</p>

<p>FUNCDOC: pt_thread_yield</p>

<p>Relinquishes hold on the processor.</p>

<p>*/</p>

<p>void pt_thread_yield(void) { YIELD; }</p>

<p>/*</p>

<p>FUNCDOC: pt_check_tid</p>

<p>Helper function. Check if <code lang='und' xml:lang='und'>tid</code> is valid. The caller holds the mutex. Returns the interpreter for <code lang='und' xml:lang='und'>tid</code>.</p>

<p>*/</p>

<p>static Parrot_Interp pt_check_tid(UINTVAL tid, NOTNULL(const char *from)) { if (tid &#62;= n_interpreters) { UNLOCK(interpreter_array_mutex); internal_exception(1, &#34;%s: illegal thread tid %d&#34;, from, tid); } if (tid == 0) { UNLOCK(interpreter_array_mutex); internal_exception(1, &#34;%s: illegal thread tid %d (main)&#34;, from, tid); } if (!interpreter_array[tid]) { UNLOCK(interpreter_array_mutex); internal_exception(1, &#34;%s: illegal thread tid %d &#45; empty&#34;, from, tid); } return interpreter_array[tid]; }</p>

<p>/*</p>

<p>FUNCDOC: mutex_unlock</p>

<p>Unlocks the mutex <code lang='und' xml:lang='und'>*arg</code>.</p>

<p>*/</p>

<p>static void mutex_unlock(void *arg) { UNLOCK(*(Parrot_mutex *) arg); }</p>

<p>/*</p>

<p>FUNCDOC: is_suspended_for_gc</p>

<p>Returns true iff <code lang='und' xml:lang='und'>interp</code> is suspended so a global GC can be performed. interpreter_array_mutex must be held.</p>

<p>*/</p>

<p>static int is_suspended_for_gc(PARROT_INTERP) { if (!interp) return 1; else if (interp&#45;&#62;thread_data&#45;&#62;wants_shared_gc) return 1; else if (interp&#45;&#62;thread_data&#45;&#62;state &#38; THREAD_STATE_SUSPENDED_GC) return 1; else if ((interp&#45;&#62;thread_data&#45;&#62;state &#38; THREAD_STATE_FINISHED) || (interp&#45;&#62;thread_data&#45;&#62;state &#38; THREAD_STATE_NOT_STARTED)) return 1; else return 0; }</p>

<p>/* XXX should this function be in a different file? */ static QUEUE_ENTRY * remove_queued_suspend_gc(PARROT_INTERP) { parrot_event *ev = NULL; QUEUE *queue = interp&#45;&#62;task_queue; QUEUE_ENTRY *prev = NULL; QUEUE_ENTRY *cur;</p>

<pre lang='und' xml:lang='und'>    queue_lock(queue);
    cur = queue&#45;&#62;head;

    while (cur) {
        ev   = (parrot_event *)cur&#45;&#62;data;

        if (ev&#45;&#62;type == EVENT_TYPE_SUSPEND_FOR_GC)
            break;

        prev = cur;
        cur  = cur&#45;&#62;next;
    }

    if (cur) {
        if (prev)
            prev&#45;&#62;next  = cur&#45;&#62;next;
        else
            queue&#45;&#62;head = cur&#45;&#62;next;

        if (cur == queue&#45;&#62;tail)
            queue&#45;&#62;tail = prev;

        if (cur == queue&#45;&#62;head)
            queue&#45;&#62;head = cur&#45;&#62;next;

        mem_sys_free(ev);
        mem_sys_free(cur);
        cur = NULL;
        DEBUG_ONLY(fprintf(stderr,&#34;%p: remove_queued_suspend_gc: got one&#34;, interp));
    }

    queue_unlock(queue);
    return cur;
}</pre>

<p>/* interpreter_array_mutex must be held */ static int pt_gc_count_threads(PARROT_INTERP) { UINTVAL i; int count = 0;</p>

<pre lang='und' xml:lang='und'>    for (i = 0; i &#60; n_interpreters; ++i) {
        Parrot_Interp cur;
        cur = interpreter_array[i];
        if (!cur)
            continue;
        if (cur&#45;&#62;thread_data&#45;&#62;state &#38; (THREAD_STATE_NOT_STARTED |
                                       THREAD_STATE_FINISHED))
            continue;
        ++count;
    }
    DEBUG_ONLY(fprintf(stderr,&#34;found %d threads&#34;, count));
    return count;
}</pre>

<p>static void pt_gc_wait_for_stage(PARROT_INTERP, thread_gc_stage_enum from_stage, thread_gc_stage_enum to_stage) { Shared_gc_info *info = shared_gc_info; int thread_count;</p>

<pre lang='und' xml:lang='und'>    DEBUG_ONLY(fprintf(stderr,&#34;%p: gc_wait_for_stage: %d&#45;&#62;%d&#34;, interp, from_stage, to_stage));

    /* XXX well&#45;timed thread death can mess this up */
    LOCK(interpreter_array_mutex);

    DEBUG_ONLY(fprintf(stderr,&#34;%p: got lock&#34;, interp));
    thread_count = pt_gc_count_threads(interp);

    PARROT_ASSERT(info&#45;&#62;gc_stage == from_stage);
    PARROT_ASSERT(!(interp&#45;&#62;thread_data&#45;&#62;state &#38; THREAD_STATE_NOT_STARTED));
    PARROT_ASSERT(!(interp&#45;&#62;thread_data&#45;&#62;state &#38; THREAD_STATE_FINISHED));

    if (from_stage == 0)
        PARROT_ASSERT(interp&#45;&#62;thread_data&#45;&#62;state &#38; THREAD_STATE_SUSPENDED_GC);
    else
        PARROT_ASSERT(!(interp&#45;&#62;thread_data&#45;&#62;state &#38; THREAD_STATE_SUSPENDED_GC));

    ++info&#45;&#62;num_reached;

    DEBUG_ONLY(fprintf(stderr,&#34;%p: gc_wait_for_stage: got %d&#34;, interp, info&#45;&#62;num_reached));

    if (info&#45;&#62;num_reached == thread_count) {
        info&#45;&#62;gc_stage    = to_stage;
        info&#45;&#62;num_reached = 0;
        COND_BROADCAST(info&#45;&#62;gc_cond);
    }
    else {
        do {
            COND_WAIT(info&#45;&#62;gc_cond, interpreter_array_mutex);
        } while (info&#45;&#62;gc_stage != to_stage);
    }
    UNLOCK(interpreter_array_mutex);
}</pre>

<p>/* Check if we need to wake threads to perform garbage collection. * This is called after thread death. * interpreter_array_mutex is assumed held. */ static void pt_gc_wakeup_check(PARROT_INTERP) { Shared_gc_info *info = shared_gc_info; int thread_count;</p>

<pre lang='und' xml:lang='und'>    thread_count = pt_gc_count_threads(interp);

    if (info&#45;&#62;num_reached == thread_count) {
        PARROT_ASSERT(info&#45;&#62;gc_stage == THREAD_GC_STAGE_NONE);
        info&#45;&#62;gc_stage    = THREAD_GC_STAGE_MARK;
        info&#45;&#62;num_reached = 0;
        COND_BROADCAST(info&#45;&#62;gc_cond);
    }
}</pre>

<p>/*</p>

<p>FUNCDOC: pt_suspend_one_for_gc</p>

<p>Suspend a single interpreter for GC. <code lang='und' xml:lang='und'>interpreter_array_mutex</code> assumed held.</p>

<p>*/</p>

<p>static void pt_suspend_one_for_gc(PARROT_INTERP) { DEBUG_ONLY(fprintf(stderr,&#34;suspend one: %p&#34;, interp)); if (is_suspended_for_gc(interp)) { DEBUG_ONLY(fprintf(stderr,&#34;ignoring already suspended&#34;)); return; }</p>

<pre lang='und' xml:lang='und'>    if (interp&#45;&#62;thread_data&#45;&#62;state &#38; THREAD_STATE_GC_WAKEUP) {
        DEBUG_ONLY(fprintf(stderr,&#34;just waking it up&#34;));
        interp&#45;&#62;thread_data&#45;&#62;state |= THREAD_STATE_SUSPENDED_GC;
        COND_SIGNAL(interp&#45;&#62;thread_data&#45;&#62;interp_cond);
    }
    else {
        DEBUG_ONLY(fprintf(stderr,&#34;queuing event&#34;));
        interp&#45;&#62;thread_data&#45;&#62;state |= THREAD_STATE_SUSPEND_GC_REQUESTED;
        Parrot_new_suspend_for_gc_event(interp);
    }
}</pre>

<p>/*</p>

<p>FUNCDOC: pt_suspend_all_for_gc</p>

<p>Get all threads to perform a GC run.</p>

<p>*/</p>

<p>static void pt_suspend_all_for_gc(PARROT_INTERP) { UINTVAL i;</p>

<pre lang='und' xml:lang='und'>    DEBUG_ONLY(fprintf(stderr,&#34;suspend_all_for_gc [interp=%p]&#34;, interp));

    LOCK(interpreter_array_mutex);
    interp&#45;&#62;thread_data&#45;&#62;state |= THREAD_STATE_SUSPENDED_GC;

    if (interp&#45;&#62;thread_data&#45;&#62;state &#38; THREAD_STATE_SUSPEND_GC_REQUESTED) {
        DEBUG_ONLY(fprintf(stderr,&#34;found while suspending all\n&#34;));
        remove_queued_suspend_gc(interp);
        interp&#45;&#62;thread_data&#45;&#62;state &#38;= ~THREAD_STATE_SUSPEND_GC_REQUESTED;
        UNLOCK(interpreter_array_mutex);
        return;
    }</pre>

<p>#if 0 for (i = 0; i &#60; n_interpreters; ++i) { Parrot_Interp other_interp; other_interp = interpreter_array[i]; if (!other_interp) continue;</p>

<pre lang='und' xml:lang='und'>        if (is_suspended_for_gc(other_interp) &#38;&#38;
            other_interp != interp &#38;&#38;
            (other_interp&#45;&#62;thread_data&#45;&#62;state &#38; THREAD_STATE_SUSPENDED_GC))
        {
            QUEUE_ENTRY *successp;
            /* this means that someone else already got this far,
             * so we have a suspend event in our queue to ignore
             */
            /* XXX still reachable? */
            DEBUG_ONLY(fprintf(stderr,&#34;apparently someone else is doing it [%p]&#34;,other_interp));
            fprintf(stderr, &#34;??? found later (%p)\n&#34;, other_interp);
            successp = remove_queued_suspend_gc(interp);
            PARROT_ASSERT(successp);
            UNLOCK(interpreter_array_mutex);
            return;
        }
    }
#endif

    /* now send all the non&#45;suspended threads to suspend for GC */
    for (i = 0; i &#60; n_interpreters; ++i) {
        Parrot_Interp other_interp = interpreter_array[i];

        if (interp == other_interp)
            continue;

        if (is_suspended_for_gc(other_interp))
            continue;

        pt_suspend_one_for_gc(other_interp);
    }
    UNLOCK(interpreter_array_mutex);
}</pre>

<p>/*</p>

<p>FUNCDOC: pt_suspend_self_for_gc</p>

<p>Suspend this thread for a full GC run.</p>

<p>XXX FIXME &#45;&#45; if GC is blocked, we need to do a GC run as soon as it becomes unblocked.</p>

<p>*/</p>

<p>void pt_suspend_self_for_gc(PARROT_INTERP) { PARROT_ASSERT(interp); PARROT_ASSERT(!interp&#45;&#62;arena_base&#45;&#62;DOD_block_level); DEBUG_ONLY(fprintf(stderr,&#34;%p: suspend_self_for_gc&#34;, interp)); /* since we are modifying our own state, we need to lock * the interpreter_array_mutex. */ LOCK(interpreter_array_mutex); DEBUG_ONLY(fprintf(stderr,&#34;%p: got lock&#34;, interp));</p>

<pre lang='und' xml:lang='und'>    PARROT_ASSERT(interp&#45;&#62;thread_data&#45;&#62;state &#38;
            (THREAD_STATE_SUSPEND_GC_REQUESTED | THREAD_STATE_SUSPENDED_GC));

    if (interp&#45;&#62;thread_data&#45;&#62;state &#38; THREAD_STATE_SUSPEND_GC_REQUESTED) {
        DEBUG_ONLY(fprintf(stderr,&#34;remove queued request&#34;));
        while (remove_queued_suspend_gc(interp));
        interp&#45;&#62;thread_data&#45;&#62;state &#38;= ~THREAD_STATE_SUSPEND_GC_REQUESTED;
    }
    if (!(interp&#45;&#62;thread_data&#45;&#62;state &#38; THREAD_STATE_SUSPENDED_GC)) {
        interp&#45;&#62;thread_data&#45;&#62;state |= THREAD_STATE_SUSPENDED_GC;
    }
    else {
        DEBUG_ONLY(fprintf(stderr,&#34;no need to set suspended\n&#34;));
    }
    UNLOCK(interpreter_array_mutex);

    /* mark and sweep our world &#45;&#45; later callbacks will keep
     * it sync&#39;d
     */
    Parrot_dod_ms_run(interp, DOD_trace_stack_FLAG);

    PARROT_ASSERT(!(interp&#45;&#62;thread_data&#45;&#62;state &#38; THREAD_STATE_SUSPENDED_GC));
}</pre>

<p>/*</p>

<p>FUNCDOC: pt_thread_join</p>

<p>Join (wait for) a joinable thread.</p>

<p>*/</p>

<p>PMC* pt_thread_join(NOTNULL(Parrot_Interp parent), UINTVAL tid) { int state; Parrot_Interp interp;</p>

<pre lang='und' xml:lang='und'>    LOCK(interpreter_array_mutex);

    interp = pt_check_tid(tid, &#34;join&#34;);

    if (interp == parent)
        do_panic(parent, &#34;Can&#39;t join self&#34;, __FILE__, __LINE__);

    if ((!(interp&#45;&#62;thread_data&#45;&#62;state &#38; (THREAD_STATE_DETACHED
            | THREAD_STATE_JOINED)) &#38;&#38;
         !(interp&#45;&#62;thread_data&#45;&#62;state &#38; THREAD_STATE_NOT_STARTED)) ||
            interp&#45;&#62;thread_data&#45;&#62;state == THREAD_STATE_FINISHED) {
        void *raw_retval = NULL;
        PMC *retval;

        interp&#45;&#62;thread_data&#45;&#62;state |= THREAD_STATE_JOINED;

        while (!(interp&#45;&#62;thread_data&#45;&#62;state &#38; THREAD_STATE_FINISHED)) {
            interp&#45;&#62;thread_data&#45;&#62;joiner = parent;
            pt_thread_wait(parent);
        }

        UNLOCK(interpreter_array_mutex);
        JOIN(interp&#45;&#62;thread_data&#45;&#62;thread, raw_retval);

        retval = (PMC *)raw_retval;
        /*
         * we need to push a cleanup handler here: if cloning
         * of the retval fails (e.g. it&#39;s a NULLPMC) this lock
         * isn&#39;t released until eternity or someone hits ^C
         *
         * TODO This is needed for all places holding a lock for
         *      non&#45;trivial tasks
         *      &#45;leo
         * TODO remove that and replace it with proper exception
         *      handling, so that a failing clone in the parent
         *      just stops that thread
         *      &#45;leo
         */
        LOCK(interpreter_array_mutex);
        CLEANUP_PUSH(mutex_unlock, &#38;interpreter_array_mutex);

        if (retval) {
            PMC *parent_ret;
            /*
             * clone the PMC into caller, if its not a shared PMC
             * the PMC is not in the parents root set nor in the
             * stack so block DOD during clone
             * XXX should probably acquire the parent&#39;s interpreter mutex
             */
            Parrot_block_DOD(parent);
            parent_ret = make_local_copy(parent, interp, retval);

            /* this PMC is living only in the stack of this currently
             * dying interpreter, so register it in parent&#39;s DOD registry
             * XXX is this still needed?
             */
            dod_register_pmc(parent, parent_ret);
            Parrot_unblock_DOD(parent);
            retval = parent_ret;
        }
        else {
            retval = PMCNULL;
        }
        interpreter_array[tid] = NULL;
        running_threads&#45;&#45;;

        DEBUG_ONLY(fprintf(stderr,&#34;destroying an interpreter [join]&#34;));
        if (Interp_debug_TEST(parent, PARROT_THREAD_DEBUG_FLAG))
            fprintf(stderr, &#34;running threads %d\n&#34;, running_threads);

        /* reparent it so memory pool merging works */
        interp&#45;&#62;parent_interpreter = parent;
        Parrot_really_destroy(interp, 0, NULL);

        CLEANUP_POP(1);
        /*
         * interpreter destruction is done &#45; unregister the return
         * value, caller gets it now
         */
        if (retval)
            dod_unregister_pmc(parent, retval);

        return retval;
    }
    /*
     * when here thread was in wrong state
     */
    state = interp&#45;&#62;thread_data&#45;&#62;state;
    UNLOCK(interpreter_array_mutex);
    real_exception(interp, NULL, 1, &#34;join: illegal thread state %d tid %d&#34;,
            state, tid);
    return NULL;
}</pre>

<p>/*</p>

<p>FUNCDOC: pt_join_threads</p>

<p>Possibly wait for other running threads. This is called when destroying <code lang='und' xml:lang='und'>interp</code>.</p>

<p>*/</p>

<p>void pt_join_threads(PARROT_INTERP) { size_t i; Shared_gc_info *info = get_pool(interp);</p>

<pre lang='und' xml:lang='und'>    if (info) {
        COND_DESTROY(info&#45;&#62;gc_cond);
        PARROT_ATOMIC_INT_DESTROY(shared_gc_info&#45;&#62;gc_block_level);
        mem_sys_free(info);
    }

    /*
     * if no threads were started &#45; fine
     */
    LOCK(interpreter_array_mutex);
    if (n_interpreters &#60;= 1) {
        UNLOCK(interpreter_array_mutex);
        return;
    }
    /*
     * only the first interpreter waits for other threads
     */
    if (interp != interpreter_array[0]) {
        UNLOCK(interpreter_array_mutex);
        return;
    }

    for (i = 1; i &#60; n_interpreters; ++i) {
        Parrot_Interp thread_interp = interpreter_array[i];
        if (thread_interp == NULL)
            continue;
        if (thread_interp&#45;&#62;thread_data&#45;&#62;state == THREAD_STATE_JOINABLE ||
            (thread_interp&#45;&#62;thread_data&#45;&#62;state &#38; THREAD_STATE_FINISHED)) {

            void *retval = NULL;
            thread_interp&#45;&#62;thread_data&#45;&#62;state |= THREAD_STATE_JOINED;
            UNLOCK(interpreter_array_mutex);
            JOIN(thread_interp&#45;&#62;thread_data&#45;&#62;thread, retval);
            LOCK(interpreter_array_mutex);
        }
    }
    UNLOCK(interpreter_array_mutex);
    return;
}</pre>

<p>/*</p>

<p>FUNCDOC: detach</p>

<p>Helper for detach and kill.</p>

<p>Returns the interpreter, if it didn&#39;t finish yet.</p>

<p>*/</p>

<p>static Parrot_Interp detach(UINTVAL tid) { Parrot_Interp interp;</p>

<pre lang='und' xml:lang='und'>    LOCK(interpreter_array_mutex);
    interp = pt_check_tid(tid, &#34;detach&#34;);
    /*
     * if interpreter is joinable, we detach em
     */
    if (interp&#45;&#62;thread_data&#45;&#62;state == THREAD_STATE_JOINABLE ||
            interp&#45;&#62;thread_data&#45;&#62;state == THREAD_STATE_FINISHED) {
        DETACH(interp&#45;&#62;thread_data&#45;&#62;thread);
        interp&#45;&#62;thread_data&#45;&#62;state |= THREAD_STATE_DETACHED;

        if (interp&#45;&#62;thread_data&#45;&#62;state &#38; THREAD_STATE_FINISHED) {
            interpreter_array[tid] = NULL;
            DEBUG_ONLY(fprintf(stderr,&#34;destroying an interpreter [detach]&#34;));
            Parrot_really_destroy(interp, 0, NULL);
            interp = NULL;
        }
    }
    UNLOCK(interpreter_array_mutex);
    return interp;
}</pre>

<p>/*</p>

<p>FUNCDOC: pt_thread_detach</p>

<p>Detaches (make non&#45;joinable) the thread.</p>

<p>*/</p>

<p>void pt_thread_detach(UINTVAL tid) { (void) detach(tid); }</p>

<p>/*</p>

<p>FUNCDOC: pt_thread_kill</p>

<p>Kills the thread.</p>

<p>*/</p>

<p>void pt_thread_kill(UINTVAL tid) { PARROT_INTERP = detach(tid);</p>

<pre lang='und' xml:lang='und'>    /* schedule a terminate event for that interpreter */
    if (interp)
        Parrot_new_terminate_event(interp);
}</pre>

<p>/*</p>

<h2><a name="Threaded_interpreter_book&#45;keeping"
>Threaded interpreter book&#45;keeping <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>FUNCDOC: pt_add_to_interpreters</p>

<p>All threaded interpreters are stored in an array. Assumes that caller holds LOCK.</p>

<p>*/</p>

<p>void pt_add_to_interpreters(PARROT_INTERP, Parrot_Interp new_interp) { size_t i; DEBUG_ONLY(fprintf(stderr,&#34;interp = %p&#34;, interp));</p>

<pre lang='und' xml:lang='und'>    if (!new_interp) {
        /*
         * Create an entry for the very first interpreter, event
         * handling needs it
         */
        PARROT_ASSERT(!interpreter_array);
        PARROT_ASSERT(n_interpreters == 0);

        interpreter_array    = mem_allocate_typed(Interp *);
        interpreter_array[0] = interp;
        n_interpreters       = 1;

        shared_gc_info = (Shared_gc_info *)mem_sys_allocate_zeroed(sizeof(*shared_gc_info));
        COND_INIT(shared_gc_info&#45;&#62;gc_cond);
        PARROT_ATOMIC_INT_INIT(shared_gc_info&#45;&#62;gc_block_level);
        PARROT_ATOMIC_INT_SET(shared_gc_info&#45;&#62;gc_block_level, 0);

        /* XXX try to defer this until later */
        PARROT_ASSERT(interp == interpreter_array[0]);
        interp&#45;&#62;thread_data      = mem_allocate_zeroed_typed(Thread_data);
        INTERPRETER_LOCK_INIT(interp);
        interp&#45;&#62;thread_data&#45;&#62;tid = 0;

        return;
    }


    new_interp&#45;&#62;thread_data = mem_allocate_zeroed_typed(Thread_data);
    INTERPRETER_LOCK_INIT(new_interp);
    running_threads++;
    if (Interp_debug_TEST(interp, PARROT_THREAD_DEBUG_FLAG))
        fprintf(stderr, &#34;running threads %d\n&#34;, running_threads);
    /*
     * look for an empty slot
     */
    for (i = 0; i &#60; n_interpreters; ++i) {
        if (interpreter_array[i] == NULL) {
            interpreter_array[i] = new_interp;
            new_interp&#45;&#62;thread_data&#45;&#62;tid   = i;
            new_interp&#45;&#62;thread_data&#45;&#62;state = THREAD_STATE_NOT_STARTED;
            return;
        }
    }

    /* need to resize */
    interpreter_array = (Interp **)mem_sys_realloc(interpreter_array,
            (n_interpreters + 1) * sizeof (Interp *));

    interpreter_array[n_interpreters] = new_interp;
    new_interp&#45;&#62;thread_data&#45;&#62;tid      = n_interpreters;
    new_interp&#45;&#62;thread_data&#45;&#62;state    = THREAD_STATE_NOT_STARTED;

    ++n_interpreters;
}</pre>

<p>/*</p>

<h2><a name="DOD_Synchronization_Functions"
>DOD Synchronization Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>FUNCDOC: pt_DOD_start_mark</p>

<p>DOD is gonna start the mark phase. In the presence of shared PMCs, we can only run one DOD run at a time because <code lang='und' xml:lang='und'>PMC&#45;&#62;next_for_GC</code> may be changed.</p>

<p><code lang='und' xml:lang='und'>flags</code> are the DOD flags. We check if we need to collect shared objects or not.</p>

<p>TODO &#45; Have a count of shared PMCs and check it during DOD.</p>

<p>TODO &#45; Evaluate if a interpreter lock is cheaper when <code lang='und' xml:lang='und'>dod_mark_ptr</code> is updated.</p>

<p>*/</p>

<p>void pt_DOD_start_mark(PARROT_INTERP) { Shared_gc_info *info; int block_level;</p>

<pre lang='und' xml:lang='und'>    DEBUG_ONLY(fprintf(stderr,&#34;%p: pt_DOD_start_mark&#34;, interp));
    /* if no other threads are running, we are safe */
    if (!running_threads)
        return;

    info = get_pool(interp);
    PARROT_ATOMIC_INT_GET(block_level, info&#45;&#62;gc_block_level);

    DEBUG_ONLY(fprintf(stderr,&#34;start threaded mark&#34;));
    /*
     * TODO now check, if we are the owner of a shared memory pool
     * if yes:
     * &#45; suspend all other threads by sending them a suspend event
     *   (or put a LOCK around updating the mark pointers)
     * &#45; return and continue the mark phase
     * &#45; then s. comments below
     */
    LOCK(interpreter_array_mutex);
    if (interp&#45;&#62;thread_data&#45;&#62;state &#38; THREAD_STATE_SUSPENDED_GC) {
        PARROT_ASSERT(!(interp&#45;&#62;thread_data&#45;&#62;state &#38;
                 THREAD_STATE_SUSPEND_GC_REQUESTED));
        DEBUG_ONLY(fprintf(stderr,&#34;already suspended...&#34;));
        UNLOCK(interpreter_array_mutex);
    }
    else if (block_level) {
        /* unthreaded collection */
        DEBUG_ONLY(fprintf(stderr,&#34;... but blocked&#34;));

        /* holding the lock */
        return;
    }
    else if (interp&#45;&#62;thread_data&#45;&#62;state &#38;
               THREAD_STATE_SUSPEND_GC_REQUESTED) {
        while (remove_queued_suspend_gc(interp));

        interp&#45;&#62;thread_data&#45;&#62;state &#38;= ~THREAD_STATE_SUSPEND_GC_REQUESTED;
        interp&#45;&#62;thread_data&#45;&#62;state |= THREAD_STATE_SUSPENDED_GC;

        DEBUG_ONLY(fprintf(stderr,&#34;%p: detected request&#34;, interp));
        UNLOCK(interpreter_array_mutex);
    }
    else {
        /* we need to stop the world */
        DEBUG_ONLY(fprintf(stderr,&#34;stop the world&#34;));
        UNLOCK(interpreter_array_mutex);

        pt_suspend_all_for_gc(interp);
    }

    DEBUG_ONLY(fprintf(stderr,&#34;%p: wait for stage&#34;, interp));
    pt_gc_wait_for_stage(interp, THREAD_GC_STAGE_NONE, THREAD_GC_STAGE_MARK);

    DEBUG_ONLY(fprintf(stderr,&#34;actually mark&#34;));
    /*
     * we can&#39;t allow parallel running DODs both would mess with shared PMCs
     * next_for_GC pointers
     */
    LOCK(interpreter_array_mutex);
    DEBUG_ONLY(fprintf(stderr,&#34;got marking lock&#34;));
}</pre>

<p>/*</p>

<p>FUNCDOC: pt_DOD_mark_root_finished</p>

<p>DOD is finished for the root set.</p>

<p>*/</p>

<p>void pt_DOD_mark_root_finished(PARROT_INTERP) { if (!running_threads) return; /* * TODO now check, if we are the owner of a shared memory pool * if yes: * &#45; now run DOD_mark on all members of our pool * &#45; if all shared PMCs are marked by all threads then * &#45; we can continue to free unused objects */ }</p>

<p>/*</p>

<p>FUNCDOC: pt_DOD_stop_mark</p>

<p>DOD&#39;s mark phase is done.</p>

<p>*/</p>

<p>void pt_DOD_stop_mark(PARROT_INTERP) { if (!running_threads) return; /* * normal operation can continue now * &#45; other threads may or not free unused objects then, * depending on their resource statistics */ if (!(interp&#45;&#62;thread_data&#45;&#62;state &#38; THREAD_STATE_SUSPENDED_GC)) { UNLOCK(interpreter_array_mutex); return; }</p>

<pre lang='und' xml:lang='und'>    PARROT_ASSERT(!(interp&#45;&#62;thread_data&#45;&#62;state &#38;
             THREAD_STATE_SUSPEND_GC_REQUESTED));
    interp&#45;&#62;thread_data&#45;&#62;state &#38;= ~THREAD_STATE_SUSPENDED_GC;

    while (remove_queued_suspend_gc(interp)) {
        /* XXX FIXME make this message never trigger */
        fprintf(stderr, &#34;%p: extraneous suspend_gc event\n&#34;, (void *)interp);
    }

    DEBUG_ONLY(fprintf(stderr,&#34;%p: unlock&#34;, interp));
    UNLOCK(interpreter_array_mutex);
    DEBUG_ONLY(fprintf(stderr,&#34;wait to sweep&#34;));

    pt_gc_wait_for_stage(interp, THREAD_GC_STAGE_MARK, THREAD_GC_STAGE_SWEEP);
}</pre>

<p>/*</p>

<p>FUNCDOC: Parrot_shared_DOD_block</p>

<p>Block stop&#45;the&#45;world DOD runs.</p>

<p>*/</p>

<p>PARROT_API void Parrot_shared_DOD_block(PARROT_INTERP) { Shared_gc_info * const info = get_pool(interp);</p>

<pre lang='und' xml:lang='und'>    if (info) {
        int level;
        PARROT_ATOMIC_INT_INC(level, info&#45;&#62;gc_block_level);
        PARROT_ASSERT(level &#62; 0);
    }
}</pre>

<p>/*</p>

<p>FUNCDCOC: Parrot_shared_DOD_unblock</p>

<p>Unblock stop&#45;the&#45;world DOD runs.</p>

<p>*/</p>

<p>PARROT_API void Parrot_shared_DOD_unblock(PARROT_INTERP) { Shared_gc_info * const info = get_pool(interp); if (info) { int level; PARROT_ATOMIC_INT_DEC(level, info&#45;&#62;gc_block_level); PARROT_ASSERT(level &#62;= 0); } }</p>

<p>/* * Local variables: * c&#45;file&#45;style: &#34;parrot&#34; * End: * vim: expandtab shiftwidth=4: */</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
