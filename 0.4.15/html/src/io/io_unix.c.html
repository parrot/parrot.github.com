<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>UNIX IO layer</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">UNIX IO layer</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../html/index.html">Contents</a> | <a href="../../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>src/io/io_unix.c &#45; UNIX IO layer</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>This is the Parrot UNIX IO layer.
It implements unbuffered,
low&#45;level,
UNIX&#45;specific functionality.</p>

<p>As &#34;UNIX&#34; is already a generalization,
it may be necessary to create separate OS&#45;specific layers for UNIX flavors,
to avoid over&#45;complicating this file.</p>

<h2><a name="References:"
>References: <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>APitUE &#45; W.
Richard Stevens,
AT&#38;T SFIO,
Perl5 (Nick Ing&#45;Simmons)</p>

<h2><a name="Functions"
>Functions <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>*/</p>

<p>#include &#34;parrot/parrot.h&#34; #include &#34;io_private.h&#34;</p>

<p>#ifdef PIO_OS_UNIX</p>

<p>/* Defined at bottom */ extern const ParrotIOLayerAPI pio_unix_layer_api;</p>

<p>ParrotIOLayer pio_unix_layer = { NULL,
&#34;unix&#34;,
PIO_L_TERMINAL,
&#38;pio_unix_layer_api,
0,
0 };</p>

<p>/* HEADERIZER HFILE: none */</p>

<p>/* HEADERIZER BEGIN: static */</p>

<p>PARROT_CONST_FUNCTION static INTVAL flags_to_unix( INTVAL flags );</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CAN_RETURN_NULL static ParrotIO * PIO_unix_accept( PARROT_INTERP,
SHIM(ParrotIOLayer *layer),
NOTNULL(ParrotIO *io) ) __attribute__nonnull__(1) __attribute__nonnull__(3);</p>

<p>INTVAL PIO_unix_async( PARROT_INTERP,
NOTNULL(ParrotIOLayer *layer),
NOTNULL(ParrotIO *io),
INTVAL b ) __attribute__nonnull__(1) __attribute__nonnull__(2) __attribute__nonnull__(3);</p>

<p>static INTVAL PIO_unix_bind( SHIM_INTERP,
SHIM(ParrotIOLayer *layer),
NOTNULL(ParrotIO *io),
NOTNULL(STRING *l) ) __attribute__nonnull__(3) __attribute__nonnull__(4);</p>

<p>static INTVAL PIO_unix_close( SHIM_INTERP,
SHIM(ParrotIOLayer *layer),
NOTNULL(ParrotIO *io) ) __attribute__nonnull__(3);</p>

<p>static INTVAL PIO_unix_connect( SHIM_INTERP,
SHIM(ParrotIOLayer *layer),
NOTNULL(ParrotIO *io),
NULLOK(STRING *r) ) __attribute__nonnull__(3);</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL static ParrotIO * PIO_unix_fdopen( PARROT_INTERP,
SHIM(ParrotIOLayer *layer),
PIOHANDLE fd,
INTVAL flags ) __attribute__nonnull__(1);</p>

<p>static INTVAL PIO_unix_flush( SHIM_INTERP,
SHIM(ParrotIOLayer *layer),
NOTNULL(ParrotIO *io) ) __attribute__nonnull__(3);</p>

<p>static INTVAL PIO_unix_init( PARROT_INTERP,
NOTNULL(ParrotIOLayer *layer) ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>static INTVAL PIO_unix_isatty( PIOHANDLE fd ); static INTVAL PIO_unix_listen( SHIM_INTERP,
SHIM(ParrotIOLayer *layer),
NOTNULL(ParrotIO *io),
INTVAL sec ) __attribute__nonnull__(3);</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CAN_RETURN_NULL static ParrotIO * PIO_unix_open( PARROT_INTERP,
NOTNULL(ParrotIOLayer *layer),
NOTNULL(const char *spath),
INTVAL flags ) __attribute__nonnull__(1) __attribute__nonnull__(2) __attribute__nonnull__(3);</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CAN_RETURN_NULL static ParrotIO * PIO_unix_pipe( PARROT_INTERP,
SHIM(ParrotIOLayer *l),
NOTNULL(const char *cmd),
int flags ) __attribute__nonnull__(1) __attribute__nonnull__(3);</p>

<p>static INTVAL PIO_unix_poll( SHIM_INTERP,
SHIM(ParrotIOLayer *l),
NOTNULL(ParrotIO *io),
int which,
int sec,
int usec ) __attribute__nonnull__(3);</p>

<p>static size_t PIO_unix_read( PARROT_INTERP,
SHIM(ParrotIOLayer *layer),
NOTNULL(ParrotIO *io),
NOTNULL(STRING **buf) ) __attribute__nonnull__(1) __attribute__nonnull__(3) __attribute__nonnull__(4);</p>

<p>static INTVAL PIO_unix_recv( PARROT_INTERP,
SHIM(ParrotIOLayer *layer),
NOTNULL(ParrotIO *io),
NOTNULL(STRING **s) ) __attribute__nonnull__(1) __attribute__nonnull__(3) __attribute__nonnull__(4);</p>

<p>static PIOOFF_T PIO_unix_seek( SHIM_INTERP,
SHIM(ParrotIOLayer *layer),
NOTNULL(ParrotIO *io),
PIOOFF_T offset,
INTVAL whence ) __attribute__nonnull__(3);</p>

<p>static INTVAL PIO_unix_send( SHIM_INTERP,
SHIM(ParrotIOLayer *layer),
NOTNULL(ParrotIO *io),
NOTNULL(STRING *s) ) __attribute__nonnull__(3) __attribute__nonnull__(4);</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CAN_RETURN_NULL static ParrotIO * PIO_unix_socket( PARROT_INTERP,
SHIM(ParrotIOLayer *layer),
int fam,
int type,
int proto ) __attribute__nonnull__(1);</p>

<p>static PIOOFF_T PIO_unix_tell( SHIM_INTERP,
SHIM(ParrotIOLayer *layer),
NOTNULL(ParrotIO *io) ) __attribute__nonnull__(3);</p>

<p>static size_t PIO_unix_write( SHIM_INTERP,
SHIM(ParrotIOLayer *layer),
NOTNULL(ParrotIO *io),
NOTNULL(STRING *s) ) __attribute__nonnull__(3) __attribute__nonnull__(4);</p>

<p>/* HEADERIZER END: static */</p>

<p>/*</p>

<p>FUNCDOC: flags_to_unix</p>

<p>Returns a UNIX&#45;specific interpretation of <code lang='und' xml:lang='und'>flags</code> suitable for passing to <code lang='und' xml:lang='und'>open()</code> and <code lang='und' xml:lang='und'>fopen()</code> in <code lang='und' xml:lang='und'>PIO_unix_open()</code> and <code lang='und' xml:lang='und'>PIO_unix_fdopen()</code> respectively.</p>

<p>*/</p>

<p>PARROT_CONST_FUNCTION static INTVAL flags_to_unix(INTVAL flags) { INTVAL oflags = 0;</p>

<pre lang='und' xml:lang='und'>    if ((flags &#38; (PIO_F_WRITE | PIO_F_READ)) == (PIO_F_WRITE | PIO_F_READ)) {
        oflags |= O_RDWR | O_CREAT;
    }
    else if (flags &#38; PIO_F_WRITE) {
        oflags |= O_WRONLY | O_CREAT;
    }
    else if (flags &#38; PIO_F_READ) {
        oflags |= O_RDONLY;
    }

    if (flags &#38; PIO_F_APPEND) {
        oflags |= O_APPEND;
    }
    else if (flags &#38; PIO_F_TRUNC) {
        oflags |= O_TRUNC;
    }
    return oflags;
}</pre>

<p>/*</p>

<p>FUNCDOC: PIO_unix_init</p>

<p>Sets up the interpreter&#39;s standard <code lang='und' xml:lang='und'>std*</code> IO handles. Returns <code lang='und' xml:lang='und'>0</code> on success and <code lang='und' xml:lang='und'>&#45;1</code> on error.</p>

<p>*/</p>

<p>static INTVAL PIO_unix_init(PARROT_INTERP, NOTNULL(ParrotIOLayer *layer)) { ParrotIOData * const d = interp&#45;&#62;piodata; if (d != NULL &#38;&#38; d&#45;&#62;table != NULL) { ParrotIO *io;</p>

<pre lang='und' xml:lang='und'>        io = PIO_unix_fdopen(interp, layer, STDIN_FILENO, PIO_F_READ);
        if (!io)
            return &#45;1;
        _PIO_STDIN(interp) = new_io_pmc(interp, io);

        io = PIO_unix_fdopen(interp, layer, STDOUT_FILENO, PIO_F_WRITE);
        if (!io)
            return &#45;1;
        _PIO_STDOUT(interp) = new_io_pmc(interp, io);

        io = PIO_unix_fdopen(interp, layer, STDERR_FILENO, PIO_F_WRITE);
        if (!io)
            return &#45;1;
        _PIO_STDERR(interp) = new_io_pmc(interp, io);

        return 0;
    }
    return &#45;1;
}</pre>

<p>/*</p>

<p>FUNCDOC: PIO_unix_open</p>

<p>Opens <code lang='und' xml:lang='und'>*spath</code>. <code lang='und' xml:lang='und'>flags</code> is a bitwise <code lang='und' xml:lang='und'>or</code> combination of <code lang='und' xml:lang='und'>PIO_F_*</code> values.</p>

<p>*/</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CAN_RETURN_NULL static ParrotIO * PIO_unix_open(PARROT_INTERP, NOTNULL(ParrotIOLayer *layer), NOTNULL(const char *spath), INTVAL flags) { INTVAL oflags; PIOHANDLE fd;</p>

<pre lang='und' xml:lang='und'>    const INTVAL type = PIO_TYPE_FILE;
    const INTVAL mode = DEFAULT_OPEN_MODE;

    if (flags &#38; PIO_F_PIPE)
        return PIO_unix_pipe(interp, layer, spath, flags);

    if ((flags &#38; (PIO_F_WRITE | PIO_F_READ)) == 0)
        return NULL;

    oflags = flags_to_unix(flags);

    /* Only files for now */
    flags |= PIO_F_FILE;

    /* Try open with no create first */
    while ((fd = open(spath, oflags &#38; (O_WRONLY | O_RDWR | O_APPEND), mode))
           &#60; 0 &#38;&#38; errno == EINTR)
        errno = 0;

    /* File open */
    if (fd &#62;= 0) {
        /*
         * Now check if we specified O_CREAT|O_EXCL or not.
         * If so, we must return NULL, else either use the
         * descriptor or create the file.
         */
        if ((oflags &#38; (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL)) {
            close(fd);
            return NULL;
        }
        /*
         * Check for truncate?
         */
        if (oflags &#38; O_TRUNC) {
            int tfd;
            while ((tfd = creat(spath, PIO_DEFAULTMODE)) &#60; 0 &#38;&#38; errno == EINTR)
                errno = 0;
            close(tfd);
        }
    }
    else if (oflags &#38; O_CREAT) {
        /* O_CREAT and file doesn&#39;t exist. */
        while ((fd = creat(spath, PIO_DEFAULTMODE)) &#60; 0 &#38;&#38; errno == EINTR)
            errno = 0;
        if (!(oflags &#38; O_WRONLY)) {
            close(fd);
            /*
             * File created, reopen with read+write
             */
            while ((fd = open(spath, oflags &#38; (O_WRONLY | O_RDWR),
                              mode)) &#60; 0 &#38;&#38; errno == EINTR)
                errno = 0;
        }
    }
    else {
        /* File doesn&#39;t exist and O_CREAT not specified */
    }

    if (fd &#62;= 0) {
        /* Set generic flag here if is a terminal then
         * higher layers can know how to setup buffering.
         * STDIN, STDOUT, STDERR would be in this case
         * so we would setup linebuffering.
         */
        ParrotIO *io;
        if (PIO_unix_isatty(fd))
            flags |= PIO_F_CONSOLE;
        io = PIO_new(interp, type, flags, mode);
        io&#45;&#62;fd = fd;
        return io;
    }
    return NULL;
}</pre>

<p># if PARROT_ASYNC_DEVEL</p>

<p>/*</p>

<p>FUNCDOC: PIO_unix_async</p>

<p>Experimental asynchronous IO.</p>

<p>This is available if <code lang='und' xml:lang='und'>PARROT_ASYNC_DEVEL</code> is defined.</p>

<p>Only works on Linux at the moment.</p>

<p>Toggles the <code lang='und' xml:lang='und'>O_ASYNC</code> flag on the IO file descriptor.</p>

<p>*/</p>

<p>INTVAL PIO_unix_async(PARROT_INTERP, NOTNULL(ParrotIOLayer *layer), NOTNULL(ParrotIO *io), INTVAL b) { int rflags; # if defined(linux) if ((rflags = fcntl(io&#45;&#62;fd, F_GETFL, 0)) &#62;= 0) { if (b) rflags |= O_ASYNC; else rflags &#38;= ~O_ASYNC; return fcntl(io&#45;&#62;fd, F_SETFL, rflags); } # else real_exception(interp, NULL, PIO_NOT_IMPLEMENTED, &#34;Async support not available&#34;); # endif return &#45;1; }</p>

<p># endif</p>

<p>/*</p>

<p>FUNCDOC: PIO_unix_fdopen</p>

<p>Returns a new <code lang='und' xml:lang='und'>ParrotIO</code> with file descriptor <code lang='und' xml:lang='und'>fd</code>.</p>

<p>*/</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL static ParrotIO * PIO_unix_fdopen(PARROT_INTERP, SHIM(ParrotIOLayer *layer), PIOHANDLE fd, INTVAL flags) { ParrotIO *io; const INTVAL mode = 0;</p>

<p># if 0 /* XXX the fcntl fails (&#45;1, errno=0) with * ./parrot &#45;tf &#45; &#60; foo.pir */</p>

<pre lang='und' xml:lang='und'>    /* FIXME &#45; Check file handle flags, validity */
#    ifdef PARROT_HAS_HEADER_FCNTL
    {
        INTVAL rflags;
        /* Get descriptor flags */
        if ((rflags = fcntl(fd, F_GETFL, 0)) &#62;= 0) {
            UNUSED(rflags);
            /*int accmode = rflags &#38; O_ACCMODE; */
            /* Check other flags (APPEND, ASYNC, etc) */
        }
        else {
            /* Probably invalid descriptor */
            return NULL;
        }
    }
#    endif
#  endif

    if (PIO_unix_isatty(fd))
        flags |= PIO_F_CONSOLE;

    /* fdopened files are always shared */
    flags |= PIO_F_SHARED;

    io = PIO_new(interp, PIO_F_FILE, flags, mode);
    io&#45;&#62;fd = fd;
    return io;
}</pre>

<p>/*</p>

<p>FUNCDOC: PIO_unix_close</p>

<p>Closes <code lang='und' xml:lang='und'>*io</code>&#39;s file descriptor.</p>

<p>*/</p>

<p>static INTVAL PIO_unix_close(SHIM_INTERP, SHIM(ParrotIOLayer *layer), NOTNULL(ParrotIO *io)) { if (io&#45;&#62;fd &#62;= 0) close(io&#45;&#62;fd); io&#45;&#62;fd = &#45;1; return 0; }</p>

<p>/*</p>

<p>FUNCDOC: PIO_unix_isatty</p>

<p>Returns a boolean value indicating whether <code lang='und' xml:lang='und'>fd</code> is a console/tty.</p>

<p>*/</p>

<p>static INTVAL PIO_unix_isatty(PIOHANDLE fd) { return isatty(fd); }</p>

<p>/*</p>

<p>FUNCDOC: PIO_unix_getblksize</p>

<p>Various ways of determining block size.</p>

<p>If passed a file descriptor then <code lang='und' xml:lang='und'>fstat()</code> and the <code lang='und' xml:lang='und'>stat</code> buffer are used if available.</p>

<p>If called without an argument then the <code lang='und' xml:lang='und'>BLKSIZE</code> constant is returned if it was available at compile time, otherwise <code lang='und' xml:lang='und'>PIO_BLKSIZE</code> is returned.</p>

<p>*/</p>

<p>INTVAL PIO_unix_getblksize(PIOHANDLE fd) { if (fd &#62;= 0) { /* Try to get the block size of a regular file */ # if 0 /* * Is it even worth adding non&#45;portable code here * or should we just estimate a nice buffer size? * Some systems have st_blksize, some don&#39;t. */ { struct stat sbuf; int err; err = fstat(fd, &#38;sbuf); if (err == 0) { return sbuf.st_blksize; } } # endif } /* Try to determine it from general means. */ # ifdef BLKSIZE return BLKSIZE; # else return PIO_BLKSIZE; # endif }</p>

<p>/*</p>

<p>FUNCDOC: PIO_unix_flush</p>

<p>At lowest layer all we can do for <code lang='und' xml:lang='und'>flush</code> is to ask the kernel to <code lang='und' xml:lang='und'>sync()</code>.</p>

<p>XXX: Is it necessary to <code lang='und' xml:lang='und'>sync()</code> here?</p>

<p>*/</p>

<p>static INTVAL PIO_unix_flush(SHIM_INTERP, SHIM(ParrotIOLayer *layer), NOTNULL(ParrotIO *io)) { return fsync(io&#45;&#62;fd); }</p>

<p>/*</p>

<p>FUNCDOC: PIO_unix_read</p>

<p>Calls <code lang='und' xml:lang='und'>read()</code> to return up to <code lang='und' xml:lang='und'>len</code> bytes in the memory starting at <code lang='und' xml:lang='und'>buffer</code>.</p>

<p>*/</p>

<p>static size_t PIO_unix_read(PARROT_INTERP, SHIM(ParrotIOLayer *layer), NOTNULL(ParrotIO *io), NOTNULL(STRING **buf)) { STRING * const s = PIO_make_io_string(interp, buf, 2048);</p>

<pre lang='und' xml:lang='und'>    const size_t len = s&#45;&#62;bufused;
    void * const buffer = s&#45;&#62;strstart;

    for (;;) {
        const int bytes = read(io&#45;&#62;fd, buffer, len);
        if (bytes &#62; 0) {
            s&#45;&#62;bufused = s&#45;&#62;strlen = bytes;
            return bytes;
        }
        else if (bytes &#60; 0) {
            switch (errno) {
            case EINTR:
                continue;
            default:
                s&#45;&#62;bufused = s&#45;&#62;strlen = 0;
                return bytes;
            }
        }
        else {
            /* Read returned 0, EOF if len requested &#62; 0 */
            if (len &#62; 0)
                io&#45;&#62;flags |= PIO_F_EOF;
            s&#45;&#62;bufused = s&#45;&#62;strlen = 0;
            return bytes;
        }
    }
}</pre>

<p>/*</p>

<p>FUNCDOC: PIO_unix_write</p>

<p>Calls <code lang='und' xml:lang='und'>write()</code> to write <code lang='und' xml:lang='und'>len</code> bytes from the memory starting at <code lang='und' xml:lang='und'>buffer</code> to the file descriptor in <code lang='und' xml:lang='und'>*io</code>.</p>

<p>*/</p>

<p>static size_t PIO_unix_write(SHIM_INTERP, SHIM(ParrotIOLayer *layer), NOTNULL(ParrotIO *io), NOTNULL(STRING *s)) { int err; size_t bytes; size_t to_write; char * const buffer = s&#45;&#62;strstart; const size_t len = s&#45;&#62;bufused; const char *ptr = buffer;</p>

<pre lang='und' xml:lang='und'>    to_write = len;
    bytes = 0;

  write_through:
    while (to_write &#62; 0) {
        if ((err = write(io&#45;&#62;fd, ptr, to_write)) &#62;= 0) {
            ptr += err;
            to_write &#45;= err;
            bytes += err;
        }
        else {
            switch (errno) {
            case EINTR:
                goto write_through;
#  ifdef EAGAIN
            case EAGAIN:
                return bytes;
#  endif
            default:
                return (size_t)&#45;1;
            }
        }
    }
    return bytes;
}</pre>

<p>/*</p>

<p>FUNCDOC: PIO_unix_seek</p>

<p>Hard seek.</p>

<p>Calls <code lang='und' xml:lang='und'>lseek()</code> to advance the read/write position on <code lang='und' xml:lang='und'>*io</code>&#39;s file descriptor to <code lang='und' xml:lang='und'>offset</code> bytes from the location indicated by <code lang='und' xml:lang='und'>whence</code>.</p>

<p>*/</p>

<p>static PIOOFF_T PIO_unix_seek(SHIM_INTERP, SHIM(ParrotIOLayer *layer), NOTNULL(ParrotIO *io), PIOOFF_T offset, INTVAL whence) { const PIOOFF_T pos = lseek(io&#45;&#62;fd, offset, whence);</p>

<pre lang='und' xml:lang='und'>    if (pos &#62;= 0) {
        switch (whence) {
            case SEEK_SET:
                io&#45;&#62;fsize = offset &#62; io&#45;&#62;fsize ? offset : io&#45;&#62;fsize;
                break;
            case SEEK_CUR:
                {
                const PIOOFF_T avail = io&#45;&#62;b.next &#45; io&#45;&#62;b.startb + offset;
                io&#45;&#62;fsize = ( avail &#62; io&#45;&#62;fsize) ? avail : io&#45;&#62;fsize;
                }
                break;
            case SEEK_END:
            default:
                break;
        }

        io&#45;&#62;lpos = io&#45;&#62;fpos;
        io&#45;&#62;fpos = pos;
    }
    /* Seek clears EOF */
    io&#45;&#62;flags &#38;= ~PIO_F_EOF;
    return pos;
}</pre>

<p>/*</p>

<p>FUNCDOC: PIO_unix_tell</p>

<p>Returns the current read/write position on <code lang='und' xml:lang='und'>*io</code>&#39;s file discriptor.</p>

<p>*/</p>

<p>static PIOOFF_T PIO_unix_tell(SHIM_INTERP, SHIM(ParrotIOLayer *layer), NOTNULL(ParrotIO *io)) { const PIOOFF_T pos = lseek(io&#45;&#62;fd, (PIOOFF_T)0, SEEK_CUR);</p>

<pre lang='und' xml:lang='und'>    return pos;
}</pre>

<p>/*</p>

<h2><a name="Networking"
>Networking <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Define <code lang='und' xml:lang='und'>PARROT_NET_DEVEL</code> to enable networking.</p>

<p>These could be native extensions but they probably should be here if we wish to make them integrated with the async IO system.</p>

<p>Very minimal stubs for now, maybe someone will run with these.</p>

<p>FUNCDOC: PIO_sockaddr_in</p>

<p><code lang='und' xml:lang='und'>PIO_sockaddr_in()</code> is not part of the layer and so must be <code lang='und' xml:lang='und'>extern</code>.</p>

<p>XXX: We can probably just write our own routines (<code lang='und' xml:lang='und'>htons()</code>, <code lang='und' xml:lang='und'>inet_aton()</code>, etc.) and take this out of platform specific compilation</p>

<p>*/</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL STRING * PIO_sockaddr_in(PARROT_INTERP, unsigned short port, NOTNULL(STRING *addr)) { struct sockaddr_in sa; /* Hard coded to IPv4 for now */ int family = AF_INET;</p>

<pre lang='und' xml:lang='und'>    char * const s = string_to_cstring(interp, addr);
    /*
     * due to a bug in OS/X, we&#39;ve to zero the struct
     * else bind is failing erratically
     */
    memset(&#38;sa, 0, sizeof (sa));
#  ifdef PARROT_DEF_INET_ATON
    if (inet_aton(s, &#38;sa.sin_addr) != 0) {
#  else
    /* positive retval is success */
    if (inet_pton(family, s, &#38;sa.sin_addr) &#62; 0) {
#  endif
        /* Success converting numeric IP */
    }
    else {
        /* Maybe it is a hostname, try to lookup */
        /* XXX Check PIO option before doing a name lookup,
         * it may have been toggled off.
         */
        struct hostent *he = gethostbyname(s);
        /* XXX FIXME &#45; Handle error condition better */
        if (!he) {
            string_cstring_free(s);
            fprintf(stderr, &#34;gethostbyname failure [%s]\n&#34;, s);
            return NULL;
        }
        memcpy((char*)&#38;sa.sin_addr, he&#45;&#62;h_addr, sizeof (sa.sin_addr));
    }
    string_cstring_free(s);

    sa.sin_family = family;
    sa.sin_port = htons(port);

    return string_make(interp, (char *)&#38;sa, sizeof (struct sockaddr_in),
            &#34;binary&#34;, 0);
}</pre>

<p># if PARROT_NET_DEVEL</p>

<p>/*</p>

<p>FUNCDOC: PIO_unix_socket</p>

<p>Uses <code lang='und' xml:lang='und'>socket()</code> to create a socket with the specified address family, socket type and protocol number.</p>

<p>*/</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CAN_RETURN_NULL static ParrotIO * PIO_unix_socket(PARROT_INTERP, SHIM(ParrotIOLayer *layer), int fam, int type, int proto) { const int sock = socket(fam, type, proto); if (sock &#62;= 0) { ParrotIO * const io = PIO_new(interp, PIO_F_SOCKET, 0, PIO_F_READ|PIO_F_WRITE); io&#45;&#62;fd = sock; memset(&#38;io&#45;&#62;local, 0, sizeof (struct sockaddr_in)); memset(&#38;io&#45;&#62;remote, 0, sizeof (struct sockaddr_in)); io&#45;&#62;remote.sin_family = fam; return io; } return NULL; }</p>

<p>/*</p>

<p>FUNCDOC: PIO_unix_connect</p>

<p>Connects <code lang='und' xml:lang='und'>*io</code>&#39;s socket to address <code lang='und' xml:lang='und'>*r</code>.</p>

<p>*/</p>

<p>static INTVAL PIO_unix_connect(SHIM_INTERP, SHIM(ParrotIOLayer *layer), NOTNULL(ParrotIO *io), NULLOK(STRING *r)) { if (r) { memcpy(&#38;io&#45;&#62;remote, PObj_bufstart(r), sizeof (struct sockaddr_in)); } AGAIN: if ((connect(io&#45;&#62;fd, (struct sockaddr*)&#38;io&#45;&#62;remote, sizeof (struct sockaddr_in))) != 0) { switch (errno) { case EINTR: goto AGAIN; case EINPROGRESS: goto AGAIN; case EISCONN: return 0; default: return &#45;1; } }</p>

<pre lang='und' xml:lang='und'>    return 0;
}</pre>

<p>/*</p>

<p>FUNCDOC: PIO_unix_bind</p>

<p>Binds <code lang='und' xml:lang='und'>*io</code>&#39;s socket to the local address and port specified by <code lang='und' xml:lang='und'>*l</code>.</p>

<p>*/</p>

<p>static INTVAL PIO_unix_bind(SHIM_INTERP, SHIM(ParrotIOLayer *layer), NOTNULL(ParrotIO *io), NOTNULL(STRING *l)) { if (!l) return &#45;1;</p>

<pre lang='und' xml:lang='und'>    memcpy(&#38;io&#45;&#62;local, PObj_bufstart(l), sizeof (struct sockaddr_in));

    if ((bind(io&#45;&#62;fd, (struct sockaddr *)&#38;io&#45;&#62;local,
                    sizeof (struct sockaddr_in))) == &#45;1) {
        return &#45;1;
    }

    return 0;
}</pre>

<p>/*</p>

<p>FUNCDOC: PIO_unix_listen</p>

<p>Listen for new connections. This is only applicable to <code lang='und' xml:lang='und'>STREAM</code> or <code lang='und' xml:lang='und'>SEQ</code> sockets.</p>

<p>*/</p>

<p>static INTVAL PIO_unix_listen(SHIM_INTERP, SHIM(ParrotIOLayer *layer), NOTNULL(ParrotIO *io), INTVAL sec) { if ((listen(io&#45;&#62;fd, sec)) == &#45;1) { return &#45;1; } return 0; }</p>

<p>/*</p>

<p>FUNCDOC: PIO_unix_accept</p>

<p>Accept a new connection and return a newly created <code lang='und' xml:lang='und'>ParrotIO</code> socket.</p>

<p>*/</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CAN_RETURN_NULL static ParrotIO * PIO_unix_accept(PARROT_INTERP, SHIM(ParrotIOLayer *layer), NOTNULL(ParrotIO *io)) { ParrotIO * const newio = PIO_new(interp, PIO_F_SOCKET, 0, PIO_F_READ|PIO_F_WRITE);</p>

<pre lang='und' xml:lang='und'>    Parrot_Socklen_t addrlen = sizeof (struct sockaddr_in);

    const int newsock = accept(io&#45;&#62;fd, (struct sockaddr *)&#38;newio&#45;&#62;remote,
                          &#38;addrlen);
    if (newsock == &#45;1 ) {
        mem_sys_free(newio);
        return NULL;
    }

    newio&#45;&#62;fd = newsock;

    /* XXX FIXME: Need to do a getsockname and getpeername here to
     * fill in the sockaddr_in structs for local and peer */

    /* Optionally do a gethostyaddr() to resolve remote IP address.
     * This should be based on an option set in the master socket
     */

    return newio;
}</pre>

<p>/*</p>

<p>FUNCDOC: PIO_unix_send</p>

<p>Send the message <code lang='und' xml:lang='und'>*s</code> to <code lang='und' xml:lang='und'>*io</code>&#39;s connected socket.</p>

<p>*/</p>

<p>static INTVAL PIO_unix_send(SHIM_INTERP, SHIM(ParrotIOLayer *layer), NOTNULL(ParrotIO *io), NOTNULL(STRING *s)) { int error, bytes, byteswrote;</p>

<pre lang='und' xml:lang='und'>    bytes = s&#45;&#62;bufused;
    byteswrote = 0;
AGAIN:
    /*
     * Ignore encoding issues for now.
     */
    if ((error = send(io&#45;&#62;fd, (char *)s&#45;&#62;strstart + byteswrote,
                    bytes, 0)) &#62;= 0) {
        byteswrote += error;
        bytes &#45;= error;
        if (!bytes) {
            return byteswrote;
        }
        goto AGAIN;
    }
    else {
        switch (errno) {
            case EINTR:
                goto AGAIN;
#    ifdef EWOULDBLOCK
            case EWOULDBLOCK:
                goto AGAIN;
#    else
            case EAGAIN:
                goto AGAIN;
#    endif
            case EPIPE:
                /* XXX why close it here and not below */
                close(io&#45;&#62;fd);
                return &#45;1;
            default:
                return &#45;1;
        }
    }
}</pre>

<p>/*</p>

<p>FUNCDOC: PIO_unix_recv</p>

<p>Receives a message in <code lang='und' xml:lang='und'>**s</code> from <code lang='und' xml:lang='und'>*io</code>&#39;s connected socket.</p>

<p>*/</p>

<p>static INTVAL PIO_unix_recv(PARROT_INTERP, SHIM(ParrotIOLayer *layer), NOTNULL(ParrotIO *io), NOTNULL(STRING **s)) { int error; unsigned int bytesread = 0; char buf[2048];</p>

<p>AGAIN: if ((error = recv(io&#45;&#62;fd, buf, 2048, 0)) &#62;= 0) { bytesread += error; /* The charset should probably be &#39;binary&#39;, but right now httpd.imc * only works with &#39;ascii&#39; */ *s = string_make(interp, buf, bytesread, &#34;ascii&#34;, 0); return bytesread; } else { switch (errno) { case EINTR: goto AGAIN; # ifdef EWOULDBLOCK case EWOULDBLOCK: goto AGAIN; # else case EAGAIN: goto AGAIN; # endif case ECONNRESET: /* XXX why close it on err return result is &#45;1 anyway */ close(io&#45;&#62;fd); *s = string_make_empty(interp, enum_stringrep_one, 0); return &#45;1; default: close(io&#45;&#62;fd); *s = string_make_empty(interp, enum_stringrep_one, 0); return &#45;1; } } }</p>

<p>/*</p>

<p>FUNCDOC: PIO_unix_poll</p>

<p>Utility function for polling a single IO stream with a timeout.</p>

<p>Returns a 1 | 2 | 4 (read, write, error) value.</p>

<p>This is not equivalent to any speficic POSIX or BSD socket call, however it is a useful, common primitive.</p>

<p>Not at all usefule &#45;&#45;leo.</p>

<p>Also, a buffering layer above this may choose to reimpliment by checking the read buffer.</p>

<p>*/</p>

<p>static INTVAL PIO_unix_poll(SHIM_INTERP, SHIM(ParrotIOLayer *l), NOTNULL(ParrotIO *io), int which, int sec, int usec) { int n; fd_set r, w, e; struct timeval t;</p>

<pre lang='und' xml:lang='und'>    t.tv_sec = sec;
    t.tv_usec = usec;
    FD_ZERO(&#38;r); FD_ZERO(&#38;w); FD_ZERO(&#38;e);
    /* These should be defined in header */
    if (which &#38; 1) FD_SET(io&#45;&#62;fd, &#38;r);
    if (which &#38; 2) FD_SET(io&#45;&#62;fd, &#38;w);
    if (which &#38; 4) FD_SET(io&#45;&#62;fd, &#38;e);
AGAIN:
    if ((select(io&#45;&#62;fd+1, &#38;r, &#38;w, &#38;e, &#38;t)) &#62;= 0) {
        n = (FD_ISSET(io&#45;&#62;fd, &#38;r) ? 1 : 0);
        n |= (FD_ISSET(io&#45;&#62;fd, &#38;w) ? 2 : 0);
        n |= (FD_ISSET(io&#45;&#62;fd, &#38;e) ? 4 : 0);
        return n;
    }
    else {
        switch (errno) {
            case EINTR:        goto AGAIN;
            default:           return &#45;1;
        }
    }
}</pre>

<p># endif /*</p>

<p>FUNCDOC: PIO_unix_pipe</p>

<p>Very limited <code lang='und' xml:lang='und'>exec</code> for now.</p>

<p>XXX: Where does this fit, should it belong in the ParrotIOLayerAPI?</p>

<p>*/</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CAN_RETURN_NULL static ParrotIO * PIO_unix_pipe(PARROT_INTERP, SHIM(ParrotIOLayer *l), NOTNULL(const char *cmd), int flags) { /* * pipe(), fork() should be defined, if this header is present * if that&#39;s not true, we need a test */ # ifdef PARROT_HAS_HEADER_UNISTD int pid, err, fds[2];</p>

<pre lang='und' xml:lang='und'>    if ((err = pipe(fds)) &#60; 0) {
        return NULL;
    }

    /* Parent &#45; return IO stream */
    if ((pid = fork()) &#62; 0) {
        ParrotIO * const io =
            PIO_new(interp, PIO_F_PIPE, 0, flags &#38; (PIO_F_READ|PIO_F_WRITE));
        if (flags &#38; PIO_F_READ) {
            /* close this writer&#39;s end of pipe */
            close(fds[1]);
            io&#45;&#62;fd = fds[0];
            io&#45;&#62;fd2 = 0;
        }
        else {  /* assume write only for now */
            /* close this reader&#39;s end */
            close(fds[0]);
            io&#45;&#62;fd = fds[1];
            io&#45;&#62;fd2 = 0;
        }
        return io;
    }

    /* Child &#45; exec process */
    if (pid == 0) {
        char *argv[10], *p, *c;
        int n;

        if (flags &#38; PIO_F_WRITE) {
            /* the other end is writing &#45; we read from the pipe */
            close(STDIN_FILENO);
            close(fds[1]);
            if (dup(fds[0]) != STDIN_FILENO) {
                exit(EXIT_SUCCESS);
            }
        }
        else {
            /* XXX redirect stdout, stderr to pipe */
            close(STDIN_FILENO);
            close(STDOUT_FILENO);
            close(STDERR_FILENO);
            if (dup(fds[0]) != STDIN_FILENO || dup(fds[1]) != STDOUT_FILENO
                    || dup(fds[1]) != STDERR_FILENO)
            {
                exit(EXIT_SUCCESS);
            }
        }
        /*
         * XXX ugly hack to be able to pass some arguments
         *     split cmd at blanks
         */
        c = strdup(cmd);
        for (n = 0, p = strtok(c, &#34; &#34;); n &#60; 9 &#38;&#38; p; p = strtok(NULL, &#34; &#34;)) {
            if (n == 0)
                cmd = p;
            argv[n++] = p;
        }
        argv[n] = NULL;
        execv(cmd, argv);       /* XXX use execvp ? */
        /* Will never reach this unless exec fails. */
        perror(&#34;execvp&#34;);
        exit(EXIT_FAILURE);
    }

    perror(&#34;fork&#34;);
#  else
    UNUSED(l);
    UNUSED(cmd);
    UNUSED(flags);
    real_exception(interp, NULL, UNIMPLEMENTED, &#34;pipe() unimplemented&#34;);
#  endif
    return NULL;
}</pre>

<p>const ParrotIOLayerAPI pio_unix_layer_api = { PIO_unix_init, PIO_base_new_layer, PIO_base_delete_layer, PIO_null_push_layer, PIO_null_pop_layer, PIO_unix_open, PIO_null_open2, PIO_null_open3, PIO_null_open_async, PIO_unix_fdopen, PIO_unix_close, PIO_unix_write, PIO_null_write_async, PIO_unix_read, PIO_null_read_async, PIO_unix_flush, NULL, /* no peek */ PIO_unix_seek, PIO_unix_tell, PIO_null_setbuf, PIO_null_setlinebuf, PIO_null_getcount, PIO_null_fill, PIO_null_eof, # if PARROT_NET_DEVEL PIO_unix_poll, PIO_unix_socket, PIO_unix_connect, PIO_unix_send, PIO_unix_recv, PIO_unix_bind, PIO_unix_listen, PIO_unix_accept # else NULL, /* no poll */ NULL, /* no socket */ NULL, /* no connect */ NULL, /* no send */ NULL, /* no recv */ NULL, /* no bind */ NULL, /* no listen */ NULL /* no accept */ # endif };</p>

<p>#endif /* PIO_OS_UNIX */</p>

<p>/*</p>

<h1><a name="SEE_ALSO"
>SEE ALSO <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p><em lang='und' xml:lang='und'><a href="io_buf.c.html">src/io/io_buf.c</a></em>, <em lang='und' xml:lang='und'><a href="io_passdown.c.html">src/io/io_passdown.c</a></em>, <em lang='und' xml:lang='und'><a href="io_stdio.c.html">src/io/io_stdio.c</a></em>, <em lang='und' xml:lang='und'><a href="io_unix.c.html">src/io/io_unix.c</a></em>, <em lang='und' xml:lang='und'><a href="io_win32.c.html">src/io/io_win32.c</a></em>, <em lang='und' xml:lang='und'><a href="io.c.html">src/io/io.c</a></em>, <em lang='und' xml:lang='und'><a href="io_private.h.html">src/io/io_private.h</a></em>.</p>

<h1><a name="HISTORY"
>HISTORY <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Initially written by Melvin Smith (mrjoltcola@mindspring.com).</p>

<p>*/</p>

<p>/* * Local variables: * c&#45;file&#45;style: &#34;parrot&#34; * End: * vim: expandtab shiftwidth=4: */</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
