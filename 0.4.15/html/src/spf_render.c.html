<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Parrot sprintf</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Parrot sprintf</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../html/index.html">Contents</a> | <a href="../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>src/spf_render.c &#45; Parrot sprintf</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>Implements the main function that drives the <code lang='und' xml:lang='und'>Parrot_sprintf</code> family and its utility functions.</p>

<h2><a name="Utility_Functions"
>Utility Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>*/</p>

<p>#define IN_SPF_SYSTEM</p>

<p>#include &#34;parrot/parrot.h&#34; #include &#34;parrot/string_funcs.h&#34; #include &#34;spf_render.str&#34;</p>

<p>typedef enum { PHASE_FLAGS = 0,
PHASE_WIDTH,
PHASE_PREC,
PHASE_TYPE,
PHASE_TERM,
PHASE_DONE } PHASE;</p>

<p>typedef struct SpfInfo_tag { UINTVAL width; UINTVAL prec; INTVAL flags; INTVAL type; PHASE phase; } SpfInfo;</p>

<p>enum { FLAG_MINUS = (1&#60;&#60;0),
FLAG_PLUS = (1&#60;&#60;1),
FLAG_ZERO = (1&#60;&#60;2),
FLAG_SPACE = (1&#60;&#60;3),
FLAG_SHARP = (1&#60;&#60;4),
FLAG_WIDTH = (1&#60;&#60;5),
FLAG_PREC = (1&#60;&#60;6) };</p>

<p>/* HEADERIZER HFILE: include/parrot/misc.h */</p>

<p>/* HEADERIZER BEGIN: static */</p>

<p>static void gen_sprintf_call( NOTNULL(char *out),
NOTNULL(SpfInfo *info),
int thingy ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>PARROT_CANNOT_RETURN_NULL static STRING * handle_flags( PARROT_INTERP,
NOTNULL(SpfInfo *info),
NOTNULL(STRING *str),
INTVAL is_int_type,
NULLOK(STRING* prefix) ) __attribute__nonnull__(1) __attribute__nonnull__(2) __attribute__nonnull__(3);</p>

<p>PARROT_CANNOT_RETURN_NULL static STRING* str_append_w_flags( PARROT_INTERP,
NOTNULL(STRING* dest),
NOTNULL(SpfInfo *info),
NOTNULL(STRING* src),
NULLOK(STRING *prefix) ) __attribute__nonnull__(1) __attribute__nonnull__(2) __attribute__nonnull__(3) __attribute__nonnull__(4);</p>

<p>/* HEADERIZER END: static */</p>

<p>/* Per Dan&#39;s orders,
we will not use sprintf if snprintf isn&#39;t * around for us.
*/ #ifdef _MSC_VER # define snprintf _snprintf #endif</p>

<p>/*</p>

<p>FUNCDOC: handle_flags</p>

<p>Handles <code lang='und' xml:lang='und'>+</code>,
<code lang='und' xml:lang='und'>&#45;</code>,
<code lang='und' xml:lang='und'>0</code>,
<code lang='und' xml:lang='und'>#</code>,
space,
width,
and prec.</p>

<p>*/</p>

<p>PARROT_CANNOT_RETURN_NULL static STRING * handle_flags(PARROT_INTERP,
NOTNULL(SpfInfo *info),
NOTNULL(STRING *str),
INTVAL is_int_type,
NULLOK(STRING* prefix)) { UINTVAL len = string_length(interp,
str);</p>

<pre lang='und' xml:lang='und'>    if (is_int_type) {
        if (info&#45;&#62;flags &#38; FLAG_PREC &#38;&#38; info&#45;&#62;prec == 0 &#38;&#38;
                len == 1 &#38;&#38;
                string_ord(interp, str, 0) == &#39;0&#39;) {
            string_chopn_inplace(interp, str, len);
            len = 0;
        }
        /* +, space */
        if (!len || string_ord(interp, str, 0) != &#39;&#45;&#39;) {
            if (info&#45;&#62;flags &#38; FLAG_PLUS) {
                STRING * const cs = CONST_STRING(interp, &#34;+&#34;);
                str = string_concat(interp, cs , str, 0);
                len++;
            }
            else if (info&#45;&#62;flags &#38; FLAG_SPACE) {
                STRING * const cs = CONST_STRING(interp, &#34; &#34;);
                str = string_concat(interp, cs , str, 0);
                len++;
            }
        }

        /* # 0x ... */
        if ((info&#45;&#62;flags &#38; FLAG_SHARP) &#38;&#38; prefix) {
            str = string_concat(interp, prefix, str, 0);
            len += string_length(interp, prefix);
        }
        /* XXX sharp + fill ??? */</pre>

<p>#if 0 /* precision &#45; only for floats, which is handled elsewhere */ if (info&#45;&#62;flags &#38; FLAG_PREC) { info&#45;&#62;flags |= FLAG_WIDTH; if (string_ord(interp, str, 0) == &#39;&#45;&#39; || string_ord(interp, str, 0) == &#39;+&#39;) { info&#45;&#62;width = info&#45;&#62;prec + 1; } else { info&#45;&#62;width = info&#45;&#62;prec; } } #endif } else { /* string precision */ if (info&#45;&#62;flags &#38; FLAG_PREC &#38;&#38; info&#45;&#62;prec == 0) { string_chopn_inplace(interp, str, len); len = 0; } else if (info&#45;&#62;flags &#38; FLAG_PREC &#38;&#38; info&#45;&#62;prec &#60; len) { string_chopn_inplace(interp, str, &#45;(INTVAL)(info&#45;&#62;prec)); len = info&#45;&#62;prec; } }</p>

<pre lang='und' xml:lang='und'>    if ((info&#45;&#62;flags &#38; FLAG_WIDTH) &#38;&#38; info&#45;&#62;width &#62; len) {
        STRING * const filler =
            ((info&#45;&#62;flags &#38; FLAG_ZERO) &#38;&#38; !(info&#45;&#62;flags &#38; FLAG_MINUS))
                ? CONST_STRING(interp, &#34;0&#34;)
                : CONST_STRING(interp, &#34; &#34;);
        STRING * const fill = string_repeat(interp, filler, info&#45;&#62;width &#45; len, NULL);

        if (info&#45;&#62;flags &#38; FLAG_MINUS) { /* left&#45;align */
            str = string_concat(interp, str, fill, 0);
        }
        else {                  /* right&#45;align */
            /* signed and zero padded */
            if (info&#45;&#62;flags &#38; FLAG_ZERO
                &#38;&#38; (string_ord(interp, str,0) == &#39;&#45;&#39; ||
                    string_ord(interp, str,0) == &#39;+&#39;)) {
                STRING *temp = NULL;
                string_substr(interp, str, 1, len&#45;1, &#38;temp, 0);
                string_chopn_inplace(interp, str, &#45;1);
                str = string_append(interp, str, fill);
                str = string_append(interp, str, temp);
            }
            else {
                str = string_concat(interp, fill, str, 0);
            }
        }
    }
    return str;
}</pre>

<p>PARROT_CANNOT_RETURN_NULL static STRING* str_append_w_flags(PARROT_INTERP, NOTNULL(STRING* dest), NOTNULL(SpfInfo *info), NOTNULL(STRING* src), NULLOK(STRING *prefix)) { src = handle_flags(interp, info, src, 1, prefix); dest = string_append(interp, dest, src); return dest; }</p>

<p>/*</p>

<p>FUNCDOC: gen_sprintf_call</p>

<p>Turn the info structure back into an sprintf format. Far from being pointless, this is used to call <code lang='und' xml:lang='und'>snprintf()</code> when we&#39;re confronted with a float.</p>

<p>*/</p>

<p>static void gen_sprintf_call(NOTNULL(char *out), NOTNULL(SpfInfo *info), int thingy) { int i = 0;</p>

<pre lang='und' xml:lang='und'>    out[i++] = &#39;%&#39;;
    if (info&#45;&#62;flags) {
        if (info&#45;&#62;flags &#38; FLAG_MINUS) {
            out[i++] = &#39;&#45;&#39;;
        }
        if (info&#45;&#62;flags &#38; FLAG_PLUS) {
            out[i++] = &#39;+&#39;;
        }
        if (info&#45;&#62;flags &#38; FLAG_ZERO) {
            out[i++] = &#39;0&#39;;
        }
        if (info&#45;&#62;flags &#38; FLAG_SPACE) {
            out[i++] = &#39; &#39;;
        }
        if (info&#45;&#62;flags &#38; FLAG_SHARP) {
            out[i++] = &#39;#&#39;;
        }
    }

    if (info&#45;&#62;flags &#38; FLAG_WIDTH) {
        if (info&#45;&#62;width &#62; PARROT_SPRINTF_BUFFER_SIZE &#45; 1) {
            info&#45;&#62;width = PARROT_SPRINTF_BUFFER_SIZE;
        }
        i += sprintf(out + i, &#34;%u&#34;, (unsigned)info&#45;&#62;width);
    }

    if (info&#45;&#62;flags &#38; FLAG_PREC) {
        if (info&#45;&#62;prec &#62; PARROT_SPRINTF_MAX_PREC) {
            info&#45;&#62;prec = PARROT_SPRINTF_MAX_PREC;
        }

        out[i++] = &#39;.&#39;;
        i += sprintf(out + i, &#34;%u&#34;, (unsigned)info&#45;&#62;prec);
    }
    if (thingy == &#39;d&#39; || thingy == &#39;i&#39; ||thingy == &#39;u&#39;) {
        /* theu?int isa HUGEU?INTVAL aka long long
         * the &#39;ll&#39; modifier is specced in susv3 &#45; hopefully all our
         * compilers support it too */
        out[i++] = &#39;l&#39;;
        out[i++] = &#39;l&#39;;
    }
    out[i++] = thingy;
    out[i] = 0;
}</pre>

<p>/*</p>

<p>FUNCDOC: Parrot_sprintf_format</p>

<p>This is the engine that does all the formatting.</p>

<p>*/</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL STRING * Parrot_sprintf_format(PARROT_INTERP, NOTNULL(STRING *pat), NOTNULL(SPRINTF_OBJ *obj)) { INTVAL i, len, old; /* * start with some allocated buffer * this speeds up tracing mandel.pasm by a factor of 3 */ STRING *targ = string_make_empty(interp, enum_stringrep_one, 128);</p>

<pre lang='und' xml:lang='und'>    /* ts is used almost universally as an intermediate target;
     * tc is used as a temporary buffer by uint_to_string and
     * as a target by gen_sprintf_call.
     */
    STRING *substr = NULL;
    char tc[PARROT_SPRINTF_BUFFER_SIZE];


    for (i = old = len = 0; i &#60; (INTVAL) string_length(interp, pat); i++) {
        if (string_ord(interp, pat, i) == &#39;%&#39;) {        /* % */
            if (len) {
                string_substr(interp, pat, old, len, &#38;substr, 1);
                /* XXX This shouldn&#39;t modify targ the pointer */
                targ = string_append(interp, targ, substr);
            }
            len = 0;
            old = i;
            if (string_ord(interp, pat, i + 1) == &#39;%&#39;) {
                /* skip this one, make next the first char
                 * of literal sequence, starting at old */
                i++;
                old++;
                len++;
                continue;
            }
            else {
                /* hoo boy, here we go... */

                HUGEINTVAL sharedint = 0;

                /* Storage for flags, etc. */
                SpfInfo info = { 0, 0, 0, 0, (PHASE)0 };

                /* Reset temporaries */
                tc[0] = &#39;\0&#39;;</pre>

<p>/* This can be really hard to understand, so I&#39;ll try to explain beforehand. * A rough grammar for a printf format is: * * grammar Parrot::PrintF_Format { * rule format { * &#60;other_stuff&#62; ( &#60;field&#62; &#60;other_stuff&#62; )* * } * * rule other_stuff { * [&#60;[^\%]&#62; | \%\%]*: * } * * rule field { * \% * &#60;flags&#62;? * &#60;width&#62;? * [\.&#60;prec&#62;]? * &#60;size&#62;? * &#60;term&#62; * } * * rule flags { * &#60;[ * + # prefix with a + if necessary * &#45; # left&#45;align * 0 # zero&#45;pad * &#60;sp&#62; # space&#45;pad * \# # 0, 0x on octal, hex; force decimal point on float * ]&#62;+ * } * * rule width { * [\d|\*]+ # minimum width * } * * rule prec { * [\d|\*]+ # width on integers; * # number of digits after decimal on floats; * # maximum width on strings * } * * rule size { * &#60;[ * h # short (or float) * l # long * H # HUGEwhateverVAL (long [long]?, [long]? double) * v # whateverVAL * O # opcode_t * P # really a PMC * S # Parrot string (only with %s) * ]&#62; * } * * rule term { * &#60;[ * c # char * d # integer * i # integer * o # octal * x # hex * X # hex with capital X (if #) * b # binary * B # binary with capital B (if #) * u # unsigned integer * p # pointer * * e # 1e1 * E # 1E1 * f # 1.0 * g # 1, 0.1, 1e1 * G # 1, 0.1, 1E1 * * s # string * ]&#62; * } * } * * Complication: once upon a time, %P existed. Now you should * use %Ps, %Pd or %Pf, but we still need to support the old form. * The same is true of %S&#45;&#45;%Ss is the best form, but %S is still * supported. * * The implementation of Parrot_vsprintf is surprisingly similar to this * regex, even though the two were developed semi&#45;independently. * Parrot_vsprintf keeps track of what it expects to see next (the * &#39;phase&#39;)&#45;&#45;flags, width, precision, size, or field type (term). If it * doesn&#39;t find a character that fits whatever it&#39;s expecting, it sets * info.phase to the next thing and tries it. The first four phases just * set flags&#45;&#45;the last does all the work. */</p>

<pre lang='und' xml:lang='und'>                for (i++; i &#60; (INTVAL) string_length(interp, pat)
                     &#38;&#38; info.phase != PHASE_DONE; i++) {
                    const INTVAL ch = string_ord(interp, pat, i);

                    switch (info.phase) {
                    /*@fallthrough@ */ case PHASE_FLAGS:
                        switch (ch) {
                        case &#39;&#45;&#39;:
                            info.flags |= FLAG_MINUS;
                            continue;

                        case &#39;+&#39;:
                            info.flags |= FLAG_PLUS;
                            continue;

                        case &#39;0&#39;:
                            info.flags |= FLAG_ZERO;
                            continue;

                        case &#39; &#39;:
                            info.flags |= FLAG_SPACE;
                            continue;

                        case &#39;#&#39;:
                            info.flags |= FLAG_SHARP;
                            continue;

                        default:
                            info.phase = PHASE_WIDTH;
                        }


                    /*@fallthrough@ */ case PHASE_WIDTH:
                        switch (ch) {
                        case &#39;0&#39;:
                        case &#39;1&#39;:
                        case &#39;2&#39;:
                        case &#39;3&#39;:
                        case &#39;4&#39;:
                        case &#39;5&#39;:
                        case &#39;6&#39;:
                        case &#39;7&#39;:
                        case &#39;8&#39;:
                        case &#39;9&#39;:
                            info.flags |= FLAG_WIDTH;
                            info.width *= 10;
                            info.width += ch &#45; &#39;0&#39;;
                            continue;

                        case &#39;*&#39;:
                            info.flags |= FLAG_WIDTH;
                            info.width = (UINTVAL)obj&#45;&#62;getint(interp,
                                                      SIZE_XVAL, obj);
                            /* fall through */

                        case &#39;.&#39;:
                            info.phase = PHASE_PREC;
                            continue;

                        default:
                            info.phase = PHASE_PREC;
                        }


                    /*@fallthrough@ */ case PHASE_PREC:
                        switch (ch) {
                        case &#39;0&#39;:
                        case &#39;1&#39;:
                        case &#39;2&#39;:
                        case &#39;3&#39;:
                        case &#39;4&#39;:
                        case &#39;5&#39;:
                        case &#39;6&#39;:
                        case &#39;7&#39;:
                        case &#39;8&#39;:
                        case &#39;9&#39;:
                            info.flags |= FLAG_PREC;
                            info.prec *= 10;
                            info.prec += ch &#45; &#39;0&#39;;
                            continue;

                        case &#39;*&#39;:
                            info.flags |= FLAG_PREC;
                            info.prec = (UINTVAL)obj&#45;&#62;getint(interp,
                                                     SIZE_XVAL, obj);
                            info.phase = PHASE_TYPE;
                            continue;

                        default:
                            info.phase = PHASE_TYPE;
                        }

                    /*@fallthrough@ */ case PHASE_TYPE:
                        switch (ch) {
                        case &#39;h&#39;:
                            info.type = SIZE_SHORT;
                            continue;

                        case &#39;l&#39;:
                            info.type = SIZE_LONG;
                            continue;

                        case &#39;L&#39;:
                        case &#39;H&#39;:
                            info.type = SIZE_HUGE;
                            continue;

                        case &#39;v&#39;:
                            info.type = SIZE_XVAL;
                            continue;

                        case &#39;O&#39;:
                            info.type = SIZE_OPCODE;
                            continue;

                        case &#39;P&#39;:
                            info.type = SIZE_PMC;
                            continue;

                        case &#39;S&#39;:
                            info.type = SIZE_PSTR;
                            continue;

                        default:
                            info.phase = PHASE_TERM;
                        }


                    /*@fallthrough@ */ case PHASE_TERM:
                        switch (ch) {
                            /* INTEGERS */
                        case &#39;c&#39;:
                            {
                            STRING * const ts = string_chr(interp,
                                 (UINTVAL)obj&#45;&#62;getint(interp, info.type, obj));
                            targ = str_append_w_flags(interp, targ,
                                    &#38;info, ts, NULL);
                            }
                            break;

                        case &#39;o&#39;:
                            {
                            const UHUGEINTVAL theuint = obj&#45;&#62;getuint(interp, info.type, obj);
                            STRING * const ts = uint_to_str(interp, tc, theuint, 8, 0);
                            STRING * const prefix = CONST_STRING(interp, &#34;0&#34;);
                            /* unsigned conversion &#45; no plus */
                            info.flags &#38;= ~FLAG_PLUS;
                            targ = str_append_w_flags(interp, targ,
                                    &#38;info, ts, prefix);
                            }
                            break;

                        case &#39;x&#39;:
                            {
                            const UHUGEINTVAL theuint = obj&#45;&#62;getuint(interp, info.type, obj);
                            STRING * const ts = uint_to_str(interp, tc, theuint, 16, 0);
                            STRING * const prefix = CONST_STRING(interp, &#34;0x&#34;);
                            /* unsigned conversion &#45; no plus */
                            info.flags &#38;= ~FLAG_PLUS;
                            targ = str_append_w_flags(interp, targ,
                                    &#38;info, ts, prefix);
                            }
                            break;

                        case &#39;X&#39;:
                            {
                            STRING * const prefix = CONST_STRING(interp, &#34;0X&#34;);
                            const UHUGEINTVAL theuint =
                                obj&#45;&#62;getuint(interp, info.type, obj);
                            STRING * const ts = uint_to_str(interp, tc, theuint, 16, 0);
                            string_upcase_inplace(interp, ts);
                            /* unsigned conversion &#45; no plus */
                            info.flags &#38;= ~FLAG_PLUS;
                            targ = str_append_w_flags(interp, targ,
                                    &#38;info, ts, prefix);
                            }
                            break;

                        case &#39;b&#39;:
                            {
                            STRING * const prefix = CONST_STRING(interp, &#34;0b&#34;);
                            const UHUGEINTVAL theuint =
                                obj&#45;&#62;getuint(interp, info.type, obj);
                            STRING * const ts = uint_to_str(interp, tc, theuint, 2, 0);
                            /* unsigned conversion &#45; no plus */
                            info.flags &#38;= ~FLAG_PLUS;
                            targ = str_append_w_flags(interp, targ,
                                    &#38;info, ts, prefix);
                            }
                            break;

                        case &#39;B&#39;:
                            {
                            STRING * const prefix = CONST_STRING(interp, &#34;0B&#34;);
                            const HUGEINTVAL theint = obj&#45;&#62;getint(interp, info.type, obj);
                            STRING * const ts = int_to_str(interp, tc, theint, 2);
                            /* unsigned conversion &#45; no plus */
                            info.flags &#38;= ~FLAG_PLUS;
                            targ = str_append_w_flags(interp, targ,
                                    &#38;info, ts, prefix);
                            }
                            break;

                        case &#39;u&#39;:
                            {
                            const UHUGEINTVAL theuint =
                                obj&#45;&#62;getuint(interp, info.type, obj);
                            sharedint = theuint;
                            }
                            goto do_sprintf;
                        case &#39;d&#39;:
                        case &#39;i&#39;:
                            /* EVIL: Work around bug in glibc that makes %0lld sometimes output an
                             * empty string. */
                            if (!(info.flags &#38; FLAG_WIDTH))
                                info.flags &#38;= ~FLAG_ZERO;
                            sharedint = obj&#45;&#62;getint(interp, info.type, obj);
do_sprintf:
                            {
                            STRING *ts;
                            gen_sprintf_call(tc, &#38;info, ch);
                            ts = cstr2pstr(tc);
                            {
                                char * const tempstr =
                                    string_to_cstring(interp, ts);</pre>

<p>#ifdef PARROT_HAS_SNPRINTF snprintf(tc, PARROT_SPRINTF_BUFFER_SIZE, tempstr, sharedint); #else /* the buffer is 4096, so no problem here */ sprintf(tc, tempstr, sharedint); #endif string_cstring_free(tempstr); } targ = string_append(interp, targ, cstr2pstr(tc)); } break;</p>

<pre lang='und' xml:lang='und'>                        case &#39;p&#39;:
                            {
                            STRING * const prefix = CONST_STRING(interp, &#34;0x&#34;);
                            const void * const ptr = obj&#45;&#62;getptr(interp, info.type, obj);
                            STRING * const ts = uint_to_str(interp, tc,
                                       (HUGEINTVAL) (size_t) ptr, 16, 0);

                            targ = str_append_w_flags(interp, targ,
                                    &#38;info, ts, prefix);
                            }
                            break;

                            /* FLOATS &#45; We cheat on these and use snprintf. */
                        case &#39;e&#39;:
                        case &#39;E&#39;:
                        case &#39;f&#39;:
                        case &#39;g&#39;:
                        case &#39;G&#39;:
                            {
                            STRING *ts;
                            const HUGEFLOATVAL thefloat = obj&#45;&#62;getfloat(interp, info.type, obj);
                            /* turn &#45;0.0 into 0.0 */
                            /* WTF if( thefloat == 0.0 ) { thefloat = 0.0; } */
                            gen_sprintf_call(tc, &#38;info, ch);
                            ts = cstr2pstr(tc);
                            /* XXX lost precision if %Hg or whatever
                               */
                            {
                                char * const tempstr =
                                    string_to_cstring(interp, ts);</pre>

<p>#ifdef PARROT_HAS_SNPRINTF snprintf(tc, PARROT_SPRINTF_BUFFER_SIZE, tempstr, (double)thefloat); #else /* the buffer is 4096, so no problem here */ sprintf(tc, tempstr, (double)thefloat); #endif string_cstring_free(tempstr); }</p>

<p>#ifdef WIN32 /* Microsoft defaults to three digits for exponents, * even when fewer digits would suffice. For the sake * of portability, we will here attempt to hide that. */</p>

<pre lang='und' xml:lang='und'>                            if (ch == &#39;g&#39; || ch == &#39;G&#39; || ch == &#39;e&#39; || ch == &#39;E&#39;) {
                                const size_t tclen = strlen(tc);
                                size_t j;
                                for (j = 0; j &#60; tclen; j++) {
                                    if ((tc[j] == &#39;e&#39; || tc[j] == &#39;E&#39;)
                                        &#38;&#38; (tc[j+1] == &#39;+&#39; || tc[j+1] == &#39;&#45;&#39;)
                                        &#38;&#38; tc[j+2] == &#39;0&#39;
                                        &#38;&#38; isdigit((unsigned char)tc[j+3])
                                        &#38;&#38; isdigit((unsigned char)tc[j+4]))
                                    {
                                        mem_sys_memmove(&#38;tc[j+2], &#38;tc[j+3], strlen(&#38;tc[j+2]));

                                        /* now fix the length if we just broke it */
                                        if ((info.flags &#38; FLAG_WIDTH) &#38;&#38; strlen(tc) &#60; info.width) {
                                            if (info.flags &#38; FLAG_MINUS)
                                                strcat(tc, &#34; &#34;);
                                            else {
                                                mem_sys_memmove(&#38;tc[1], &#38;tc[0], strlen(tc) + 1);
                                                tc[0] = (info.flags &#38; FLAG_ZERO) ? &#39;0&#39; : &#39; &#39;;
                                            }
                                        }

                                        /* only one fix required per string */
                                        break;
                                    }
                                }
                            }
#endif /* WIN32 */

                            targ = string_append(interp, targ,
                                                 cstr2pstr(tc));
                            }
                            break;

                            /* STRINGS */
                        case &#39;r&#39;:        /* Python repr */
                            /* XXX the right fix is to add a getrepr entry *
                             * to SPRINTF_OBJ, but for now, getstring_pmc  *
                             * is inlined and modified to call get_repr    */
                            if (obj&#45;&#62;getstring == pmc_core.getstring) {
                                STRING *ts;
                                STRING *string;
                                PMC * const tmp =
                                    VTABLE_get_pmc_keyed_int(interp,
                                                             ((PMC *)obj&#45;&#62;data),
                                                             (obj&#45;&#62;index));

                                obj&#45;&#62;index++;
                                string = (VTABLE_get_repr(interp, tmp));

                                ts = handle_flags(interp, &#38;info, string,
                                    0, NULL);

                                targ = string_append(interp, targ, ts);

                                break;
                            }

                        case &#39;s&#39;:
                          CASE_s:
                            {
                            STRING * const string = obj&#45;&#62;getstring(interp, info.type, obj);

                            STRING * const ts = handle_flags(interp, &#38;info, string,
                                    0, NULL);

                            targ = string_append(interp, targ, ts);
                            }
                            break;

                        default:
                            /* fake the old %P and %S commands */
                            if (info.type == SIZE_PMC
                                || info.type == SIZE_PSTR) {
                                i&#45;&#45;;
                                goto CASE_s;
                                /* case &#39;s&#39; will see the SIZE_PMC or SIZE_PSTR
                                 * and assume it was %Ps (or %Ss).  Genius,
                                 * no?
                                 */
                            }
                            else {
                                real_exception(interp, NULL, INVALID_CHARACTER,
                                                   &#34;&#39;%c&#39; is not a valid &#34;
                                                   &#34;sprintf format&#34;,
                                                   ch);
                            }
                        }

                        info.phase = PHASE_DONE;
                        break;

                    case PHASE_DONE:
                        /* This is the terminating condition of the surrounding
                         * loop, so...
                         */
                        PANIC(interp, &#34;We can&#39;t be here&#34;);
                    }
                }
            }

            old = i;
            i&#45;&#45;;
        }
        else {
            len++;
        }
    }
    if (len) {
        string_substr(interp, pat, old, len, &#38;substr, 1);
        targ = string_append(interp, targ, substr);
    }

    return targ;
}</pre>

<p>/*</p>

<h1><a name="SEE_ALSO"
>SEE ALSO <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p><em lang='und' xml:lang='und'>src/misc.h</em>, <em lang='und' xml:lang='und'><a href="misc.c.html">src/misc.c</a></em>, <em lang='und' xml:lang='und'><a href="spf_vtable.c.html">src/spf_vtable.c</a></em>.</p>

<p>*/</p>

<p>/* * Local variables: * c&#45;file&#45;style: &#34;parrot&#34; * End: * vim: expandtab shiftwidth=4: */</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
