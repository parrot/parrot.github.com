<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Parrot extension interface</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Parrot extension interface</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../html/index.html">Contents</a> | <a href="../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>src/extend.c &#45; Parrot extension interface</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>These are the functions that parrot extensions (i.e.
parrot subroutines written in C,
or some other compiled language,
rather than in parrot bytecode) may access.</p>

<p>There is a deliberate distancing from the internals here.
Don&#39;t go peeking inside &#45;&#45; you&#39;ve as much access as bytecode does,
but no more,
so we can provide backwards compatibility for as long as we possibly can.</p>

<h2><a name="Functions"
>Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>*/</p>

<p>/* Some internal notes.
Parrot will die a horrible and bizarre death if the stack start pointer&#39;s not set and a DOD run is triggered.
The pointer *will* be set by the interpreter if the interpreter calls code which calls these functions,
so most extension code is safe,
no problem.</p>

<pre lang='und' xml:lang='und'>   The problem comes in if these routines are called from *outside*
   an interpreter. This happens when an embedding application calls
   them to do stuff with PMCs, STRINGS, interpreter contents, and
   suchlike things. This is perfectly legal &#45;&#45; in fact it&#39;s what
   we&#39;ve documented should be done &#45;&#45; but the problem is that the
   stack base pointer will be NULL. This is Very Bad.

   To deal with this there are two macros that are defined to handle
   the problem.

   PARROT_CALLIN_START(interp) will figure out if the stack
   anchor needs setting and, if so, will set it. It must *always*
   come immediately after the last variable declared in the block
   making the calls into the interpreter, as it declares a variable
   and has some code.

   PARROT_CALLIN_END(interp) will put the stack anchor back to
   the way it was, and should always be the last statement before a
   return. (If you have multiple returns have it in multiple times)

   Not doing this is a good way to introduce bizarre heisenbugs, so
   just do it. This is the only place they ought to have to be put
   in, and most of the functions are already written, so it&#39;s not
   like it&#39;s an onerous requirement.</pre>

<p>*/</p>

<p>#include &#34;parrot/parrot.h&#34; #include &#34;parrot/extend.h&#34;</p>

<p>/* HEADERIZER HFILE: include/parrot/extend.h */</p>

<p>/*</p>

<p>FUNCDOC: Parrot_PMC_get_string_intkey</p>

<p>Return the integer keyed string value of the passed&#45;in PMC</p>

<p>*/</p>

<p>PARROT_API Parrot_String Parrot_PMC_get_string_intkey(PARROT_INTERP, Parrot_PMC pmc, Parrot_Int key) { Parrot_String retval; PARROT_CALLIN_START(interp); retval = VTABLE_get_string_keyed_int(interp, pmc, key); PARROT_CALLIN_END(interp); return retval; }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_PMC_get_pointer_intkey</p>

<p>Return the keyed, signed integer value of the value in the PMC.</p>

<p>*/</p>

<p>PARROT_API PARROT_WARN_UNUSED_RESULT PARROT_CAN_RETURN_NULL void * Parrot_PMC_get_pointer_intkey(PARROT_INTERP, Parrot_PMC pmc, Parrot_Int key) { void *retval; PARROT_CALLIN_START(interp); retval = VTABLE_get_pointer_keyed_int(interp, pmc, key); PARROT_CALLIN_END(interp); return retval; }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_PMC_get_pmc_intkey</p>

<p>Return the integer keyed PMC value of the passed&#45;in PMC</p>

<p>*/</p>

<p>PARROT_API Parrot_PMC Parrot_PMC_get_pmc_intkey(PARROT_INTERP, Parrot_PMC pmc, Parrot_Int key) { Parrot_PMC retval; PARROT_CALLIN_START(interp); retval = VTABLE_get_pmc_keyed_int(interp, pmc, key); PARROT_CALLIN_END(interp); return retval; }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_PMC_get_intval</p>

<p>Return the signed integer value of the value in the PMC.</p>

<p>*/</p>

<p>PARROT_API Parrot_Int Parrot_PMC_get_intval(PARROT_INTERP, Parrot_PMC pmc) { Parrot_Int retval; PARROT_CALLIN_START(interp); retval = VTABLE_get_integer(interp, pmc); PARROT_CALLIN_END(interp); return retval; }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_PMC_get_intval_intkey</p>

<p>Return the keyed, signed integer value of the value in the PMC.</p>

<p>*/</p>

<p>PARROT_API Parrot_Int Parrot_PMC_get_intval_intkey(PARROT_INTERP, Parrot_PMC pmc, Parrot_Int key) { Parrot_Int retval; PARROT_CALLIN_START(interp); retval = VTABLE_get_integer_keyed_int(interp, pmc, key); PARROT_CALLIN_END(interp); return retval; }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_PMC_get_intval_pmckey</p>

<p>Return the keyed, signed integer value of the value in the PMC.</p>

<p>*/</p>

<p>PARROT_API Parrot_Int Parrot_PMC_get_intval_pmckey(PARROT_INTERP, Parrot_PMC pmc, Parrot_PMC key) { Parrot_Int retval; PARROT_CALLIN_START(interp); retval = VTABLE_get_integer_keyed(interp, pmc, key); PARROT_CALLIN_END(interp); return retval; }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_PMC_get_numval</p>

<p>Return the floating&#45;point value of the PMC.</p>

<p>*/</p>

<p>PARROT_API Parrot_Float Parrot_PMC_get_numval(PARROT_INTERP, Parrot_PMC pmc) { Parrot_Float retval; PARROT_CALLIN_START(interp); retval = VTABLE_get_number(interp, pmc); PARROT_CALLIN_END(interp); return retval; }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_PMC_get_numval_intkey</p>

<p>Return the keyed, signed integer value of the value in the PMC.</p>

<p>*/</p>

<p>PARROT_API Parrot_Float Parrot_PMC_get_numval_intkey(PARROT_INTERP, Parrot_PMC pmc, Parrot_Int key) { Parrot_Float retval; PARROT_CALLIN_START(interp); retval = VTABLE_get_number_keyed_int(interp, pmc, key); PARROT_CALLIN_END(interp); return retval; }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_PMC_get_cstring_intkey</p>

<p>Return a null&#45;terminated string that represents the string value of the PMC.</p>

<p>Note that you must free this string with <code lang='und' xml:lang='und'>string_cstring_free()</code>!</p>

<p>*/</p>

<p>PARROT_API PARROT_MALLOC PARROT_CAN_RETURN_NULL char * Parrot_PMC_get_cstring_intkey(PARROT_INTERP, Parrot_PMC pmc, Parrot_Int key) { STRING *intermediate; char *retval;</p>

<pre lang='und' xml:lang='und'>    PARROT_CALLIN_START(interp);
    intermediate = VTABLE_get_string_keyed_int(interp, pmc, key);
    retval       = string_to_cstring(interp, intermediate);
    PARROT_CALLIN_END(interp);

    return retval;
}</pre>

<p>/*</p>

<p>FUNCDOC: Parrot_PMC_get_cstring</p>

<p>Return a null&#45;terminated string that represents the string value of the PMC.</p>

<p>Note that you must free this string with <code lang='und' xml:lang='und'>string_cstring_free()</code>!</p>

<p>*/</p>

<p>PARROT_API PARROT_MALLOC PARROT_CAN_RETURN_NULL char * Parrot_PMC_get_cstring(PARROT_INTERP, Parrot_PMC pmc) { STRING *intermediate; char *retval;</p>

<pre lang='und' xml:lang='und'>    PARROT_CALLIN_START(interp);
    intermediate = VTABLE_get_string(interp, pmc);
    retval       = string_to_cstring(interp, intermediate);
    PARROT_CALLIN_END(interp);

    return retval;
}</pre>

<p>/*</p>

<p>FUNCDOC: Parrot_PMC_get_cstringn</p>

<p>Return a null&#45;terminated string for the PMC, along with the length.</p>

<p>Yes, right now this is a bit of a cheat. It needs fixing, but without disturbing the interface.</p>

<p>Note that you must free the string with <code lang='und' xml:lang='und'>string_cstring_free()</code>.</p>

<p>*/</p>

<p>PARROT_API PARROT_MALLOC PARROT_CAN_RETURN_NULL char * Parrot_PMC_get_cstringn(PARROT_INTERP, Parrot_PMC pmc, NOTNULL(Parrot_Int *length)) { char *retval;</p>

<pre lang='und' xml:lang='und'>    PARROT_CALLIN_START(interp);
    retval  = string_to_cstring(interp, VTABLE_get_string(interp, pmc));
    *length = strlen(retval);
    PARROT_CALLIN_END(interp);

    return retval;
}</pre>

<p>/*</p>

<p>FUNCDOC: Parrot_PMC_get_cstringn_intkey</p>

<p>Return a null&#45;terminated string for the PMC, along with the length.</p>

<p>Yes, right now this is a bit of a cheat. It needs fixing, but without disturbing the interface.</p>

<p>Note that you must free this string with <code lang='und' xml:lang='und'>string_cstring_free()</code>.</p>

<p>*/</p>

<p>PARROT_API PARROT_MALLOC PARROT_CAN_RETURN_NULL char * Parrot_PMC_get_cstringn_intkey(PARROT_INTERP, Parrot_PMC pmc, NOTNULL(Parrot_Int *length), Parrot_Int key) { char *retval;</p>

<pre lang='und' xml:lang='und'>    PARROT_CALLIN_START(interp);
    retval  = string_to_cstring(interp,
                               VTABLE_get_string_keyed_int(interp, pmc, key));
    *length = strlen(retval);
    PARROT_CALLIN_END(interp);

    return retval;
}</pre>

<p>/*</p>

<p>FUNCDOC: Parrot_PMC_set_string</p>

<p>Assign the passed&#45;in Parrot string to the passed&#45;in PMC.</p>

<p>*/</p>

<p>PARROT_API void Parrot_PMC_set_string(PARROT_INTERP, Parrot_PMC pmc, Parrot_String value) { PARROT_CALLIN_START(interp); VTABLE_set_string_native(interp, pmc, value); PARROT_CALLIN_END(interp); }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_PMC_set_string_intkey</p>

<p>Assign the passed&#45;in Parrot string to the passed&#45;in PMC.</p>

<p>*/</p>

<p>PARROT_API void Parrot_PMC_set_string_intkey(PARROT_INTERP, Parrot_PMC pmc, Parrot_Int key, Parrot_String value) { PARROT_CALLIN_START(interp); VTABLE_set_string_keyed_int(interp, pmc, key, value); PARROT_CALLIN_END(interp); }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_PMC_set_pmc_intkey</p>

<p>Assign the passed&#45;in pmc to the passed&#45;in slot of the passed&#45;in PMC.</p>

<p>*/</p>

<p>PARROT_API void Parrot_PMC_set_pmc_intkey(PARROT_INTERP, Parrot_PMC pmc, Parrot_Int key, Parrot_PMC value) { PARROT_CALLIN_START(interp); VTABLE_set_pmc_keyed_int(interp, pmc, key, value); PARROT_CALLIN_END(interp); }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_PMC_set_pmc_pmckey</p>

<p>Assign the passed&#45;in pmc to the passed&#45;in slot of the passed&#45;in PMC.</p>

<p>*/</p>

<p>PARROT_API void Parrot_PMC_set_pmc_pmckey(PARROT_INTERP, Parrot_PMC pmc, Parrot_PMC key, Parrot_PMC value) { PARROT_CALLIN_START(interp); VTABLE_set_pmc_keyed(interp, pmc, key, value); PARROT_CALLIN_END(interp); }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_PMC_set_pointer_intkey</p>

<p>Assign the passed&#45;in pointer to the passed&#45;in PMC.</p>

<p>*/</p>

<p>PARROT_API void Parrot_PMC_set_pointer_intkey(PARROT_INTERP, Parrot_PMC pmc, Parrot_Int key, NULLOK(void *value)) { PARROT_CALLIN_START(interp); VTABLE_set_pointer_keyed_int(interp, pmc, key, value); PARROT_CALLIN_END(interp); }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_PMC_set_intval</p>

<p>Assign the passed&#45;in Parrot integer to the passed&#45;in PMC.</p>

<p>*/</p>

<p>PARROT_API void Parrot_PMC_set_intval(PARROT_INTERP, Parrot_PMC pmc, Parrot_Int value) { PARROT_CALLIN_START(interp); VTABLE_set_integer_native(interp, pmc, value); PARROT_CALLIN_END(interp); }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_PMC_set_intval_intkey</p>

<p>Assign the passed&#45;in Parrot integer to the passed&#45;in PMC.</p>

<p>*/</p>

<p>PARROT_API void Parrot_PMC_set_intval_intkey(PARROT_INTERP, Parrot_PMC pmc, Parrot_Int key, Parrot_Int value) { PARROT_CALLIN_START(interp); VTABLE_set_integer_keyed_int(interp, pmc, key, value); PARROT_CALLIN_END(interp); }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_PMC_set_numval</p>

<p>Assign the passed&#45;in Parrot number to the passed&#45;in PMC.</p>

<p>*/</p>

<p>PARROT_API void Parrot_PMC_set_numval(PARROT_INTERP, Parrot_PMC pmc, Parrot_Float value) { PARROT_CALLIN_START(interp); VTABLE_set_number_native(interp, pmc, value); PARROT_CALLIN_END(interp); }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_PMC_set_numval_intkey</p>

<p>Assign the passed&#45;in Parrot number to the passed&#45;in PMC.</p>

<p>*/</p>

<p>PARROT_API void Parrot_PMC_set_numval_intkey(PARROT_INTERP, Parrot_PMC pmc, Parrot_Int key, Parrot_Float value) { PARROT_CALLIN_START(interp); VTABLE_set_number_keyed_int(interp, pmc, key, value); PARROT_CALLIN_END(interp); }</p>

<p>/*</p>

<p>Parrot_PMC_set_cstring</p>

<p>Assign the passed&#45;in null&#45;terminated C string to the passed&#45;in PMC.</p>

<p>*/</p>

<p>PARROT_API void Parrot_PMC_set_cstring(PARROT_INTERP, Parrot_PMC pmc, NULLOK(const char *value)) { PARROT_CALLIN_START(interp); VTABLE_set_string_native(interp, pmc, string_from_cstring(interp, value, 0)); PARROT_CALLIN_END(interp); }</p>

<p>/*</p>

<p>Parrot_PMC_set_cstring_intkey</p>

<p>Assign the passed&#45;in null&#45;terminated C string to the passed&#45;in PMC.</p>

<p>*/</p>

<p>PARROT_API void Parrot_PMC_set_cstring_intkey(PARROT_INTERP, Parrot_PMC pmc, Parrot_Int key, NULLOK(const char *value)) { PARROT_CALLIN_START(interp); VTABLE_set_string_keyed_int(interp, pmc, key, string_from_cstring(interp, value, 0)); PARROT_CALLIN_END(interp); }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_PMC_set_cstringn</p>

<p>Assign the passed&#45;in length&#45;noted string to the passed&#45;in PMC.</p>

<p>*/</p>

<p>PARROT_API void Parrot_PMC_set_cstringn(PARROT_INTERP, Parrot_PMC pmc, NULLOK(const char *value), Parrot_Int length) { PARROT_CALLIN_START(interp); VTABLE_set_string_native(interp, pmc, string_from_cstring(interp, value, length)); PARROT_CALLIN_END(interp); }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_PMC_push_intval</p>

<p>Push the passed&#45;in Parrot integer onto the passed in PMC</p>

<p>*/</p>

<p>PARROT_API void Parrot_PMC_push_intval(PARROT_INTERP, Parrot_PMC pmc, Parrot_Int value) { PARROT_CALLIN_START(interp); VTABLE_push_integer(interp, pmc, value); PARROT_CALLIN_END(interp); }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_PMC_push_numval</p>

<p>Push the passed&#45;in Parrot number onto the passed in PMC</p>

<p>*/</p>

<p>PARROT_API void Parrot_PMC_push_numval(PARROT_INTERP, Parrot_PMC pmc, Parrot_Float value) { PARROT_CALLIN_START(interp); VTABLE_push_float(interp, pmc, value); PARROT_CALLIN_END(interp); }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_PMC_delete_pmckey</p>

<p>Deletes the value associated with the passed&#45;in PMC from the PMC.</p>

<p>*/</p>

<p>PARROT_API void Parrot_PMC_delete_pmckey(PARROT_INTERP, Parrot_PMC pmc, Parrot_PMC key) { PARROT_CALLIN_START(interp); VTABLE_delete_keyed(interp, pmc, key); PARROT_CALLIN_END(interp); }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_PMC_set_cstringn_intkey</p>

<p>Assign the passed&#45;in length&#45;noted string to the passed&#45;in PMC.</p>

<p>*/</p>

<p>PARROT_API void Parrot_PMC_set_cstringn_intkey(PARROT_INTERP, Parrot_PMC pmc, Parrot_Int key, NULLOK(const char *value), Parrot_Int length) { PARROT_CALLIN_START(interp); VTABLE_set_string_keyed_int(interp, pmc, key, string_from_cstring(interp, value, length)); PARROT_CALLIN_END(interp); }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_PMC_new</p>

<p>Create and return a new PMC.</p>

<p>*/</p>

<p>PARROT_API Parrot_PMC Parrot_PMC_new(PARROT_INTERP, Parrot_Int type) { Parrot_PMC newpmc; PARROT_CALLIN_START(interp); newpmc = pmc_new_noinit(interp, type); VTABLE_init(interp, newpmc); PARROT_CALLIN_END(interp); return newpmc; }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_PMC_typenum</p>

<p>Returns the internal identifier that represents the named class.</p>

<p>*/</p>

<p>PARROT_API Parrot_Int Parrot_PMC_typenum(PARROT_INTERP, NULLOK(const char *_class)) { Parrot_Int retval; PARROT_CALLIN_START(interp); retval = pmc_type(interp, string_from_cstring(interp, _class, 0)); PARROT_CALLIN_END(interp); return retval; }</p>

<p>/*</p>

<p>Parrot_PMC_null</p>

<p>Returns the special <code lang='und' xml:lang='und'>NULL</code> PMC.</p>

<p>*/</p>

<p>PARROT_API Parrot_PMC Parrot_PMC_null(void) { return PMCNULL; }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_free_cstring</p>

<p>Deallocate a C string that the interpreter has handed to you.</p>

<p>*/</p>

<p>PARROT_API void Parrot_free_cstring(NULLOK(char *string)) { string_cstring_free(string); }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_call_sub</p>

<p>Call a parrot subroutine with the given function signature. The first char in <code lang='und' xml:lang='und'>signature</code> denotes the return value. Next chars are arguments.</p>

<p>The return value of this function can be void or a pointer type.</p>

<p>Signature chars are:</p>

<pre lang='und' xml:lang='und'>    v ... void return
    I ... Parrot_Int
    N ... Parrot_Float
    S ... Parrot_String
    P ... Parrot_PMC</pre>

<p>FUNCDOC: Parrot_call_sub_ret_int</p>

<p>FUNCDOC: Parrot_call_sub_ret_float</p>

<p>Like above, with Parrot_Int or Parrot_Float return result.</p>

<p>*/</p>

<p>PARROT_API PARROT_WARN_UNUSED_RESULT PARROT_CAN_RETURN_NULL void* Parrot_call_sub(PARROT_INTERP, Parrot_PMC sub, NOTNULL(const char *signature), ...) { va_list ap; void *result;</p>

<pre lang='und' xml:lang='und'>    PARROT_CALLIN_START(interp);

    va_start(ap, signature);
    CONTEXT(interp&#45;&#62;ctx)&#45;&#62;constants =
        PMC_sub(sub)&#45;&#62;seg&#45;&#62;const_table&#45;&#62;constants;
    result = Parrot_runops_fromc_arglist(interp, sub, signature, ap);
    va_end(ap);

    PARROT_CALLIN_END(interp);
    return result;
}</pre>

<p>PARROT_API Parrot_Int Parrot_call_sub_ret_int(PARROT_INTERP, Parrot_PMC sub, NOTNULL(const char *signature), ...) { va_list ap; Parrot_Int result;</p>

<pre lang='und' xml:lang='und'>    PARROT_CALLIN_START(interp);

    va_start(ap, signature);
    CONTEXT(interp&#45;&#62;ctx)&#45;&#62;constants =
        PMC_sub(sub)&#45;&#62;seg&#45;&#62;const_table&#45;&#62;constants;
    result = Parrot_runops_fromc_arglist_reti(interp, sub, signature, ap);
    va_end(ap);

    PARROT_CALLIN_END(interp);
    return result;
}</pre>

<p>PARROT_API Parrot_Float Parrot_call_sub_ret_float(PARROT_INTERP, Parrot_PMC sub, NOTNULL(const char *signature), ...) { va_list ap; Parrot_Float result;</p>

<pre lang='und' xml:lang='und'>    PARROT_CALLIN_START(interp);

    va_start(ap, signature);
    CONTEXT(interp&#45;&#62;ctx)&#45;&#62;constants =
        PMC_sub(sub)&#45;&#62;seg&#45;&#62;const_table&#45;&#62;constants;
    result = Parrot_runops_fromc_arglist_retf(interp, sub, signature, ap);
    va_end(ap);

    PARROT_CALLIN_END(interp);
    return result;
}</pre>

<p>/*</p>

<p>FUNCDOC: Parrot_call_method</p>

<p>FUNCDOC: Parrot_call_method_ret_int</p>

<p>FUNCDOC: Parrot_call_method_ret_float</p>

<p>Call a parrot method for the given object.</p>

<p>*/</p>

<p>PARROT_API PARROT_WARN_UNUSED_RESULT PARROT_CAN_RETURN_NULL void * Parrot_call_method(PARROT_INTERP, Parrot_PMC sub, Parrot_PMC obj, Parrot_String method, NOTNULL(const char *signature), ...) { void *result; va_list ap;</p>

<pre lang='und' xml:lang='und'>    PARROT_CALLIN_START(interp);
    va_start(ap, signature);
    result = Parrot_run_meth_fromc_arglist(interp, sub,
            obj, method, signature, ap);
    va_end(ap);
    PARROT_CALLIN_END(interp);
    return result;
}</pre>

<p>PARROT_API Parrot_Int Parrot_call_method_ret_int(PARROT_INTERP, Parrot_PMC sub, Parrot_PMC obj, Parrot_String method, NOTNULL(const char *signature), ...) { Parrot_Int result; va_list ap;</p>

<pre lang='und' xml:lang='und'>    PARROT_CALLIN_START(interp);
    va_start(ap, signature);
    result = Parrot_run_meth_fromc_arglist_reti(interp, sub,
            obj, method, signature, ap);
    va_end(ap);
    PARROT_CALLIN_END(interp);
    return result;
}</pre>

<p>PARROT_API Parrot_Float Parrot_call_method_ret_float(PARROT_INTERP, Parrot_PMC sub, Parrot_PMC obj, Parrot_String method, NOTNULL(const char *signature), ...) { Parrot_Float result; va_list ap;</p>

<pre lang='und' xml:lang='und'>    PARROT_CALLIN_START(interp);
    va_start(ap, signature);
    result = Parrot_run_meth_fromc_arglist_retf(interp, sub,
            obj, method, signature, ap);
    va_end(ap);
    PARROT_CALLIN_END(interp);
    return result;
}</pre>

<p>/*</p>

<p>FUNCDOC: Parrot_get_intreg</p>

<p>Return the value of an integer register.</p>

<p>*/</p>

<p>PARROT_API Parrot_Int Parrot_get_intreg(PARROT_INTERP, Parrot_Int regnum) { return REG_INT(interp, regnum); }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_get_numreg</p>

<p>Return the value of a numeric register.</p>

<p>*/</p>

<p>PARROT_API Parrot_Float Parrot_get_numreg(PARROT_INTERP, Parrot_Int regnum) { return REG_NUM(interp, regnum); }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_get_strreg</p>

<p>Return the value of a string register.</p>

<p>*/</p>

<p>PARROT_API Parrot_String Parrot_get_strreg(PARROT_INTERP, Parrot_Int regnum) { return REG_STR(interp, regnum); }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_get_pmcreg</p>

<p>Return the value of a PMC register.</p>

<p>*/</p>

<p>PARROT_API Parrot_PMC Parrot_get_pmcreg(PARROT_INTERP, Parrot_Int regnum) { return REG_PMC(interp, regnum); }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_set_intreg</p>

<p>Set the value of an I register.</p>

<p>*/</p>

<p>PARROT_API void Parrot_set_intreg(PARROT_INTERP, Parrot_Int regnum, Parrot_Int value) { REG_INT(interp, regnum) = value; }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_set_numreg</p>

<p>Set the value of an N register.</p>

<p>*/</p>

<p>PARROT_API void Parrot_set_numreg(PARROT_INTERP, Parrot_Int regnum, Parrot_Float value) { REG_NUM(interp, regnum) = value; }</p>

<p>/*</p>

<p>Parrot_set_strreg</p>

<p>Set the value of an S register.</p>

<p>*/</p>

<p>PARROT_API void Parrot_set_strreg(PARROT_INTERP, Parrot_Int regnum, Parrot_String value) { REG_STR(interp, regnum) = value; }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_set_pmcreg</p>

<p>Set the value of a P register.</p>

<p>*/</p>

<p>PARROT_API void Parrot_set_pmcreg(PARROT_INTERP, Parrot_Int regnum, Parrot_PMC value) { REG_PMC(interp, regnum) = value; }</p>

<p>/*=for api extend Parrot_new_string * */ /*</p>

<p>FUNCDOC: Parrot_new_string</p>

<p>Create a new Parrot string from a passed&#45;in buffer. Pass in a 0 for flags for right now.</p>

<p>A copy of the buffer is made.</p>

<p>*/</p>

<p>PARROT_API PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL Parrot_String Parrot_new_string(PARROT_INTERP, NULLOK(char *buffer), int length, NULLOK(const char * const encoding_name), Parrot_Int flags) { Parrot_String retval; PARROT_CALLIN_START(interp); retval = string_make(interp, buffer, length, encoding_name, flags); PARROT_CALLIN_END(interp); return retval; }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_find_language</p>

<p>Find the magic language token for a language, by language name.</p>

<p>*/</p>

<p>PARROT_API PARROT_WARN_UNUSED_RESULT Parrot_Language Parrot_find_language(PARROT_INTERP, NOTNULL(char *language)) { return 0; }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_register_pmc</p>

<p>Add a reference of the PMC to the interpreters DOD registry. This prevents PMCs only known to extension from getting destroyed during DOD runs.</p>

<p>*/</p>

<p>PARROT_API void Parrot_register_pmc(PARROT_INTERP, Parrot_PMC pmc) { PARROT_CALLIN_START(interp); dod_register_pmc(interp, pmc); PARROT_CALLIN_END(interp); }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_unregister_pmc</p>

<p>Remove a reference of the PMC from the interpreters DOD registry. If the reference count reaches zero, the PMC will be destroyed during the next DOD run.</p>

<p>FUNCDOC: Parrot_get_dod_registry</p>

<p>Return Parrot&#39;s internal DOD registry PMC. See also: <em lang='und' xml:lang='und'><a href="pmc/addrregistry.pmc.html">src/pmc/addrregistry.pmc</a></em>.</p>

<p>*/</p>

<p>PARROT_API void Parrot_unregister_pmc(PARROT_INTERP, Parrot_PMC pmc) { PARROT_CALLIN_START(interp); dod_unregister_pmc(interp, pmc); PARROT_CALLIN_END(interp); }</p>

<p>PARROT_API Parrot_PMC Parrot_get_dod_registry(PARROT_INTERP) { PMC *registry = interp&#45;&#62;DOD_registry; PARROT_CALLIN_START(interp); if (!registry) { registry = interp&#45;&#62;DOD_registry = pmc_new(interp, enum_class_AddrRegistry); } PARROT_CALLIN_END(interp); return registry; }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_pmc_set_vtable</p>

<p>Replaces the vtable of the PMC.</p>

<p>*/</p>

<p>PARROT_API void Parrot_PMC_set_vtable(SHIM_INTERP, Parrot_PMC pmc, Parrot_VTABLE vtable) { pmc&#45;&#62;vtable = vtable; }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_get_vtable</p>

<p>Returns the vtable corresponding to the given PMC ID.</p>

<p>*/</p>

<p>PARROT_API PARROT_PURE_FUNCTION Parrot_VTABLE Parrot_get_vtable(PARROT_INTERP, Parrot_Int id) { return interp&#45;&#62;vtables[id]; }</p>

<p>/*</p>

<h1><a name="SEE_ALSO"
>SEE ALSO <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>See <em lang='und' xml:lang='und'>include/parrot/extend.h</em> and <em lang='und' xml:lang='und'>docs/pdds/pdd11_extending.pod</em>.</p>

<h1><a name="HISTORY"
>HISTORY <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>Initial version by Dan Sugalski.</p>

<p>*/</p>

<p>/* * Local variables: * c&#45;file&#45;style: &#34;parrot&#34; * End: * vim: expandtab shiftwidth=4: */</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
