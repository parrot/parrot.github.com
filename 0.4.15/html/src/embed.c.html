<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>The Parrot embedding interface</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">The Parrot embedding interface</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../html/index.html">Contents</a> | <a href="../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>src/embed.c &#45; The Parrot embedding interface</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>This file implements the Parrot embedding interface.</p>

<h2><a name="Functions"
>Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>*/</p>

<p>#include &#34;parrot/parrot.h&#34; #include &#34;parrot/embed.h&#34; #include &#34;parrot/oplib/ops.h&#34;</p>

<p>/* HEADERIZER HFILE: none */ /* The visible types are different than what we use in here */</p>

<p>/* HEADERIZER BEGIN: static */</p>

<p>static FLOATVAL calibrate( PARROT_INTERP ) __attribute__nonnull__(1);</p>

<p>static const char * op_name( PARROT_INTERP,
int k ) __attribute__nonnull__(1);</p>

<p>static void print_debug( PARROT_INTERP,
SHIM(int status),
SHIM(void *p) ) __attribute__nonnull__(1);</p>

<p>static void print_profile( PARROT_INTERP,
SHIM(int status),
SHIM(void *p) ) __attribute__nonnull__(1);</p>

<p>static int prof_sort_f( NOTNULL(const void *a),
NOTNULL(const void *b) ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>static PMC* set_current_sub( PARROT_INTERP ) __attribute__nonnull__(1);</p>

<p>static PMC* setup_argv( PARROT_INTERP,
int argc,
char ** argv ) __attribute__nonnull__(1);</p>

<p>/* HEADERIZER END: static */</p>

<p>extern int Parrot_exec_run;</p>

<p>/*</p>

<p>FUNCDOC: Parrot_new</p>

<p>Returns a new Parrot interpreter.</p>

<p>The first created interpreter (<code lang='und' xml:lang='und'>parent</code> is <code lang='und' xml:lang='und'>NULL</code>) is the last one to get destroyed.</p>

<p>*/</p>

<p>#ifdef JIT_CAPABLE # if EXEC_CAPABLE # include &#34;parrot/exec.h&#34; # endif /* EXEC_CAPABLE */ # include &#34;jit.h&#34; #endif</p>

<p>PARROT_API Parrot_Interp Parrot_new(Parrot_Interp parent) { /* inter_create.c:make_interpreter builds a new Parrot_Interp.
*/ return make_interpreter(parent,
PARROT_NO_FLAGS); }</p>

<p>extern void Parrot_initialize_core_pmcs(PARROT_INTERP);</p>

<p>/*</p>

<p>FUNCDOC: Parrot_init</p>

<p>Initializes the new interpreter.
This function only has effect the first time it is called.
Therefore Parrot_init() doesn&#39;t have to be called on an interpreter returned from Parrot_new().</p>

<p>Use this function when you intend to enter the run loop,
which automatically sets the top of stack pointer.</p>

<p>FUNCDOC: Parrot_init_stacktop</p>

<p>Like above.
Additionally sets the stack top,
so that Parrot objects created in inner stack frames will be visible during DODs stack walking code.
<b>stack_top</b> should be the address of an automatic variable in the caller&#39;s stack frame.
All unanchored Parrot objects (PMCs) must live in inner stack frames so that they are not destroyed during DOD runs.</p>

<p>Use this function when you call into Parrot before entering a run loop.</p>

<p>*/</p>

<p>/* XXX Parrot_init() should be removed,
no longer required for embedders */ PARROT_API void Parrot_init(PARROT_INTERP) { if (!interp&#45;&#62;world_inited) { /* global_setup.c:init_world sets up some vtable stuff.
* It must only be called once.
*/</p>

<pre lang='und' xml:lang='und'>        interp&#45;&#62;world_inited = 1;
        init_world(interp);
    }
}</pre>

<p>PARROT_API void Parrot_init_stacktop(PARROT_INTERP, void *stack_top) { interp&#45;&#62;lo_var_ptr = stack_top; Parrot_init(interp); }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_set_flag</p>

<p>Sets a flag in the interpreter specified by <code lang='und' xml:lang='und'>flag</code>, any of <code lang='und' xml:lang='und'>PARROT_BOUNDS_FLAG</code>, or <code lang='und' xml:lang='und'>PARROT_PROFILE_FLAG</code> to enable profiling, and bounds checking respectively or <code lang='und' xml:lang='und'>PARROT_THR_TYPE_1</code>, <code lang='und' xml:lang='und'>PARROT_THR_TYPE_2</code>, or <code lang='und' xml:lang='und'>PARROT_THR_TYPE_3</code> to disable thread communication and variable sharing, disable variable sharing but enable thread communication, or to enable variable sharing.</p>

<p>FUNCDOC: Parrot_set_debug</p>

<p>Set a debug flag: <code lang='und' xml:lang='und'>PARROT_DEBUG_FLAG</code>.</p>

<p>FUNCDOC: Parrot_set_trace</p>

<p>Set a trace flag: <code lang='und' xml:lang='und'>PARROT_TRACE_FLAG</code></p>

<p>*/</p>

<p>PARROT_API void Parrot_set_flag(PARROT_INTERP, INTVAL flag) { /* These two macros (from interpreter.h) do exactly what they look like. */</p>

<pre lang='und' xml:lang='und'>    Interp_flags_SET(interp, flag);
    switch (flag) {
        case PARROT_BOUNDS_FLAG:
        case PARROT_PROFILE_FLAG:
            Interp_core_SET(interp, PARROT_SLOW_CORE);
            break;
        default:
            break;
    }
}</pre>

<p>PARROT_API void Parrot_set_debug(PARROT_INTERP, UINTVAL flag) { interp&#45;&#62;debug_flags |= flag; }</p>

<p>PARROT_API void Parrot_set_trace(PARROT_INTERP, UINTVAL flag) { CONTEXT(interp&#45;&#62;ctx)&#45;&#62;trace_flags |= flag; Interp_core_SET(interp, PARROT_SLOW_CORE); }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_clear_flag</p>

<p>Clears a flag in the interpreter.</p>

<p>FUNCDOC: Parrot_clear_debug</p>

<p>Clears a flag in the interpreter.</p>

<p>FUNCDOC: Parrot_clear_trace</p>

<p>Clears a flag in the interpreter.</p>

<p>*/</p>

<p>PARROT_API void Parrot_clear_flag(PARROT_INTERP, INTVAL flag) { Interp_flags_CLEAR(interp, flag); }</p>

<p>PARROT_API void Parrot_clear_debug(PARROT_INTERP, UINTVAL flag) { interp&#45;&#62;debug_flags &#38;= ~flag; }</p>

<p>PARROT_API void Parrot_clear_trace(PARROT_INTERP, UINTVAL flag) { CONTEXT(interp&#45;&#62;ctx)&#45;&#62;trace_flags &#38;= ~flag; }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_test_flag</p>

<p>Test the interpreter flags specified in <code lang='und' xml:lang='und'>flag</code>.</p>

<p>FUNCDOC: Parrot_test_debug</p>

<p>Test the interpreter flags specified in <code lang='und' xml:lang='und'>flag</code>.</p>

<p>FUNCDOC: Parrot_test_trace</p>

<p>Test the interpreter flags specified in <code lang='und' xml:lang='und'>flag</code>.</p>

<p>*/</p>

<p>PARROT_API Parrot_Int Parrot_test_flag(PARROT_INTERP, INTVAL flag) { return Interp_flags_TEST(interp, flag); }</p>

<p>PARROT_API UINTVAL Parrot_test_debug(PARROT_INTERP, UINTVAL flag) { return interp&#45;&#62;debug_flags &#38; flag; }</p>

<p>PARROT_API UINTVAL Parrot_test_trace(PARROT_INTERP, UINTVAL flag) { return CONTEXT(interp&#45;&#62;ctx)&#45;&#62;trace_flags &#38; flag; }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_set_run_core</p>

<p>Sets the specified run core.</p>

<p>*/</p>

<p>PARROT_API void Parrot_set_run_core(PARROT_INTERP, Parrot_Run_core_t core) { Interp_core_SET(interp, core); }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_setwarnings</p>

<p>Activates the given warnings.</p>

<p>*/</p>

<p>PARROT_API void Parrot_setwarnings(PARROT_INTERP, Parrot_warnclass wc) { /* Activates the given warnings. (Macro from warnings.h.) */ PARROT_WARNINGS_on(interp, wc); }</p>

<p>/*</p>

<p>FUNCDOC: Parrot_readbc</p>

<p>Read in a bytecode, unpack it into a <code lang='und' xml:lang='und'>PackFile</code> structure, and do fixups.</p>

<p>*/</p>

<p>PARROT_API PackFile * Parrot_readbc(PARROT_INTERP, NULLOK(const char *fullname)) { INTVAL program_size, wanted; char *program_code; PackFile *pf; FILE * io = NULL; INTVAL is_mapped = 0; #ifdef PARROT_HAS_HEADER_SYSMMAN int fd = &#45;1; #endif</p>

<pre lang='und' xml:lang='und'>    if (fullname == NULL || strcmp(fullname, &#34;&#45;&#34;) == 0) {
        /* read from STDIN */
        io = stdin;
        /* read 1k at a time */
        program_size = 0;
    }
    else {
        STRING * const fs = string_make(interp, fullname,
                strlen(fullname), NULL, 0);
        if (!Parrot_stat_info_intval(interp, fs, STAT_EXISTS)) {
            PIO_eprintf(interp, &#34;Parrot VM: Can&#39;t stat %s, code %i.\n&#34;,
                    fullname, errno);
            return NULL;
        }
        /*
         * TODO check for regular file
         */

        program_size = Parrot_stat_info_intval(interp, fs, STAT_FILESIZE);</pre>

<p>#ifndef PARROT_HAS_HEADER_SYSMMAN io = fopen(fullname, &#34;rb&#34;); if (!io) { PIO_eprintf(interp, &#34;Parrot VM: Can&#39;t open %s, code %i.\n&#34;, fullname, errno); return NULL; } #endif /* PARROT_HAS_HEADER_SYSMMAN */</p>

<pre lang='und' xml:lang='und'>    }
#ifdef PARROT_HAS_HEADER_SYSMMAN
again:
#endif
    /* if we&#39;ve opened a file (or stdin) with PIO, read it in */
    if (io) {
        size_t chunk_size;
        char *cursor;
        INTVAL read_result;

        chunk_size = program_size &#62; 0 ? program_size : 1024;
        program_code = (char *)mem_sys_allocate(chunk_size);
        wanted = program_size;
        program_size = 0;
        cursor = (char *)program_code;

        while ((read_result =
                fread(cursor, 1, chunk_size, io)) &#62; 0) {
            program_size += read_result;
            if (program_size == wanted)
                break;
            chunk_size = 1024;
            program_code =
                (char *)mem_sys_realloc(program_code, program_size + chunk_size);

            if (!program_code) {
                PIO_eprintf(interp,
                            &#34;Parrot VM: Could not reallocate buffer &#34;
                            &#34;while reading packfile from PIO.\n&#34;);
                return NULL;
            }

            cursor = (char *)program_code + program_size;
        }

        if (read_result &#60; 0) {
            PIO_eprintf(interp,
                    &#34;Parrot VM: Problem reading packfile from PIO.\n&#34;);
            return NULL;
        }
        fclose(io);
    }
    else {
        /* if we&#39;ve gotten here, we opted not to use PIO to read the file.
         * use mmap */</pre>

<p>#ifdef PARROT_HAS_HEADER_SYSMMAN</p>

<pre lang='und' xml:lang='und'>        fd = open(fullname, O_RDONLY | O_BINARY);
        if (!fd) {
            PIO_eprintf(interp, &#34;Parrot VM: Can&#39;t open %s, code %i.\n&#34;,
                    fullname, errno);
            return NULL;
        }

        program_code =
            (char *)mmap(0, program_size, PROT_READ, MAP_SHARED, fd, (off_t)0);

        if (program_code == (void *)MAP_FAILED) {
            Parrot_warn(interp, PARROT_WARNINGS_IO_FLAG,
                    &#34;Parrot VM: Can&#39;t mmap file %s, code %i.\n&#34;,
                    fullname, errno);
            /* try again, now with IO reading the file */
            io = fopen(fullname, &#34;rb&#34;);
            if (!io) {
                PIO_eprintf(interp,
                        &#34;Parrot VM: Can&#39;t open %s, code %i.\n&#34;,
                        fullname, errno);
                return NULL;
            }
            goto again;
        }
        is_mapped = 1;</pre>

<p>#else /* PARROT_HAS_HEADER_SYSMMAN */</p>

<pre lang='und' xml:lang='und'>        PIO_eprintf(interp, &#34;Parrot VM: uncaught error occurred reading &#34;
                    &#34;file or mmap not available.\n&#34;);
        return NULL;</pre>

<p>#endif /* PARROT_HAS_HEADER_SYSMMAN */</p>

<pre lang='und' xml:lang='und'>    }

    /* Now that we have the bytecode, let&#39;s unpack it. */

    pf = PackFile_new(interp, is_mapped);

    if (!PackFile_unpack(interp, pf, (opcode_t *)program_code, program_size)) {
        PIO_eprintf(interp, &#34;Parrot VM: Can&#39;t unpack packfile %s.\n&#34;,
                fullname);
        return NULL;
    }

    /*
     * Set :main routine
     */
    do_sub_pragmas(interp, pf&#45;&#62;cur_cs, PBC_PBC, NULL);
    /*
     * JITting and/or prederefing the sub/the bytecode is done
     * in switch_to_cs before actual usage of the segment
     */</pre>

<p>#ifdef PARROT_HAS_HEADER_SYSMMAN</p>

<pre lang='und' xml:lang='und'>    if (fd &#62;= 0) {
        close(fd);   /* the man page states, it&#39;s ok to close a mmaped file */
    }
#else
/* XXX Parrot_exec uses this
    mem_sys_free(program_code); */
#endif

    return pf;
}</pre>

<p>/*</p>

<p>FUNCDOC: Parrot_loadbc</p>

<p>Loads the <code lang='und' xml:lang='und'>PackFile</code> returned by <code lang='und' xml:lang='und'>Parrot_readbc()</code>.</p>

<p>*/</p>

<p>PARROT_API void Parrot_loadbc(PARROT_INTERP, NOTNULL(PackFile *pf)) { if (pf == NULL) { PIO_eprintf(interp, &#34;Invalid packfile\n&#34;); return; } interp&#45;&#62;initial_pf = pf; interp&#45;&#62;code = pf&#45;&#62;cur_cs; }</p>

<p>/*</p>

<p>FUNCDOC: setup_argv</p>

<p>Creates and returns <code lang='und' xml:lang='und'>ARGS</code> array PMC.</p>

<p>*/</p>

<p>static PMC* setup_argv(PARROT_INTERP, int argc, char ** argv) { INTVAL i; PMC *userargv;</p>

<pre lang='und' xml:lang='und'>    if (Interp_debug_TEST(interp, PARROT_START_DEBUG_FLAG)) {
        PIO_eprintf(interp,
                &#34;*** Parrot VM: Setting up ARGV array.&#34;
                &#34; Current argc: %d ***\n&#34;,
                argc);
    }

    userargv = pmc_new_noinit(interp, enum_class_ResizableStringArray);
    /* immediately anchor pmc to root set */
    VTABLE_set_pmc_keyed_int(interp, interp&#45;&#62;iglobals,
            (INTVAL)IGLOBALS_ARGV_LIST, userargv);
    VTABLE_init(interp, userargv);

    for (i = 0; i &#60; argc; i++) {
        /* Run through argv, adding everything to @ARGS. */
        STRING *arg = string_make(interp, argv[i], strlen(argv[i]),
                NULL, PObj_external_FLAG);

        if (Interp_debug_TEST(interp, PARROT_START_DEBUG_FLAG)) {
            PIO_eprintf(interp, &#34;\t%vd: %s\n&#34;, i, argv[i]);
        }

        VTABLE_push_string(interp, userargv, arg);
    }
    return userargv;
}</pre>

<p>/*</p>

<p>FUNCDOC: prof_sort_f</p>

<p>Sort function for profile data. Sorts by time.</p>

<p>*/</p>

<p>static int prof_sort_f(NOTNULL(const void *a), NOTNULL(const void *b)) { const FLOATVAL timea = ((const ProfData *)a)&#45;&#62;time; const FLOATVAL timeb = ((const ProfData *)b)&#45;&#62;time;</p>

<pre lang='und' xml:lang='und'>    if (timea &#60; timeb)
        return 1;
    if (timea &#62; timeb)
        return &#45;1;
    return 0;
}</pre>

<p>/*</p>

<p>FUNCDOC: op_name</p>

<p>Returns the name of the opcode.</p>

<p>*/</p>

<p>static const char * op_name(PARROT_INTERP, int k) { switch (k) { case PARROT_PROF_DOD_p1: return &#34;DOD_mark_root&#34;; case PARROT_PROF_DOD_p2: return &#34;DOD_mark_next&#34;; case PARROT_PROF_DOD_cp: return &#34;DOD_collect_PMC&#34;; case PARROT_PROF_DOD_cb: return &#34;DOD_collect_buffers&#34;; case PARROT_PROF_GC: return &#34;GC&#34;; case PARROT_PROF_EXCEPTION: return &#34;EXCEPTION&#34;; default: break; } return interp&#45;&#62;op_info_table[k &#45; PARROT_PROF_EXTRA].full_name; }</p>

<p>/*</p>

<p>FUNCDOC: calibrate</p>

<p>With this calibration, reported times of <code lang='und' xml:lang='und'>parrot &#45;p</code> almost match those measured with time <code lang='und' xml:lang='und'>parrot &#45;b</code>.</p>

<p>*/</p>

<p>static FLOATVAL calibrate(PARROT_INTERP) { size_t n = interp&#45;&#62;op_count; size_t i; FLOATVAL start, empty; opcode_t code[] = { 1 }; /* noop */ opcode_t *pc = code;</p>

<pre lang='und' xml:lang='und'>    if (n &#60; 1000000)    /* minimum opcode count for calibration */
        n = 1000000;
    start = Parrot_floatval_time();
    for (empty = 0.0, i = 0; i &#60; n; i++)
       pc =  (interp&#45;&#62;op_func_table[*code])(pc, interp);
    empty += Parrot_floatval_time() &#45; start;
    return empty / (FLOATVAL)n;
}</pre>

<p>/*</p>

<p>FUNCDOC: print_profile</p>

<p>Prints out a profile listing.</p>

<p>*/</p>

<p>static void print_profile(PARROT_INTERP, SHIM(int status), SHIM(void *p)) { RunProfile * const profile = interp&#45;&#62;profile;</p>

<pre lang='und' xml:lang='und'>    if (profile) {
        UINTVAL j;
        int k;
        int jit;
        UINTVAL op_count = 0;
        UINTVAL call_count = 0;
        FLOATVAL sum_time = 0.0;
        const FLOATVAL empty = calibrate(interp);

        PIO_printf(interp,
                   &#34; Code J Name                         &#34;
                   &#34;Calls  Total/s       Avg/ms\n&#34;);
        for (j = 0; j &#60; interp&#45;&#62;op_count + PARROT_PROF_EXTRA; j++) {
            const UINTVAL n = profile&#45;&#62;data[j].numcalls;
            profile&#45;&#62;data[j].op = j;
            if (j &#62;= PARROT_PROF_EXTRA) {
                profile&#45;&#62;data[j].time &#45;= empty * n;
                if (profile&#45;&#62;data[j].time &#60; 0.0) /* faster than noop */
                    profile&#45;&#62;data[j].time = 0.0;
            }
        }
        qsort(profile&#45;&#62;data, interp&#45;&#62;op_count +
                PARROT_PROF_EXTRA,
                sizeof (ProfData), prof_sort_f);
        for (j = 0; j &#60; interp&#45;&#62;op_count + PARROT_PROF_EXTRA; j++) {
            const UINTVAL n = profile&#45;&#62;data[j].numcalls;

            if (n &#62; 0) {
                const FLOATVAL t = profile&#45;&#62;data[j].time;

                op_count++;
                call_count += n;
                sum_time += t;

                k = profile&#45;&#62;data[j].op;
                jit = &#39;&#45;&#39;;
#if JIT_CAPABLE
                if (k &#62;= PARROT_PROF_EXTRA &#38;&#38;
                    op_jit[k &#45; PARROT_PROF_EXTRA].extcall != 1)
                    jit = &#39;j&#39;;
#endif
                PIO_printf(interp, &#34; %4d %c %&#45;25s %8vu  %10vf  %10.6vf\n&#34;,
                        k &#45; PARROT_PROF_EXTRA,
                        jit,
                        op_name(interp, k),
                        n,
                        t,
                        (FLOATVAL)(t * 1000.0 / (FLOATVAL)n));
            }
        }

        PIO_printf(interp, &#34; %4vu &#45; %&#45;25s %8vu  %10vf  %10.6vf\n&#34;,
                op_count,
                &#34;&#45;&#34;,
                call_count,
                sum_time,
                (FLOATVAL)(sum_time * 1000.0 / (FLOATVAL)call_count));
    }
}</pre>

<p>/*</p>

<p>FUNCDOC: print_debug</p>

<p>Prints GC info.</p>

<p>*/</p>

<p>static void print_debug(PARROT_INTERP, SHIM(int status), SHIM(void *p)) { if (Interp_debug_TEST(interp, PARROT_MEM_STAT_DEBUG_FLAG)) { /* Give the souls brave enough to activate debugging an earful * about GC. */</p>

<pre lang='und' xml:lang='und'>        PIO_eprintf(interp, &#34;*** Parrot VM: Dumping GC info ***\n&#34;);
        PDB_info(interp);
    }
}</pre>

<p>static PMC* set_current_sub(PARROT_INTERP) { opcode_t i, ci; Parrot_sub *sub; PMC *sub_pmc; size_t offs;</p>

<pre lang='und' xml:lang='und'>    PackFile_ByteCode * const cur_cs = interp&#45;&#62;code;
    PackFile_FixupTable * const ft = cur_cs&#45;&#62;fixups;
    PackFile_ConstTable * const ct = cur_cs&#45;&#62;const_table;

    /*
     * Walk the fixup table.  The first Sub&#45;like entry should be our
     * entry point with the address at our resume_offset.
     */

    for (i = 0; i &#60; ft&#45;&#62;fixup_count; i++) {
        switch (ft&#45;&#62;fixups[i]&#45;&#62;type) {
            case enum_fixup_sub:
                ci = ft&#45;&#62;fixups[i]&#45;&#62;offset;
                sub_pmc = ct&#45;&#62;constants[ci]&#45;&#62;u.key;
                sub = PMC_sub(sub_pmc);
                if (sub&#45;&#62;seg != cur_cs)
                    continue;
                offs = sub&#45;&#62;start_offs;
                if (offs == interp&#45;&#62;resume_offset) {
                    CONTEXT(interp&#45;&#62;ctx)&#45;&#62;current_sub = sub_pmc;
                    CONTEXT(interp&#45;&#62;ctx)&#45;&#62;current_HLL = sub&#45;&#62;HLL_id;
                    return sub_pmc;
                }
                break;
        }
    }
    /*
     * if we didn&#39;t find anything put a dummy PMC into current_sub
     */
    sub_pmc = pmc_new(interp, enum_class_Sub);
    PMC_sub(sub_pmc)&#45;&#62;start_offs = 0;
    CONTEXT(interp&#45;&#62;ctx)&#45;&#62;current_sub = sub_pmc;
    return sub_pmc;
}</pre>

<p>/*</p>

<p>FUNCDOC: Parrot_runcode</p>

<p>Sets up <code lang='und' xml:lang='und'>ARGV</code> and runs the ops.</p>

<p>*/</p>

<p>PARROT_API void Parrot_runcode(PARROT_INTERP, int argc, char *argv[]) { PMC *userargv, *main_sub;</p>

<pre lang='und' xml:lang='und'>    if (Interp_debug_TEST(interp, PARROT_START_DEBUG_FLAG)) {
        PIO_eprintf(interp,
                &#34;*** Parrot VM: Setting stack top. ***\n&#34;);
    }
    /* Debugging mode nonsense. */
    if (Interp_debug_TEST(interp, PARROT_START_DEBUG_FLAG)) {
        if (Interp_flags_TEST(interp, PARROT_BOUNDS_FLAG)) {
            PIO_eprintf(interp,
                    &#34;*** Parrot VM: Bounds checking enabled. ***\n&#34;);
        }
        if (Interp_trace_TEST(interp, PARROT_TRACE_OPS_FLAG)) {
            PIO_eprintf(interp, &#34;*** Parrot VM: Tracing enabled. ***\n&#34;);
        }
        PIO_eprintf(interp, &#34;*** Parrot VM: &#34;);
        switch (interp&#45;&#62;run_core) {
            case PARROT_SLOW_CORE:
                PIO_eprintf(interp, &#34;Slow core&#34;);
                break;
            case PARROT_FAST_CORE:
                PIO_eprintf(interp, &#34;Fast core&#34;);
                break;
            case PARROT_SWITCH_CORE:
            case PARROT_SWITCH_JIT_CORE:
                PIO_eprintf(interp, &#34;Switch core&#34;);
                break;
            case PARROT_CGP_CORE:
            case PARROT_CGP_JIT_CORE:
                PIO_eprintf(interp, &#34;CGP core&#34;);
                break;
            case PARROT_CGOTO_CORE:
                PIO_eprintf(interp, &#34;CGoto core&#34;);
                break;
            case PARROT_JIT_CORE:
                PIO_eprintf(interp, &#34;JIT core&#34;);
                break;
            case PARROT_EXEC_CORE:
                PIO_eprintf(interp, &#34;EXEC core&#34;);
                break;
        }
        PIO_eprintf(interp, &#34; ***\n&#34;);
    }

    /* Set up @ARGS (or whatever this language calls it) in userargv. */
    userargv = setup_argv(interp, argc, argv);</pre>

<p>#if EXEC_CAPABLE</p>

<pre lang='und' xml:lang='und'>    /* s. runops_exec interpreter.c */
    if (Interp_core_TEST(interp, PARROT_EXEC_CORE)) {
        Parrot_exec_run = 1;
    }</pre>

<p>#endif</p>

<pre lang='und' xml:lang='und'>    /*
     * If any profile information was gathered, print it out
     * before exiting, then print debug infos if turned on.
     */
    Parrot_on_exit(interp, print_debug,   NULL);
    Parrot_on_exit(interp, print_profile, NULL);

    /* Let&#39;s kick the tires and light the fires&#45;&#45;call interpreter.c:runops. */
    main_sub = CONTEXT(interp&#45;&#62;ctx)&#45;&#62;current_sub;
    /*
     * if no sub was marked being :main, we create a dummy sub with offset 0
     */
    if (!main_sub) {
        main_sub = set_current_sub(interp);
    }
    CONTEXT(interp&#45;&#62;ctx)&#45;&#62;current_sub = NULL;
    CONTEXT(interp&#45;&#62;ctx)&#45;&#62;constants =
        interp&#45;&#62;code&#45;&#62;const_table&#45;&#62;constants;
    Parrot_runops_fromc_args(interp, main_sub, &#34;vP&#34;, userargv);
}</pre>

<p>/*</p>

<p>FUNCDOC: Parrot_debug</p>

<p>Runs the interpreter&#39;s bytecode in debugging mode.</p>

<p>*/</p>

<p>PARROT_API opcode_t * Parrot_debug(NOTNULL(Parrot_Interp debugger), opcode_t * pc) { const char *command; Interp *interp;</p>

<pre lang='und' xml:lang='und'>    PDB_t * const pdb = debugger&#45;&#62;pdb;

    pdb&#45;&#62;cur_opcode = pc;

    PDB_init(debugger, NULL);
    /* disassemble needs this for now */
    interp = pdb&#45;&#62;debugee;
    interp&#45;&#62;pdb = pdb;
    debugger&#45;&#62;lo_var_ptr = interp&#45;&#62;lo_var_ptr;

    PDB_disassemble(interp, NULL);

    while (!(pdb&#45;&#62;state &#38; PDB_EXIT)) {
        PDB_get_command(debugger);
        command = pdb&#45;&#62;cur_command;
        PDB_run_command(debugger, command);
    }
    return NULL;
}</pre>

<p>/*</p>

<p>FUNCDOC: Parrot_disassemble</p>

<p>Disassembles and prints out the interpreter&#39;s bytecode.</p>

<p>This is used by the Parrot disassembler.</p>

<p>*/</p>

<p>PARROT_API void Parrot_disassemble(PARROT_INTERP) { PDB_t *pdb = mem_allocate_zeroed_typed(PDB_t); PDB_line_t *line; int debugs; int num_mappings = 0; int curr_mapping = 0; int op_code_seq_num = 0;</p>

<pre lang='und' xml:lang='und'>    interp&#45;&#62;pdb     = pdb;
    pdb&#45;&#62;cur_opcode = interp&#45;&#62;code&#45;&#62;base.data;

    PDB_disassemble(interp, NULL);

    line   = pdb&#45;&#62;file&#45;&#62;line;
    debugs = (interp&#45;&#62;code&#45;&#62;debugs != NULL);

    PIO_printf(interp, &#34;%12s&#45;%12s&#34;, &#34;Seq_Op_Num&#34;, &#34;Relative&#45;PC&#34;);

    if ( debugs ) {
        PIO_printf(interp, &#34; %6s:\n&#34;,&#34;SrcLn#&#34;);
        num_mappings = interp&#45;&#62;code&#45;&#62;debugs&#45;&#62;num_mappings;
    }
    else {
        PIO_printf(interp, &#34;\n&#34;);
    }

    while (line&#45;&#62;next) {
        const char *c;

        /* PIO_printf(interp, &#34;%i &#60; %i %i == %i \n&#34;, curr_mapping,
         * num_mappings, op_code_seq_num,
         * interp&#45;&#62;code&#45;&#62;debugs&#45;&#62;mappings[curr_mapping]&#45;&#62;offset); */

        if (debugs &#38;&#38; curr_mapping &#60; num_mappings) {
            if ( op_code_seq_num == interp&#45;&#62;code&#45;&#62;debugs&#45;&#62;mappings[curr_mapping]&#45;&#62;offset) {
                const int filename_const_offset = interp&#45;&#62;code&#45;&#62;debugs&#45;&#62;mappings[curr_mapping]&#45;&#62;u.filename;
                PIO_printf(interp, &#34;Current Source Filename %Ss\n&#34;, interp&#45;&#62;code&#45;&#62;const_table&#45;&#62;constants[filename_const_offset]&#45;&#62;u.string);
                curr_mapping++;
            }
        }

        PIO_printf(interp, &#34;%012i&#45;%012i&#34;, op_code_seq_num, line&#45;&#62;opcode &#45; interp&#45;&#62;code&#45;&#62;base.data);

        if ( debugs )
            PIO_printf(interp, &#34; %06i: &#34;,interp&#45;&#62;code&#45;&#62;debugs&#45;&#62;base.data[op_code_seq_num]);

        /* If it has a label print it */
        if (line&#45;&#62;label)
            PIO_printf(interp, &#34;L%li:\t&#34;, line&#45;&#62;label&#45;&#62;number);
        else
            PIO_printf(interp, &#34;\t&#34;);

        c = pdb&#45;&#62;file&#45;&#62;source + line&#45;&#62;source_offset;

        while (c &#38;&#38; *c != &#39;\n&#39;)
            PIO_printf(interp, &#34;%c&#34;, *(c++));

        PIO_printf(interp, &#34;\n&#34;);
        line = line&#45;&#62;next;
        op_code_seq_num++;
    }

    return;
}</pre>

<p>/*</p>

<p>FUNCDOC: Parrot_run_native</p>

<p>Run the C function <code lang='und' xml:lang='und'>func</code> through the program <code lang='und' xml:lang='und'>[enternative, end]</code>. This ensures that the function is run with the same setup as in other run loops.</p>

<p>This function is used in some of the source tests in <em lang='und' xml:lang='und'>t/src</em> which use the interpreter outside a runloop.</p>

<p>*/</p>

<p>PARROT_API void Parrot_run_native(PARROT_INTERP, native_func_t func) { static opcode_t program_code[2]; PackFile * pf;</p>

<pre lang='und' xml:lang='und'>    program_code[0] = interp&#45;&#62;op_lib&#45;&#62;op_code(&#34;enternative&#34;, 0);
    program_code[1] = 0; /* end */
    pf = PackFile_new(interp, 0);
    pf&#45;&#62;cur_cs = (PackFile_ByteCode *)
        (pf&#45;&#62;PackFuncs[PF_BYTEC_SEG].new_seg)(interp, pf, &#34;code&#34;, 1);
    pf&#45;&#62;cur_cs&#45;&#62;base.data = program_code;
    pf&#45;&#62;cur_cs&#45;&#62;base.size = 2;
    Parrot_loadbc(interp, pf);
    run_native = func;
    if (interp&#45;&#62;code &#38;&#38; interp&#45;&#62;code&#45;&#62;const_table) {
        CONTEXT(interp&#45;&#62;ctx)&#45;&#62;constants =
            interp&#45;&#62;code&#45;&#62;const_table&#45;&#62;constants;
    }
    runops(interp, interp&#45;&#62;resume_offset);
}</pre>

<p>/*</p>

<h1><a name="SEE_ALSO"
>SEE ALSO <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p><em lang='und' xml:lang='und'>include/parrot/embed.h</em> and <em lang='und' xml:lang='und'><a href="../docs/embed.pod.html">docs/embed.pod</a></em>.</p>

<h1><a name="HISTORY"
>HISTORY <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>Initial version by Brent Dax on 2002.1.28.</p>

<p>*/</p>

<p>/* * Local variables: * c&#45;file&#45;style: &#34;parrot&#34; * End: * vim: expandtab shiftwidth=4: */</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
