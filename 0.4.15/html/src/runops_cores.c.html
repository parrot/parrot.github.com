<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Run Loops</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Run Loops</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../html/index.html">Contents</a> | <a href="../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>src/runops_cores.c &#45; Run Loops</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>This file implements the various run loops for the interpreter.
A slow one with bounds checking,
tracing and (optional) profiling,
and a fast one without.
There&#39;s also one which uses computed <code lang='und' xml:lang='und'>goto</code>,
which enables the faster dispatch of operations.</p>

<h2><a name="Functions"
>Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>*/</p>

<p>#include &#34;runops_cores.h&#34; #include &#34;parrot/embed.h&#34; #include &#34;trace.h&#34; #include &#34;interp_guts.h&#34;</p>

<p>#ifdef HAVE_COMPUTED_GOTO # include &#34;parrot/oplib/core_ops_cg.h&#34; #endif</p>

<p>/* HEADERIZER HFILE: src/runops_cores.h */</p>

<p>/* HEADERIZER BEGIN: static */</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CAN_RETURN_NULL static opcode_t * runops_trace_core( PARROT_INTERP,
NOTNULL(opcode_t *pc) ) __attribute__nonnull__(1) __attribute__nonnull__(2);</p>

<p>/* HEADERIZER END: static */</p>

<p>/*</p>

<p>FUNCDOC: runops_fast_core</p>

<p>Runs the Parrot operations starting at <code lang='und' xml:lang='und'>pc</code> until there are no more operations.</p>

<p>No bounds checking,
profiling or tracing is performed.</p>

<p>*/</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CAN_RETURN_NULL opcode_t * runops_fast_core(PARROT_INTERP,
NOTNULL(opcode_t *pc)) { while (pc) { DO_OP(pc,
interp); } return pc; }</p>

<p>/*</p>

<p>FUNCDOC: runops_cgoto_core</p>

<p>Runs the Parrot operations starting at <code lang='und' xml:lang='und'>pc</code> until there are no more operations,
using the computed <code lang='und' xml:lang='und'>goto</code> core.</p>

<p>No bounds checking,
profiling or tracing is performed.</p>

<p>If computed <code lang='und' xml:lang='und'>goto</code> is not available then Parrot exits with exit code 1.</p>

<p>*/</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CAN_RETURN_NULL opcode_t * runops_cgoto_core(PARROT_INTERP,
NOTNULL(opcode_t *pc)) { #ifdef HAVE_COMPUTED_GOTO pc = cg_core(pc,
interp); return pc; #else PIO_eprintf(interp,
&#34;Computed goto unavailable in this configuration.\n&#34;); Parrot_exit(interp,
1); #endif }</p>

<p>/*</p>

<p>FUNCDOC: runops_slow_core</p>

<p>Runs the Parrot operations starting at <code lang='und' xml:lang='und'>pc</code> until there are no more operations,
with tracing and bounds checking enabled.</p>

<p>*/</p>

<p>#ifdef code_start # undef code_start #endif #ifdef code_end # undef code_end #endif</p>

<p>#define code_start interp&#45;&#62;code&#45;&#62;base.data #define code_end (interp&#45;&#62;code&#45;&#62;base.data + interp&#45;&#62;code&#45;&#62;base.size)</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CAN_RETURN_NULL static opcode_t * runops_trace_core(PARROT_INTERP,
NOTNULL(opcode_t *pc)) { static size_t dod,
gc; Arenas * const arena_base = interp&#45;&#62;arena_base; Interp *debugger; PMC* pio;</p>

<pre lang='und' xml:lang='und'>    dod = arena_base&#45;&#62;dod_runs;
    gc = arena_base&#45;&#62;collect_runs;
    if (!interp&#45;&#62;debugger) {
        PMC *pio;

        debugger = interp&#45;&#62;debugger =
            /*
             * using a distinct interpreter for tracing should be ok
             * &#45; just in case, make it easy to switch
             */
#if 1
            make_interpreter(interp, 0);
#else
            interp;
#endif
        debugger&#45;&#62;lo_var_ptr = interp&#45;&#62;lo_var_ptr;
        pio = PIO_STDERR(debugger);
        if (PIO_isatty(debugger, pio))
            PIO_setlinebuf(debugger, pio);
        else {
            /* this is essential (100 x faster!)  and should probably
             * be in init/open code */
            PIO_setbuf(debugger, pio, 8192);
        }
    }
    else
        debugger = interp&#45;&#62;debugger;
    trace_op(interp, code_start, code_end, pc);
    while (pc) {
        if (pc &#60; code_start || pc &#62;= code_end) {
            real_exception(interp, NULL, 1,
                    &#34;attempt to access code outside of current code segment&#34;);
        }
        CONTEXT(interp&#45;&#62;ctx)&#45;&#62;current_pc = pc;

        DO_OP(pc, interp);
        trace_op(interp, code_start, code_end, pc);
        if (dod != arena_base&#45;&#62;dod_runs) {
            dod = arena_base&#45;&#62;dod_runs;
            PIO_eprintf(debugger, &#34;       DOD\n&#34;);
        }
        if (gc != arena_base&#45;&#62;collect_runs) {
            gc = arena_base&#45;&#62;collect_runs;
            PIO_eprintf(debugger, &#34;       GC\n&#34;);
        }
    }
    pio = PIO_STDERR(debugger);
    PIO_flush(debugger, pio);

    return pc;
}</pre>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CAN_RETURN_NULL opcode_t * runops_slow_core(PARROT_INTERP, NOTNULL(opcode_t *pc)) {</p>

<pre lang='und' xml:lang='und'>    if (Interp_trace_TEST(interp, PARROT_TRACE_OPS_FLAG)) {
        return runops_trace_core(interp, pc);
    }
    else if (interp&#45;&#62;debugger &#38;&#38; interp&#45;&#62;debugger&#45;&#62;pdb) {
        return Parrot_debug(interp&#45;&#62;debugger, pc);
    }
    while (pc) {
        if (pc &#60; code_start || pc &#62;= code_end) {
            real_exception(interp, NULL, 1,
                    &#34;attempt to access code outside of current code segment&#34;);
        }
        CONTEXT(interp&#45;&#62;ctx)&#45;&#62;current_pc = pc;

        DO_OP(pc, interp);
    }
#undef code_start
#undef code_end
    return pc;
}</pre>

<p>/*</p>

<p>FUNCDOC: runops_profile_core</p>

<p>Runs the Parrot operations starting at <code lang='und' xml:lang='und'>pc</code> until there are no more operations, with tracing, bounds checking and profiling enabled.</p>

<p>*/</p>

<p>PARROT_WARN_UNUSED_RESULT PARROT_CAN_RETURN_NULL opcode_t * runops_profile_core(PARROT_INTERP, NOTNULL(opcode_t *pc)) { opcode_t cur_op; RunProfile * const profile = interp&#45;&#62;profile;</p>

<pre lang='und' xml:lang='und'>    const opcode_t old_op = profile&#45;&#62;cur_op;
    /*
     * if we are reentering the runloop:
     * &#45; remember old op and calc time till now
     */
    if (old_op) {
        profile&#45;&#62;data[old_op].time +=
            Parrot_floatval_time() &#45; profile&#45;&#62;starttime;
    }

    while (pc) {/* &#38;&#38; pc &#62;= code_start &#38;&#38; pc &#60; code_end) */
        CONTEXT(interp&#45;&#62;ctx)&#45;&#62;current_pc = pc;
        profile&#45;&#62;cur_op = cur_op = *pc + PARROT_PROF_EXTRA;
        profile&#45;&#62;data[cur_op].numcalls++;
        profile&#45;&#62;starttime = Parrot_floatval_time();

        DO_OP(pc, interp);

        /* profile&#45;&#62;cur_op may be different, if exception was thrown */
        profile&#45;&#62;data[profile&#45;&#62;cur_op].time +=
            Parrot_floatval_time() &#45; profile&#45;&#62;starttime;
    }
    if (old_op) {
        /* old opcode continues */
        profile&#45;&#62;starttime = Parrot_floatval_time();
        profile&#45;&#62;cur_op = old_op;
    }
    return pc;
}</pre>

<p>/* * Local variables: * c&#45;file&#45;style: &#34;parrot&#34; * End: * vim: expandtab shiftwidth=4: */</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
