<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>compilers/imcc/reg_alloc.c</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">compilers/imcc/reg_alloc.c</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../html/index.html">Contents</a> | <a href="../../../html/compilers.html">Compilers</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>compilers/imcc/reg_alloc.c</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Register allocator:</p>

<p>This is a brute force register allocator.
It uses a graph&#45;coloring algorithm,
but the implementation is very kludgy.</p>

<p>It is a partial implementation of a Briggs&#45;style register allocator The following parts are just missing:</p>

<pre lang='und' xml:lang='und'> &#45; Renumbering
 &#45; Coaelesceing</pre>

<h2><a name="Functions"
>Functions <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a
><b><code lang='und' xml:lang='und'>PARROT_CANNOT_RETURN_NULL static unsigned int *ig_get_word(int i, int j, int N, NOTNULL(unsigned int *graph), NOTNULL(int *bit_ofs))</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_void_ig_set(int_i,_int_j,_int_N,_NOTNULL(unsigned_int_*graph))"
><b><code lang='und' xml:lang='und'>static void ig_set(int i, int j, int N, NOTNULL(unsigned int *graph))</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="int_ig_test(int_i,_int_j,_int_N,_NOTNULL(unsigned_int_*graph))"
><b><code lang='und' xml:lang='und'>int ig_test(int i, int j, int N, NOTNULL(unsigned int *graph))</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="PARROT_CANNOT_RETURN_NULL_static_unsigned_int*_ig_allocate(int_N)"
><b><code lang='und' xml:lang='und'>PARROT_CANNOT_RETURN_NULL static unsigned int *ig_allocate(int N)</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="void_imc_reg_alloc(PARROT_INTERP,_NULLOK(IMC_Unit_*unit))"
><b><code lang='und' xml:lang='und'>void imc_reg_alloc(PARROT_INTERP, NULLOK(IMC_Unit *unit))</b></code></a></dt><p class="pad"></p>

<dd>imc_reg_alloc is the main loop of the allocation algorithm. It operates on a single compilation unit at a time.</dd><p class="pad"></p>

<dt><a name="void_free_reglist(NOTNULL(IMC_Unit_*unit))"
><b><code lang='und' xml:lang='und'>void free_reglist(NOTNULL(IMC_Unit *unit))</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="void_graph_coloring_reg_alloc(PARROT_INTERP,_NOTNULL(IMC_Unit_*unit))"
><b><code lang='und' xml:lang='und'>void graph_coloring_reg_alloc(PARROT_INTERP, NOTNULL(IMC_Unit *unit))</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_void_make_stat(NOTNULL(IMC_Unit_*unit),_NULLOK(int_*sets),_NULLOK(int_*cols))"
><b><code lang='und' xml:lang='und'>static void make_stat(NOTNULL(IMC_Unit *unit), NULLOK(int *sets), NULLOK(int *cols))</b></code></a></dt><p class="pad"></p>

<dd>some statistics about register usage printed with &#45;&#45;verbose &#45;&#45;verbose</dd><p class="pad"></p>

<dt><a name="static_void_imc_stat_init(NOTNULL(IMC_Unit_*unit))"
><b><code lang='und' xml:lang='und'>static void imc_stat_init(NOTNULL(IMC_Unit *unit))</b></code></a></dt><p class="pad"></p>

<dd>registes usage of .pir</dd><p class="pad"></p>

<dt><a name="static_void_print_stat(PARROT_INTERP,_NOTNULL(IMC_Unit_*unit))"
><b><code lang='und' xml:lang='und'>static void print_stat(PARROT_INTERP, NOTNULL(IMC_Unit *unit))</b></code></a></dt><p class="pad"></p>

<dd>and final</dd><p class="pad"></p>

<dt><a name="static_int_reg_sort_f(ARGIN(const_void_*a),_ARGIN(const_void_*b))"
><b><code lang='und' xml:lang='und'>static int reg_sort_f(ARGIN(const void *a), ARGIN(const void *b))</b></code></a></dt><p class="pad"></p>

<dd>sort list by line nr</dd><p class="pad"></p>

<dt><a name="static_void_sort_reglist(NOTNULL(IMC_Unit_*unit))"
><b><code lang='und' xml:lang='und'>static void sort_reglist(NOTNULL(IMC_Unit *unit))</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_void_build_reglist(Parrot_Interp_interp,_NOTNULL(IMC_Unit_*unit))"
><b><code lang='und' xml:lang='und'>static void build_reglist(Parrot_Interp interp, NOTNULL(IMC_Unit *unit))</b></code></a></dt><p class="pad"></p>

<dd>make a linear list of IDENTs and VARs, set n_symbols TODO split the whole life analysis into 4, one per register kind registers of different kind never interfere, but the reglist has them all</dd><p class="pad"></p>

<dd>Registers are now sorted according to the line on which their usage starts, which means that they are sorted by basic block numbers too.</dd><p class="pad"></p>

<dd>Run through them and allocate all that don&#39;t overlap in one bunch.</dd><p class="pad"></p>

<dt><a name="static_void_rebuild_reglist(NOTNULL(IMC_Unit_*unit))"
><b><code lang='und' xml:lang='und'>static void rebuild_reglist(NOTNULL(IMC_Unit *unit))</b></code></a></dt><p class="pad"></p>

<dd>Exclude all already allocated registers (&#60; first_avail) from reglist. This reduced the size of the interference graph significantly</dd><p class="pad"></p>

<dt><a name="static_void_build_interference_graph(PARROT_INTERP,_NOTNULL(IMC_Unit_*unit))"
><b><code lang='und' xml:lang='und'>static void build_interference_graph(PARROT_INTERP, NOTNULL(IMC_Unit *unit))</b></code></a></dt><p class="pad"></p>

<dd>Creates the interference graph between the variables.</dd><p class="pad"></p>

<dd>Data structure is a 2&#45;d array &#39;interference_graph&#39; bitmap where row/column indices represent the same index in the list of all symbols (unit&#45;&#62;reglist) in the current compilation unit.</dd><p class="pad"></p>

<dd>Two variables interfere when they are alive at the same time.</dd><p class="pad"></p>

<dt><a name="static_void_compute_du_chain(NOTNULL(IMC_Unit_*unit))"
><b><code lang='und' xml:lang='und'>static void compute_du_chain(NOTNULL(IMC_Unit *unit))</b></code></a></dt><p class="pad"></p>

<dd>Compute a DU&#45;chain for each symbolic in a compilation unit</dd><p class="pad"></p>

<dt><a name="static_void_compute_one_du_chain(NOTNULL(SymReg_*r),_NOTNULL(IMC_Unit_*unit))"
><b><code lang='und' xml:lang='und'>static void compute_one_du_chain(NOTNULL(SymReg *r), NOTNULL(IMC_Unit *unit))</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>static int interferes(PARROT_INTERP, NOTNULL(IMC_Unit *unit), NOTNULL(SymReg *r0), NOTNULL(SymReg *r1))</b></code></a></dt><p class="pad"></p>

<dd>See if r0&#39;s chain interferes with r1.</dd><p class="pad"></p>

<dd>We currently decide that two vars interfere if they are both alive at any point. This could be improved, requiring that one is alive at the point of _definition_ of the other.</dd><p class="pad"></p>

<dt><a name="static_int_ig_find_color(ARGIN(const_IMC_Unit_*unit),_ARGIN(const_char_*avail))"
><b><code lang='und' xml:lang='und'>static int ig_find_color(ARGIN(const IMC_Unit *unit), ARGIN(const char *avail))</b></code></a></dt><p class="pad"></p>

<dd>find available color for register #x in available colors</dd><p class="pad"></p>

<dt><a name="static_int_try_allocate(PARROT_INTERP,_NOTNULL(IMC_Unit_*unit))"
><b><code lang='und' xml:lang='und'>static int try_allocate(PARROT_INTERP, NOTNULL(IMC_Unit *unit))</b></code></a></dt><p class="pad"></p>

<dd>Color the graph, assigning registers to each symbol:</dd><p class="pad"></p>

<dd>We just proceed popping items from the stack and assigning a free color to them.</dd><p class="pad"></p>

<dd>If we run out of colors, then we need to spill the top node.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>static void map_colors(NOTNULL(IMC_Unit *unit), int x, NOTNULL(unsigned int *graph), NOTNULL(char *avail), int typ, int already_allocated)</b></code></a></dt><p class="pad"></p>

<dd>map_colors: calculates what colors can be assigned to the x&#45;th symbol.</dd><p class="pad"></p>

<dt><a name="static_int_first_avail(NOTNULL(IMC_Unit_*unit),_int_reg_set,_NULLOK(Set_**avail))"
><b><code lang='und' xml:lang='und'>static int first_avail(NOTNULL(IMC_Unit *unit), int reg_set, NULLOK(Set **avail))</b></code></a></dt><p class="pad"></p>

<dd>find first available register of the given reg_set</dd><p class="pad"></p>

<dt><a name="static_void_allocate_uniq(PARROT_INTERP,_NOTNULL(IMC_Unit_*unit),_int_usage)"
><b><code lang='und' xml:lang='und'>static void allocate_uniq(PARROT_INTERP, NOTNULL(IMC_Unit *unit), int usage)</b></code></a></dt><p class="pad"></p>

<dd>allocate lexicals or non&#45;volatile in ascending order</dd><p class="pad"></p>

<dt><a name="static_void_vanilla_reg_alloc(SHIM_INTERP,_NOTNULL(IMC_Unit_*unit))"
><b><code lang='und' xml:lang='und'>static void vanilla_reg_alloc(SHIM_INTERP, NOTNULL(IMC_Unit *unit))</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_void_allocate_lexicals(PARROT_INTERP,_NOTNULL(IMC_Unit_*unit))"
><b><code lang='und' xml:lang='und'>static void allocate_lexicals(PARROT_INTERP, NOTNULL(IMC_Unit *unit))</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_void_allocate_non_volatile(PARROT_INTERP,_NOTNULL(IMC_Unit_*unit))"
><b><code lang='und' xml:lang='und'>static void allocate_non_volatile(PARROT_INTERP, NOTNULL(IMC_Unit *unit))</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>
</dl>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../resources/parrot_small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
