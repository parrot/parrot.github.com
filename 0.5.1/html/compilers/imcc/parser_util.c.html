<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>compilers/imcc/parser_util.c</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">compilers/imcc/parser_util.c</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../html/index.html">Contents</a> | <a href="../../../html/compilers.html">Compilers</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>compilers/imcc/parser_util.c</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>ParserUtil &#45; Parser support functions.</p>

<h2><a name="Functions"
>Functions <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a
><b><code lang='und' xml:lang='und'>PARROT_WARN_UNUSED_RESULT PARROT_CAN_RETURN_NULL Instruction *iNEW(PARROT_INTERP, NOTNULL(IMC_Unit *unit), NOTNULL(SymReg *r0), NOTNULL(char *type), NULLOK(SymReg *init), int emit)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'> * P = new type, [init]
 * PASM like:
 *   new P, .SomeThing
 * is done in the lexer, this is a mess
 * best would be to have a flag in core.ops, where a PMC type is expected</pre>

<dt><a
><b><code lang='und' xml:lang='und'>void op_fullname(NOTNULL(char *dest), ARGIN(const char *name), NOTNULL(SymReg *args[]), int narg, int keyvec)</b></code></a></dt><p class="pad"></p>

<dd>Lookup the full opcode given the short name</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>   set I0, 5  &#45;&#62; set_i_ic
   set I0, I1 &#45;&#62; set_i_i</pre>

<dd>Obviously the registers must be examined before returning the correct opcode.</dd><p class="pad"></p>

<dd>NOTE: All this nasty IMC_TRACE is for tracking down equally nasty bugs, so if you don&#39;t like the looks of it, stay out, but please don&#39;t remove it. :) &#45;Mel</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_WARN_UNUSED_RESULT int check_op(PARROT_INTERP, NOTNULL(char *fullname), ARGIN(const char *name), NOTNULL(SymReg *r[]), int narg, int keyvec)</b></code></a></dt><p class="pad"></p>

<dd>Return opcode value for op name</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_WARN_UNUSED_RESULT PARROT_CAN_RETURN_NULL static Instruction *maybe_builtin(PARROT_INTERP, ARGIN(const char *name), NOTNULL(SymReg **r), int n)</b></code></a></dt><p class="pad"></p>

<dd>TODO: Needs to be documented!!!</dd><p class="pad"></p>

<dt><a name="PARROT_WARN_UNUSED_RESULT_int_is_op(PARROT_INTERP,_ARGIN(const_char_*name))"
><b><code lang='und' xml:lang='und'>PARROT_WARN_UNUSED_RESULT int is_op(PARROT_INTERP, ARGIN(const char *name))</b></code></a></dt><p class="pad"></p>

<dd>Is instruction a parrot opcode?</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL static const char *to_infix(PARROT_INTERP, ARGIN(const char *name), NOTNULL(SymReg **r), NOTNULL(int *n), int mmd_op)</b></code></a></dt><p class="pad"></p>

<dd>sub x, y, z =&#62; infix .MMD_SUBTRACT, x, y, z</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_WARN_UNUSED_RESULT static int is_infix(ARGIN(const char *name), int n, NOTNULL(SymReg **r))</b></code></a></dt><p class="pad"></p>

<dd>TODO: Needs to be documented!!!</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_MALLOC PARROT_CANNOT_RETURN_NULL PARROT_WARN_UNUSED_RESULT static Instruction *var_arg_ins(PARROT_INTERP, NOTNULL(IMC_Unit *unit), ARGIN(const char *name), NOTNULL(SymReg **r), int n, int emit)</b></code></a></dt><p class="pad"></p>

<dd>TODO: Needs to be documented!!!</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_CAN_RETURN_NULL Instruction *INS(PARROT_INTERP, NOTNULL(IMC_Unit *unit), ARGIN(const char *name), ARGIN_NULLOK(const char *fmt), NOTNULL(SymReg **r), int n, int keyvec, int emit)</b></code></a></dt><p class="pad"></p>

<dd>Make an instruction.</dd><p class="pad"></p>

<dd>name ... op name fmt ... optional format regs ... SymReg ** n ... # of params keyvec ... s. KEY_BIT() emit ... if true, append to instructions</dd><p class="pad"></p>

<dd>s. e.g. imc.c for usage</dd><p class="pad"></p>

<dt><a name="PARROT_API_int_do_yylex_init(PARROT_INTERP,_NOTNULL(yyscan_t*_yyscanner))"
><b><code lang='und' xml:lang='und'>PARROT_API int do_yylex_init(PARROT_INTERP, NOTNULL(yyscan_t *yyscanner))</b></code></a></dt><p class="pad"></p>

<dd>TODO: Needs to be documented!!!</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL PMC *imcc_compile(PARROT_INTERP, ARGIN(const char *s), int pasm_file, NOTNULL(STRING **error_message))</b></code></a></dt><p class="pad"></p>

<dd>Compile a pasm or imcc string</dd><p class="pad"></p>

<dd>FIXME as we have separate constants, the old constants in ghash must be deleted.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL PMC *imcc_compile_pasm(PARROT_INTERP, ARGIN(const char *s))</b></code></a></dt><p class="pad"></p>

<dd>TODO: Needs to be documented!!!</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'> * Note: This function is provided for backward compatibility. This
 * function can go away in future.</pre>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL PMC *imcc_compile_pir(PARROT_INTERP, ARGIN(const char *s))</b></code></a></dt><p class="pad"></p>

<dd>TODO: Needs to be documented!!!</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'> * Note: This function is provided for backward compatibility. This
 * function can go away in future.</pre>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL PMC *IMCC_compile_pir_s(PARROT_INTERP, ARGIN(const char *s), NOTNULL(STRING **error_message))</b></code></a></dt><p class="pad"></p>

<dd>TODO: Needs to be documented!!!</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL PMC *IMCC_compile_pasm_s(PARROT_INTERP, ARGIN(const char *s), NOTNULL(STRING **error_message))</b></code></a></dt><p class="pad"></p>

<dd>TODO: Needs to be documented!!!</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL PMC *imcc_compile_pasm_ex(PARROT_INTERP, ARGIN(const char *s))</b></code></a></dt><p class="pad"></p>

<dd>TODO: Needs to be documented!!!</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL PMC *imcc_compile_pir_ex(PARROT_INTERP, ARGIN(const char *s))</b></code></a></dt><p class="pad"></p>

<dd>TODO: Needs to be documented!!!</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_CANNOT_RETURN_NULL static void *imcc_compile_file(PARROT_INTERP, ARGIN(const char *fullname), NOTNULL(STRING **error_message))</b></code></a></dt><p class="pad"></p>

<dd>Compile a file by filename (can be either PASM or IMCC code)</dd><p class="pad"></p>

<dt><a name="PARROT_CANNOT_RETURN_NULL_void_*_IMCC_compile_file(PARROT_INTERP,_ARGIN(const_char_*s))"
><b><code lang='und' xml:lang='und'>PARROT_CANNOT_RETURN_NULL void *IMCC_compile_file(PARROT_INTERP, ARGIN(const char *s))</b></code></a></dt><p class="pad"></p>

<dd>TODO: Needs to be documented!!!</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'> * Note: This function is provided for backward compatibility. This
 * function can go away in future.</pre>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_CANNOT_RETURN_NULL void *IMCC_compile_file_s(PARROT_INTERP, ARGIN(const char *s), NOTNULL(STRING **error_message))</b></code></a></dt><p class="pad"></p>

<dd>TODO: Needs to be documented!!!</dd><p class="pad"></p>

<dt><a name="void_register_compilers(PARROT_INTERP)"
><b><code lang='und' xml:lang='und'>void register_compilers(PARROT_INTERP)</b></code></a></dt><p class="pad"></p>

<dd>Register additional compilers with the interpreter</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_WARN_UNUSED_RESULT static int change_op(PARROT_INTERP, NOTNULL(IMC_Unit *unit), NOTNULL(SymReg **r), int num, int emit)</b></code></a></dt><p class="pad"></p>

<dd>TODO: Needs to be documented!!!</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_WARN_UNUSED_RESULT int try_find_op(PARROT_INTERP, NOTNULL(IMC_Unit *unit), ARGIN(const char *name), NOTNULL(SymReg **r), int n, int keyvec, int emit)</b></code></a></dt><p class="pad"></p>

<dd>Try to find valid op doing the same operation e.g.</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>   add_n_i_n =&#62; add_n_n_i
   div_n_ic_n =&#62; div_n_nc_n
   div_n_i_n =&#62; set_n_i ; div_n_n_n
   ge_n_ic_ic =&#62; ge_n_nc_ic
   acos_n_i   =&#62; acos_n_n</pre>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_WARN_UNUSED_RESULT PARROT_CAN_RETURN_NULL static const char *try_rev_cmp(ARGIN(const char *name), NOTNULL(SymReg **r))</b></code></a></dt><p class="pad"></p>

<dd>TODO: Needs to be documented!!!</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_CAN_RETURN_NULL Instruction *multi_keyed(PARROT_INTERP, NOTNULL(IMC_Unit *unit), NOTNULL(char *name), NOTNULL(SymReg **r), int nr, int keyvec, int emit)</b></code></a></dt><p class="pad"></p>

<dd>TODO: Needs to be documented!!!</dd><p class="pad"></p>

<dt><a name="int_imcc_fprintf(PARROT_INTERP,_NOTNULL(FILE_*fd),_ARGIN(const_char_*fmt),_...)"
><b><code lang='und' xml:lang='und'>int imcc_fprintf(PARROT_INTERP, NOTNULL(FILE *fd), ARGIN(const char *fmt), ...)</b></code></a></dt><p class="pad"></p>

<dd>TODO: Needs to be documented!!!</dd><p class="pad"></p>

<dt><a name="int_imcc_vfprintf(PARROT_INTERP,_NOTNULL(FILE_*fd),_ARGIN(const_char_*format),_va_list_ap)"
><b><code lang='und' xml:lang='und'>int imcc_vfprintf(PARROT_INTERP, NOTNULL(FILE *fd), ARGIN(const char *format), va_list ap)</b></code></a></dt><p class="pad"></p>

<dd>TODO: Needs to be documented!!!</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_MALLOC PARROT_WARN_UNUSED_RESULT PARROT_CANNOT_RETURN_NULL char *str_dup(ARGIN(const char *old))</b></code></a></dt><p class="pad"></p>

<dd>TODO: Needs to be documented!!!</dd><p class="pad"></p>

<dt><a name="PARROT_API_void_imcc_init(PARROT_INTERP)"
><b><code lang='und' xml:lang='und'>PARROT_API void imcc_init(PARROT_INTERP)</b></code></a></dt><p class="pad"></p>

<dd>TODO: Needs to be documented!!!</dd><p class="pad"></p>

<dt><a name="PARROT_API_void_imcc_destroy(PARROT_INTERP)"
><b><code lang='und' xml:lang='und'>PARROT_API void imcc_destroy(PARROT_INTERP)</b></code></a></dt><p class="pad"></p>

<dd>TODO: Needs to be documented!!!</dd><p class="pad"></p>
</dl>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../resources/parrot_small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
