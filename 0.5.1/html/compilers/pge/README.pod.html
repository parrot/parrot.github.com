<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Untitled</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Untitled</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../html/index.html">Contents</a> | <a href="../../../html/compilers.html">Compilers</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="Parrot_Grammar_Engine_(PGE)"
>Parrot Grammar Engine (PGE) <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>This is a regular expression/rules/grammar engine/parser designed to run in Parrot.
It&#39;s still a work in progress,
but has a lot of nice features in it,
including support for perl 6 regexes,
globs,
shift&#45;reduce parsing,
and some support for perl 5 regular expressions.
It also includes the &#34;pgc.pir&#34; grammar compiler,
which can convert an entire grammar specification into the appropriate PIR code for execution.</p>

<p>A nice feature of PGE is that one can easily combine many different parsing styles into a single interface.
PGE uses perl 6 rules for its top&#45;down parsing,
an operator precedence parser for bottom&#45;up (shift/reduce) parsing,
and allows control to pass freely between the two styles as well as to custom parsing subroutines.</p>

<h1><a name="Installation"
>Installation <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>PGE assumes that it is part of the parrot distribution in the <em lang='und' xml:lang='und'>compilers/pge</em> directory.
Simply type <code lang='und' xml:lang='und'>make</code> in this directory to build the various *.pbc files and install them into runtime/parrot/library.</p>

<p>The distribution comes with a small <em lang='und' xml:lang='und'>demo.pir</em> program that gives an example of using PGE.
To run the demo,
simply do <code lang='und' xml:lang='und'>parrot demo.pir</code>.
The demo understands the following commands:</p>

<pre lang='und' xml:lang='und'>    rule pattern      &#45; compile a Perl 6 rule from &#34;pattern&#34;
    save name         &#45; save the current rule as &#34;name&#34;
    text              &#45; a text string to match against previously entered rule
    pir               &#45; display the PIR code generated for current rule
    exp               &#45; display the expression tree for the current rule
    trace             &#45; toggle pattern execution tracing
    next              &#45; repeat last match on target string</pre>

<h1><a name="PGE&#39;s_rule_engine_(PGE::P6Regex)"
>PGE&#39;s rule engine (PGE::P6Regex) <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Once PGE is compiled and installed, you generally load it using the load_bytecode operation, as in</p>

<pre lang='und' xml:lang='und'>    load_bytecode &#39;PGE.pbc&#39;</pre>

<p>This imports the PGE::P6Regex compiler, which can be used to compile strings of Perl 6 rules. A sample compile sequence would be:</p>

<pre lang='und' xml:lang='und'>    .local pmc p6regex_compile
    p6regex_compile = compreg &#39;PGE::P6Regex&#39;         # get the compiler

    .local string pattern
    .local pmc rulesub
    pattern = &#39;^(From|Subject)\:&#39;                  # pattern to compile
    rulesub = p6regex_compile(pattern)             # compile it to rulesub</pre>

<p>Then, to match a target string we simply call the subroutine to get back a <code lang='und' xml:lang='und'>PGE::Match</code> object:</p>

<pre lang='und' xml:lang='und'>    .local pmc match
    $S0 = &#39;From: pmichaud@pobox.com&#39;               # target string
    match = rulesub($S0)                           # execute rule</pre>

<p>The Match object is true if it successfully matched, and contains the strings and subpatterns that were matched as part of the capture. Parrot&#39;s &#34;Data::Dumper&#34; can be used to quickly view the results of the match:</p>

<pre lang='und' xml:lang='und'>    load_bytecode &#39;dumper.pir&#39;
    load_bytecode &#39;PGE/Dumper.pir&#39;

  match_loop:
    unless match goto match_fail                   # if match fails stop
    print &#34;match succeeded\n&#34;
    _dumper(match)
    match.&#39;next&#39;()                                 # find the next match
    goto match_loop

  match_fail:
    print &#34;match failed\n&#34;</pre>

<p>One can also get the intermediate PIR code that PGE generates for the rule subroutine &#45;&#45; just use</p>

<pre lang='und' xml:lang='und'>    $S0 = p6regex_compile(pattern, &#39;target&#39;=&#62;&#39;PIR&#39;)</pre>

<p>and you can print/inspect the contents of $S0 to see the generated code.</p>

<p>See the STATUS file for a list of implemented and yet&#45;to&#45;be&#45;implemented features.</p>

<h1><a name="Known_limitations_of_the_rule_engine"
>Known limitations of the rule engine <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>PGE doesn&#39;t (yet) properly handle nested repetitions of zero&#45;length patterns in groups &#45;&#45; that&#39;s coming soon.</p>

<p>Many well&#45;known optimizations (e.g., Boyer&#45;Moore) aren&#39;t implemented yet, although a variety of optimizations are being added as we generate code.</p>

<p>Lastly, error handling needs to be improved, but this will likely be decided as we discover how PGE integrates with the rest of Parrot.</p>

<h1><a name="Implementation_notes"
>Implementation notes <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Basically, PGE is a compiler just like any other, except that its &#34;language&#34; is the Perl 6 regex syntax and its output is a subroutine that can match strings. So, PGE consists of a series of parsers (for each pattern matching language), an intermediate expression format, and a code generator.</p>

<p>The parsers can be written using PIR subroutines or PGE&#39;s built&#45;in operator precedence (shift/reduce) parser; the parser for Perl 6 regexes is built with the operator precedence parser. This parser produces a parse tree (in the form of a Match object) for a given Perl 6 regex. The parse tree then goes through semantic analysis and reduction phases before being sent to code generation to produce a PIR subroutine.</p>

<p>The generated PIR code uses bsr/ret for its internal backtracking (optimized for tailcalls) and uses Parrot calling conventions for all interfaces with external callers/callees such as subrules.</p>

<p>PGE also uses Parrot coroutines for the matching engine, so that after a successful match is found, the next match within the same string can be found by simply returning control to the matching coroutine, which then picks up from where it had previously left off until another match is discovered.</p>

<p>The code still needs a fair amount of commenting. In general, if you have a question about a particular section of code, send Pm an email and he&#39;ll write the comments for it.</p>

<h1><a name="AUTHOR"
>AUTHOR <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Patrick Michaud (pmichaud@pobox.com) is the author and maintainer. Patches and suggestions should be sent to the Perl 6 compiler list (perl6&#45;compiler@perl.org).</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../resources/parrot_small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
