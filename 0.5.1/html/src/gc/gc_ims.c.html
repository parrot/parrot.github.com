<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Incremental mark and sweep garbage collection</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Incremental mark and sweep garbage collection</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../html/index.html">Contents</a> | <a href="../../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>src/gc/gc_ims.c &#45; Incremental mark and sweep garbage collection</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>The following comments describe a new garbage collection scheme for Parrot.</p>

<p>The scheme of this algorithm is described in the literature with these keywords:</p>

<pre lang='und' xml:lang='und'> &#45; non&#45;copying, mark &#38; sweep
 &#45; incremental
 &#45; realtime
 &#45; incremental update with write barrier</pre>

<p>Further we might try this optimization</p>

<pre lang='und' xml:lang='und'> &#45; treadmill optimization or
 &#45; implict reclamation</pre>

<h1><a name="Drawbacks_of_the_current_mark_and_sweep_collector."
>Drawbacks of the current mark and sweep collector. <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<pre lang='und' xml:lang='und'> * can take arbitrary time to complete (1s for 1 Meg objects)
 * can&#39;t be used in multi&#45;threaded Parrot
 * works fast for plain (non&#45;aggregate) objects but suffers badly
   for nested aggregates or HLL objects
 * the sweep phase takes time proportional to the allocated storage</pre>

<h1><a name="INCREMENTAL_GARBAGE_COLLECTION"
>INCREMENTAL GARBAGE COLLECTION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<h2><a name="Terms"
>Terms <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="object"
>object</a></dt><p class="pad"></p>

<dd>An item like a buffer header or a PMC which is managed by Parrot&#39;s dynamic memory system.</dd><p class="pad"></p>

<dt><a name="aggregate"
>aggregate</a></dt><p class="pad"></p>

<dd>An object that possibly holds references to other objects. For example an array, hash, or reference PMC.</dd><p class="pad"></p>

<dt><a name="tri&#45;color_marking"
>tri&#45;color marking</a></dt><p class="pad"></p>

<dd>All objects have one of three colors: white, grey, or black.</dd><p class="pad"></p>

<dd>At the beginning of a DOD run all objects are white (not yet visited). During marking objects are greyed (visited &#45; found alive), but their contents isn&#39;t yet scanned. A fully scanned grey object gets finally colored black. It will not again be rescanned in this DOD run.</dd><p class="pad"></p>

<dd>Only aggregates can be grey, non&#45;containers are blackened immediately.</dd><p class="pad"></p>

<dd>Objects on the free&#45;list are sometimes denoted having the color off&#45;white or ecru.</dd><p class="pad"></p>

<dt><a name="DOD"
>DOD</a></dt><p class="pad"></p>

<dd>Dead object detection. Please note that in Parrot src and docs this stands for the stop&#45;the&#45;world garbage collector that recycles objects.</dd><p class="pad"></p>

<dt><a name="GC"
>GC</a></dt><p class="pad"></p>

<dd>In Parrot tree the copying garbage collector that recycles string and buffer memory. Configure.pl has a switch to use a malloc library instead, which makes string and buffer memory non&#45;moving.</dd><p class="pad"></p>

<dt><a name="collector"
>collector</a></dt><p class="pad"></p>

<dd>The DOD and reclamation system.</dd><p class="pad"></p>

<dt><a name="mutator"
>mutator</a></dt><p class="pad"></p>

<dd>The normal operation of the program which may or may not change the collectors view of objects.</dd><p class="pad"></p>

<dt><a name="incremental"
>incremental</a></dt><p class="pad"></p>

<dd>Garbage collection and normal program operation is interleaved. This guarantees short and bounded pause times. Garbage collection doesn&#39;t significantly interrupt program execution, collector and mutator are running pseudo&#45;parallel.</dd><p class="pad"></p>

<dt><a name="root_set"
>root set</a></dt><p class="pad"></p>

<dd>All structures in the interpreter that might point to objects. E.g. stacks, globals, and of course the registers. All objects the interpreter works with, are directly or indirectly reachable starting from the root set.</dd><p class="pad"></p>

<dt><a name="the_tri&#45;color_invariant"
>the tri&#45;color invariant</a></dt><p class="pad"></p>

<dd>At no time a black object may reference a white one directly. Actually this is the strong incarnation of the invariant &#45; all paths from black objects to white objects lead over at least one grey object.</dd><p class="pad"></p>

<dd>The weak tri&#45;color invariant is: there is at least one such path to a white object, so that it&#39;s reachable.</dd><p class="pad"></p>

<dd>The strong invariant is the basic idea of mark and sweep too. But as the mutator isn&#39;t running during DOD the invariant is never violated.</dd><p class="pad"></p>

<dd>Due to this invariant, after the root set has been marked and when all greyed objects are marked (blackened), the white objects have to be dead.</dd><p class="pad"></p>

<dt><a name="paint_it_black"
>paint it black</a></dt><p class="pad"></p>

<dd>Or, which color do new objects have?</dd><p class="pad"></p>

<dd>Actually this should be tunable. Or it depends. If objects are born white and die immediately, they get collected in the same GC cycle. OTOH when these objects are stored into an existing (black) array, we have to do more work to keep the tri&#45;color invariant valid.</dd><p class="pad"></p>

<dd>Anyway, when allocating new objects white, the collector must run more often or must do more work per increment to make the algorithm stop somewhen.</dd><p class="pad"></p>

<dt><a name="write_barrier"
>write barrier</a></dt><p class="pad"></p>

<dd>To keep the tri&#45;color invariant valid all pointer stores into black objects have to be tracked. If a white object would be stored into a black array, and this object isn&#39;t refered to by another object it would get collected. The write barrier greys the white object, so that it get scanned later or alternatively greys the aggregate for a rescan. The latter can be better, if a sequence of such stores would happen.</dd><p class="pad"></p>
</dl>

<h2><a name="Data_structure_overview"
>Data structure overview <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>The incremental mark and sweep collector has an additional structure in the arena_base that keeps track of the collector&#39;s state. Pool and arena structures are unchanged. Only the allocation of new arena blocks is done much more fine grained in e.g. 8K blocks.</p>

<h2><a name="Implicit_reclamation_(optional)"
>Implicit reclamation (optional) <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="from&#45;space"
>from&#45;space</a></dt><p class="pad"></p>

<dd>The graph of all objects found live during the last collection.</dd><p class="pad"></p>

<dt><a name="to&#45;space"
>to&#45;space</a></dt><p class="pad"></p>

<dd>The work area of the collector. During marking live objects are &#34;moved&#34; from the from&#45;space into the to&#45;space. This is the same as the text_for_GC list used in src/dod.c. The to&#45;space is initially empty. During marking it gets greyed and finally all reachable objects are black.</dd><p class="pad"></p>

<dt><a name="free&#45;list"
>free&#45;list</a></dt><p class="pad"></p>

<dd>New objects are allocated from the free&#45;list. The free&#45;list is adjacent to the to&#45;space. Allocating a new objects thus means, moving the free pointer one word forward and paint the new object black.</dd><p class="pad"></p>
</dl>

<p>All objects get two additional pointers (forward, backward) and are arranged like in this scheme:</p>

<pre lang='und' xml:lang='und'>    &#60;&#45;&#45; allocation direction         marking &#45;&#45;&#62;
            |                          |
  [w] &#60;&#45;&#45;&#62; [w] &#60;&#45;&#45;&#62; [b] &#60;&#45;&#45;&#62; [b] &#60;&#45;&#45;&#62; [g] &#60;&#45;&#45;&#62; [g] &#60;&#45;&#45;&#62; [w] &#60;&#45;&#62; [w]

            ^        ^                 ^                 ^
            |        |                 |                 |
   free&#45;list&#45;ptr     to&#45;space          scan&#45;pointer      from&#45;space</pre>

<p>Objects get &#34;moved&#34; during collection by rearranging the doubly&#45;linked object pointers. At the end of a DOD run (when the last grey object is blackened), the from&#45;space and the free&#45;list are merged serving as the new free&#45;list of the next DOD cycle. This operation is just a few pointer manipulations that replaces the sweep phase of a mark and sweep collector.</p>

<h2><a name="Phases_of_operation"
>Phases of operation <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="a)_initialization"
>a) initialization</a></dt><p class="pad"></p>

<dd>After interpreter creation the DOD system is initialized by marking parts of the root set (globals, internal structures).</dd><p class="pad"></p>

<dt><a name="b)_program_operation"
>b) program operation</a></dt><p class="pad"></p>

<dd>For each bunch of allocated objects (A) the collector does k.A work, for some constant k &#62; 1. As new objects are allocated black the number of whites is reduced steadily. This means that the throttle factor k could be less then one too, but this could highly increase average memory usage.</dd><p class="pad"></p>

<dd>To keep the memory usage limited k &#62; 1 must hold.</dd><p class="pad"></p>

<dt><a name="c)_near_the_end_of_a_DOD_cycle"
>c) near the end of a DOD cycle</a></dt><p class="pad"></p>

<dd>The rest of the root set is scanned, i.e. the registers. By deferring scanning of registers all temporaries that might have exist somewhen just stay unscanned &#45; they will be collected in this DOD cycle, if we allocate new objects white or in the next DOD cycle.</dd><p class="pad"></p>

<dt><a name="d)_finishing_a_DOD_cycle"
>d) finishing a DOD cycle</a></dt><p class="pad"></p>

<dd>The current sweep of the whole arena is done, or with implicit reclamation:</dd><p class="pad"></p>

<dd>Garbage gets appended to the free&#45;list by merging the unscanned from&#45;space with the free&#45;list, these objects are all considered white. All other items are in the to&#45;space and are black. These objects constitute the from&#45;space of the new collection cycle.</dd><p class="pad"></p>

<dd>Now he meaning of the black bit is reversed effectively setting the new from&#45;space to white.</dd><p class="pad"></p>

<dd>The next DOD cycle is initialized in one step a) and the new cycle starts.</dd><p class="pad"></p>

<dd>Alternatively the mutator could run and allocate objects for some time, without starting the collector again, if there are plenty of free objects on all free&#45;lists.</dd><p class="pad"></p>

<dt><a name="e)_collect_buffer_memory"
>e) collect buffer memory</a></dt><p class="pad"></p>

<dd>Finally, we might trigger a collect run on string and buffer memory if there is an impending shortage of resources. While the copying compactor is rather independent of the collector that cleans object headers, it&#39;s more efficient to collect buffer memory when the live information is accurate. This avoids copying of dead buffer memory.</dd><p class="pad"></p>
</dl>

<h2><a name="Comparison_with_our_current_mark_and_sweep_collector"
>Comparison with our current mark and sweep collector <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<pre lang='und' xml:lang='und'>  MS  ... mark and sweep (stop&#45;the&#45;world)
  IMS ... incremental mark and sweep
  IMIR .. incremental mark implicit reclamation

                       MS                 IMS               IMIR
  &#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;
  operation            stop&#45;the&#45;world     incremental       incremental
  time per DOD cycle   unbounded          bounded           bounded
  size overhead        1 word             1 word            2 words
  time overhead        O(2*live + dead)   O(2*live + dead)  O(live)   2)</pre>

<p>Notes:</p>

<pre lang='und' xml:lang='und'>  2) it should be possible to mark containers at once by using the
     information of the from&#45;space pointers and tracking changes
     to the aggregate.</pre>

<h2><a name="Implementation_details_and_unsorted_remarks"
>Implementation details and unsorted remarks <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="the_object_graph"
>the object graph</a></dt><p class="pad"></p>

<dd>The MS and IMS scheme use the next_for_GC pointer for keeping track of references. This interferes with the freeze functionality, which can use the same pointer to keep track of visited objects.</dd><p class="pad"></p>

<dd>IMIR has a dedicated pointer pair to build the object graph.</dd><p class="pad"></p>

<dt><a name="Greying_objects"
>Greying objects</a></dt><p class="pad"></p>

<dd>Greying objects is done depth&#45;first. This has much better cache locality then visiting an object again much later. In the picture above this means that grey objects are inserted at the left end of the mark chain immediately to the right of the object that gets blackened.</dd><p class="pad"></p>

<dt><a name="big_aggregates"
>big aggregates</a></dt><p class="pad"></p>

<dd>Greying has to be done in increments. Big aggregates can&#39;t have a mark vtable that could run arbitrarily long. This means that the DOD system must know the layout of arrays, hashes, and objects. This is currently true for arrays and objects but not for hashes. But the latter need some refactoring of internals anyway.</dd><p class="pad"></p>

<dd>To avoid visiting all aggregate elements, it could be better to track the graph of old aggregates by using a write barrier for all writes into the array. This would basically create a generational collector. The old generation (the aggregate) isn&#39;t scanned. But changes to this &#34;old generation&#34; are tracked and reflected in the collectors graph of objects.</dd><p class="pad"></p>

<dt><a name="timely_destruction"
>timely destruction</a></dt><p class="pad"></p>

<dd>The interpreter arena has a count of currently active objects that need timely destruction. When during scope exit an high priority sweep is triggered, we have basically two cases:</dd><p class="pad"></p>

<dd>1) all of these objects were already seen by this DOD run &#45; the scope exit can continue.</dd><p class="pad"></p>

<dd>2) Not all objects were seen &#45; they might be alive or not. This means that the DOD cycle must run to the end to decide, if these objects are alive (or again until all are found alive).</dd><p class="pad"></p>

<dd>To increase performance its likely that we need some additional information that keeps track of the location of such objects and just try to mark paths to objects that need timely destruction.</dd><p class="pad"></p>

<dt><a name="concurrent_or_parallel_collection"
>concurrent or parallel collection</a></dt><p class="pad"></p>

<dd>As the described algorithm is already incremental its well&#45;suited for parallel collection in a multi&#45;threaded Parrot. The work of greying objects can be done in parallel by atomically handling a bunch of objects to another thread. After doing some increments of marking, these objects then get returned to the shared to&#45;space. The parallel collection is finished when the last object is blackened and all threads have reached the thread barrier rendezvous point. (Please note the very different meaning of barrier here).</dd><p class="pad"></p>

<dd>But also a single&#45;threaded Parrot can vastly take advantage by running increments of the collection during waiting for I/O completion or during a sleep opcode.</dd><p class="pad"></p>
</dl>

<h1><a name="FUNCTIONS"
>FUNCTIONS <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<dl>
<dt><a
><b><code lang='und' xml:lang='und'>static void gc_ims_add_free_object(PARROT_INTERP, NOTNULL(Small_Object_Pool *pool), NOTNULL(PObj *to_add))</b></code></a></dt><p class="pad"></p>

<dd>Add object <code lang='und' xml:lang='und'>to_add</code> to the free_list in the given pool. <code lang='und' xml:lang='und'>pool&#45;</code>num_free_objects&#62; has to be updated by the caller.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>PARROT_CANNOT_RETURN_NULL PARROT_WARN_UNUSED_RESULT static PObj *gc_ims_get_free_object(PARROT_INTERP, NOTNULL(Small_Object_Pool *pool))</b></code></a></dt><p class="pad"></p>

<dd>Get a new object off the free_list in the given pool.</dd><p class="pad"></p>

<dt><a name="static_void_gc_ims_alloc_objects(PARROT_INTERP,_NOTNULL(Small_Object_Pool_*pool))"
><b><code lang='und' xml:lang='und'>static void gc_ims_alloc_objects(PARROT_INTERP, NOTNULL(Small_Object_Pool *pool))</b></code></a></dt><p class="pad"></p>

<dd>Allocate new objects for the given pool.</dd><p class="pad"></p>

<dt><a name="static_void_gc_ims_pool_init(SHIM_INTERP,_NOTNULL(Small_Object_Pool_*pool))"
><b><code lang='und' xml:lang='und'>static void gc_ims_pool_init(SHIM_INTERP, NOTNULL(Small_Object_Pool *pool))</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_void_parrot_gc_ims_deinit(PARROT_INTERP)"
><b><code lang='und' xml:lang='und'>static void parrot_gc_ims_deinit(PARROT_INTERP)</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="void_Parrot_gc_ims_init(PARROT_INTERP)"
><b><code lang='und' xml:lang='und'>void Parrot_gc_ims_init(PARROT_INTERP)</b></code></a></dt><p class="pad"></p>

<dd>Initialize the state structures of the gc system. Called immediately before creation of memory pools. This function must set the function pointers for <code lang='und' xml:lang='und'>add_free_object_fn</code>, <code lang='und' xml:lang='und'>get_free_object_fn</code>, <code lang='und' xml:lang='und'>alloc_objects_fn</code>, and <code lang='und' xml:lang='und'>more_objects_fn</code>.</dd><p class="pad"></p>

<dt><a name="static_void_parrot_gc_ims_reinit(PARROT_INTERP)"
><b><code lang='und' xml:lang='und'>static void parrot_gc_ims_reinit(PARROT_INTERP)</b></code></a></dt><p class="pad"></p>

<dd>Reinitialize the collector for the next collection cycle.</dd><p class="pad"></p>

<dt><a name="static_void_parrot_gc_ims_mark(PARROT_INTERP)"
><b><code lang='und' xml:lang='und'>static void parrot_gc_ims_mark(PARROT_INTERP)</b></code></a></dt><p class="pad"></p>

<dd>Mark a bunch of children.</dd><p class="pad"></p>

<dd>The work depends on item counts with and without a next_for_GC field. The former are marked immediately, only the latter need real work here.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>static int sweep_cb(PARROT_INTERP, NOTNULL(Small_Object_Pool *pool), int flag, NOTNULL(void *arg))</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_void_parrot_gc_ims_sweep(PARROT_INTERP)"
><b><code lang='und' xml:lang='und'>static void parrot_gc_ims_sweep(PARROT_INTERP)</b></code></a></dt><p class="pad"></p>

<dd>Free unused objects in all header pools.</dd><p class="pad"></p>

<dd>TODO split work per pool.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>static int collect_cb(PARROT_INTERP, NOTNULL(Small_Object_Pool *pool), int flag, NOTNULL(void *arg))</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_int_parrot_gc_ims_collect(PARROT_INTERP,_int_check_only)"
><b><code lang='und' xml:lang='und'>static int parrot_gc_ims_collect(PARROT_INTERP, int check_only)</b></code></a></dt><p class="pad"></p>

<dd>Run the copying collector in memory pools, if it could yield some free memory.</dd><p class="pad"></p>

<dt><a name="static_void_parrot_gc_ims_run_increment(PARROT_INTERP)"
><b><code lang='und' xml:lang='und'>static void parrot_gc_ims_run_increment(PARROT_INTERP)</b></code></a></dt><p class="pad"></p>

<dd>Run one increment of collection. This function is triggered by object allocation.</dd><p class="pad"></p>

<dt><a name="static_void_parrot_gc_ims_run(PARROT_INTERP,_int_flags)"
><b><code lang='und' xml:lang='und'>static void parrot_gc_ims_run(PARROT_INTERP, int flags)</b></code></a></dt><p class="pad"></p>

<dd>Interface to <code lang='und' xml:lang='und'>Parrot_do_dod_run</code>. <code lang='und' xml:lang='und'>flags</code> is one of:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  DOD_lazy_FLAG   ... timely destruction
  DOD_finish_FLAG ... run until live bits are clear</pre>

<dt><a name="void_Parrot_dod_ims_wb(PARROT_INTERP,_NOTNULL(PMC_*agg),_NOTNULL(PMC_*_new))"
><b><code lang='und' xml:lang='und'>void Parrot_dod_ims_wb(PARROT_INTERP, NOTNULL(PMC *agg), NOTNULL(PMC *_new))</b></code></a></dt><p class="pad"></p>

<dd>Write barrier called by the DOD_WRITE_BARRIER macro. Always when storing a white object into a black aggregate, either the object must be greyed or the aggregate must be rescanned &#45; by greying it.</dd><p class="pad"></p>
</dl>

<h1><a name="SEE_ALSO"
>SEE ALSO <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p><em lang='und' xml:lang='und'><a href="dod.c.html">src/gc/dod.c</a></em>, <em lang='und' xml:lang='und'>include/parrot/dod.h</em>, <em lang='und' xml:lang='und'>include/parrot/pobj.h</em>,</p>

<h1><a name="HISTORY"
>HISTORY <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Initial version by leo (2004.08.12 &#45; 2004.08.15)</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../resources/parrot_small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
