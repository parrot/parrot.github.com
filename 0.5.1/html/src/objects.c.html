<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Class and object</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Class and object</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../html/index.html">Contents</a> | <a href="../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>objects.c &#45; Class and object</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>Handles class and object manipulation.</p>

<h2><a name="Functions"
>Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="INTVAL_Parrot_get_vtable_index"
><b><code lang='und' xml:lang='und'>INTVAL Parrot_get_vtable_index</b></code></a></dt><p class="pad"></p>

<dd>Return index if <code lang='und' xml:lang='und'>name</code> is a valid vtable slot name.</dd><p class="pad"></p>

<dt><a name="static_PMC*_find_vtable_meth_ns"
><b><code lang='und' xml:lang='und'>static PMC *find_vtable_meth_ns</b></code></a></dt><p class="pad"></p>

<dd>Return Sub PMC if a method with the vtable name exists in ns</dd><p class="pad"></p>

<dt><a name="PMC*_Parrot_find_vtable_meth"
><b><code lang='und' xml:lang='und'>PMC *Parrot_find_vtable_meth</b></code></a></dt><p class="pad"></p>

<dd>Given pmc,
run through its mro looking for the meth vtable method.
Return the vtable method PMC if found.</dd><p class="pad"></p>

<dt><a name="STRING*_readable_name"
><b><code lang='und' xml:lang='und'>STRING *readable_name</b></code></a></dt><p class="pad"></p>

<dd>Given a String or Key PMC return the STRING* representation</dd><p class="pad"></p>

<dd>RT#45967 this function,
key_set_to_string,
and the key PMC get_repr should be consolidated</dd><p class="pad"></p>

<dt><a name="static_void_fail_if_exist"
><b><code lang='und' xml:lang='und'>static void fail_if_exist</b></code></a></dt><p class="pad"></p>

<dd>Throws an exception if a PMC or class with the same name already exists.</dd><p class="pad"></p>

<dd>RT#45969 uses global class registry</dd><p class="pad"></p>

<dt><a name="static_void_rebuild_attrib_stuff"
><b><code lang='und' xml:lang='und'>static void rebuild_attrib_stuff</b></code></a></dt><p class="pad"></p>

<dd>Take the class and completely rebuild the attribute stuff for it.
Horribly destructive,
and definitely not a good thing to do if there are instantiated objects for the class</dd><p class="pad"></p>

<dt><a name="static_void_create_deleg_pmc_vtable"
><b><code lang='und' xml:lang='und'>static void create_deleg_pmc_vtable</b></code></a></dt><p class="pad"></p>

<dd>Create a vtable that dispatches either to the contained PMC in the first attribute (deleg_pmc) or to an overridden method (delegate),
depending on the existence of the method for this class.</dd><p class="pad"></p>

<dt><a name="const_char*_Parrot_MMD_method_name"
><b><code lang='und' xml:lang='und'>const char *Parrot_MMD_method_name</b></code></a></dt><p class="pad"></p>

<dd>Return the method name for the given MMD enum.</dd><p class="pad"></p>

<dt><a name="INTVAL_Parrot_MMD_method_idx"
><b><code lang='und' xml:lang='und'>INTVAL Parrot_MMD_method_idx</b></code></a></dt><p class="pad"></p>

<dd>Return the MMD function number for method name or &#45;1 on failure.</dd><p class="pad"></p>

<dd>RT#45973 allow dynamic expansion at runtime.</dd><p class="pad"></p>

<dt><a name="PMC_*_Parrot_single_subclass"
><b><code lang='und' xml:lang='und'>PMC *Parrot_single_subclass</b></code></a></dt><p class="pad"></p>

<dd>Subclass a class.
Single parent class,
nice and straightforward.
If <code lang='und' xml:lang='und'>child_class</code> is <code lang='und' xml:lang='und'>NULL</code>,
this is an anonymous subclass we&#39;re creating,
function.</dd><p class="pad"></p>

<dt><a name="void_Parrot_new_class"
><b><code lang='und' xml:lang='und'>void Parrot_new_class</b></code></a></dt><p class="pad"></p>

<dd>Creates a new class,
named <code lang='und' xml:lang='und'>class_name</code>.</dd><p class="pad"></p>

<dt><a name="PMC_*_Parrot_class_lookup"
><b><code lang='und' xml:lang='und'>PMC *Parrot_class_lookup</b></code></a></dt><p class="pad"></p>

<dd>Looks for the class named <code lang='und' xml:lang='und'>class_name</code> and returns it if it exists.
Otherwise it returns <code lang='und' xml:lang='und'>PMCNULL</code>.</dd><p class="pad"></p>

<dt><a name="PMC_*_Parrot_class_lookup_p"
><b><code lang='und' xml:lang='und'>PMC *Parrot_class_lookup_p</b></code></a></dt><p class="pad"></p>

<dd>Looks for the class named <code lang='und' xml:lang='und'>class_name</code> and returns it if it exists.
Otherwise it returns <code lang='und' xml:lang='und'>PMCNULL</code>.</dd><p class="pad"></p>

<dt><a name="static_INTVAL_register_type"
><b><code lang='und' xml:lang='und'>static INTVAL register_type</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_void_parrot_class_register"
><b><code lang='und' xml:lang='und'>static void parrot_class_register</b></code></a></dt><p class="pad"></p>

<dd>This is the way to register a new Parrot class as an instantiable type.
Doing this involves putting it in the class hash,
setting its vtable so that the <code lang='und' xml:lang='und'>init</code> method initializes objects of the class rather than the class itself,
and adding it to the interpreter&#39;s base type table so you can create a new <code lang='und' xml:lang='und'>foo</code> in PASM like this: <code lang='und' xml:lang='und'>new Px, foo</code>.</dd><p class="pad"></p>

<dt><a name="static_PMC*_get_init_meth"
><b><code lang='und' xml:lang='und'>static PMC *get_init_meth</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_void_do_initcall"
><b><code lang='und' xml:lang='und'>static void do_initcall</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="void_Parrot_instantiate_object_init"
><b><code lang='und' xml:lang='und'>void Parrot_instantiate_object_init</b></code></a></dt><p class="pad"></p>

<dd>Creates a Parrot object.
Takes a passed&#45;in class PMC that has sufficient information to describe the layout of the object and makes the object.</dd><p class="pad"></p>

<dt><a name="void_Parrot_instantiate_object"
><b><code lang='und' xml:lang='und'>void Parrot_instantiate_object</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_void_instantiate_object"
><b><code lang='und' xml:lang='und'>static void instantiate_object</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_PMC*_not_empty"
><b><code lang='und' xml:lang='und'>static PMC *not_empty</b></code></a></dt><p class="pad"></p>

<dd>Add the parent class to the current class&#39; parent list.
This also involved adding all the parent&#39;s parents,
as well as all attributes of the parent classes that we&#39;re adding in.</dd><p class="pad"></p>

<dd>The MRO (method resolution order) is the C3 algorithm used by Perl6 and Python (&#62;= 2.3).
See also: <a href='http://pugs.blogs.com/pugs/2005/07/day_165_r5671_j.html'><a href="http://pugs.blogs.com/pugs/2005/07/day_165_r5671_j.html">http://pugs.blogs.com/pugs/2005/07/day_165_r5671_j.html</a></a></dd><p class="pad"></p>

<dt><a name="static_PMC*_class_mro_merge"
><b><code lang='und' xml:lang='und'>static PMC *class_mro_merge</b></code></a></dt><p class="pad"></p>

<dd>merge the list if lists</dd><p class="pad"></p>

<dt><a name="static_PMC*_create_class_mro"
><b><code lang='und' xml:lang='und'>static PMC *create_class_mro</b></code></a></dt><p class="pad"></p>

<dd>create C3 MRO</dd><p class="pad"></p>

<dt><a name="PMC_*_Parrot_remove_parent"
><b><code lang='und' xml:lang='und'>PMC *Parrot_remove_parent</b></code></a></dt><p class="pad"></p>

<dd>This currently does nothing but return <code lang='und' xml:lang='und'>PMCNULL</code>.</dd><p class="pad"></p>

<dt><a name="PMC_*_Parrot_multi_subclass"
><b><code lang='und' xml:lang='und'>PMC *Parrot_multi_subclass</b></code></a></dt><p class="pad"></p>

<dd>This currently does nothing but return <code lang='und' xml:lang='und'>PMCNULL</code>.</dd><p class="pad"></p>

<dt><a name="INTVAL_Parrot_object_isa"
><b><code lang='und' xml:lang='und'>INTVAL Parrot_object_isa</b></code></a></dt><p class="pad"></p>

<dd>Returns whether the object <code lang='und' xml:lang='und'>pmc</code> is an instance of class <code lang='und' xml:lang='und'>_class</code>.</dd><p class="pad"></p>

<dt><a name="PMC_*_Parrot_new_method_cache"
><b><code lang='und' xml:lang='und'>PMC *Parrot_new_method_cache</b></code></a></dt><p class="pad"></p>

<dd>This should create and return a new method cache PMC.</dd><p class="pad"></p>

<dd>Currently it does nothing but return <code lang='und' xml:lang='und'>PMCNULL</code>.</dd><p class="pad"></p>

<dt><a name="void_mark_object_cache"
><b><code lang='und' xml:lang='und'>void mark_object_cache</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="void_init_object_cache"
><b><code lang='und' xml:lang='und'>void init_object_cache</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="void_destroy_object_cache"
><b><code lang='und' xml:lang='und'>void destroy_object_cache</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_void_invalidate_type_caches"
><b><code lang='und' xml:lang='und'>static void invalidate_type_caches</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_void_invalidate_all_caches"
><b><code lang='und' xml:lang='und'>static void invalidate_all_caches</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="void_Parrot_invalidate_method_cache"
><b><code lang='und' xml:lang='und'>void Parrot_invalidate_method_cache</b></code></a></dt><p class="pad"></p>

<dd>Clear method cache for the given class.
If class is NULL,
caches for all classes are invalidated.</dd><p class="pad"></p>

<dt><a name="PMC_*_Parrot_find_method_direct"
><b><code lang='und' xml:lang='und'>PMC *Parrot_find_method_direct</b></code></a></dt><p class="pad"></p>

<dd>Find a method PMC for a named method,
given the class PMC,
current interpreter,
and name of the method.
Don&#39;t use a possible method cache.</dd><p class="pad"></p>

<dt><a name="PMC_*_Parrot_find_method_with_cache"
><b><code lang='und' xml:lang='und'>PMC *Parrot_find_method_with_cache</b></code></a></dt><p class="pad"></p>

<dd>Find a method PMC for a named method,
given the class PMC,
current interp,
and name of the method.</dd><p class="pad"></p>

<dd>This routine should use the current scope&#39;s method cache,
if there is one.
If not,
it creates a new method cache.
Or,
rather,
it will when we&#39;ve got that bit working.
For now it unconditionally goes and looks up the name in the global stash.</dd><p class="pad"></p>

<dt><a name="static_void_debug_trace_find_meth"
><b><code lang='und' xml:lang='und'>static void debug_trace_find_meth</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_PMC_*_find_method_direct_1"
><b><code lang='und' xml:lang='und'>static PMC *find_method_direct_1</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="void_Parrot_note_method_offset"
><b><code lang='und' xml:lang='und'>void Parrot_note_method_offset</b></code></a></dt><p class="pad"></p>

<dd>Notes where in the hierarchy we just found a method.
Used so that we can do a next and continue the search through the hierarchy for the next instance of this method.</dd><p class="pad"></p>

<dt><a name="INTVAL_Parrot_add_attribute"
><b><code lang='und' xml:lang='und'>INTVAL Parrot_add_attribute</b></code></a></dt><p class="pad"></p>

<dd>Adds the attribute <code lang='und' xml:lang='und'>attr</code> to the class.</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>   Life is ever so much easier if a class keeps its attributes at the
   end of the attribute array, since we don&#39;t have to insert and
   reorder attributes. Inserting&#39;s no big deal, especially since we&#39;re
   going to break horribly if you insert into a class that&#39;s been
   subclassed, but it&#39;ll do for now.</pre>

<dt><a name="PMC_*_Parrot_get_attrib_by_num"
><b><code lang='und' xml:lang='und'>PMC *Parrot_get_attrib_by_num</b></code></a></dt><p class="pad"></p>

<dd>Returns attribute number <code lang='und' xml:lang='und'>attrib</code> from <code lang='und' xml:lang='und'>object</code>. Presumably the code is asking for the correct attribute number.</dd><p class="pad"></p>

<dt><a name="static_INTVAL_attr_str_2_num"
><b><code lang='und' xml:lang='und'>static INTVAL attr_str_2_num</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="PMC_*_Parrot_get_attrib_by_str"
><b><code lang='und' xml:lang='und'>PMC *Parrot_get_attrib_by_str</b></code></a></dt><p class="pad"></p>

<dd>Returns attribute with full qualified name <code lang='und' xml:lang='und'>attr</code> from <code lang='und' xml:lang='und'>object</code>.</dd><p class="pad"></p>

<dt><a name="void_Parrot_set_attrib_by_num"
><b><code lang='und' xml:lang='und'>void Parrot_set_attrib_by_num</b></code></a></dt><p class="pad"></p>

<dd>Set attribute number <code lang='und' xml:lang='und'>attrib</code> from <code lang='und' xml:lang='und'>object</code> to <code lang='und' xml:lang='und'>value</code>. Presumably the code is asking for the correct attribute number.</dd><p class="pad"></p>

<dt><a name="void_Parrot_set_attrib_by_str"
><b><code lang='und' xml:lang='und'>void Parrot_set_attrib_by_str</b></code></a></dt><p class="pad"></p>

<dd>Sets attribute with full qualified name <code lang='und' xml:lang='und'>attr</code> from <code lang='und' xml:lang='und'>object</code> to <code lang='und' xml:lang='und'>value</code>.</dd><p class="pad"></p>

<dt><a name="INTVAL_Parrot_class_offset"
><b><code lang='und' xml:lang='und'>INTVAL Parrot_class_offset</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="PMC_*_Parrot_find_class_constructor"
><b><code lang='und' xml:lang='und'>PMC *Parrot_find_class_constructor</b></code></a></dt><p class="pad"></p>

<dd>Find and return the constructor method PMC for the named sub. The classtoken is an identifier for the class used for fast lookup, or 0 if you don&#39;t have an identifier token (which, as they&#39;re currently undefined, is pretty likely).</dd><p class="pad"></p>

<dt><a name="PMC_*_Parrot_find_class_destructor"
><b><code lang='und' xml:lang='und'>PMC *Parrot_find_class_destructor</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="PMC_*_Parrot_find_class_fallback"
><b><code lang='und' xml:lang='und'>PMC *Parrot_find_class_fallback</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="void_Parrot_set_class_constructor"
><b><code lang='und' xml:lang='und'>void Parrot_set_class_constructor</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="void_Parrot_set_class_destructor"
><b><code lang='und' xml:lang='und'>void Parrot_set_class_destructor</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="void_Parrot_set_class_fallback"
><b><code lang='und' xml:lang='und'>void Parrot_set_class_fallback</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="static_PMC*_C3_merge"
><b><code lang='und' xml:lang='und'>static PMC *C3_merge</b></code></a></dt><p class="pad"></p>

<dd>RT#48260: Not yet documented!!!</dd><p class="pad"></p>

<dt><a name="PMC*_Parrot_ComputeMRO_C3"
><b><code lang='und' xml:lang='und'>PMC *Parrot_ComputeMRO_C3</b></code></a></dt><p class="pad"></p>

<dd>Computes the C3 linearization for the given class.</dd><p class="pad"></p>

<dt><a name="void_Parrot_ComposeRole"
><b><code lang='und' xml:lang='und'>void Parrot_ComposeRole</b></code></a></dt><p class="pad"></p>

<dd>Used by the Class and Object PMCs internally to compose a role into either of them. The <code lang='und' xml:lang='und'>role</code> parameter is the role that we are composing into the class or role. <code lang='und' xml:lang='und'>methods_hash</code> is the hash of method names to invokable PMCs that contains the methods the class or role has. <code lang='und' xml:lang='und'>roles_list</code> is the list of roles the the class or method does.</dd><p class="pad"></p>

<dd>The <code lang='und' xml:lang='und'>role</code> parameter is only dealt with by its external interface. Whether this routine is usable by any other object system implemented in Parrot very much depends on how closely the role composition semantics they want are to the default implementation.</dd><p class="pad"></p>
</dl>

<h1><a name="SEE_ALSO"
>SEE ALSO <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p><em lang='und' xml:lang='und'>include/parrot/objects.h</em>, <em lang='und' xml:lang='und'><a href="../docs/pdds/pdd15_objects.pod.html">docs/pdds/pdd15_objects.pod</a></em>.</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../resources/parrot_small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
