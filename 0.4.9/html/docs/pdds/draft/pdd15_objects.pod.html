<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Object and Class semantics for Parrot</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Object and Class semantics for Parrot</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../../html/index.html">Contents</a> | <a href="../../../../html/docs.html">Documentation</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>docs/pdds/pdd15_objects.pod &#45; Object and Class semantics for Parrot</p>

<h1><a name="ABSTRACT"
>ABSTRACT <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>This PDD describes the semantics of Parrot&#39;s object and class systems.</p>

<h1><a name="VERSION"
>VERSION <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>$Revision$</p>

<h1><a name="DEFINITIONS"
>DEFINITIONS <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<h2><a name="Class"
>Class <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<h2><a name="Object"
>Object <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<h2><a name="Attribute"
>Attribute <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>An attribute is a slot in an object that contains a value,
generally a PMC.
Attributes are referenced by class name/attribute name pairs.</p>

<p>Attributes are set on a class&#45;wide basis,
and all the objects of a class will have the same set of attributes.
Most OO languages don&#39;t allow attribute changes to existing classes,
but Parrot&#39;s base attribute system does allow it.
In order to safely support advanced dynamic features in HLLs,
attributes are not accesible via fixed attribute offsets,
but only via named lookup.</p>

<h2><a name="Method"
>Method <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>A method is a piece of code that you invoke by name through an object.</p>

<h2><a name="Parent_class"
>Parent class <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Also called the super&#45;class.
The parent class is,
in an inheritance situation,
the class being derived from.
If A derives from B,
B is the parent class of A.</p>

<h2><a name="Child_class"
>Child class <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Also called the sub&#45;class.
The child class is,
in an inheritance situation,
the class doing the deriving.
If A derives from B,
A is the child class.</p>

<h2><a name="Role"
>Role <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>A role adds attributes and methods into a class without inheritance.
The composed class retains a list of roles applied to it (so they can be checked with <code lang='und' xml:lang='und'>does</code>),
but otherwise maintains no distinction between composed attributes and methods and those defined in the class.</p>

<h2><a name="Delegate"
>Delegate <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>An object that is transparently (to the user) embedded in another object.
Delegate objects are used in those cases where we can&#39;t inherit from a class because the class is from a different object universe.</p>

<h2><a name="Property"
>Property <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>A property is a role that only adds attributes and accessors.</p>

<p>Properties are generally assigned at runtime,
and a particular property may or may not exist on a PMC at any particular time.
Properties are not restricted to objects as such&#45;&#45;any PMC may have a property attached to it.</p>

<h2><a name="Interface"
>Interface <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>An interface is a role that only adds methods.</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<dl>
<dt><a
>&#45; The object and class system provides the flexibility to implement a core set of dynamic languages (Perl 6,
Ruby,
Python,
etc).
Other class systems may be implemented later to support other languages.</a></dt><p class="pad"></p>

<dt><a name="&#45;_Classes_have_an_associated_namespace._(Which_may_be_anonymous)"
>&#45; Classes have an associated namespace.
(Which may be anonymous)</a></dt><p class="pad"></p>

<dt><a name="&#45;_Classes_have_one_or_more_immediate_parent_classes"
>&#45; Classes have one or more immediate parent classes</a></dt><p class="pad"></p>

<dt><a name="&#45;_Classes_have_a_catalog_of_attribute_names."
>&#45; Classes have a catalog of attribute names.</a></dt><p class="pad"></p>

<dt><a name="&#45;_Classes_have_a_list_of_roles_they_implement"
>&#45; Classes have a list of roles they implement</a></dt><p class="pad"></p>

<dt><a name="&#45;_Classes_can_instantiate_an_object_of_their_class"
>&#45; Classes can instantiate an object of their class</a></dt><p class="pad"></p>

<dt><a name="&#45;_Classes_can_add_and_remove_parent_classes"
>&#45; Classes can add and remove parent classes</a></dt><p class="pad"></p>

<dt><a name="&#45;_Classes_can_add_and_remove_attributes"
>&#45; Classes can add and remove attributes</a></dt><p class="pad"></p>

<dt><a name="&#45;_Classes_can_add_(but_not_remove)_roles"
>&#45; Classes can add (but not remove) roles</a></dt><p class="pad"></p>

<dt><a
>&#45; Classes are instances of a meta&#45;class and have their own sets of class methods and class attributes</a></dt><p class="pad"></p>

<dt><a name="&#45;_Objects_have_an_array_of_attributes._Attribute_values_may_be_PMCs_or_a_low&#45;level_type."
>&#45; Objects have an array of attributes.
Attribute values may be PMCs or a low&#45;level type.</a></dt><p class="pad"></p>

<dt><a name="&#45;_Objects_have_an_associated_class."
>&#45; Objects have an associated class.</a></dt><p class="pad"></p>

<dt><a name="&#45;_Objects_may_have_a_custom_vtable_or_use_a_class&#45;wide_vtable."
>&#45; Objects may have a custom vtable or use a class&#45;wide vtable.</a></dt><p class="pad"></p>

<dt><a name="&#45;_Objects_can_call_a_method"
>&#45; Objects can call a method</a></dt><p class="pad"></p>

<dt><a name="&#45;_Objects_can_retrieve_a_method_PMC_for_a_method_(for_deferred_method_calls)"
>&#45; Objects can retrieve a method PMC for a method (for deferred method calls)</a></dt><p class="pad"></p>

<dt><a name="&#45;_Objects_can_fetch_their_class"
>&#45; Objects can fetch their class</a></dt><p class="pad"></p>

<dt><a
>&#45; Objects can be subclassed (note that objects may not necessarily be able to have their classes changed arbitrarily,
but making a subclass and moving the object to it is allowable)</a></dt><p class="pad"></p>

<dt><a name="&#45;_Objects_can_get_an_attribute_by_name"
>&#45; Objects can get an attribute by name</a></dt><p class="pad"></p>

<dt><a name="&#45;_Objects_can_set_an_attribute_by_name"
>&#45; Objects can set an attribute by name</a></dt><p class="pad"></p>
</dl>

<h1><a name="IMPLEMENTATION"
>IMPLEMENTATION <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>There are four pieces to the object implementation.
There are the PMCs for the classes and objects,
the opcodes the engine uses to do objecty things,
the specific vtable methods used to perform those objecty things,
and the supporting code provided by the interpreter engine to do the heavy lifting.</p>

<p>Please note that Parrot,
in general,
does <i>not</i> restrict operations on objects and classes.
If a language has restrictions on what can be done with them,
the language is responsible for making sure that disallowed things do not happen.
For example,
Parrot permits multiple inheritance,
and will not stop code that adds a new parent to an existing class.
If a language doesn&#39;t allow for multiple inheritance it must not emit code which would add multiple parents to a class.
(Parrot may,
at some point,
allow imposition of runtime restrictions on a class,
but currently it doesn&#39;t)</p>

<h2><a name="Class_PMC_API"
>Class PMC API <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>There are two PMC classes,
<code lang='und' xml:lang='und'>Class</code> and <code lang='und' xml:lang='und'>Object</code>.
Class PMCs hold all the class&#45;specific information.
Instantiating a new OO class creates a new Class PMC,
and enters the new OO class into Parrot&#39;s PMC class table,
at which point it is indistinguishable from any other PMC class.</p>

<p>It&#39;s important to note that &#39;standard&#39; classes are Class PMC instances,
or instances of a subclass of the Class PMC,
and &#39;standard&#39; objects are Object PMCs.
It isn&#39;t necessary to create a brand new low&#45;level PMC class for each OO class,
and they all share the Class or Object vtable,
respectively.</p>

<p>An instance of the Class PMC has six attributes,
which are:</p>

<dl>
<dt><a name="0"
>0</a></dt><p class="pad"></p>

<dd>The class name</dd><p class="pad"></p>

<dt><a name="1"
>1</a></dt><p class="pad"></p>

<dd>A link to the class&#39;s associated namespace</dd><p class="pad"></p>

<dt><a name="2"
>2</a></dt><p class="pad"></p>

<dd>An array PMC of the immediate parent classes</dd><p class="pad"></p>

<dt><a name="3"
>3</a></dt><p class="pad"></p>

<dd>A cached array of all parent PMCs,
in search order (this is an optional optimization,
and can be calculated from the class&#39;s rules of inheritance,
the list of immediate parent classes,
and the parent classes&#39; rules of inheritance)</dd><p class="pad"></p>

<dt><a name="4"
>4</a></dt><p class="pad"></p>

<dd>An array PMC of the composed roles</dd><p class="pad"></p>

<dt><a name="5"
>5</a></dt><p class="pad"></p>

<dd>An array PMC of the methods defined in the class or composed into the class</dd><p class="pad"></p>

<dt><a name="6"
>6</a></dt><p class="pad"></p>

<dd>The class attribute hash.
Keys are the attribute names and the values are a hash of attribute characteristics,
including name,
type,
and the class they&#39;re associated with.</dd><p class="pad"></p>
</dl>

<p>The attribute catalog holds only the attributes defined in a particular class.
When instantiating an object,
it is necessary to scan all parent classes as well as the instantiated class for attributes defined there.
The inheritance rules for a particular HLL will determine which child class attributes override which parent class attributes.</p>

<p>We may also add a cache to the class object: a hash that contains all child and parent attribute characteristcs.
Whether this is useful largely depends on how slow it is to scan through the list of parent classes,
and how dynamic we want the system to be.
(If a parent class changes its set of attributes,
should that change appear in later instantiations of objects from child classes?
Probably,
in which case caching parent attributes is an obstacle.)</p>

<p>Class PMCs also have the &#34;I am a class&#34; flag set on them.</p>

<h3><a name="Methods"
>Methods</a></h3>

<dl>
<dt><a name="name"
>name</a></dt><p class="pad"></p>

<dd>The accessor for the name attribute.
With no argument,
it simply returns the current value for name.
When passed an argument,
it sets the name of the class,
and also sets the association with a namespace.</dd><p class="pad"></p>

<dt><a name="new"
>new</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>    obj = class.&#39;new&#39;( &#39;myattrib&#39; =&#62; &#34;Foo&#34; )</pre>

<dd>Create a new instance object from the class object. It takes an optional slurpy, named list of attributes and values to initialize the object.</dd><p class="pad"></p>

<dt><a name="attributes"
>attributes</a></dt><p class="pad"></p>

<dd>An accessor for the attributes of the class. It returns the a Hash of all attributes, with a key of the attribute name, and a value of the Attribute object. The accessor is read&#45;only.</dd><p class="pad"></p>

<dt><a name="add_attribute"
>add_attribute</a></dt><p class="pad"></p>

<dd>Adds a single attribute to the class. It takes a simple string name, and a simple string value for type.</dd><p class="pad"></p>

<dt><a name="parents"
>parents</a></dt><p class="pad"></p>

<dd>An accessor for the parents of the class. It returns an Array of all parents. The accessor is read&#45;only.</dd><p class="pad"></p>

<dt><a name="add_parent"
>add_parent</a></dt><p class="pad"></p>

<dd>Adds a single parent to the class. It takes a simple string name.</dd><p class="pad"></p>
</dl>

<h2><a name="Object_PMC_API"
>Object PMC API <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p><code lang='und' xml:lang='und'>Object</code> PMCs are the actual objects, and hold all the per&#45;object instance data.</p>

<p>The Object PMC is an array of meta&#45;information and attributes. The elements of this array are:</p>

<dl>
<dt><a name="0"
>0</a></dt><p class="pad"></p>

<dd>The class PMC</dd><p class="pad"></p>

<dt><a name="1"
>1</a></dt><p class="pad"></p>

<dd>The class name</dd><p class="pad"></p>

<dt><a name="2"
>2</a></dt><p class="pad"></p>

<dd>The object attribute hash. Keys are the attribute names and the values are the attribute values. (The &#34;hash&#34; may be implemented as a typed structure following the CStruct proposal.)</dd><p class="pad"></p>
</dl>

<p>A list of the object&#39;s attributes is accessible by extracting the keys from the object attribute hash. This direct introspetive capability may not be directly exposed in the HLLs (preserving the boundaries of an opaque object).</p>

<p>Note that Object PMCs have the &#34;I am an object&#34; flag set on them.</p>

<p>Object PMCs have no methods aside from those defined in their associated class. They do have vtable methods providing access to certain low&#45;level information about the object, method call functionality, etc. See the sections below on <a href='TODO'>Objects</a> and <a href='TODO'>Vtables</a>.</p>

<h2><a name="Opcodes"
>Opcodes <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>The following ops are provided to deal with objects. Please note that method calls are governed by parrot&#39;s calling conventions, and as such objects, method PMCs, return continuations, and parameters must be in the right places, though some ops will put parameters where they need to go.</p>

<dl>
<dt><a name="classoffset_Ix,_Py,_Sz_[deprecated]"
>classoffset Ix, Py, Sz [deprecated]</a></dt><p class="pad"></p>

<dd>Returns the offset of the first attribute for class Sz in object Py.</dd><p class="pad"></p>

<dt><a name="getattribute_Px,_Py,_Iz"
>getattribute Px, Py, Iz</a></dt><p class="pad"></p>

<dd>Returns attribute Iz of object Py and puts it in Px. Note that the attribute number is an absolute offset.</dd><p class="pad"></p>

<dt><a name="getattribute_Px,_Py,_Sz"
>getattribute Px, Py, Sz</a></dt><p class="pad"></p>

<dd>Get the attribute with the fully qualified name Sz from object Py and put it in Px.</dd><p class="pad"></p>

<dt><a name="setattribute_Px,_Iy,_Pz"
>setattribute Px, Iy, Pz</a></dt><p class="pad"></p>

<dd>Set the attribute Iy of object Px to Pz. Note that this op stores the <b>actual</b> PMC rather than a copy, and so if the PMC&#39;s value is subsequently changed, the value of the attribute will also change.</dd><p class="pad"></p>

<dt><a name="setattribute_Px,_Sy,_Pz"
>setattribute Px, Sy, Pz</a></dt><p class="pad"></p>

<dd>Set the attribute of object Px with the fully qualified name Sy to Pz</dd><p class="pad"></p>

<dt><a name="callmethod"
>callmethod</a></dt><p class="pad"></p>

<dt><a name="callmethod_Sz"
>callmethod Sz</a></dt><p class="pad"></p>

<dd>Call a method. If the method name is provided, we find the PMC for the named method and put it in the sub/method slot. If no name is provided we assume that all the calling conventions have already been set up and the method PMC is already in the proper place.</dd><p class="pad"></p>

<dt><a name="callmethodcc"
>callmethodcc</a></dt><p class="pad"></p>

<dt><a name="callmethodcc_Sx"
>callmethodcc Sx</a></dt><p class="pad"></p>

<dd>Make a method call, automatically generating a return continuation. If a method name is passed in we look up the method PMC for the object and put it in the method slot. If a method name isn&#39;t provided then we assume that things are already properly set up.</dd><p class="pad"></p>

<dt><a name="tailcallmethod_(Unimplemented)_[deprecated]"
>tailcallmethod (Unimplemented) [deprecated]</a></dt><p class="pad"></p>

<dt><a name="tailcallmethod_Sx_(Unimplemented)_[deprecated]"
>tailcallmethod Sx (Unimplemented) [deprecated]</a></dt><p class="pad"></p>

<dd>Make a tailcall to method Sx. If no method name is given, we assume everything is already set up properly.</dd><p class="pad"></p>

<dt><a name="newclass_Px,_Sy"
>newclass Px, Sy</a></dt><p class="pad"></p>

<dd>Create a new base class named Sy, and put the PMC for it in Px</dd><p class="pad"></p>

<dt><a name="subclass_Px,_Py,_Sz"
>subclass Px, Py, Sz</a></dt><p class="pad"></p>

<dd>Create a new class, named Sz, which has Py as its immediate parent.</dd><p class="pad"></p>

<dt><a name="addparent_Px,_Py"
>addparent Px, Py</a></dt><p class="pad"></p>

<dd>Add class Py to the end of the list of immediate parents of class Px. Adds any attributes of Py (and its parent classes) that aren&#39;t already in Px.</dd><p class="pad"></p>

<dt><a name="removeparent_Px,_Py_(Unimplemented)"
>removeparent Px, Py (Unimplemented)</a></dt><p class="pad"></p>

<dd>Remove class Py from the parent list of Px. All parent classes of Py which aren&#39;t parent classes of what remains of Px&#39;s parent list are removed, as are their attributes.</dd><p class="pad"></p>

<dt><a name="addattribute_Px,_Sy"
>addattribute Px, Sy</a></dt><p class="pad"></p>

<dd>Add attribute Sy to class Px. This will add the attribute slot to all objects of class Px and children of class Px, with a default value of <code lang='und' xml:lang='und'>Null</code>.</dd><p class="pad"></p>

<dt><a name="removeattribute_Px,_Sy_(Unimplemented)"
>removeattribute Px, Sy (Unimplemented)</a></dt><p class="pad"></p>

<dd>Remove the attribute Sy from class Px, all objects of class Px, and all objects of a child of class Px.</dd><p class="pad"></p>

<dt><a name="instantiate_Px,_Py,_Sz_(Unimplemented)_[deprecated]"
>instantiate Px, Py, Sz (Unimplemented) [deprecated]</a></dt><p class="pad"></p>

<dd>Instantiate a brand new class, based on the metadata in Py, named Sz.</dd><p class="pad"></p>
</dl>

<h2><a name="Vtables"
>Vtables <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>To make this work all PMCs must have the following vtable entries. They may, for non&#45;objects, throw an exception.</p>

<p>The catalog metadata for objects is considered to be attributes on the class, so to get the offset for a class for an object, you fetch the object&#39;s class then look up the offset attribute from it. (The class attributes are detailed later) This is safe in general, since the only code reasonably querying a class&#39; attribute list is the class code itself, and if a class doesn&#39;t know whether it&#39;s a Class&#45;style class or not you&#39;ve got bigger problems.</p>

<dl>
<dt><a name="find_method(string_*)"
>find_method(string *)</a></dt><p class="pad"></p>

<dd>Returns the PMC for the named method. If no method of this name exists, nor can be constructed, returns a Null PMC.</dd><p class="pad"></p>

<dd>Note that for languages which support default fallback methods, such as Perl 5&#39;s AUTOLOAD, this would be the place to return it if a normal lookup fails.</dd><p class="pad"></p>

<dt><a name="isa(class_*)"
>isa(class *)</a></dt><p class="pad"></p>

<dd>Returns true or false if the class passed in as a parameter is in the inheritance hierarchy of the object.</dd><p class="pad"></p>

<dt><a name="can(string_*)"
>can(string *)</a></dt><p class="pad"></p>

<dd>Returns true or false if the object can perform the requested method. (Including with an AUTOLOAD)</dd><p class="pad"></p>

<dt><a name="does(class_*)"
>does(class *)</a></dt><p class="pad"></p>

<dd>Returns true or false to note whether the object in question implements the interface passed in.</dd><p class="pad"></p>

<dt><a name="get_attr(INTVAL)_[deprecated]"
>get_attr(INTVAL) [deprecated]</a></dt><p class="pad"></p>

<dd>Returns the attribute at the passed&#45;in offset for the object.</dd><p class="pad"></p>

<dt><a name="get_attr(STRING*)"
>get_attr(STRING*)</a></dt><p class="pad"></p>

<dd>Returns the attribute with the fully qualified name for the object.</dd><p class="pad"></p>

<dt><a name="set_attr(INTVAL,_PMC_*)_[deprecated]"
>set_attr(INTVAL, PMC *) [deprecated]</a></dt><p class="pad"></p>

<dd>Sets the attribute for the passed&#45;in offset to the passed&#45;in PMC value</dd><p class="pad"></p>

<dt><a name="set_attr(STRING*,_PMC_*)"
>set_attr(STRING*, PMC *)</a></dt><p class="pad"></p>

<dd>Set the attribute with the fully qualified name for the object.</dd><p class="pad"></p>

<dt><a name="get_class"
>get_class</a></dt><p class="pad"></p>

<dd>Returns the class PMC for the object.</dd><p class="pad"></p>
</dl>

<p>Currently Parrot only supports mutating a class&#39; metainformation for Class classes. This is a restriction which will be lifted at some point soon.</p>

<h2><a name="What_The_Bytecode_Sees"
>What The Bytecode Sees <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>The bytecode is isolated from most of the internal details of the implementation. This allows both for flexibility in the implementation and forward compatibility, generally good things. It also allows for multiple concurrent interoperable object systems. The major thrust is for transparent use of objects, though most class activity (including creation of subclasses and modifications of existing classes) should be transparent as well.</p>

<h1><a name="EXAMPLES"
>EXAMPLES <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>The following examples all assume we&#39;re working with basic Object objects and Class classes.</p>

<h2><a name="Creating_a_new_class"
>Creating a new class <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>To create a new class <code lang='und' xml:lang='und'>Foo</code> which has no parent classes:</p>

<pre lang='und' xml:lang='und'>   newclass $P0, &#34;Foo&#34;</pre>

<h2><a name="Creating_a_new_class_with_multiple_parents"
>Creating a new class with multiple parents <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>To create a class <code lang='und' xml:lang='und'>Foo</code> with the parents <code lang='und' xml:lang='und'>A</code> and <code lang='und' xml:lang='und'>B</code>, the code would be:</p>

<pre lang='und' xml:lang='und'>   getclass $P0, &#34;A&#34;
   getclass $P1, &#34;B&#34;
   subclass $P2, $P0, &#34;Foo&#34;
   addparent $P2, $P1</pre>

<h2><a name="Creating_a_new_class_with_attributes"
>Creating a new class with attributes <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Adding the attributes <code lang='und' xml:lang='und'>a</code> and <code lang='und' xml:lang='und'>b</code> to the new class <code lang='und' xml:lang='und'>Foo</code>:</p>

<pre lang='und' xml:lang='und'>  newclass $P0, &#34;Foo&#34;
  addattribute $P0, &#34;a&#34;   # This is offset 0 + classoffset
  addattribute $P0, &#34;b&#34;   # This is offset 1 + classoffset</pre>

<h2><a name="Instantiating_an_object"
>Instantiating an object <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Assuming we want an object of class <code lang='und' xml:lang='und'>Foo</code>:</p>

<pre lang='und' xml:lang='und'>  .local pmc FooClass
  .local pmc MyObject
  find_class FooClass, &#34;Foo&#34;
  new MyObject, FooClass</pre>

<h2><a name="Calling_a_method_on_an_object"
>Calling a method on an object <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Calling the method <code lang='und' xml:lang='und'>Xyzzy</code> on an object, assuming the PDD03 calling conventions are respected:</p>

<pre lang='und' xml:lang='und'>  callmethod &#34;Xyzzy&#34;

  set S0, &#34;Xyzzy&#34;
  callmethod</pre>

<p>Or, if a return continuation needs constructing:</p>

<pre lang='und' xml:lang='und'>  callmethodcc &#34;Xyzzy&#34;

  set S0, &#34;Xyzzy&#34;
  callmethodcc</pre>

<h2><a name="Accessing_attributes_from_within_a_class"
>Accessing attributes from within a class <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>With named access:</p>

<pre lang='und' xml:lang='und'>  getattribute $P1, $P0, &#34;Foo\x0b&#34;</pre>

<h1><a name="Explanations"
>Explanations <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>To get a new class, you can do a <code lang='und' xml:lang='und'>newclass</code>, which creates a new class with no parents besides parrot&#39;s default super&#45;ish parent class.</p>

<p>To get a new child class, you have two potential options:</p>

<dl>
<dt><a name="Subclass_the_parent"
>Subclass the parent</a></dt><p class="pad"></p>

<dt><a name="Create_a_new_standalone_class_and_add_a_parent"
>Create a new standalone class and add a parent</a></dt><p class="pad"></p>
</dl>

<p>Both ways work. It is, however, more efficient to use the first method, and just subclass the immediate parent class of your new class.</p>

<p>When adding in extra parents in a multiple&#45;inheritance scenario, subclass the first class in the immediate parent list then use the <code lang='und' xml:lang='und'>addparent</code> op to add in the rest of the immediate parents.</p>

<h2><a name="VTABLE_OVERLOADING"
>VTABLE OVERLOADING <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Classes may override the vtable methods, allowing objects of a class to behave like a primitive PMC. Each vtable slot has a corresponding named method that parrot looks for in your class hierarchy when an object is used in a primitive context.</p>

<p>To use these properly at a low&#45;level requires a good working knowledge of the way Parrot works&#45;&#45;generally for higher&#45;level languages the language compiler or runtime will provide easier&#45;to&#45;use wrappers. These methods are all prototyped, and take a single fixed argument list, and return at most a single value.</p>

<p>While vtable methods <i>may</i> take a continuation, those continuations may <i>not</i> escape the vtable method&#39;s execution. This is due to the way that vtable methods are called by the interpreter&#45;&#45;once a vtable method is exited any continuation taken within it is no longer valid and may not be used.</p>

<p>Note that any class method that wishes to use parrot&#39;s multi&#45;method dispatch system may do so. This is, in fact, encouraged, though it is not required. In the absence of explicit multimethod dispatch, a left&#45;side wins scheme is used.</p>

<p>The following list details the raw method names:</p>

<dl>
<dt><a name="init"
>init</a></dt><p class="pad"></p>

<dd>Called when the object is first created.</dd><p class="pad"></p>

<dt><a name="init_pmc"
>init_pmc</a></dt><p class="pad"></p>

<dd>Alternative entry point called when object is first created. Accepts a PMC parameter used to initialize the given object. Interpretation of the PMC is PMC&#45;specific.</dd><p class="pad"></p>

<dd>NOTE: It is strongly suggested that init_pmc(PMCNULL) be equivalent to init(), though there will of necessity be exceptions.</dd><p class="pad"></p>

<dt><a name="morph"
>morph</a></dt><p class="pad"></p>

<dt><a name="mark"
>mark</a></dt><p class="pad"></p>

<dd>Called when the DOD is tracing live PMCs. If this method is called then the code must mark all strings and PMCs that it contains as live, otherwise they may be collected.</dd><p class="pad"></p>

<dd>This method is only called if the PMC is flagged as having a special mark routine, and is not necessary for normal objects.</dd><p class="pad"></p>

<dt><a name="destroy"
>destroy</a></dt><p class="pad"></p>

<dd>Called when the object is destroyed. This method is only called if the PMC is marked as having an active finalizer.</dd><p class="pad"></p>

<dt><a name="getprop"
>getprop</a></dt><p class="pad"></p>

<dt><a name="setprop"
>setprop</a></dt><p class="pad"></p>

<dt><a name="delprop"
>delprop</a></dt><p class="pad"></p>

<dt><a name="getprops"
>getprops</a></dt><p class="pad"></p>

<dt><a name="type"
>type</a></dt><p class="pad"></p>

<dt><a name="type_keyed"
>type_keyed</a></dt><p class="pad"></p>

<dt><a name="type_keyed_int"
>type_keyed_int</a></dt><p class="pad"></p>

<dt><a name="type_keyed_str"
>type_keyed_str</a></dt><p class="pad"></p>

<dt><a name="subtype"
>subtype</a></dt><p class="pad"></p>

<dt><a name="name"
>name</a></dt><p class="pad"></p>

<dt><a name="clone"
>clone</a></dt><p class="pad"></p>

<dt><a name="find_method"
>find_method</a></dt><p class="pad"></p>

<dt><a name="get_integer"
>get_integer</a></dt><p class="pad"></p>

<dd>Return the integer value of the object</dd><p class="pad"></p>

<dt><a name="get_integer_keyed"
>get_integer_keyed</a></dt><p class="pad"></p>

<dt><a name="get_integer_keyed_int"
>get_integer_keyed_int</a></dt><p class="pad"></p>

<dt><a name="get_integer_keyed_str"
>get_integer_keyed_str</a></dt><p class="pad"></p>

<dt><a name="get_number"
>get_number</a></dt><p class="pad"></p>

<dd>Return the floating&#45;point value of the object</dd><p class="pad"></p>

<dt><a name="get_number_keyed"
>get_number_keyed</a></dt><p class="pad"></p>

<dt><a name="get_number_keyed_int"
>get_number_keyed_int</a></dt><p class="pad"></p>

<dt><a name="get_number_keyed_str"
>get_number_keyed_str</a></dt><p class="pad"></p>

<dt><a name="get_bignum"
>get_bignum</a></dt><p class="pad"></p>

<dd>Return the extended precision numeric value of the PMC</dd><p class="pad"></p>

<dt><a name="get_string"
>get_string</a></dt><p class="pad"></p>

<dd>Return the string value of the PMC</dd><p class="pad"></p>

<dt><a name="get_string_keyed"
>get_string_keyed</a></dt><p class="pad"></p>

<dt><a name="get_string_keyed_int"
>get_string_keyed_int</a></dt><p class="pad"></p>

<dt><a name="get_string_keyed_str"
>get_string_keyed_str</a></dt><p class="pad"></p>

<dt><a name="get_bool"
>get_bool</a></dt><p class="pad"></p>

<dd>Return the true/false value of the PMC</dd><p class="pad"></p>

<dt><a name="get_bool_keyed"
>get_bool_keyed</a></dt><p class="pad"></p>

<dt><a name="get_bool_keyed_int"
>get_bool_keyed_int</a></dt><p class="pad"></p>

<dt><a name="get_bool_keyed_str"
>get_bool_keyed_str</a></dt><p class="pad"></p>

<dt><a name="get_pmc"
>get_pmc</a></dt><p class="pad"></p>

<dd>Return the PMC for this PMC.</dd><p class="pad"></p>

<dt><a name="get_pmc_keyed"
>get_pmc_keyed</a></dt><p class="pad"></p>

<dt><a name="get_pmc_keyed_int"
>get_pmc_keyed_int</a></dt><p class="pad"></p>

<dt><a name="get_pmc_keyed_str"
>get_pmc_keyed_str</a></dt><p class="pad"></p>

<dt><a name="get_pointer"
>get_pointer</a></dt><p class="pad"></p>

<dt><a name="get_pointer_keyed"
>get_pointer_keyed</a></dt><p class="pad"></p>

<dt><a name="get_pointer_keyed_int"
>get_pointer_keyed_int</a></dt><p class="pad"></p>

<dt><a name="get_pointer_keyed_str"
>get_pointer_keyed_str</a></dt><p class="pad"></p>

<dt><a name="set_integer_native"
>set_integer_native</a></dt><p class="pad"></p>

<dd>Set the integer value of this PMC</dd><p class="pad"></p>

<dt><a name="set_integer_same"
>set_integer_same</a></dt><p class="pad"></p>

<dt><a name="set_integer_keyed"
>set_integer_keyed</a></dt><p class="pad"></p>

<dt><a name="set_integer_keyed_int"
>set_integer_keyed_int</a></dt><p class="pad"></p>

<dt><a name="set_integer_keyed_str"
>set_integer_keyed_str</a></dt><p class="pad"></p>

<dt><a name="set_number_native"
>set_number_native</a></dt><p class="pad"></p>

<dd>Set the floating&#45;point value of this PMC</dd><p class="pad"></p>

<dt><a name="set_number_same"
>set_number_same</a></dt><p class="pad"></p>

<dt><a name="set_number_keyed"
>set_number_keyed</a></dt><p class="pad"></p>

<dt><a name="set_number_keyed_int"
>set_number_keyed_int</a></dt><p class="pad"></p>

<dt><a name="set_number_keyed_str"
>set_number_keyed_str</a></dt><p class="pad"></p>

<dt><a name="set_bignum_int"
>set_bignum_int</a></dt><p class="pad"></p>

<dd>Set the extended&#45;precision value of this PMC</dd><p class="pad"></p>

<dt><a name="set_string_native"
>set_string_native</a></dt><p class="pad"></p>

<dd>Set the string value of this PMC</dd><p class="pad"></p>

<dt><a name="set_string_same"
>set_string_same</a></dt><p class="pad"></p>

<dt><a name="set_string_keyed"
>set_string_keyed</a></dt><p class="pad"></p>

<dt><a name="set_string_keyed_int"
>set_string_keyed_int</a></dt><p class="pad"></p>

<dt><a name="set_string_keyed_str"
>set_string_keyed_str</a></dt><p class="pad"></p>

<dt><a name="set_bool"
>set_bool</a></dt><p class="pad"></p>

<dd>Set the true/false value of this PMC</dd><p class="pad"></p>

<dt><a name="assign_pmc"
>assign_pmc</a></dt><p class="pad"></p>

<dd>Set the value to the value of the passed in</dd><p class="pad"></p>

<dt><a name="set_pmc"
>set_pmc</a></dt><p class="pad"></p>

<dd>Make the PMC refer to the PMC passed in</dd><p class="pad"></p>

<dt><a name="set_pmc_keyed"
>set_pmc_keyed</a></dt><p class="pad"></p>

<dt><a name="set_pmc_keyed_int"
>set_pmc_keyed_int</a></dt><p class="pad"></p>

<dt><a name="set_pmc_keyed_str"
>set_pmc_keyed_str</a></dt><p class="pad"></p>

<dt><a name="set_pointer"
>set_pointer</a></dt><p class="pad"></p>

<dt><a name="set_pointer_keyed"
>set_pointer_keyed</a></dt><p class="pad"></p>

<dt><a name="set_pointer_keyed_int"
>set_pointer_keyed_int</a></dt><p class="pad"></p>

<dt><a name="set_pointer_keyed_str"
>set_pointer_keyed_str</a></dt><p class="pad"></p>

<dt><a name="elements"
>elements</a></dt><p class="pad"></p>

<dd>Return the number of elements in the PMC, if the PMC is treated as an aggregate.</dd><p class="pad"></p>

<dt><a name="pop_integer"
>pop_integer</a></dt><p class="pad"></p>

<dt><a name="pop_float"
>pop_float</a></dt><p class="pad"></p>

<dt><a name="pop_string"
>pop_string</a></dt><p class="pad"></p>

<dt><a name="pop_pmc"
>pop_pmc</a></dt><p class="pad"></p>

<dt><a name="push_integer"
>push_integer</a></dt><p class="pad"></p>

<dt><a name="push_float"
>push_float</a></dt><p class="pad"></p>

<dt><a name="push_string"
>push_string</a></dt><p class="pad"></p>

<dt><a name="push_pmc"
>push_pmc</a></dt><p class="pad"></p>

<dt><a name="shift_integer"
>shift_integer</a></dt><p class="pad"></p>

<dt><a name="shift_float"
>shift_float</a></dt><p class="pad"></p>

<dt><a name="shift_string"
>shift_string</a></dt><p class="pad"></p>

<dt><a name="shift_pmc"
>shift_pmc</a></dt><p class="pad"></p>

<dt><a name="unshift_integer"
>unshift_integer</a></dt><p class="pad"></p>

<dt><a name="unshift_float"
>unshift_float</a></dt><p class="pad"></p>

<dt><a name="unshift_string"
>unshift_string</a></dt><p class="pad"></p>

<dt><a name="unshift_pmc"
>unshift_pmc</a></dt><p class="pad"></p>

<dt><a name="splice"
>splice</a></dt><p class="pad"></p>

<dt><a name="add"
>add</a></dt><p class="pad"></p>

<dt><a name="add_int"
>add_int</a></dt><p class="pad"></p>

<dt><a name="add_float"
>add_float</a></dt><p class="pad"></p>

<dt><a name="subtract"
>subtract</a></dt><p class="pad"></p>

<dt><a name="subtract_int"
>subtract_int</a></dt><p class="pad"></p>

<dt><a name="subtract_float"
>subtract_float</a></dt><p class="pad"></p>

<dt><a name="multiply"
>multiply</a></dt><p class="pad"></p>

<dt><a name="multiply_int"
>multiply_int</a></dt><p class="pad"></p>

<dt><a name="multiply_float"
>multiply_float</a></dt><p class="pad"></p>

<dt><a name="divide"
>divide</a></dt><p class="pad"></p>

<dt><a name="divide_int"
>divide_int</a></dt><p class="pad"></p>

<dt><a name="divide_float"
>divide_float</a></dt><p class="pad"></p>

<dt><a name="modulus"
>modulus</a></dt><p class="pad"></p>

<dt><a name="modulus_int"
>modulus_int</a></dt><p class="pad"></p>

<dt><a name="modulus_float"
>modulus_float</a></dt><p class="pad"></p>

<dt><a name="cmodulus"
>cmodulus</a></dt><p class="pad"></p>

<dt><a name="cmodulus_int"
>cmodulus_int</a></dt><p class="pad"></p>

<dt><a name="cmodulus_float"
>cmodulus_float</a></dt><p class="pad"></p>

<dt><a name="neg"
>neg</a></dt><p class="pad"></p>

<dt><a name="bitwise_or"
>bitwise_or</a></dt><p class="pad"></p>

<dt><a name="bitwise_or_int"
>bitwise_or_int</a></dt><p class="pad"></p>

<dt><a name="bitwise_and"
>bitwise_and</a></dt><p class="pad"></p>

<dt><a name="bitwise_and_int"
>bitwise_and_int</a></dt><p class="pad"></p>

<dt><a name="bitwise_xor"
>bitwise_xor</a></dt><p class="pad"></p>

<dt><a name="bitwise_xor_int"
>bitwise_xor_int</a></dt><p class="pad"></p>

<dt><a name="bitwise_ors"
>bitwise_ors</a></dt><p class="pad"></p>

<dt><a name="bitwise_ors_str"
>bitwise_ors_str</a></dt><p class="pad"></p>

<dt><a name="bitwise_ands"
>bitwise_ands</a></dt><p class="pad"></p>

<dt><a name="bitwise_ands_str"
>bitwise_ands_str</a></dt><p class="pad"></p>

<dt><a name="bitwise_xors"
>bitwise_xors</a></dt><p class="pad"></p>

<dt><a name="bitwise_xors_str"
>bitwise_xors_str</a></dt><p class="pad"></p>

<dt><a name="bitwise_not"
>bitwise_not</a></dt><p class="pad"></p>

<dt><a name="bitwise_shl"
>bitwise_shl</a></dt><p class="pad"></p>

<dt><a name="bitwise_shl_int"
>bitwise_shl_int</a></dt><p class="pad"></p>

<dt><a name="bitwise_shr"
>bitwise_shr</a></dt><p class="pad"></p>

<dt><a name="bitwise_shr_int"
>bitwise_shr_int</a></dt><p class="pad"></p>

<dt><a name="concatenate"
>concatenate</a></dt><p class="pad"></p>

<dt><a name="concatenate_native"
>concatenate_native</a></dt><p class="pad"></p>

<dt><a name="is_equal"
>is_equal</a></dt><p class="pad"></p>

<dt><a name="is_same"
>is_same</a></dt><p class="pad"></p>

<dt><a name="cmp"
>cmp</a></dt><p class="pad"></p>

<dt><a name="cmp_num"
>cmp_num</a></dt><p class="pad"></p>

<dt><a name="cmp_string"
>cmp_string</a></dt><p class="pad"></p>

<dt><a name="logical_or"
>logical_or</a></dt><p class="pad"></p>

<dt><a name="logical_and"
>logical_and</a></dt><p class="pad"></p>

<dt><a name="logical_xor"
>logical_xor</a></dt><p class="pad"></p>

<dt><a name="logical_not"
>logical_not</a></dt><p class="pad"></p>

<dt><a name="repeat"
>repeat</a></dt><p class="pad"></p>

<dt><a name="repeat_int"
>repeat_int</a></dt><p class="pad"></p>

<dt><a name="increment"
>increment</a></dt><p class="pad"></p>

<dt><a name="decrement"
>decrement</a></dt><p class="pad"></p>

<dt><a name="exists_keyed"
>exists_keyed</a></dt><p class="pad"></p>

<dt><a name="exists_keyed_int"
>exists_keyed_int</a></dt><p class="pad"></p>

<dt><a name="exists_keyed_str"
>exists_keyed_str</a></dt><p class="pad"></p>

<dt><a name="defined"
>defined</a></dt><p class="pad"></p>

<dt><a name="defined_keyed"
>defined_keyed</a></dt><p class="pad"></p>

<dt><a name="defined_keyed_int"
>defined_keyed_int</a></dt><p class="pad"></p>

<dt><a name="defined_keyed_str"
>defined_keyed_str</a></dt><p class="pad"></p>

<dt><a name="delete_keyed"
>delete_keyed</a></dt><p class="pad"></p>

<dt><a name="delete_keyed_int"
>delete_keyed_int</a></dt><p class="pad"></p>

<dt><a name="delete_keyed_str"
>delete_keyed_str</a></dt><p class="pad"></p>

<dt><a name="nextkey_keyed"
>nextkey_keyed</a></dt><p class="pad"></p>

<dt><a name="nextkey_keyed_int"
>nextkey_keyed_int</a></dt><p class="pad"></p>

<dt><a name="nextkey_keyed_str"
>nextkey_keyed_str</a></dt><p class="pad"></p>

<dt><a name="substr"
>substr</a></dt><p class="pad"></p>

<dt><a name="substr_str"
>substr_str</a></dt><p class="pad"></p>

<dt><a name="invoke"
>invoke</a></dt><p class="pad"></p>

<dt><a name="can"
>can</a></dt><p class="pad"></p>

<dt><a name="does"
>does</a></dt><p class="pad"></p>

<dt><a name="isa"
>isa</a></dt><p class="pad"></p>

<dt><a name="freeze"
>freeze</a></dt><p class="pad"></p>

<dt><a name="thaw"
>thaw</a></dt><p class="pad"></p>

<dt><a name="thawfinish"
>thawfinish</a></dt><p class="pad"></p>

<dt><a name="visit"
>visit</a></dt><p class="pad"></p>

<dt><a name="share"
>share</a></dt><p class="pad"></p>
</dl>

<h1><a name="LANGUAGE_NOTES"
>LANGUAGE NOTES <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>This PDD is due an overhaul. This requirements section is for language implementers to list the OO&#45;related needs of their language in so as to aid that.</p>

<h2><a name="PMCS"
>PMCS <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Ruby: Just like small talk, everything is an object. I&#39;m hoping to be able to implement core Ruby classes(String, Array, Hash, Module, etc) something like this.</p>

<p>ParrotClass | RubyClass String | | \ / RubyString</p>

<h2><a name="Objectspace"
>Objectspace <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Ruby: Objectspace in ruby allows the programmer to iterate through every live object in the system. There is some debate about how to make this play nice with different garbage collection schemes.</p>

<h2><a name="Classes"
>Classes <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>A class is a collection of methods and attributes. It would be desirable, for those classes whose definition is fully known at compile time, to have a convenient way to have the class along with its attributes and methods stored into a PBC file rather than created at runtime. However, creation of new classes at runtime will be needed too.</p>

<h2><a name="Meta&#45;classes"
>Meta&#45;classes <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Ruby: Ruby has meta classes. It would be nice if classes were objects in Parrots OO model.</p>

<h2><a name="Attributes"
>Attributes <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Attributes are instance data associated with a class (or role, however those are supported). They may not always be of a type specified by a PMC, though boxing/unboxing is of course an option.</p>

<p>Perl 6: All attributes are opaque (not externally visible, even to any subclasses).</p>

<p>.Net: Attributes may be private (not externally visible), public (always externally visible), protected (only visible to subclasses) and internal (only visible inside the current assembly &#45; the closest correspondence in Parrot is perhaps only visible inside the same PBC file). Additionally, it is allowable for a subclass to introduce an attribute of the same name as the a parent class has, and they both exist depending on what type an instance of the class is currently viewed as being (read: there is a difference between the type of the reference and the type of the value).</p>

<p>Ruby: Attributes can be dynamically added and removed at runtime.</p>

<h2><a name="Methods"
>Methods <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Perl 6: Methods may be public (anyone can invoke them) or private (only invokable by the class they are defined in). Additionally, submethods are methods that do not get inherited.</p>

<p>.Net: Like attributes, methods may be public, private, protected or internal.</p>

<p>Ruby: has a method_missing that gets called when method resolution fails to find a method. Methods can be dynamically added and removed at runtime.</p>

<h2><a name="Constructors"
>Constructors <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>A constructor is run when an object is instantiated.</p>

<p>.Net: There may be many constructors for an object (provided they all have different signatures), and the correct one is called based upon the passed parameters.</p>

<h2><a name="Inheritance"
>Inheritance <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Perl 6: Multiple inheritance.</p>

<p>.Net: Single inheritance.</p>

<p>Ruby: Single inheritance but support for mixins of ruby modules.</p>

<h2><a name="Interfaces"
>Interfaces <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>An interface specifies a set of methods that must be implemented by a class that inherits (or implements) the interface, but does not provide any form of implementation for them.</p>

<p>.Net: Interfaces are pretty much what was just describe above. XXX Need to check behavior of you implement two interfaces with methods of the same name.</p>

<h2><a name="Roles"
>Roles <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>A role consists of a set of methods and attributes. It cannot be instantiated on its own, but must be composed into a class. When this happens its methods and attributes become of that classes methods and attributes. This may happen at compile time or runtime, however when a role is composed into a class at runtime then what really happens is that a new anonymous class is created with the role composed into it and then the namespace entry for the existing class is updated to refer to the new one. Note that this means classes must be garbage collectable, with all those referred to by a namespace or with objects of that class existing being marked live.</p>

<p>Perl 6: Roles pretty much are a Perl 6 thing, so the definition above contains all that is needed. An open question is whether Parrot worry about collision detection? For compile time composition that&#39;s easy to punt to the compiler; for runtime composition, that&#39;s not so easy though.</p>

<h2><a name="Introspection_(aka_Reflection)"
>Introspection (aka Reflection) <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Perl 6: Reflection provides access to a list of methods that a class has, its parent classes and the roles it does, as well as the name of the class and its memory address. For methods, their name, signature, return type and whether the method is declared multi are available.</p>

<p>.Net: Reflection provides access to a list of attributes and methods as well as the name of the class and its parent. The types of attributes and signatures of methods are also available.</p>

<h2><a name="Inner_Classes"
>Inner Classes <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>An inner class is essentially a class defined within a class. Therefore it has access to things private to its outer class.</p>

<p>Perl 6: Inner classes are allowed, and may also be private.</p>

<p>.Net: Inner classes are allowed and may be private, public, protected or internal.</p>

<h2><a name="Delegation"
>Delegation <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Delegation is where a method call is &#34;forwarded&#34; to another class. Parrot may provide support for simple cases of it directly, or could just provide a &#34;no method matched&#34; fallback method that the compiler fills out to implement the delegation.</p>

<p>Perl 6: Delegation support is highly flexible, even allowing a regex to match method names that should be delegated to a particular object.</p>

<h2><a name="Prototype&#45;based_OO"
>Prototype&#45;based OO <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Prototype&#45;based OO has no classes. All objects are cloned from existing objects and modified. Requires lightweight singleton creation, without a needing separate class for every instance object. (Self, JavaScript, and Io are examples of prototype&#45;based 00.)</p>

<h1><a name="QUESTIONS"
>QUESTIONS <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>Should we have a super or next opcode?</p>

<h1><a name="NOTES"
>NOTES <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<h2><a name="Interaction_with_PMCs"
>Interaction with PMCs <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>The interaction between objects and PMCs is currently underspecified.</p>

<h2><a name="Translation"
>Translation <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>The following list a set of languages, then within each language what the parrot term translates to.</p>

<dl>
<dt><a name="Python"
>Python</a></dt><p class="pad"></p>

<dl>
<dt><a name="Attribute"
>Attribute</a></dt><p class="pad"></p>

<dd>A Python attribute maps to a parrot property</dd><p class="pad"></p>
</dl>

<dt><a name=".NET"
>.NET</a></dt><p class="pad"></p>

<dl>
<dt><a name="Attribute"
>Attribute</a></dt><p class="pad"></p>

<dd>What .NET calls an attribute parrot calls a property</dd><p class="pad"></p>

<dt><a name="Property"
>Property</a></dt><p class="pad"></p>

<dd>What .NET calls a property we call an attribute</dd><p class="pad"></p>
</dl>

<dt><a name="Generic_Terminology"
>Generic Terminology</a></dt><p class="pad"></p>

<dl>
<dt><a name="Instance_Variable"
>Instance Variable</a></dt><p class="pad"></p>

<dd>Instance Variables map to what we call attributes</dd><p class="pad"></p>
</dl>
</dl>

<h1><a name="ATTACHMENTS"
>ATTACHMENTS <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>None.</p>

<h1><a name="FOOTNOTES"
>FOOTNOTES <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>None.</p>

<h1><a name="REFERENCES"
>REFERENCES <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>None.</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
