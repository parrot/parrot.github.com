<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Garbage Collection Subsystems</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Garbage Collection Subsystems</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../html/index.html">Contents</a> | <a href="../../../html/docs.html">Documentation</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>docs/pdds/pdd09_gc.pod &#45; Garbage Collection Subsystems</p>

<h1><a name="ABSTRACT"
>ABSTRACT <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>This PDD describes how DOD/GC systems work,
and what&#39;s required of PMC classes.</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Doing DOD takes a bit of work&#45;&#45;we need to make sure that everything is findable from the root set,
and that we don&#39;t go messing up data shared between interpreters.</p>

<h1><a name="GC_TERMS"
>GC TERMS <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<h2><a name="GC_Schemes"
>GC Schemes <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>There are basically three general schemes to achieve garbage collection.</p>

<dl>
<dt><a name="Reference_counting"
>Reference counting</a></dt><p class="pad"></p>

<dd>All objects have a count,
how often they are refered to by other objects.
If that count reaches zero,
the object&#39;s space can be reclaimed.
This scheme can&#39;t cope with reference loops,
i.e,
a loop of dead objects,
all referencing one another but not reachable from elsewhere,
never gets collected.</dd><p class="pad"></p>

<dt><a name="Mark_and_Sweep"
>Mark and Sweep</a></dt><p class="pad"></p>

<dd>Starting from the root set (Parrot registers,
stacks,
internal structures) all reachable objects (and objects reachable from these) are marked being alive.</dd><p class="pad"></p>

<dd>Ojbects not reached are considered being dead and get collected by a sweep through the objects arenas.</dd><p class="pad"></p>

<dt><a name="Copying_collection"
>Copying collection</a></dt><p class="pad"></p>

<dd>Live objects are copied into a new memory region.
The old memory space can then be reclaimed.</dd><p class="pad"></p>
</dl>

<h2><a name="GC_Variants"
>GC Variants <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="stop&#45;the&#45;world"
>stop&#45;the&#45;world</a></dt><p class="pad"></p>

<dd>During a GC cycle the processing of user code is stopped.
Normal operation continues only after the whole GC cycle is performed.
This can lead to arbitrary long pauses during program execution.</dd><p class="pad"></p>

<dt><a name="incremental"
>incremental</a></dt><p class="pad"></p>

<dd>GC is done in small increments intermittent with normal program operation.</dd><p class="pad"></p>

<dt><a name="real&#45;time"
>real&#45;time</a></dt><p class="pad"></p>

<dd>The pauses caused by GC don&#39;t exceed a certain limit.</dd><p class="pad"></p>

<dt><a name="concurrent"
>concurrent</a></dt><p class="pad"></p>

<dd>The GC system runs as a separate thread and really concurrently on a multi&#45;processor machine.</dd><p class="pad"></p>

<dt><a name="parallel"
>parallel</a></dt><p class="pad"></p>

<dd>Multiple threads are participating in GC.</dd><p class="pad"></p>

<dt><a name="generational"
>generational</a></dt><p class="pad"></p>

<dd>The object space is divided between a young generation (short&#45;lived temporaries) and one or more old generations.
By not scanning the old generation this can considerably speed up GC.</dd><p class="pad"></p>
</dl>

<h1><a name="GC_SUBSYSTEMS"
>GC SUBSYSTEMS <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<h2><a name="Fix&#45;sized_Headers"
>Fix&#45;sized Headers <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>All managed objects (PMCs,
Strings,
Buffers) inside Parrot are subject to garbage collection.
As these objects aren&#39;t allowed to move after creation,
garbage collection is done by a non&#45;copying scheme.
Further: as we have to cope with pointers to objects on the C stack and in CPU registers,
the garbage collection scheme is a conservative one.</p>

<p>DOD/GC is normally triggered by allocation of new objects,
which happens usually from some stack nesting below the run&#45;loop.
There is a small chance that an integer on the C stack is misinterpreted as a pointer to an object.
This object would kept alive in such a case.</p>

<p>The live&#45;ness information gained by dead object detection (DOD) is also the base for collecting variable sized&#45;data that may hang off buffers.</p>

<h2><a name="Variable&#45;sized_Buffer_Memory"
>Variable&#45;sized Buffer Memory <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Variable&#45;sized memory like string memory gets collected,
when the associated header isn&#39;t found to be alive during DOD.
While a copying collection could basically[1] be done at any time,
its inefficient to copy buffers of objects that are non yet detected being dead.
This implies that before a collection in the memory pools is run,
a DOD run for fixed&#45;sized headers is triggered.</p>

<p>[1] Dead objects stay dead,
there is no possibility of a reusal of dead objects.</p>

<h1><a name="IMPLEMENTATION_OF_FIXED&#45;SIZED_HEADER_GC"
>IMPLEMENTATION OF FIXED&#45;SIZED HEADER GC <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<h2><a name="General_Notes"
>General Notes <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>GC subsystems are rather independent.
The goal for Parrot is just to provide new object headers in the fasted possible way.
How that is achieved can be considered as an implementation detail.</p>

<p>While GC subsystems are independent they may share some code to reduce Parrot memory footprint.
E.g.
stop&#45;the&#45;world mark and sweep and incremental mark and sweep use the same arena structures and share arena creation and DOD routines.</p>

<h2><a name="Initialization"
>Initialization <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Currently only one GC system is active (selected at configure or compile time).
But future versions might support switching GC systems during runtime to accommodate for different work loads.</p>

<dl>
<dt><a name="void_Parrot_gc_XXX_init(Interp_*)"
><b><code lang='und' xml:lang='und'>void Parrot_gc_XXX_init(Interp *)</b></code></a></dt><p class="pad"></p>

<dd>Initialize GC system named <code lang='und' xml:lang='und'>XXX</code>.</dd><p class="pad"></p>

<dd>Called from <em lang='und' xml:lang='und'>src/memory.c:mem_setup_allocator()</em> after creating <code lang='und' xml:lang='und'>arena_base</code>.
The initialization code is responsible for the creation of the header pools and has to fill the following function pointer slots in <code lang='und' xml:lang='und'>arena_base</code>:</dd><p class="pad"></p>
</dl>

<h2><a name="Arena_base_function_pointers"
>Arena_base function pointers <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="void_(*do_dod_run)_(Interp_*,_int_flags)"
><b><code lang='und' xml:lang='und'>void (*do_dod_run) (Interp *, int flags)</b></code></a></dt><p class="pad"></p>

<dd>Trigger or perform a DOD/GC run.</dd><p class="pad"></p>

<dd>Flags is one of:</dd><p class="pad"></p>

<dl>
<dt><a name="DOD_trace_normal_|_DOD_trace_stack_FLAG"
>DOD_trace_normal | DOD_trace_stack_FLAG</a></dt><p class="pad"></p>

<dd>Run a normal GC cycle.
This is normally called by resource shortage in the buffer memory pools before a collection is run.
The bit named <code lang='und' xml:lang='und'>DOD_trace_stack_FLAG</code> indicates that the C&#45;stack (and other system areas like the processor registers) have to be traced too.</dd><p class="pad"></p>

<dd>The implementation might or might not actually run a full GC cycle.
If e.g an incremental GC system just has finished the mark phase,
it would do nothing.
OTOH if no objects are currently marked live,
the implementation should run the mark phase,
so that copying of dead objects is avoided.</dd><p class="pad"></p>

<dt><a name="DOD_lazy_FLAG"
>DOD_lazy_FLAG</a></dt><p class="pad"></p>

<dd>Do a timely destruction run.
The goal is to either detect all objects that need timely destruction or to do a full collection.
In the former case the collection can be interrupted or postponed.
This is called from the Parrot run&#45;loop.
No system areas have to be traced.</dd><p class="pad"></p>

<dt><a name="DOD_finish_FLAG"
>DOD_finish_FLAG</a></dt><p class="pad"></p>

<dd>Called during interpreter destruction.
The GC subsystem must clear the live state of all objects and perform a sweep in the PMC header pool,
so that destructors and finalizers get called.</dd><p class="pad"></p>

<dt><a name="DOD_no_trace_volatile_roots"
>DOD_no_trace_volatile_roots</a></dt><p class="pad"></p>

<dd>Trace root set except volatile roots.
That is skip e.g.
registers.</dd><p class="pad"></p>
</dl>

<dt><a name="void_(*de_init_gc_system)_(Interp*)"
><b><code lang='und' xml:lang='und'>void (*de_init_gc_system) (Interp*)</b></code></a></dt><p class="pad"></p>

<dd>Called during interpreter destruction.
Free used resources and memory pools.</dd><p class="pad"></p>

<dt><a name="void_(*mark_object)_(Interp*,_Pobj*)"
><b><code lang='und' xml:lang='und'>void (*mark_object) (Interp*, Pobj*)</b></code></a></dt><p class="pad"></p>

<dd>Mark the object being live.
This function gets invoked by the following macro:</dd><p class="pad"></p>

<dt><a name="Parrot_pobj_lives(Interp*,_PObj_*)"
><b><code lang='und' xml:lang='und'>Parrot_pobj_lives(Interp*, PObj *)</b></code></a></dt><p class="pad"></p>

<dd>which might do nothing if the object is already marked live.</dd><p class="pad"></p>

<dt><a name="void_(*init_pool)_(Interp*,_struct_Small_Object_Pool_*)"
><b><code lang='und' xml:lang='und'>void (*init_pool) (Interp*, struct Small_Object_Pool *)</b></code></a></dt><p class="pad"></p>

<dd>A function to initialize the given pool.
This function should set the following object allocation functions for the given pool.</dd><p class="pad"></p>
</dl>

<h2><a name="Object_allocation"
>Object allocation <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Each header pool provides one function pointer to get a new object from that pool.</p>

<dl>
<dt><a name="PObj_*_(*get_free_object)_(Interp*,_struct_Small_Object_Pool*)"
><b><code lang='und' xml:lang='und'>PObj * (*get_free_object) (Interp*, struct Small_Object_Pool*)</b></code></a></dt><p class="pad"></p>

<dd>It should return one free object from the given pool.
Object flags are returned clear,
except flags that are used by the garbage collector itself.
If the pool is a buffer header pool,
all other object memory is zeroed.</dd><p class="pad"></p>
</dl>

<h2><a name="Write_Barrier"
>Write Barrier <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>The GC subsystem has to provide these (possibly empty) macros:</p>

<dl>
<dt><a name="DOD_WRITE_BARRIER(Interp*,_PMC_*agg,_PMC_*old,_PMC_*new)"
><b><code lang='und' xml:lang='und'>DOD_WRITE_BARRIER(Interp*, PMC *agg, PMC *old, PMC *new)</b></code></a></dt><p class="pad"></p>

<dd>This macro is invoked when in aggregate <code lang='und' xml:lang='und'>agg</code> the element <code lang='und' xml:lang='und'>old</code> is getting overritten by <code lang='und' xml:lang='und'>new</code>.
Both <code lang='und' xml:lang='und'>old</code> and <code lang='und' xml:lang='und'>new</code> may be NULL.</dd><p class="pad"></p>

<dt><a name="DOD_WRITE_BARRIER_KEY(Interp*,_PMC_*agg,_PMC_*old,_PObj_*old_key,_PMC_*new,_PObj_*new_key)"
><b><code lang='und' xml:lang='und'>DOD_WRITE_BARRIER_KEY(Interp*, PMC *agg, PMC *old, PObj *old_key, PMC *new, PObj *new_key)</b></code></a></dt><p class="pad"></p>

<dd>Like above.
Invoked when a hash key is inserted,
possibly replacing and old key.</dd><p class="pad"></p>
</dl>

<h2><a name="The_Arena_base_structure"
>The Arena_base structure <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>The <code lang='und' xml:lang='und'>arena_base</code> holds the mentioned function pointers,
pointers to the header pools,
some statistic counters,
and a pointer <code lang='und' xml:lang='und'>void *gc_private</code> reserved for the GC subsystem.</p>

<p>The GC subsystem is responsible for updating the appropriate statistic fields of the structure.</p>

<h2><a name="Blocking_GC"
>Blocking GC <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Being able to block GC and DOD is important&#45;&#45;you&#39;d hate to have the newly allocated Buffers or PMCs you&#39;ve got yanked out from underneath you.
That&#39;d be no fun.
Use the following routines to control GC:</p>

<dl>
<dt><a name="Parrot_block_DOD(Interp_*interpreter)"
>Parrot_block_DOD(Interp *interpreter)</a></dt><p class="pad"></p>

<dd>Block DOD for the passed interpreter.
(But <b>not</b> GC)</dd><p class="pad"></p>

<dt><a name="Parrot_block_GC(Interp_*interpreter)"
>Parrot_block_GC(Interp *interpreter)</a></dt><p class="pad"></p>

<dd>Block GC for the passed interpreter.
(But <b>not</b> DOD)</dd><p class="pad"></p>

<dt><a name="Parrot_unblock_DOD(Interp_*interpreter)"
>Parrot_unblock_DOD(Interp *interpreter)</a></dt><p class="pad"></p>

<dd>Unblock DOD for the passed interpreter.
(But not GC)</dd><p class="pad"></p>

<dt><a name="Parrot_unblock_GC(Interp_*interpreter)"
>Parrot_unblock_GC(Interp *interpreter)</a></dt><p class="pad"></p>

<dd>Unblock GC for the passed interpreter.
(But not DOD)</dd><p class="pad"></p>
</dl>

<p>Note that the blocking is recursive&#45;&#45;if you call Parrot_block_DOD() three times in succession,
you need to call Parrot_unblock_DOD() three times to re&#45;enable DOD.</p>

<h2><a name="Important_flags"
>Important flags <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>For PMCs and Buffers to be collected properly,
you <b>must</b> get the flags set on them properly.
Otherwise Bad Things Will Happen.</p>

<p>Note: don&#39;t manipulate these flags directly.
Always use the macros defined in <em lang='und' xml:lang='und'>include/parrot/pobj.h</em>.</p>

<dl>
<dt><a name="PObj_active_destroy_FLAG"
>PObj_active_destroy_FLAG</a></dt><p class="pad"></p>

<dd>The PMC has some sort of active destructor,
and will have that destructor called when the PMC is destroyed.</dd><p class="pad"></p>

<dt><a name="PObj_custom_mark_FLAG"
>PObj_custom_mark_FLAG</a></dt><p class="pad"></p>

<dd>The <code lang='und' xml:lang='und'>mark</code> vtable slot will be called during DOD.
The mark function must call <code lang='und' xml:lang='und'>Parrot_pobj_lives</code> for all non&#45;NULL objects that PMC refers too.</dd><p class="pad"></p>

<dd>Please note that <code lang='und' xml:lang='und'>Parrot_pobj_lives</code> may be a macro.</dd><p class="pad"></p>

<dt><a name="PObj_data_is_PMC_array_FLAG"
>PObj_data_is_PMC_array_FLAG</a></dt><p class="pad"></p>

<dd>Set if the data pointer points to an array of objects.
The length of the array is <code lang='und' xml:lang='und'>PMC_int_val(SELF)</code>.</dd><p class="pad"></p>

<dt><a name="PObj_external_FLAG"
>PObj_external_FLAG</a></dt><p class="pad"></p>

<dd>Set if the buffer points to memory that came from outside Parrot&#39;s memory system.</dd><p class="pad"></p>

<dt><a name="PObj_sysmem_FLAG"
>PObj_sysmem_FLAG</a></dt><p class="pad"></p>

<dd>Set if the memory came from the system malloc.
When the buffer is considered dead,
the memory will be freed back to the system.</dd><p class="pad"></p>

<dt><a name="PObj_COW_FLAG"
>PObj_COW_FLAG</a></dt><p class="pad"></p>

<dd>The buffer&#39;s memory is copy on write.
Any changes to the buffer must first have the buffer&#39;s memory copied.
The COW flag should then be removed.</dd><p class="pad"></p>
</dl>

<p>The following flags can be used by the GC subsystem:</p>

<dl>
<dt><a name="PObj_live_FLAG"
>PObj_live_FLAG</a></dt><p class="pad"></p>

<dd>The system considers the object to be alive for collection purposes.</dd><p class="pad"></p>

<dt><a name="PObj_on_free_list_FLAG"
>PObj_on_free_list_FLAG</a></dt><p class="pad"></p>

<dd>The object is unused,
and on the free list for later allocation.</dd><p class="pad"></p>

<dt><a name="PObj_custom_GC_FLAG"
>PObj_custom_GC_FLAG</a></dt><p class="pad"></p>

<dd>DWIM.</dd><p class="pad"></p>
</dl>

<h1><a name="ATTACHMENTS"
>ATTACHMENTS <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>None.</p>

<h1><a name="FOOTNOTES"
>FOOTNOTES <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>None.</p>

<h1><a name="REFERENCES"
>REFERENCES <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>None.</p>

<h1><a name="VERSION"
>VERSION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<h2><a name="CURRENT"
>CURRENT <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<pre lang='und' xml:lang='und'>    Maintainer: Dan Sugalski
    Class: Internals
    PDD Number: 9
    Version: 1.2
    Status: Developing
    Last Modified: 26 August 2004
    PDD Format: 1
    Language: English</pre>

<h2><a name="HISTORY"
>HISTORY <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="Version_1.2"
>Version 1.2</a></dt><p class="pad"></p>

<dd>26 August 2004</dd><p class="pad"></p>

<dt><a name="Version_1.1"
>Version 1.1</a></dt><p class="pad"></p>

<dd>26 February 2002</dd><p class="pad"></p>

<dt><a name="version_1"
>version 1</a></dt><p class="pad"></p>

<dd>None. First version</dd><p class="pad"></p>
</dl>

<h1><a name="CHANGES"
>CHANGES <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<dl>
<dt><a name="Version_1.2"
>Version 1.2</a></dt><p class="pad"></p>

<dd>Removed old flags. Documented GC schemes and subsystem interface.</dd><p class="pad"></p>

<dt><a name="Version_1.1"
>Version 1.1</a></dt><p class="pad"></p>

<dd>Started documenting the internal routines</dd><p class="pad"></p>

<dt><a name="Version_1.0"
>Version 1.0</a></dt><p class="pad"></p>

<dd>None. First version</dd><p class="pad"></p>
</dl>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
