<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Parrot IO</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Parrot IO</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../html/index.html">Contents</a> | <a href="../../../html/pmc.html">PMCs</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>src/pmc/parrotio.pmc &#45; Parrot IO</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>These are the vtable functions for Parrot IO.</p>

<h2><a name="Methods"
>Methods <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="METHOD_INTVAL_say(STRING_*s)"
><b><code lang='und' xml:lang='und'>METHOD INTVAL say(STRING *s)</b></code></a></dt><p class="pad"></p>

<dd>Print the string with an appended newline to SELF or to stdout if used as a class method.</dd><p class="pad"></p>

<dt><a name="METHOD_PMC*_open(STRING*_file,_STRING_*mode,_STRING*_layer)"
><b><code lang='und' xml:lang='und'>METHOD PMC *open(STRING *file, STRING *mode, STRING *layer)</b></code></a></dt><p class="pad"></p>

<dd>Opens the file with the given mode,
using the given IO layer.</dd><p class="pad"></p>

<dt><a name="METHOD_INTVAL_set_readline_interactive(INTVAL)"
><b><code lang='und' xml:lang='und'>METHOD INTVAL set_readline_interactive(INTVAL)</b></code></a></dt><p class="pad"></p>

<dd>Sets readline interactive mode to the given value,
if PARROT_HAS_READLINE is defined,
that is,
if the readline library is available.
The return values are:</dd><p class="pad"></p>

<ul>
<li>&#45;1</li><p class="pad"></p>

<p>readline isn&#39;t configured</p>

<li>&#45;2</li><p class="pad"></p>

<p>The file is not open/not input or not a tty,
if turning on interactive.</p>

<li>0 / 1</li><p class="pad"></p>

<p>old interactive setting</p>
</ul>

<dt><a name="METHOD_PMC*_readline(STRING*_prompt)"
><b><code lang='und' xml:lang='und'>METHOD PMC *readline(STRING *prompt)</b></code></a></dt><p class="pad"></p>

<dd>Reads a line from the given PIO.
If readline is interactive and a prompt is not empty,
it will be displayed.
The interactive feature is not available with the <code lang='und' xml:lang='und'>readline</code> opcode (which will be removed anyway).
Interactive mode adds non&#45;empty lines to the readline history.</dd><p class="pad"></p>

<dd>Returns the line without the newline in a String PMC.
If ^D/eof occurred,
this will return a Null PMC.</dd><p class="pad"></p>

<dd>SYNOPSIS</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>      pio = getstdin
      $I0 = pio.&#39;set_readline_interactive&#39;(1)
      if $I0 &#62;= 0 goto loop
      printerr &#34;set_readline_interactive failed: &#34;
      ...
  loop:
      $P1 = pio.&#39;readline&#39;(&#39;hello polly&#62; &#39;)
      if null $P1  goto ex
      ..
      goto loop
  ex:</pre>

<dt><a name="METHOD_STRING*_slurp(STRING*_name);"
>METHOD STRING* slurp(STRING* name);</a></dt><p class="pad"></p>

<dd>Slurp an (existing, disc) file named <i>name</i> into a STRING result.</dd><p class="pad"></p>

<dd>Please note that this method isn&#39;t catching any failures yet.</dd><p class="pad"></p>

<dd>Usage as class method:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  .local pmc cl
  cl = getclass &#39;ParrotIO&#39;
  $S0 = cl.&#39;slurp&#39;(&#39;the_file&#39;)</pre>

<dd>The file will be opened, read, and closed.</dd><p class="pad"></p>

<dd>Or with an openend file:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  pio = open &#39;the_file&#39;, &#39;&#60;&#39;
  $S0 = pio.&#39;slurp&#39;(&#39;&#39;)</pre>

<dd>This does <b>not</b> close the file.</dd><p class="pad"></p>

<dt><a name="void_class_init()"
><b><code lang='und' xml:lang='und'>void class_init()</b></code></a></dt><p class="pad"></p>

<dd>Class initialization.</dd><p class="pad"></p>

<dt><a name="METHOD_INTVAL_eof()"
><b><code lang='und' xml:lang='und'>METHOD INTVAL eof()</b></code></a></dt><p class="pad"></p>

<dd>Returns true or false according to the end of file state of the object.</dd><p class="pad"></p>

<dt><a name="METHOD_void_flush()"
><b><code lang='und' xml:lang='und'>METHOD void flush()</b></code></a></dt><p class="pad"></p>

<dd>Flushes pending writes.</dd><p class="pad"></p>

<dt><a name="METHOD_INTVAL_setbuf(INTVAL)"
><b><code lang='und' xml:lang='und'>METHOD INTVAL setbuf(INTVAL)</b></code></a></dt><p class="pad"></p>

<dd>XXX TBD</dd><p class="pad"></p>

<dt><a name="METHOD_INTVAL_setlinebuf()"
><b><code lang='und' xml:lang='und'>METHOD INTVAL setlinebuf()</b></code></a></dt><p class="pad"></p>

<dd>XXX TBD</dd><p class="pad"></p>

<dt><a name="void_init()"
><b><code lang='und' xml:lang='und'>void init()</b></code></a></dt><p class="pad"></p>

<dd>Initializes the IO PMC.</dd><p class="pad"></p>

<dt><a name="void_destroy()"
><b><code lang='und' xml:lang='und'>void destroy()</b></code></a></dt><p class="pad"></p>

<dd>Destroys the IO PMC, flushing and closing as necessary.</dd><p class="pad"></p>

<dt><a name="PMC*_clone()"
><b><code lang='und' xml:lang='und'>PMC *clone()</b></code></a></dt><p class="pad"></p>

<dd>Clones the IO PMC.</dd><p class="pad"></p>

<dd>For now, both PMCs refer to the same <code lang='und' xml:lang='und'>ParrotIO</code> object. If we have different IO layers, we might copy <code lang='und' xml:lang='und'>data</code> and <code lang='und' xml:lang='und'>struct_val</code>.</dd><p class="pad"></p>

<dt><a name="INTVAL_get_bool()"
><b><code lang='und' xml:lang='und'>INTVAL get_bool()</b></code></a></dt><p class="pad"></p>

<dd>Returns whether at <code lang='und' xml:lang='und'>EOF</code> or not.</dd><p class="pad"></p>

<dt><a name="STRING*_get_string_keyed_int(INTVAL_n)"
><b><code lang='und' xml:lang='und'>STRING *get_string_keyed_int(INTVAL n)</b></code></a></dt><p class="pad"></p>

<dd>Returns the name of the nth layer. <b>n</b> &#62;= 0 returns layer names up from the bottom. If <b>n</b> is negative, returns layer names from top down. For non&#45;existent layers, returns an empty string.</dd><p class="pad"></p>

<dt><a name="void_push_string(STRING*_value)"
><b><code lang='und' xml:lang='und'>void push_string(STRING *value)</b></code></a></dt><p class="pad"></p>

<dd>Pushes the layer name <code lang='und' xml:lang='und'>value</code> onto the PIO&#39;s layer stack.</dd><p class="pad"></p>

<dt><a name="STRING*_pop_string()"
><b><code lang='und' xml:lang='und'>STRING *pop_string()</b></code></a></dt><p class="pad"></p>

<dd>Pops a layer off the PIO&#39;s layer stack and returns its name.</dd><p class="pad"></p>
</dl>

<h1><a name="HISTORY"
>HISTORY <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Initial version by leo 2003/06/23.</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
