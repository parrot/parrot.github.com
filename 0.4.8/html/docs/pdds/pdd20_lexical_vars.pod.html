<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Lexical variables</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Lexical variables</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../html/index.html">Contents</a> | <a href="../../../html/docs.html">Documentation</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>docs/pdds/pdd20_lexical_vars.pod &#45; Lexical variables</p>

<h1><a name="VERSION"
>VERSION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>$Revision$</p>

<h1><a name="ABSTRACT"
>ABSTRACT <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>This document defines the requirements and implementation strategy for lexically scoped variables.</p>

<h1><a name="SYNOPSIS"
>SYNOPSIS <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<pre lang='und' xml:lang='und'>    .sub foo
        .lex &#34;$a&#34;, P0
        P1 = new Integer
        P1 = 13013
        store_lex &#34;$a&#34;, P1
        print P0            # prints 13013
    .end

    .sub bar :outer(foo)
        P0 = find_lex &#34;$a&#34;  # may succeed; depends on closure creation
    .end

    .sub baz
        P0 = find_lex &#34;$a&#34;  # guaranteed to fail: no .lex, no :outer()
    .end

    .sub corge
        print &#34;hi&#34;
    .end                    # no .lex and no :lex, thus: no LexInfo, no LexPad


    # Lexical behavior varies by HLL.  For example,
    # Tcl&#39;s lexicals are not declared at compile time.

    .HLL &#34;Tcl&#34;, &#34;tcl_group&#34;

    .sub grault :lex        # without &#34;:lex&#34;, Tcl subs have no lexicals
        P0 = find_lex &#34;x&#34;   # FAILS

        P0 = new Integer    # really TclInteger
        P0 = 42
        store_lex &#34;x&#34;, P0   # creates lexical &#34;x&#34;

        P0 = find_lex &#34;x&#34;   # SUCCEEDS
    .end</pre>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>For Parrot purposes, &#34;lexical variables&#34; are variables stored in a hash (or hash&#45;like) PMC associated with a subroutine invocation, a.k.a. a call frame.</p>

<h2><a name="Conceptual_Model"
>Conceptual Model <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<h3><a name="LexInfo_PMC"
>LexInfo PMC</a></h3>

<p>LexInfos contain what is known at compile time about lexical variables of a given subroutine: their names (for most languages), perhaps their types, etc. They are the interface through which the PIR compiler stores and validates compile&#45;time information about lexical variables.</p>

<p>At compile time, each newly created Subroutine (or Subroutine derivative, e.g. Closure) that uses lexical variables will be populated with a PMC of HLL&#45;mapped type LexInfo. (Note that this type may actually be Null in some HLLs, e.g. Tcl.)</p>

<h3><a name="LexPad_PMC"
>LexPad PMC</a></h3>

<p>LexPads hold what becomes known at run time about lexical variables of a given invocation of a given subroutine: their values, of course, and for some languages (e.g. Tcl) their names. They are the interface through which the Parrot runtime stores and fetches lexical variables.</p>

<p>At run time, each call frame for a Subroutine (or Subroutine derivative) that uses lexical variables will be populated with a PMC of HLL&#45;mapped type LexPad. Note that call frames for subroutines without lexical variables will omit the LexPad.</p>

<p>From the interface perspective, LexPads are basically Hashes, with strings as keys and PMCs as values. They extend the basic Hash interface with specialized initialization (requiring a reference to an associated LexInfo) and the query METHOD &#34;get_lexinfo()&#34; (to return it).</p>

<p>LexPad keys are unique. Therefore, in each subroutine, there can be only one lexical variable with a given name.</p>

<p>In the normal use case, LexPads are not exposed to user code (not for any special reason; it just worked out that way). Instead, specialized opcodes implement the common use cases. Specialized opcodes are particularly a Good Idea here because most lexical usage involves searching more than one LexPad, so a single LexPad reference wouldn&#39;t be as useful as one might expect. And, of course, opcodes can cheat ... er, can be written in optimized C. :&#45;)</p>

<p>TODO: Describe how lexical naming system interacts with non&#45;ASCII character sets.</p>

<h3><a name="Lexical_Lookup_Algorithm"
>Lexical Lookup Algorithm</a></h3>

<p>If Parrot is asked to access a lexical variable named $var, Parrot follows the following strategy. Note that fetch and store use the exact same approach.</p>

<p>Parrot starts with the currently executing subroutine $sub, then loops through these steps:</p>

<pre lang='und' xml:lang='und'>  1. Starting at the current call frame, walk back until an active frame is
     found that is executing $sub.  Call it $frame.

     (NOTE: The first time through, $sub is the current subroutine and $frame
     is the currently live frame.)

  2. Look for $var in $frame.get_lexpad using standard Hash methods.

  3. If the given pad contains $var, fetch/store it and REPORT SUCCESS.

  4. Set $sub to $sub.outer.  (That is, the textually enclosing subroutine.)
     But if $sub has no outer sub, REPORT FAILURE.</pre>

<h3><a name="LexPad_and_LexInfo_are_optional;_the_&#34;:lex&#34;_attribute"
>LexPad and LexInfo are optional; the &#34;:lex&#34; attribute</a></h3>

<p>Parrot does not assume that every subroutine needs lexical variables. Therefore, Parrot defaults to <i>not</i> creating LexInfo or LexPad PMCs. It only creates a Lexinfo when it first encounters a &#34;.lex&#34; directive in the subroutine. If no such directive is found, Parrot does not create a LexInfo for it at compile time, and therefore cannot create a LexPad for it at run time.</p>

<p>However, an absence of &#34;.lex&#34; directives is normal for some languages (e.g. Tcl) which lack compile&#45;time knowledge of lexicals. For these languages, the additional Subroutine attribute &#34;:lex&#34; should be specified. It forces Parrot to create LexInfo and LexPads.</p>

<h3><a name="Closures"
>Closures</a></h3>

<p>NOTE: This section should be taken using the &#34;as&#45;if&#34; rule: Parrot behaves as if this section were literally true. As always, short cuts (development and runtime) may be taken.</p>

<p>Closures are specialized Subroutines that carry their <i>lexical environment</i> along with them. A lexical environment, which we will call a &#34;LexEnv&#34; for brevity, is a list of LexPads to be searched when looking for lexical variables. Its implementation may be as simple as a basic PMC array, but any ordered integer&#45;indexed collection will do.</p>

<h3><a name="Closure_creation:_Capturing_the_lexical_environment"
>Closure creation: Capturing the lexical environment</a></h3>

<p>The <code lang='und' xml:lang='und'>newclosure</code> op creates a Closure from a Subroutine and gives that Closure a new LexEnv attribute. The LexEnv is then populated with pointers to the current <i>enclosing</i> LexPads. The definition of &#34;enclosing&#34; is not obvious, though.</p>

<p>The algorithm used to find &#34;enclosing&#34; LexPads is a loop of the following steps, starting with $sub set to the running Subroutine (which is a Closure):</p>

<pre lang='und' xml:lang='und'>  1. Starting at the current call frame, walk back until an active frame is
     found that is executing $sub.  Call it $frame.

     (NOTE: The first time through, $sub is the current subroutine and $frame
            is the currently live frame.)

  2. Append $frame&#39;s LexPad to the LexEnv.

  3. If $sub has a LexEnv, append $sub&#39;s LexEnv to the LexEnv being built,
     and END LOOP.  Otherwise:

  4. Set $sub to $sub.outer.  (That is, the textually enclosing subroutine.)
     But if $sub has no outer sub, END LOOP.</pre>

<p>NOTE: The <code lang='und' xml:lang='und'>newclosure</code> opcode should check to make sure that the target Subroutine has a :outer() attribute that points back to the currently running Subroutine. This is a requirement for closures.</p>

<h3><a name="Closure_runtime:_Using_the_lexical_environment"
>Closure runtime: Using the lexical environment</a></h3>

<p>At runtime, the <code lang='und' xml:lang='und'>find_lex</code> opcode behaves differently in closures. It has no need to walk the call stack finding LexPads &#45; they have all already been collected conveniently together in the LexEnv. Therefore, in a Closure, <code lang='und' xml:lang='und'>find_lex</code> <i>ignores</i> the call stack, and instead searches (1) the current call frame&#39;s LexPad &#45; i.e. the Closure&#39;s own lexicals &#45;&#45; and then (2) the LexPads in the LexEnv.</p>

<h3><a name="HLL_Type_Mapping"
>HLL Type Mapping</a></h3>

<p>The implementation of lexical variables in the PIR compiler depends on two new PMCs: LexPad and LexInfo. However, the default Parrot LexPad and LexInfo PMCs will not meet the needs of all languages. They should suit Perl 6, for example, but not Tcl.</p>

<p>Therefore, it is expected that HLLs will map the LexPad and LexInfo types to something more appropriate (e.g. TclLexPad and TclLexInfo). That mapping will automatically occur when the appropriate &#34;.HLL&#34; directive is in force.</p>

<p>Using Tcl as an extreme example: TclLexPad will likely be a thin veneer on PMCHash. Meanwhile, TclLexInfo will likely map to Null: Tcl provides no reliable compile&#45;time information about lexicals; without any compile&#45;time information to store, there&#39;s no need for TclLexInfo to do anything interesting.</p>

<h3><a name="Nested_Subroutines_Have_Outies;_the_&#34;:outer&#34;_attribute"
>Nested Subroutines Have Outies; the &#34;:outer&#34; attribute</a></h3>

<p>For HLLs that support nested subroutines, Parrot provides a way to denote that a given subroutine is conceptually &#34;inside&#34; another. Lookup for lexical variables starts at the current call frame and proceeds through call frames that invoke &#34;outer&#34; subroutines. The specific meaning of &#34;outer&#34; is defined below, but it&#39;s designed to support the common linguistic structure of nested subroutines where inner subs refer to lexical variables contained in outer blocks.</p>

<p>Note that &#34;outer&#34; and &#34;caller&#34; are very different concepts! For example, given the Perl 6 code:</p>

<pre lang='und' xml:lang='und'>   sub foo {
      my $a = 1;
      my sub a { eval &#39;$a&#39; }
      return &#38;a;
   }</pre>

<p>The &#38;foo subroutine is the outer subroutine of &#38;a, but it is not the caller of &#38;a.</p>

<p>In the above example, the definition of the Parrot subroutine implementing &#38;a must include a notation that it is textually enclosed within &#38;foo. This is a static attribute of a Subroutine, set at compile time and never changed thereafter. (Unless you&#39;re evil, or Damian. But I repeat myself.) This information is given through an &#34;:outer()&#34; subroutine attribute, e.g.:</p>

<pre lang='und' xml:lang='und'>    .sub a :outer(foo)</pre>

<p>Note that the &#34;foo&#34; sub <b>must</b> be compiled first; in other words, &#34;foo&#34; must appear before &#34;a&#34; in the source text. Compilers can easily do this via preorder traversal of lexically&#45;nested subs.</p>

<h2><a name="Required_Interfaces:_LexPad,_LexInfo,_Closure"
>Required Interfaces: LexPad, LexInfo, Closure <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<h3><a name="LexInfo"
>LexInfo</a></h3>

<p>Below are the standard LexInfo methods that all HLL LexInfo PMCs may support. Each LexInfo PMC should only define the methods that it can usefully implement, so the compiler can use method lookup failure to generate useful diagnostics (e.g. &#34;register aliasing not supported by Tcl lexicals&#34;).</p>

<p>Each language&#39;s LexInfo will implement methods that are helpful to that language&#39;s LexPad. In the extreme case, LexInfo can be Null &#45;&#45; but if it is, the given HLL should not generate any &#34;.lex*&#34; directives.</p>

<dl>
<dt><a name="void_init_pmc(PMC_*sub)"
><b>void init_pmc(PMC *sub)</b></a></dt><p class="pad"></p>

<dd>Called exactly once.</dd><p class="pad"></p>

<dt><a name="PMC_*get_sub()"
><b>PMC *get_sub()</b></a></dt><p class="pad"></p>

<dd>Return the associated Subroutine.</dd><p class="pad"></p>

<dt><a name="void_declare_lex_preg(STRING_*name,_INTVAL_preg)"
><b>void declare_lex_preg(STRING *name, INTVAL preg)</b></a></dt><p class="pad"></p>

<dd>Declare a lexical variable that is an alias for a PMC register. The PIR compiler calls this method in response to a <code lang='und' xml:lang='und'>.lex STRING, PREG</code> directive. For example, given this preamble:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    .lex &#34;$a&#34;, $P0
    $P1 = new Integer</pre>

<dd>These two opcodes have an identical effect:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    $P0 = $P1
    store_lex &#34;$a&#34;, $P1</pre>

<dd>And these two opcodes also have an identical effect:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    $P1 = $P0
    $P1 = find_lex &#34;$a&#34;</pre>
</dl>

<h3><a name="LexPad"
>LexPad</a></h3>

<p>LexPads start by implementing the Hash interface: variable names are string keys, and variable values are PMCs.</p>

<p>In addition, LexPads must implement the following methods:</p>

<dl>
<dt><a name="void_init_pmc(PMC_*lexinfo)"
><b>void init_pmc(PMC *lexinfo)</b></a></dt><p class="pad"></p>

<dd>Called exactly once. Note that Parrot guarantees that this method will be called after the new Context object is made current. It is recommended that any LexPad that aliases registers take a pointer to the current Context at init_pmc() time.</dd><p class="pad"></p>

<dt><a name="PMC_*get_lexinfo()"
><b>PMC *get_lexinfo()</b></a></dt><p class="pad"></p>

<dd>Return the associated LexInfo.</dd><p class="pad"></p>
</dl>

<h3><a name="Closure"
>Closure</a></h3>

<p>For debugging and introspection, the Closure PMC should support:</p>

<dl>
<dt><a name="PMC_*get_lexenv()"
><b>PMC *get_lexenv()</b></a></dt><p class="pad"></p>

<dd>Return the associated LexEnv, an ordered integer&#45;index collection (e.g. an Array) of LexPads captured at <code lang='und' xml:lang='und'>newclosure</code> time.</dd><p class="pad"></p>
</dl>

<h2><a name="Default_Parrot_LexPad_and_LexInfo"
>Default Parrot LexPad and LexInfo <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>The default LexInfo supports lexicals only as aliases for PMC registers. It therefore implements declare_lex_preg(). (Internally, it could be a Hash of some kind, where keys are String variable names and values are integer register numbers.)</p>

<p>The default LexPad (like all LexPads) implements the Hash interface. When asked to look up a variable, it finds the corresponding register number by querying its associated LexInfo. It then gets or sets the given numbered register in its associated Parrot Context structure.</p>

<h2><a name="Introspection_without_Call_Frame_PMCs"
>Introspection without Call Frame PMCs <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Due to implementation concerns, it will not be until late in Parrot development &#45;&#45; if ever &#45;&#45; that call frames will be available to user code as PMCs. Until then, the interpreter and continuation PMCs will be the interface to use to get frame info.</p>

<p>For example, to get the immediate caller&#39;s LexPad, use:</p>

<pre lang='und' xml:lang='und'>    $P0 = getinterp
    $P1 = $P0[&#34;lexpad&#34;; 1]</pre>

<p>It&#39;s likely that this interface will continue to be available even once call frames become visible as PMCs.</p>

<p>TODO: Full interpreter introspection interface.</p>

<h1><a name="ATTACHMENTS"
>ATTACHMENTS <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>None.</p>

<h1><a name="FOOTNOTES"
>FOOTNOTES <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>None.</p>

<h1><a name="REFERENCES"
>REFERENCES <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>None.</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
