<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>Parrot  - Parrot Compiler Tools</title>
        <link rel="stylesheet" type="text/css"
            href="../../../resources/parrot.css"
            media="all">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    </head>
    <body>
        <div id="wrapper">
            <div id="header">

                <a href="http://www.parrot.org">
                <img border=0 src="../../../resources/parrot_logo.png" id="logo" alt="parrot">
                </a>
            </div> <!-- "header" -->
            <div id="divider"></div>
            <div id="mainbody">
                <div id="breadcrumb">
                    <a href="../../../html/index.html">Home</a> &raquo; Parrot Compiler Tools
                </div>

<h1><a name="Parrot_Compiler_Tools"
>Parrot Compiler Tools</a></h1>

<p></p>

<p>So far we&#39;ve talked a lot about low&#45;level Parrot programming with PIR.
However,
the true power of Parrot is its ability to host programs written in high level languages such as Perl 6,
Python,
Ruby,
Tcl,
and PHP.
In order to write code in these languages developers need there to be compilers that convert from them into PIR or Parrot bytecode so that they can be executed by Parrot.
This process is analogous to how traditional compilers convert high level languages into assembly language or machine code for later assembly or direct execution.
However,
instead of compiling to the machine code for a particular hardware platform,
Parrot&#39;s language compilers output platform independent Parrot code that run on the virtual machine.
Parrot&#39;s suite of compiler tools perform all the necessary steps to make this conversion possible: Lexical analysis,
parsing,
optimization,
resource allocation and code generation.
When we say things like &#34;Lexical Analysis&#34; and &#34;Parsing&#34;,
people who have worked on compilers before may be anticipating that they will have to write these tools using <i>lex</i> or <i>yacc</i>.
The Parrot team is proud to say that this is not the case: Parrot&#39;s solutions to these problems are much nicer then that.</p>

<p>Instead of traditional lexical analyzers and parser&#45;generators that have been the mainstay of compiler designers for decades,
Parrot uses an advanced set of parsing tools called the Parrot Compiler Tools (PCT)<!--
	INDEX: Parrot Compiler Tools
-->.
PCT uses a subset of the Perl 6 programming language called <i>Not Quite Perl</i><!--
	INDEX: Not Quite Perl
--> (NQP) and an implementation of the Perl 6 Grammar Engine <!--
	INDEX: Perl 6 Grammar Engine
--> (PGE) to build compilers for Parrot.
We will talk about these in depth in chapters CHP&#45;5 Chapter 5 PGE and CHP&#45;6 Chapter 6 NQP.
Instead of using traditional low&#45;level languages to write compilers,
we can use a modern dynamic language like Perl 6 to write them instead.
As a note of interest this means that the Perl 6 compiler on Parrot is itself being written in Perl 6.
This is a mind&#45;boggling process known as <code>bootstrapping</code>.</p>

<p>The language&#45;neutrality of the interpreter was a conscious design decision.
In the early days of Parrot development the Parrot and Perl 6 projects were closely intertwined and it would have been easy for the two to overlap and intermingle throughout.
However,
by keeping the two projects separate and encapsulated the codebase became cleaner and more managable and the door was opened to support a whole host of other dynamic languages equally well.
This modular design also benefits future language designers,
not just designers of current languages.
Instead of targeting tools like <i>lex</i>/<i>yacc</i> and having to reimplement low&#45;level features such as garbage collection and dynamic data types,
language designers and compiler implementers can leave the details to Parrot and focus on the high&#45;level features of their language instead: syntax,
libraries,
capabilities.
Parrot implements all the necessary infrastructure and exposes a rich interface that all programming languages can make use of.
In fact,
since Parrot aims to support a wide variety of these languages,
it provides more features then any one of them would need.</p>

<p>For the benefit of it&#39;s high&#45;level languages,
Parrot supports a number of important features: A robust exceptions system,
compilation into platform&#45;independent bytecode,
a clean extension and embedding interface,
just&#45;in&#45;time compilation to machine code,
native library interface mechanisms,
garbage collection,
support for objects and classes,
and a robust concurrency model.
Parrot provides all of these things and more that compiler designers can use immediately without having to develop their own versions of these from the ground up.
Designing a new language or implementing a new compiler for an old language are easier and faster projects then anybody would expect them to be.</p>

<p>Language interoperability is a core goal for Parrot.
Different languages are suited to different tasks,
and picking which language to use in a large software project is a common planning problem.
There&#39;s rarely a perfect fit,
at least not for all individual parts of large complex projects.
Developers often find themselves settling for one particular language because it has the fewest disadvantages from among the alternatives.
Instead of forcing people to use just one for all parts like this,
Parrot provides the ability to easily and seamlessly combine multiple languages within a single project.
This opens up the potential to use well&#45;tested libraries from one language,
take advantage of clean problem&#45;domain expression in a second,
while binding these parts together in a third that elegantly captures the overall architecture.
It&#39;s about using languages according to their inherent strengths,
and mitigating the costs of their weaknesses.</p>

<h2><a name="PCT_Overview"
>PCT Overview</a></h2>

<p>The <!--
	INDEX: Parrot Compiler Tools;PCT
--> Parrot Compiler Tools (PCT) are a collection of tools and classes which handle the creation of a compiler and driver program for a high&#45;level language on Parrot.
Many of these tools were originally created by the Perl 6 development team to help with the development of their compiler project.
However,
PCT is used by compiler projects for many different languages to great effect.
Most developers would agree that writing a compiler using Perl 6 syntax and dynamic language tools is much nicer then having to write them in C,
<i>lex</i>,
and <i>yacc</i>.
More then 40 years after these venerable tools were first created,
we think we finally have a superior way to generate compilers.
Read on,
and we think you will agree.</p>

<p>PCT is composed of several classes that are used to implement various parts of a compiler.
These classes are subclassed by your compiler to fill in the languages&#45;specific details that your language requires.
The <!--
	INDEX: HLLCompiler
--> <code>PCT::HLLCompiler</code> class specifies the interface for the compiler and implements the compiler object that is used at runtime to parse and execute code.
The <!--
	INDEX: Parrot Compiler Tools;PCT::Grammar
--> <code>PCT::Grammar</code> and <!--
	INDEX: Parrot Compiler Tools;PCT::Grammar::Actions
--> <code>PCT::Grammar::Actions</code> classes are used to create the parser and syntax tree generator,
respectively.
Creating a new HLL compiler is as easy as subclassing these three entities with methods specific to your language.</p>

<h3><a name="Grammars_and_Action_Files"
>Grammars and Action Files</a></h3>

<p>Creating a compiler using PCT requires three basic files: The main entry point file,
the grammar specification file and the grammar actions file.
In addition,
compilers and the languages they implement often utilize large libaries of built&#45;in routines to help support compile&#45;time and runtime semantics.</p>

<ul>
<li>The main file</li>

<p>The main file is typically written in PIR and should contain the <code>:main</code> function that creates and executes the compiler object.
The new <code>PCT::HLLCompiler</code> object is located and instantiated,
the various necessary libraries are loaded,
and any special global variables are created and initialized.</p>

<p>The main file tends to be very short,
with the guts of the compiler logic implemented in the grammar and actions files,
and the various classes and library routines implemented in other files.
This is by convention,
however,
there is no particular reason why the main file cannot be large and complex if that&#39;s how you want to do it.</p>

<li>A grammar file</li>

<p>The grammar for the high level language is specified using the Perl 6 grammar engine (PGE) and is stored in a <code>.pg</code> file.
This file should subclass the <code>PCT::Grammar</code> class and implement all the necessary rules to successfully parse the language.</p>

<li>An actions file</li>

<p>Actions files are written in NQP,
a small language modeled on Perl 6 but with very few features and limited capabilities.
The actions file contains methods on the <code>PCT::Grammar:Actions</code> object which receive parse data from the grammar rules and use them to construct an <!--
	INDEX: Abstract Syntax Tree;Parrot Abstract Syntax Tree;AST;PAST
--> Abstract Syntax Tree (AST).
Our particular implementation of an AST is called the Parrot Abstract Syntax Tree (PAST).</p>
</ul>

<p>PCT allows a customizable workflow,
but the basic elements are simple.
The source code of the high level language is passed into the grammar engine which parses it and returns a <!--
	INDEX: PGE;Match Object
--> special Match object that represents a pattern in the code.
This match object is passed to the actions methods,
which convert the match into a PAST tree.
PCT then takes the PAST tree nd uses it to generate PIR code which can be saved to a file,
converted to bytecode,
or executed directly.</p>

<h3><a name="mk_language_shell.pl"
><code>mk_language_shell.pl</code></a></h3>

<p>The only way creating a new language compiler could be easier is if these files created themselves.
Luckily for us PCT includes a tool for automatically generating a new compiler project: <code>mk_language_shell.pl</code>.
This program automatically creates a new directory in <em>languages/</em> for your new language,
it creates the three files we mentioned above,
it creates starter files for libraries,
it creates a makefile to automate the build process,
and it creates a basic test harness for performing TAP&#45;based unit testing.
All of these are demonstrative stubs and will obviously need to be edited furiously or even completely overwritten,
but they give a good idea of what is needed to start on development of the compiler.
With a single command though,
you can create a working compiler,
albeit one for a very limited example language.
From there,
it&#39;s up to you to fill in all the details.</p>

<p><code>mk_language_shell.pl</code> is designed to be run from within the Parrot repository file structure.
You pass it on the command line the name of the new project to create.
There are no real rules about this,
but we do have some guidlines to keep things flowing smoothly.
Typically a new implementation of an existing language is given a special project name,
not the name of the language itself.
Consider the way Perl 5 distributions are named things like &#34;Active Perl&#34; or &#34;Strawberry Perl&#34;,
or how Python distributions might be &#34;IronPython&#34; or &#34;VPython&#34;.
So a Ruby&#45;on&#45;Parrot compiler wouldn&#39;t be called &#34;ruby&#34;,
we would use an implementation name like <em>cardinal</em>.
The TCL compiler on Parrot is likewise called <em>partcl</em>,
not just &#34;tcl&#34;.
Some languages take the convention of adding the prefix &#34;par&#45;&#34; to their language name,
and others try to come up with a name that is the name of a bird.
These are just some fun possibilities,
not limitations of any sort.
If you are implementing an entirely new language,
it might be a good idea to just name your project after the language you are implementing.
Let other implementations come up with creative project names for their work.</p>

<p>From the Parrot directory,
you invoke <code>mk_language_shell.pl</code> like this:</p>

<pre>  cd languages/
  perl ../tools/build/mk_language_shell.pl &#60;project name&#62;</pre>

<p>It will create all the files we described and then you can get to work on your new compiler.</p>

<h3><a name="Parsing_Fundamentals"
>Parsing Fundamentals</a></h3>

<p>Compilers typically consist of at least three components that we&#39;ve mentioned already: The lexical analyzer, the parser, and the code generator . The lexical analyzer converts the HLL input file into individual tokens. A token may consist of an individual punctuation mark(&#34;+&#34;), an identifier (&#34;myVar&#34;), a keyword (&#34;while&#34;), or any other artifact that cannot be sensibly broken down into smalle parts. The parser takes a stream of these input tokens, and attempts to match them against a given pattern, or grammar. The matching process orders the input tokens into an abstract syntax tree, which is a form that the computer can easily work with. The AST is passed to the code generator which converts it into code of the target language. For something like the GCC C compiler, the target language is machine code. For PCT and Parrot, the target languages are PIR and PBC.</p>

<p>Parsers come in two general varieties: Top&#45;down and bottom&#45;up. Top&#45;down parsers start with a top&#45;level rule, a rule which is supposed to represent the entire input. It attempts to match various combination of subrules until the entire input is matched. Bottom&#45;down parsers, on the other hand, start with individual tokens from the lexical analyzer and attempt to combine them together into larger and larger patterns until they produce a top&#45;level token.</p>

<p>PGE itself is one of a class of parsers called a <i>top&#45;down</i> parser, although it also contains a bottom&#45;up <i>operator precedence</i> parser, for things like mathematical expressions where bottom&#45;up methods are more efficient. We&#39;ll discuss both algorithms and the ways PGE switches between the two in the next chapter on PGE. An in&#45;depth discussion of the various parsing algorithms is well beyond the scope of this book, but we will try to give a coherent overview that will get new compiler writers started quickly.</p>

<h2><a name="Driver_Programs"
>Driver Programs</a></h2>

<p>The driver program for the new compiler must create instances of the various necessary classes that run the parser. It must also include the standard function libraries, create global variables, and handle commandline options. Most commandline options are handled by PCT, but there are some behaviors that the driver program will want to override.</p>

<p>PCT programs can, by default, be run in two ways: Interactive mode, which is run one statement at a time in the console, and file mode which loads and runs an entire file at once. For interactive mode, it is necessary to specify information about the prompt that&#39;s used and the environment that&#39;s expected. Help and error messages need to be written for the user too.</p>

<h3><a name="HLLCompiler_class"
><code>HLLCompiler</code> class</a></h3>

<p>The <code>HLLCompiler</code> class is a class that implements a compiler object. The compiler object contains references to parser grammar and actions files, it lets you specify the steps involved in the compilation process, and also implements some basic functionality that a compiler needs to provide. Let&#39;s take a look at a bare&#45;bones main file, like the one that would be created by <code>mk_language_shell.pl</code>:</p>

<pre>  .sub &#39;onload&#39; :anon :load :init
      load_bytecode &#39;PCT.pbc&#39;
      $P0 = get_hll_global [&#39;PCT&#39;], &#39;HLLCompiler&#39;
      $P1 = $P0.&#39;new&#39;()
      $P1.&#39;language&#39;(&#39;MyCompiler&#39;)
      $P1.&#39;parsegrammar&#39;(&#39;MyCompiler::Grammar&#39;)
      $P1.&#39;parseactions&#39;(&#39;MyCompiler::Grammar::Actions&#39;)
  .end

  .sub &#39;main&#39; :main
      .param pmc args
      $P0 = compreg &#39;MyCompiler&#39;
      $P1 = $P0.&#39;command_line&#39;(args)
  .end</pre>

<p>This basic driver consists of two parts. The first is an <code>:onload</code> function that creates the driver object as an instance of <code>HLLCompiler</code>, sets the necessary options, and registers the compiler with Parrot. The <code>:main</code> function is where parsing and execution begin. It calls the <code>compreg</code> opcode to retrieve the registered compiler object for the language &#34;MyCompiler&#34; and invokes that compiler object using the options received from the commandline.</p>

<p>It&#39;s worth noting here that the <code>compreg</code> opcode can be used more then once in a program for different languages. You can create multiple instances of a compiler object for a single language (such as for runtime eval) or you can create compiler objects for multiple languages for easy interoperability. The Rakudo Perl 6 <code>eval</code> function uses exactly this mechanism to allow runtime eval of code snippets in other languages for instance:</p>

<pre>  eval(&#34;...&#34;, :lang&#60;Ruby&#62;);</pre>

<h3><a name="HLLCompiler_methods"
><code>HLLCompiler</code> methods</a></h3>

<p>We saw several methods of the HLLCompiler method in the example above: <code>language</code>, <code>parsegrammar</code>, and <code>parseactions</code>. These all need to be called for a new compiler, and should be treated as a bare minimum interface to use. The <code>language</code> method takes a string argument that is the name of the compiler. The HLLCompiler object will use this name to register the compiler object with Parrot so that it can be retrieved later. The <code>parsegrammar</code> method is used to create a reference to the grammar file that you write with PGE. The <code>parseactions</code> method takes the class name of the NQP file used to create the AST&#45;generator for the compiler. There are several other methods that can be used as well:</p>

<blockquote>
<p>=item* <code>commandline_prompt</code></p>

<p>The <code>commandline_prompt</code> method allows you to specify a custom prompt to be used in interactive mode.</p>

<p>=item* <code>commandline_banner</code></p>

<p>The <code>commandline_banner</code> method allows you to specify a banner message that is displayed once when the compiler is executed in interactive mode.</p>
</blockquote>

<p><code>HLLCompiler</code> has other methods as well that are being developed and tested but these are the most important ones for now.</p>
            </div> <!-- "mainbody" -->
            <div id="divider"></div>
            <div id="footer">
	        Copyright &copy; 2002-2009, Parrot Foundation.
            </div>
        </div> <!-- "wrapper" -->
    </body>
</html>
