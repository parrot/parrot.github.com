<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>Parrot  - Grammar Actions</title>
        <link rel="stylesheet" type="text/css"
            href="../../../resources/parrot.css"
            media="all">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    </head>
    <body>
        <div id="wrapper">
            <div id="header">

                <a href="http://www.parrot.org">
                <img border=0 src="../../../resources/parrot_logo.png" id="logo" alt="parrot">
                </a>
            </div> <!-- "header" -->
            <div id="divider"></div>
            <div id="mainbody">
                <div id="breadcrumb">
                    <a href="../../../html/index.html">Home</a> &raquo; Grammar Actions
                </div>

<h1><a name="Grammar_Actions"
>Grammar Actions</a></h1>

<p>Protofunction signatures aren&#39;t the only way to apply functions to rules matched by the parser.
In fact,
they might be the most primitive because they use PIR code to implement the operator logic.
Another way has been made available,
by programming function actions in a language that&#39;s almost,
but Not Quite Perl (NQP).</p>

<p>NQP is a small language that&#39;s implemented as a subset of Perl 6 syntax and semantics.
It was originally developed as a bootstrapping tool to help allow the Rakudo Perl 6 compiler to be written in Perl 6 itself.
It has since been used to implement many other compilers on Parrot as well,
and has become a permanent member of the Parrot Compiler Toolkit (PCT).</p>

<p>NQP represents almost the smallest subset of the Perl 6 language necessary to implement the logic of a parser,
although some developers have complained enough to get a few extra syntactic features added in above the bare minimum.
NQP also happens to be a Perl 6 subset that&#39;s not entirely dissimilar from Perl 5,
so Perl 5 programmers should not be too lost when using it.</p>

<h2><a name="NQP_Basics"
>NQP Basics</a></h2>

<p>Like all flavors and versions of Perl,
NQP uses special prefix symbols called <i>sigils</i> to differentiate different types of variables.
The <code>$</code> sigil is used for scalars,
<code>@</code> is used for arrays,
and <code>%</code> is used for hashes Perl 6 aficionados will know that this isn&#39;t entirely true,
but an in&#45;depth look at Perl 6&#39;s context awareness is another topic for another book.
A &#34;scalar&#34; is really any single value,
and can interchangeably be given a string value,
or an integer value,
or an object reference.
In NQP we can write things like this:</p>

<pre> $scalar := &#34;This is a string&#34;
 $x      := 123
 $pi     := 3.1415      # rounding</pre>

<p>Wait a minute, what&#39;s that weird <code>:=</code> symbol? Why don&#39;t we just use the plain old vanilla <code>=</code> sign? The problem is that <i>NQP doesn&#39;t have it</i>. Remember how we mentioned that NQP was a minimal subset or Perl 6? The <code>:=</code> operator is the <i>bind</i> operator, that makes one value an alias <code>C programmers and the like may call it a &#34;reference&#34;</code> for another. In most cases you can ignore the distinction between the two, but be warned that it&#39;s not a regular variable assignment.</p>

<p>With hashes and arrays, it might be tempting to do a list assignment like we&#39;ve all grown familiar with in Perl 5 and other dynamic languages:</p>

<pre> @small_integers := (1, 2, 3, 4);                      # WRONG!
 %leading_ladies := (&#34;Trillian&#34; =&#62; &#34;Hitchhikers Guide&#34;,
                    &#34;Leia&#34; =&#62; &#34;Starwars&#34;);             # WRONG!</pre>

<p>Here&#39;s another little gotcha, NQP doesn&#39;t have list or hash context! If it&#39;s necessary to initialize a whole list at once, you can write:</p>

<pre> @small_integers[0] := 1;
 @small_integers[1] := 2;
 # ... And so on, and so forth ...</pre>

<p>It&#39;s also possible to assign a list in <i>scalar context</i> as follows:</p>

<pre> $array_but_a_scalar := (1, 2, 3, 4)</pre>

<p>Or, you could write a new function in PIR to create a new array from a variadic argument list:</p>

<pre> @my_array := create_new_array(1, 2, 3, 4)</pre>

<p>Which calls the PIR function:</p>

<pre> .namespace []
 .sub &#39;create_new_array&#39;
     .param pmc elems :slurpy
     .return(elems)
 .end</pre>

<p>Remember how we said NQP was a bare&#45;bones subset of Perl 6? It really doesn&#39;t have a lot of features that programmers might expect. In this chapter we will talk about some of the features and capabilities that it does have.</p>

<h3><a name="Calling_Actions_From_Rules"
>Calling Actions From Rules</a></h3>

<p>When talking about grammar rules, we discussed the funny little <code>{*}</code> symbol that calls an action. The action in question is an NQP method with the same name as the rule that calls it. NQP rules can be called with two different function signatures:</p>

<pre> method name ($/) { ... }</pre>

<p>And with a key:</p>

<pre> method name($/, $key) { ... }</pre>

<p>Here&#39;s an example that shows how the keys are used:</p>

<pre> rule cavepeople {
      &#39;Fred&#39;  {*}    #= Caveman
    | &#39;Wilma&#39; {*}    #= Cavewoman
    | &#39;Dino&#39;  {*}    #= Dinosaur
 }</pre>

<p>And here is the rule that tells us the result:</p>

<pre> method cavepeople($/, $key) {
    if $key eq &#39;Caveman&#39; {
        say &#34;We&#39;ve found a caveman!&#34;;
    } elsif $key eq &#39;Cavewoman&#39; {
        say &#34;We&#39;ve found a cavewoman!&#34;;
    } elsif $key eq &#39;Dinosaur&#39; {
        say &#34;A dinosaur isn&#39;t a caveperson at all!&#34;;
    }
 }</pre>

<p>The key is just a string that contains whatever text is on the line after the <code>#=</code> symbol. If we don&#39;t have a <code>#=</code> we don&#39;t use a <code>$key</code> in our method. If you attempt to use one without the other, the NQP compiler will die with error messages about mismatched argument/parameter numbers.</p>

<h3><a name="The_Match_Object_$/"
>The Match Object <code>$/</code></a></h3>

<p>The match object <code>$/</code> may have a funny&#45;looking name, but it&#39;s a data structure that&#39;s all business. It&#39;s both a hash and an array. Plus, since it&#39;s a special variable it also gets a special shortcut syntax that can be used to save a few keystrokes:</p>

<pre> $/{&#39;Match_item&#39;}   is the same as  $&#60;Match_item&#62;
 $/[0]              is the same as  $[0]</pre>

<p>In the match object, each item in the hash is named after one of the items that we matched in the rule. So, if we have a file with input &#34;<code>X + 5</code>&#34; and a rule:</p>

<pre> rule introductions {
    &#60;variable&#62; &#60;operator&#62; &#60;number&#62;
 }</pre>

<p>Our match object is going to look like this: <code>$/ = (&#34;variable&#34; =</code> &#34;x&#34;, &#34;operator&#34; =&#62; &#34;+&#34;, &#34;number&#34; =&#62; &#34;5&#34;)&#62;</p>

<p>If we have multiple values with the same name, or items with quantifiers <code>*</code> or <code>+</code> on it, those members of the match object may be arrays. So, if we have the input &#34;A A A B B&#34;, and the following rule:</p>

<pre> rule letters {
    &#60;vowel&#62;* &#60;consonant&#62;*
 }</pre>

<p>The match object will look like this (in Perl 5 syntax):</p>

<pre> $/ = (&#34;vowel&#34; =&#62; [&#34;A&#34;, &#34;A&#34;, &#34;A&#34;], &#34;consonant&#34; =&#62; [&#34;B&#34;, &#34;B&#34;])</pre>

<p>We can get the number of matches in each group by casting it to a scalar using the <code>$( )</code> operator:</p>

<pre> $($&#60;vowel&#62;) == 3</pre>

<h3><a name="Inline_PIR"
>Inline PIR</a></h3>

<p>Now that we know what the match object is, we can talk about the inline PIR functionality. In a PGE rule, we can use the <code>{{ }}</code> double curly brackets to go into inline&#45;PIR mode. Inside these brackets arbitrary PIR code can be executed to affect the operation of the parser. We can access the variable <code>$/</code> directly in the grammar without having to jump into NQP, and actually examine and affect the values in it.</p>

<h3><a name="PAST_Nodes"
>PAST Nodes</a></h3>

<p>The job of NQP is to make abstract syntax trees, and the PCT implementation of syntax trees is implemented in the PAST class. There are many different types of objects in the PAST class, each of which represents a particular program construct. These constructs are relatively common and simple, but there are powerful levels of configuration that allow complicated programming structures to be represented.</p>

<h3><a name="Making_Trees"
>Making Trees</a></h3>

<p>Every action has the ability to create a PAST node that represents that action and additional PAST nodes, that are children of that node. Calling the <code>make</code> command on that node adds it into the growing PAST tree that PCT maintains. Once the <code>TOP</code> rule matches successfully and returns, PCT takes that tree and starts the process of optimizing it and converting it into PIR and PBC code for execution.</p>
            </div> <!-- "mainbody" -->
            <div id="divider"></div>
            <div id="footer">
	        Copyright &copy; 2002-2009, Parrot Foundation.
            </div>
        </div> <!-- "wrapper" -->
    </body>
</html>
