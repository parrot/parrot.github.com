<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>Parrot  - Dynamic Opcodes</title>
        <link rel="stylesheet" type="text/css"
            href="../../../resources/parrot.css"
            media="all">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    </head>
    <body>
        <div id="wrapper">
            <div id="header">

                <a href="http://www.parrot.org">
                <img border=0 src="../../../resources/parrot_logo.png" id="logo" alt="parrot">
                </a>
            </div> <!-- "header" -->
            <div id="divider"></div>
            <div id="mainbody">
                <div id="breadcrumb">
                    <a href="../../../html/index.html">Home</a> &raquo; Dynamic Opcodes
                </div>

<h1><a name="Dynamic_Opcodes"
>Dynamic Opcodes</a></h1>

<p></p>

<p>The smallest executable component is not the compilation unit or even the subroutine,
but is actually the opcode.
Opcodes in Parrot,
like opcodes in other machines (both virtual and physical),
are individual instructions that implement low&#45;level operations in the machine.
In the world of microprocessors,
the word &#34;opcode&#34; typically refers to the numeric identifier for each instructions.
The human&#45;readable word used in the associated assembly language is called the &#34;mnemonic&#34;.
An assembler,
among other tasks,
is responsible for converting mnemonics into opcodes for execution.
In Parrot,
instead of referring to an instruction by different names depending on what form it&#39;s in,
we just call them all &#34;opcodes&#34;.
Of course the list of things that qualify as &#34;low&#45;level&#34; in Parrot can be pretty advanced compared to the functionality supplied by regular assembly language opcodes.</p>

<h2><a name="Opcodes"
>Opcodes</a></h2>

<p>Opcodes are the smallest logical execution element in Parrot.
An individual opcode corresponds,
in an abstract kind of way,
with a single machine code instruction for a particular hardware processor architecture.
The difference is that Parrot&#39;s opcodes can perform some very complex and high&#45;level tasks that each may take many execution cycles for the average hardware processor.
Also,
Parrot&#39;s opcodes can be dynamically loaded in from a special library file called a <i>dynop library</i>.
We&#39;ll talk about dynops a little bit later.</p>

<h3><a name="Opcode_naming"
>Opcode naming</a></h3>

<p>To the PIR and PASM programmers,
opcodes appear to be polymorphic.
That is,
some opcodes appear to have multiple argument formats.
This is just an illusion,
however.
Parrot opcodes are not polymorphic,
although certain features enable it to appear that way.
Different argument list formats are detected during parsing and translated into separate,
and unique,
opcode names.</p>

<h3><a name="Opcode_Multiple_Dispatch"
>Opcode Multiple Dispatch</a></h3>

<h2><a name="Writing_Opcodes"
>Writing Opcodes</a></h2>

<p>Writing Opcodes,
like writing PMCs,
is done in a C&#45;like language which is later compiled into C code by the <!--
	INDEX: opcode compiler
--> opcode compiler.
The opcode script represents a thin overlay on top of ordinary C code: All valid C code is valid opcode script.
There are a few neat additions that make writing opcodes easier.
This script is very similar to that used to define PMCs.
The <code>INTERP</code> constant,
for instance,
is always available in the opcodes like they are in VTABLE and METHOD declarations.
Unlike VTABLEs and METHODs,
opcodes are defined with the <code>op</code> keyword.</p>

<p>Opcodes are written in files with the <code>.ops</code> extension.
The core operation files are stored in the <code>src/ops/</code> directory.</p>

<h3><a name="Opcode_Parameters"
>Opcode Parameters</a></h3>

<p>Each opcode can take any fixed number of input and output arguments.
These arguments can be any of the four primary data types&#45;&#45;INTVALs,
PMCs,
NUMBERS and STRINGs&#45;&#45;but can also be one of several other types of values including LABELs,
KEYs and INTKEYs.</p>

<p>Each parameter can be an input,
an output or both,
using the <code>in</code>,
<code>out</code>,
and <code>inout</code> keywords respectively.
Here is an example:</p>

<pre>  op Foo (out INT, in NUM)</pre>

<p>This opcode could be called like this:</p>

<pre>  $I0 = Foo $N0     # in PIR syntax
  Foo $I0, $N0      # in PASM syntax</pre>

<p>When Parrot parses through the file and sees the <code>Foo</code> operation, it converts it to the real name <code>Foo_i_n</code>. The real name of an opcode is its name followed by an underscore&#45;separated ordered list of the parameters to that opcode. This is how Parrot appears to use polymorphism: It translates the overloaded opcode common names into longer unique names depending on the parameter list of that opcode. Here is a list of some of the variants of the <code>add</code> opcode:</p>

<pre>  add_i_i      # $I0 += $I1
  add_n_n      # $N0 += $N1
  add_p_p      # $P0 += $P1
  add_i_i_i    # $I0 = $I1 + $I2
  add_p_p_i    # $P0 = $P1 + $I0
  add_p_p_n    # $P0 = $P1 + $N0</pre>

<p>This isn&#39;t a complete list, but you should get the picture. Each different combination of parameters translates to a different unique operation, and each operation is remarkably simple to implement. In some cases, Parrot can even use its multi&#45;method dispatch system to call opcodes which are heavily overloaded, or for which there is no exact fit but the parameters could be coerced into different types to complete the operation. For instance, attempting to add a STRING to a PMC might coerce the string into a numerical type first, and then dispatch to the <code>add_p_p_n</code> opcode. This is just an example, and the exact mechanisms may change as more opcodes are added or old ones are deleted.</p>

<p>Parameters can be one of the following types:</p>

<ul>
<li>INT</li>

<li>NUM</li>

<li>STR</li>

<li>PMC</li>

<li>KEY</li>

<li>INTKEY</li>

<li>LABEL</li>
</ul>

<p>In addition to these types, you need to specify the direction that data is moving through that parameter:</p>

<ul>
<li>in</li>

<li>out</li>

<li>inout</li>

<li>invar</li>
</ul>

<h3><a name="Opcode_Control_Flow"
>Opcode Control Flow</a></h3>

<p>Some opcodes have the ability to alter control flow of the program they are in. There are a number of control behaviors that can be implemented, such as an unconditional jump in the <code>goto</code> opcode, or a subroutine call in the <code>call</code> code, or the conditional behavior implemented by <code>if</code>.</p>

<p>At the end of each opcode you can call a <code>goto</code> operation to jump to the next opcode to execute. If no <code>goto</code> is performed, control flow will continue like normal to the next operation in the program. In this way, opcodes can easily manipulate control flow. Opcode script provides a number of keywords to alter control flow:</p>

<ul>
<li>NEXT()</li>

<p>If <code>NEXT</code> contains the address of the next opcode in memory. You don&#39;t need to call <code>goto NEXT()</code>, however, because the default behavior for all opcodes is to automatically jump to the next opcode in the program You can do this if you really want to, but it really wouldn&#39;t help you any. The <code>NEXT</code> keyword is frequently used in places like the <code>invoke</code> opcode to create a continuation to the next opcode to return to after the subroutine returns.</p>

<li>ADDRESS()</li>

<p>Jumps execution to the given address.</p>

<pre>  ADDRESS(x);</pre>

<p>Here, <code>x</code> should be an <code>opcode_t *</code> value of the opcode to jump to.</p>

<li>OFFSET()</li>

<p>Jumps to the address given as an offset from the current address.</p>

<pre>  OFFSET(x)</pre>

<p>Here, <code>x</code> is an offset in <code>size_t</code> units that represents how far forward (positive) or how far backwards (negative) to jump to.</p>

<li>POP()</li>

<p><code>POP</code> pops the next opcode address off the control stack. To put an address onto the control stack, use the <code>PUSH</code> keyword instead. <code>PUSH</code> takes a single <code>opcode_t *</code> argument to store, and <code>POP</code> returns a single <code>opcode_ *</code> value.</p>
</ul>

<h2><a name="The_Opcode_Compiler"
>The Opcode Compiler</a></h2>

<p>As we&#39;ve seen in our discussions above, ops have a number of transformations to go through before they can be become C code and compiled into Parrot. The various special variables like <code>$1</code>, <code>INTERP</code> and <code>ADDRESS</code> need to be converted to normal variable values. Also, each runcore requires the ops be compiled into various formats: The slow and fast cores need the ops to be compiled into individual subroutines. The switch core needs all the ops to be compiled into a single function using a large <code>switch</code> statement. The computed goto cores require the ops be compiled into a large function with a large array of label addresses.</p>

<p>Parrot&#39;s opcode compiler is a tool that&#39;s tasked with taking raw opcode files with a <code>.ops</code> extension and converting them into several different formats, all of which need to be syntactically correct C code for compilation.</p>

<h2><a name="Dynops"
>Dynops</a></h2>

<p>Parrot has about 1200 built&#45;in opcodes. These represent operations which are sufficiently simple and fundamental, but at the same time are very common. However, these do not represent all the possible operations that some programmers are going to want to use. Of course, not all of those 1200 ops are unique, many of them are overloaded variants of one another. As an example there are about 36 variants of the <code>set</code> opcode, to account for all the different types of values you may want to set to all the various kinds of registers. The number of unique operations therefore is much smaller then 1200.</p>

<p>This is where <i>dynops</i> come in. Dynops are dynamically&#45;loadable libraries of ops that can be written and compiled separately from Parrot and loaded in at runtime. dynops, along with dynpmcs and runtime libraries are some of the primary ways that Parrot can be extended.</p>

<p>Parrot ships with a small number of example dynops libraries in the file <a href='TODO#dynoplibs%2F'>&#34;dynoplibs/&#34; in src</a>. These are small libraries of mostly nonsensical but demonstrative opcodes that can be used as an example to follow.</p>

<p>Dynops can be written in a <code>.ops</code> file like the normal built&#45;in ops are. The ops file should use <code>#include &#34;parrot/extend.h&#34;</code> in addition to any other libraries the ops need. They can be compiled into C using the opcode compiler, then compiled into a shared library using a normal C compiler. Once compiled, the dynops can be loaded into Parrot using the .loadlib directive.</p>
            </div> <!-- "mainbody" -->
            <div id="divider"></div>
            <div id="footer">
	        Copyright &copy; 2002-2009, Parrot Foundation.
            </div>
        </div> <!-- "wrapper" -->
    </body>
</html>
