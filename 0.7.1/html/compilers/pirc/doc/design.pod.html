<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
    <HEAD>
        <TITLE>description PIRC&#39;s design.</TITLE>
        <LINK REL="stylesheet" TYPE="text/css"
            HREF="../../../../resources/perl.css"
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY>
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">description PIRC&#39;s design.</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../../html/index.html">Contents</a> | <a href="../../../../html/compilers.html">Compilers</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>design.pod &#45; description PIRC&#39;s design.</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>This document describes the design and implementation of PIRC,
a PIR Compiler.
This document describes the hand&#45;written,
recursive&#45;descent implementation which can be found in <em lang='und' xml:lang='und'>compilers/pirc/src</em>.
This implementation is currently not actively maintained,
but kept here for potential future use.</p>

<p>For a new implementation of PIR,
you might want to look at <em lang='und' xml:lang='und'>compilers/pirc/new</em>,
which is an implementation using Bison and Flex.</p>

<h1><a name="OVERVIEW"
>OVERVIEW <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>PIRC currently consists of a PIR parser,
together with a lexer.
It also has the beginning of semantic actions in the parser.
Through the use of a vtable,
several back&#45;ends can be implemented,
leaving the parser untouched.</p>

<p>Documentation of the lexer and the parser can be generated by running:</p>

<pre lang='und' xml:lang='und'> make docs</pre>

<p>which will generate html files in the <code lang='und' xml:lang='und'>doc</code> directory.</p>

<p>This document will only provide a high&#45;level overview.</p>

<h1><a name="THE_LEXER"
>THE LEXER <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>The lexer is defined in <code lang='und' xml:lang='und'>pirlexer.c</code>. The header file lists all tokens that may be returned by the lexer.</p>

<p>The lexer reads the complete file contents into a buffer, from which it reads the individual words, or <i>tokens</i>. A buffer is much faster than using <code lang='und' xml:lang='und'>getc()</code> for each character, as I/O is relatively slow.</p>

<h1><a name="THE_PARSER"
>THE PARSER <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>The parser is defined in <code lang='und' xml:lang='und'>pirparser.c</code>. The header file only predeclares the <code lang='und' xml:lang='und'>parser_state</code> structure, but its definition is written in the C file, to hide the implementation details from other files. Access to specific fields is done through accessor functions, defined in the header file as well.</p>

<p>The parser communicates with the lexer through the lexer&#39;s accessor function. Of these, the <code lang='und' xml:lang='und'>next_token()</code> function is most important: it requests the next token from the lexer.</p>

<p>The parser does not know anything about the spelling of tokens, although it can request these through <code lang='und' xml:lang='und'>find_keyword()</code>.</p>

<h1><a name="SEMANTIC_ACTIONS"
>SEMANTIC ACTIONS <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>The parser calls at a number of places <code lang='und' xml:lang='und'>emit</code> functions. These are <i>hooks</i> to which a function can be hooked, that will be called when the parser calls that function. This is implemented using vtables. Of course, not all hooks need to be used. If a hook is not assigned a function by the user, the default empty function is invoked. This is done to prevent NULL checks; let&#39;s just hope the optimizer sees the invoked function is empty, so the overhead of calling it is removed.</p>

<h2><a name="Example_Vtable_methods"
>Example Vtable methods <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>This section gives a simple example to show how things are used. Let&#39;s consider a simplified version of a <code lang='und' xml:lang='und'>long_invocation</code>. Syntactically, it looks like this (this is the simplified version):</p>

<pre lang='und' xml:lang='und'> long&#45;invocation &#45;&#62; &#39;.begin_call&#39; &#39;\n&#39;
                    arguments
                    &#39;.call&#39; invokable &#39;\n&#39;
                    results
                    &#39;.end_call&#39; &#39;\n&#39;

 invocant &#45;&#62; IDENTIFIER | PREG</pre>

<p>The parsing routine for long&#45;invocation (again, its simplified version) looks as follows:</p>

<pre lang='und' xml:lang='und'> static void
 long_invocation(parser_state *p) {
      emit_invocation_start(p); /* indicate start of invocation */
      match(p, T_PCC_BEGIN);
      match(p, T_NEWLINE);
      arguments(p);

      match(p, T_PCC_CALL); /* check for token &#39;.call&#39; */
      match(p, T_NEWLINE);  /* check for a newline */

      /* get current token from lexer and store it as the invokable object */
      emit_invokable(p, get_current_token(p&#45;&#62;lexer));

      /* check whether it was an invokable object and get next token */
      switch (p&#45;&#62;curtoken) {
          case T_IDENTIFIER:
          case T_PREG:
              emit_invokable(p, get_current_token(p&#45;&#62;lexer));
              break;
          default:
              syntax_error(p, 1, &#34;invokable object expected&#34;);
              break;
      }

      results(p);

      match(p, T_PCC_END); /* accept token &#39;.end_call&#39; */
      match(p, T_NEWLINE); /* accept the newline token */
      emit_invocation_end(p); /* close down invocation sequence */

 }

 static void
 arguments(parser_state *p) {
      emit_args_start(p);   /* start sequence of arguments */
      /* handle arguments */
      emit_args_end(p); /* stop sequence of arguments */
 }

 static void
 results(p) {
      emit_results_start(p); /* start sequence of results */
      /* handle results */
      emit_results_end(p); /* stop sequence of results */
 }</pre>

<p>To each of the emit_* function calls, the writer of the back&#45;end can hook a custom function, that does the Appropiate Thing. What is appropiate, depends on the back&#45;end. Some back&#45;ends need to construct a data structure (AST) (for example the PBC backend would need this), others can just spit out what they get (like the PIR back&#45;end).</p>

<h2><a name="Supported_back&#45;ends"
>Supported back&#45;ends <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Currently, there are the following back&#45;end targets:</p>

<ul>
<li>PAST &#45; textual form of PAST using Data::Dumper format.</li><p class="pad"></p>

<li>PIR &#45; PIR output, which <i>may</i> change PIR syntax into PASM syntax.</li><p class="pad"></p>

<li>JSON &#45; JSON is extremely simple, and adding this back&#45;end was pretty easy.</li><p class="pad"></p>

<li>PBC &#45; but this one is not implemented at all. Just a stub file.</li><p class="pad"></p>
</ul>

<p>See src/pirvtable.{c,h} for details.</p>

<p>Please note that none of the back&#45;ends is complete.</p>

<h2><a name="VTable_Methods"
>VTable Methods <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>Now, you might ask yourself, who or what decides where these hooks, or vtable method calls are done. &#34;Why is there a hook over <i>here</i>?&#34; Well, that&#39;s done by figuring out at what moment a back&#45;end might need to get some information of the parser. As the parser continues, the tokens being read are lost, if they&#39;re not stored anywhere. So, every once and a while the back&#45;end needs to be able to store stuff, so it can do its job properly.</p>

<p>The vtable is not complete yet. There are a number of parsing routines that do not have associated vtable methods (invocations). Of course, we don&#39;t want the parser to do too much vtable invocations. On the other hand, if the parser does too few, constructing a back&#45;end might be impossible. It&#39;s a bit of a trade&#45;off.</p>

<h1><a name="OVERVIEW"
>OVERVIEW <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>This section gives an overview of what functionality is in what file:</p>

<ul>
<li>src/pirlexer.{c,h} &#45; implementation of the lexer</li><p class="pad"></p>

<li>src/pirparser.{c,h} &#45; implementation of the parser</li><p class="pad"></p>

<li>src/pirvtable.{c,h} &#45; constructor of an empty vtable</li><p class="pad"></p>

<li>src/pirout.{c,h} &#45; back&#45;end that implements the vtable methods to output PIR</li><p class="pad"></p>

<li>src/pastout.{c,h} &#45; back&#45;end that implements the vtable methods to output PAST (in Data::Dumper format)</li><p class="pad"></p>

<li>src/pbcout.{c,h} &#45; dummy back&#45;end for PBC. This file only creates a vtable, but no implementation yet.</li><p class="pad"></p>

<li>src/jsonout.{c,h} &#45; back&#45;end that implements the vtable methods to output JSON.</li><p class="pad"></p>

<li>src/pirmain.c &#45; main file for <code lang='und' xml:lang='und'>pirc</code>. Execution starts here.</li><p class="pad"></p>
</ul>

<h1><a name="WHAT_NEEDS_TO_BE_DONE"
>WHAT NEEDS TO BE DONE <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>There are some major TODOs:</p>

<ul>
<li>Check whether an identifier is actually a Parrot op. In IMCC, this is done by calling Parrot_is_builtin(). However, for that, we need a Parrot_Interp. Currently I have problems getting things to link correctly.</li><p class="pad"></p>

<li>Complete at least 1 back&#45;end, to see what more vtable entries we need. And of course, to generate PBC in the end.</li><p class="pad"></p>

<li>Complete the vtable structure with all needed vtable methods.</li><p class="pad"></p>

<li>Memory management; not all memory is freed at this moment. Does it need to be done by the back&#45;end, or by the parser?</li><p class="pad"></p>
</ul>

<h1><a name="AUTHOR"
>AUTHOR <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>Klaas&#45;Jan Stol &#60;parrotcode at gmail dot com&#62;</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../../resources/parrot_small.png"
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
