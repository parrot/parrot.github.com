<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
    <HEAD>
        <TITLE>Parrot class representing surfaces in Parrot SDL</TITLE>
        <LINK REL="stylesheet" TYPE="text/css"
            HREF="../../../../../resources/perl.css"
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY>
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Parrot class representing surfaces in Parrot SDL</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../../../html/index.html">Contents</a> | <a href="../../../../../html/libs.html">Libraries</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../../../resources/up.gif'></a></a></h1>

<p>SDL::Surface &#45; Parrot class representing surfaces in Parrot SDL</p>

<h1><a name="SYNOPSIS"
>SYNOPSIS <a href='#_top'><img alt='^' border=0 src='../../../../../resources/up.gif'></a></a></h1>

<pre lang='und' xml:lang='und'>    # load this library
    load_bytecode &#39;library/SDL/Surface.pir&#39;

    # create a new SDL::Surface object
    surface = new &#39;SDL::Surface&#39;
    surface.&#39;init&#39;( &#39;height&#39; =&#62; 480, &#39;width&#39; =&#62; 640 )

    # ... blit to, fill, update, and flip this surface as necessary</pre>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../../../resources/up.gif'></a></a></h1>

<p>A SDL::Surface object represents a surface in SDL. All drawing operations draw to a surface (and most draw from a surface). You&#39;ll likely not instantiate this class directly, but all SDL::Image and SDL::Sprite objects operate on objects of this class, and you&#39;ll receive an SDL::Surface from the SDL::App constructor.</p>

<h1><a name="METHODS"
>METHODS <a href='#_top'><img alt='^' border=0 src='../../../../../resources/up.gif'></a></a></h1>

<p>All SDL::Surface objects have the following methods:</p>

<dl>
<dt><a name="init(_surface_args_)"
>init( surface_args )</a></dt><p class="pad"></p>

<dd>Given a list of key&#45;value pairs, the attributes of this surface. The valid keys are <code lang='und' xml:lang='und'>height</code> and <code lang='und' xml:lang='und'>width</code>, two integer values representing the height and width of this surface in pixels. Other keys are <code lang='und' xml:lang='und'>depth</code>, the screen depth, <code lang='und' xml:lang='und'>flags</code>, the SDL flags, and <code lang='und' xml:lang='und'>r</code>, <code lang='und' xml:lang='und'>g</code>, <code lang='und' xml:lang='und'>b</code>, and <code lang='und' xml:lang='und'>a</code>, representing the bit depth of each component.</dd><p class="pad"></p>

<dt><a name="new_from_surface(_raw_surface_)"
>new_from_surface( raw_surface )</a></dt><p class="pad"></p>

<dd>Given a <code lang='und' xml:lang='und'>raw_surface</code> object, sometimes returned from raw SDL functions, create and return a new SDL::Surface object.</dd><p class="pad"></p>

<dd>I&#39;m not sure I like the name of this method. It may change. That may be okay; you have little reason to use it directly.</dd><p class="pad"></p>

<dt><a name="height()"
>height()</a></dt><p class="pad"></p>

<dd>Returns the height of this surface, in pixels. This is always an integer value.</dd><p class="pad"></p>

<dt><a name="width()"
>width()</a></dt><p class="pad"></p>

<dd>Returns the width of this surface, in pixels. This is always an integer value.</dd><p class="pad"></p>

<dt><a name="fill_rect(_rect,_color_)"
>fill_rect( rect, color )</a></dt><p class="pad"></p>

<dd>Given an SDL::Rect representing a portion of this surface and an SDL::Color representing a color, fills a portion of this surface with the given color.</dd><p class="pad"></p>

<dt><a name="update_rect(_rect_)"
>update_rect( rect )</a></dt><p class="pad"></p>

<dd>If this is a single&#45;buffered surface (unless you&#39;ve explicitly requested double buffering when intializing your SDL::App), updates the portion of this surface represented by the SDL::Rect.</dd><p class="pad"></p>

<dd>Do this on the main surface to see your changes.</dd><p class="pad"></p>

<dt><a name="update_rects(_array_of_rects_)"
>update_rects( array_of_rects )</a></dt><p class="pad"></p>

<dd>Updates multiple areas represented by SDL::Rect objects within this surface all at once. Pass in an <code lang='und' xml:lang='und'>Array</code> of rects to update.</dd><p class="pad"></p>

<dt><a name="flip()"
>flip()</a></dt><p class="pad"></p>

<dd>Given a double&#45;buffered surface (if you&#39;ve explicitly enabled double&#45;buffering when creating your SDL::App), flips the back buffer (to which you draw, in that case) to the main buffer, so you can see it.</dd><p class="pad"></p>

<dt><a name="blit(_source_surface,_source_rect,_destination_rect_)"
>blit( source_surface, source_rect, destination_rect )</a></dt><p class="pad"></p>

<dd>Given a SDL::Surface to use as a source, a SDL::Rect representing the source within the source surface, and a SDL::Rect representing the destination within the current surface to which to draw, copies the appropriate region from the source to this surface.</dd><p class="pad"></p>

<dd>That&#39;s a terrible sentence, but after you try it once or twice, you&#39;ll understand.</dd><p class="pad"></p>

<dt><a name="surface()"
>surface()</a></dt><p class="pad"></p>

<dd>Returns the underlying surface this object represents. You should never need to use this directly.</dd><p class="pad"></p>

<dt><a name="color_key(_color_)"
>color_key( color )</a></dt><p class="pad"></p>

<dd>Sets the transparent pixel value for the surface. This signature may change, if I add flag options.</dd><p class="pad"></p>

<dt><a name="bpp()"
>bpp()</a></dt><p class="pad"></p>

<dd>Returns the bitdepth of the current surface.</dd><p class="pad"></p>

<dt><a name="lock()"
>lock()</a></dt><p class="pad"></p>

<dd>Locks the surface for raw pixel drawing. Call this before calling <code lang='und' xml:lang='und'>draw_pixel()</code> or any other pixel operation. Be careful what else you do while you hold the lock.</dd><p class="pad"></p>

<dt><a name="unlock()"
>unlock()</a></dt><p class="pad"></p>

<dd>Unlocks the surface after you&#39;ve finished raw pixel operations.</dd><p class="pad"></p>

<dt><a name="draw_pixel(_x,_y,_color_)"
>draw_pixel( x, y, color )</a></dt><p class="pad"></p>

<dd>Draws a pixel at the position represented by integers <code lang='und' xml:lang='und'>x</code> and <code lang='und' xml:lang='und'>y</code> with the given SDL::Color <code lang='und' xml:lang='und'>color</code>.</dd><p class="pad"></p>

<dd>If you want as much speed as possible, call <code lang='und' xml:lang='und'>color_for_surface</code> on the SDL::Color and pass in the value you receive instead. This method will not have to perform a time&#45;consuming conversion. This is a classic tradeoff between memory and speed. Happily, colors are (reasonably cheap) integers at heart.</dd><p class="pad"></p>

<dt><a name="pixels()"
>pixels()</a></dt><p class="pad"></p>

<dd>Return the raw pixels array of the surface. It can be filled with raw colors like this:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  .local pmc surface, pixels
  .local int offset, x, y, raw_color
  pixels  = surface.&#39;pixels&#39;()
  offset  = surface.&#39;width&#39;()
  ...
  $I0 = offset * y
  $I0 .= x
  pixels[0; $I0] = raw_color       # pixels[&#39;array&#39;; $O] = raw_color</pre>

<dd>Please note that the function returns an UnManagedStruct pointing to an array, therefore the double indexing is needed.</dd><p class="pad"></p>

<dd>See also <b>draw_pixels()</b> above for locking/unlocking the surface and how to fetch raw colors.</dd><p class="pad"></p>

<dt><a name="convert_red()"
>convert_red()</a></dt><p class="pad"></p>

<dd>A helper method to convert the red component of any color to work with this surface.</dd><p class="pad"></p>

<dt><a name="convert_green()"
>convert_green()</a></dt><p class="pad"></p>

<dd>A helper method to convert the green component of any color to work with this surface.</dd><p class="pad"></p>

<dt><a name="convert_blue()"
>convert_blue()</a></dt><p class="pad"></p>

<dd>A helper method to convert the blue component of any color to work with this surface.</dd><p class="pad"></p>
</dl>

<h1><a name="AUTHOR"
>AUTHOR <a href='#_top'><img alt='^' border=0 src='../../../../../resources/up.gif'></a></a></h1>

<p>Written and maintained by chromatic, &#60;chromatic at wgz dot org&#62;, with suggestions from Jens Rieks. Please send patches, feedback, and suggestions to the Perl 6 Internals mailing list.</p>

<h1><a name="COPYRIGHT"
>COPYRIGHT <a href='#_top'><img alt='^' border=0 src='../../../../../resources/up.gif'></a></a></h1>

<p>Copyright (C) 2004&#45;2008, The Perl Foundation.</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../../../resources/parrot_small.png"
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
