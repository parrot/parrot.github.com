<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
    <HEAD>
        <TITLE>parser for Parrot Intermediate Representation</TITLE>
        <LINK REL="stylesheet" TYPE="text/css"
            HREF="../../../../resources/perl.css"
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY>
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">parser for Parrot Intermediate Representation</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../../html/index.html">Contents</a> | <a href="../../../../html/compilers.html">Compilers</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>pirparser.c &#45; parser for Parrot Intermediate Representation</p>

<h1><a name="THOUGHTS_FOR_LATER"
>THOUGHTS FOR LATER <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<ul>
<li>Add error correcting stuff,
so parsing can continue after simple errors.</li><p class="pad"></p>

<li>Maybe use #define&#39;s to implement small functions.
Effectively,
these routines will be inlined in compilation_unit() or instruction(),
but when using #define&#39;s it&#39;s still code that looks good.</li><p class="pad"></p>

<li>Skip first token of statements if it&#39;s sure that the token has already been checked by the caller.
For instance,
no need to match &#39;goto&#39; again,
if it was already checked in compilation_unit().</li><p class="pad"></p>

<li>Maybe use compilers/bcg for back&#45;end,
if that would fit well.</li><p class="pad"></p>
</ul>

<h1><a name="PARSER_INTERNALS"
>PARSER INTERNALS <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<p>The parser_state structure has the following fields:</p>

<pre lang='und' xml:lang='und'> typedef struct parser_state {
   struct     lexer_state *lexer; &#45;&#45; the lexer
   token      curtoken;           &#45;&#45; the current token as returned by the lexer
   char     **heredoc_ids;        &#45;&#45; array for holding heredoc arguments
   unsigned   heredoc_index;      &#45;&#45; index to keep track of heredoc ids in the array
   unsigned   parse_errors;       &#45;&#45; counter for parse_errors
   pirvtable *vtable;             &#45;&#45; vtable holding pointers for output routines
 }</pre>

<h1><a name="PARSER_API"
>PARSER API <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<dl>
<dt><a name="void_exit_parser(parser_state_*p)"
><b><code lang='und' xml:lang='und'>void exit_parser(parser_state *p)</b></code></a></dt><p class="pad"></p>

<dd>Clean up and exit the program normally.</dd><p class="pad"></p>

<dt><a name="int_get_parse_errors(parser_state_*p)"
><b><code lang='und' xml:lang='und'>int get_parse_errors(parser_state *p)</b></code></a></dt><p class="pad"></p>

<dd>return the number of parse errors.</dd><p class="pad"></p>

<dt><a name="parser_state_*_new_parser(char_const_*_filename,_pirvtable_*vtable)"
><b><code lang='und' xml:lang='und'>parser_state *new_parser(char const *filename, pirvtable *vtable)</b></code></a></dt><p class="pad"></p>

<dd>constructor for a parser_state object. The specified filename is parsed. The semantic actions in vtable are called at certain points in the code. The vtable is constructed in the parser&#39;s client code.</dd><p class="pad"></p>

<dt><a name="struct_lexer_state_const_*_get_lexer(parser_state_*p)"
><b><code lang='und' xml:lang='und'>struct lexer_state const *get_lexer(parser_state *p)</b></code></a></dt><p class="pad"></p>

<dd>returns the specified parser&#39;s lexer</dd><p class="pad"></p>

<dt><a name="token_get_token(parser_state_*p)"
><b><code lang='und' xml:lang='und'>token get_token(parser_state *p)</b></code></a></dt><p class="pad"></p>

<dd>returns the specified parser&#39;s current token</dd><p class="pad"></p>
</dl>

<h1><a name="HELPER_FUNCTIONS"
>HELPER FUNCTIONS <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<dl>
<dt><a name="static_void_resize_heredoc_args(parser_state_*p)"
><b><code lang='und' xml:lang='und'>static void resize_heredoc_args(parser_state *p)</b></code></a></dt><p class="pad"></p>

<dd>Reallocate memory for the array holding heredoc arguments. If needed, the array is resized to twice its previous size. So, initially it&#39;s MAX_HEREDOC_ARGS, after the first resize(), it&#39;s 2 times MAX_HEREDOC_ARGS, after the second time it&#39;s 2 * 2 * MAX_HEREDOC_ARGS, etc.</dd><p class="pad"></p>

<dt><a name="static_void_syntax_error(parser_state_*p,_int_numargs,_...)"
><b><code lang='und' xml:lang='und'>static void syntax_error(parser_state *p, int numargs, ...)</b></code></a></dt><p class="pad"></p>

<dd>Handle all syntax error through this function. numargs is the number of variable arguments. All arguments should be of type &#34;char *&#34; !!!</dd><p class="pad"></p>

<dt><a name="static_void_match(parser_state_*p,_token_expected)"
><b><code lang='und' xml:lang='und'>static void match(parser_state *p, token expected)</b></code></a></dt><p class="pad"></p>

<dd>checks whether the current token is the same as the expected token. If so, all is ok, and the next token is fetched. If not, an appropiate syntax error is reported.</dd><p class="pad"></p>
</dl>

<h1><a name="GRAMMAR"
>GRAMMAR <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h1>

<h2><a name="Conventions"
>Conventions <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<p>The following conventions are used:</p>

<pre lang='und' xml:lang='und'> [ foo ]       indicate an optional foo element
 { foo }       indicate zero or more foo elements
 ( foo | bar ) either foo or bar
 IDENTIFIER    match a token of type IDENTIFIER
 &#39;string&#39;      match the literal &#39;string&#39;</pre>

<h2><a name="Grammar_rules"
>Grammar rules <a href='#_top'><img alt='^' border=0 src='../../../../resources/up.gif'></a></a></h2>

<h3><a name="Expressions"
>Expressions</a></h3>

<dl>
<dt><a name="static_token_expression(parser_state_*p)"
><b><code lang='und' xml:lang='und'>static token expression(parser_state *p)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  expression &#45;&#62; ( IDENTIFIER | INTC | NUMC | STRINGC | register )</pre>

<dt><a name="static_void_string_value(parser_state_*p)"
><b><code lang='und' xml:lang='und'>static void string_value(parser_state *p)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  string_value &#45;&#62; SREG | PASM_SREG | STRINGC</pre>

<dt><a name="static_void_method(parser_state_*p)"
><b><code lang='und' xml:lang='und'>static void method(parser_state *p)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  method &#45;&#62; IDENTIFIER | STRINGC</pre>

<dt><a name="static_void_target(parser_state_*p)"
><b><code lang='und' xml:lang='und'>static void target(parser_state *p)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  target   &#45;&#62; register | IDENTIFIER</pre>

<dt><a name="static_void_type(parser_state_*p)"
><b><code lang='und' xml:lang='und'>static void type(parser_state *p)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  type &#45;&#62; &#39;int&#39; | &#39;num&#39; | &#39;pmc&#39; | &#39;string&#39;</pre>

<dt><a name="static_void_key(parser_state_*p)"
><b><code lang='und' xml:lang='und'>static void key(parser_state *p)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  key &#45;&#62; &#39;&#45;&#39; expression | &#39;..&#39; expression | expression [ &#39;..&#39; [ expression ] ]</pre>

<dt><a name="static_void_keylist(parser_state_*p)"
><b><code lang='und' xml:lang='und'>static void keylist(parser_state *p)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  keylist &#45;&#62; &#39;[&#39; key { (&#39;;&#39;|&#39;,&#39;) key } &#39;]&#39;</pre>

<dt><a name="static_void_arg_flags(parser_state_*p)"
><b><code lang='und' xml:lang='und'>static void arg_flags(parser_state *p)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  arg_flags &#45;&#62; { arg_flag }

  arg_flag &#45;&#62; &#39;:flat&#39; | &#39;:named&#39; [ &#39;(&#39; STRINGC &#39;)&#39; ]</pre>

<dt><a name="static_void_argument(parser_state_*p)"
><b><code lang='und' xml:lang='und'>static void argument(parser_state *p)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  argument &#45;&#62; HEREDOCID | expression arg_flags | STRINGC (&#39;=&#62;&#39; expression | arg_flags)</pre>

<dt><a name="static_void_argument_list(parser_state_*p)"
><b><code lang='und' xml:lang='und'>static void argument_list(parser_state *p)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  argument_list &#45;&#62; argument { &#39;,&#39; argument }</pre>

<dt><a name="static_void_arguments(parser_state_*p)"
><b><code lang='und' xml:lang='und'>static void arguments(parser_state *p)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  arguments &#45;&#62; &#39;(&#39; [argument_list] &#39;)&#39; heredoc_arguments

  heredoc_arugments &#45;&#62; { HEREDOC_STRING }</pre>
</dl>

<h3><a name="Statements"
>Statements</a></h3>

<dl>
<dt><a name="static_void_methodcall(parser_state_*p)"
><b><code lang='und' xml:lang='und'>static void methodcall(parser_state *p)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  methodcall &#45;&#62; INVOCANT_IDENT method arguments</pre>

<dt><a name="static_void_arith_expression(parser_state_*p)"
><b><code lang='und' xml:lang='und'>static void arith_expression(parser_state *p)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  arith_expr &#45;&#62; [ binop expression ]

  binop      &#45;&#62; &#39;+&#39;  | &#39;&#45;&#39; | &#39;*&#39;  | &#39;/&#39; | &#39;//&#39; | &#39;%&#39;  | &#39;~~&#39;  | &#39;~&#39;
              | &#39;&#38;&#38;&#39; | &#39;&#38;&#39; | &#39;||&#39; | &#39;|&#39; | &#39;&#60;&#60;&#39; | &#39;&#62;&#62;&#39; | &#39;&#62;&#62;&#62;&#39; | &#39;.&#39;</pre>

<dt><a name="static_void_parrot_instruction(parser_state_*p)"
><b><code lang='und' xml:lang='und'>static void parrot_instruction(parser_state *p)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  parrot_instruction &#45;&#62; PARROT_OP [ expression {&#39;,&#39; expression } ]</pre>

<dt><a name="static_void_assignment(parser_state_*p)"
><b><code lang='und' xml:lang='und'>static void assignment(parser_state *p)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  assignment &#45;&#62; &#39;=&#39; ( unop expression
                    | expression arith_expr
                    | target ( keylist | arguments )
                    | STRINGC arguments
                    | &#39;global&#39; STRINGC
                    | heredocstring
                    | methodcall
                    | &#39;null&#39;
                    | parrot_instruction
                    )

  unop       &#45;&#62; &#39;&#45;&#39; | &#39;!&#39; | &#39;~&#39;</pre>

<dt><a name="static_void_return_statement(parser_state_*p)"
><b><code lang='und' xml:lang='und'>static void return_statement(parser_state *p)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  return_statement &#45;&#62; &#39;.return&#39; ( arguments
                                | target arguments
                                | methodcall
                                )
                                &#39;\n&#39;</pre>

<dt><a name="static_void_yield_statement(parser_state_*p)"
><b><code lang='und' xml:lang='und'>static void yield_statement(parser_state *p)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  yield_statement &#45;&#62; &#39;.yield&#39; arguments &#39;\n&#39;</pre>

<dt><a name="static_void_local_id_list(parser_state_*p)"
><b><code lang='und' xml:lang='und'>static void local_id_list(parser_state *p)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  local_id_list &#45;&#62; local_id { &#39;,&#39; local_id }

  local_id  &#45;&#62; IDENTIFIER [&#39;:unique_reg&#39;]</pre>

<dt><a name="static_void_declaration_list(parser_state_*p)"
><b><code lang='und' xml:lang='und'>static void declaration_list(parser_state *p)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  declaration_list &#45;&#62; type local_id_list &#39;\n&#39;</pre>

<dt><a name="static_void_local_declaration(parser_state_*p)"
><b><code lang='und' xml:lang='und'>static void local_declaration(parser_state *p)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  local_declaration &#45;&#62; &#39;.local&#39; declaration_list</pre>

<dt><a name="static_void_lex_declaration(parser_state_*p)"
><b><code lang='und' xml:lang='und'>static void lex_declaration(parser_state *p)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  lex_declaration &#45;&#62; &#39;.lex&#39; STRINGC &#39;,&#39; target &#39;\n&#39;</pre>

<dt><a name="static_void_conditional_expression(parser_state_*p)"
><b><code lang='und' xml:lang='und'>static void conditional_expression(parser_state *p)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  conditional_expression &#45;&#62; expression [cond_op expression]

  cond_op &#45;&#62; &#39;&#62;&#39; | &#39;&#62;=&#39; | &#39;&#60;&#39; | &#39;&#60;=&#39; | &#39;==&#39; | &#39;!=&#39;</pre>

<dt><a name="static_void_jump_statement(parser_state_*p)"
><b><code lang='und' xml:lang='und'>static void jump_statement(parser_state *p)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  jump_statement &#45;&#62; &#39;goto&#39; IDENTIFIER &#39;\n&#39;</pre>

<dt><a name="static_void_goto_statement(parser_state_*p)"
><b><code lang='und' xml:lang='und'>static void goto_statement(parser_state *p)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  goto_statement &#45;&#62; jump_statement</pre>

<dt><a name="static_void_unless_statement(parser_state_*p)"
><b><code lang='und' xml:lang='und'>static void unless_statement(parser_state *p)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  unless_statement &#45;&#62; &#39;unless&#39; ([&#39;null&#39;] expression | conditional_expression) jump_statement</pre>

<dt><a name="static_void_if_statement(parser_state_*p)"
><b><code lang='und' xml:lang='und'>static void if_statement(parser_state *p)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  if_statement &#45;&#62; &#39;if&#39; ([&#39;null&#39;] expression | conditional_expression) jump_statement</pre>

<dt><a name="static_void_const_definition(parser_state_*p)"
><b><code lang='und' xml:lang='und'>static void const_definition(parser_state *p)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  const_definition &#45;&#62; &#39;int&#39; IDENTIFIER &#39;=&#39; INTC
                    | &#39;num&#39; IDENTIFIER &#39;=&#39; NUMC
                    | &#39;pmc&#39; IDENTIFIER &#39;=&#39; STRINGC
                    | &#39;string&#39; IDENTIFIER &#39;=&#39; STRINGC</pre>

<dt><a name="static_void_param_flags(parser_state_*p)"
><b><code lang='und' xml:lang='und'>static void param_flags(parser_state *p)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  param_flags &#45;&#62; { param_flag }

  param_flag &#45;&#62; &#39;:slurpy&#39;
              | &#39;:named&#39;[&#39;(&#39; STRINGC &#39;)&#39;]
              | &#39;:unique_reg&#39;
              | &#39;:optional&#39;
              | &#39;:opt_flag&#39;</pre>

<dt><a name="static_void_invokable(parser_state_*p)"
><b><code lang='und' xml:lang='und'>static void invokable(parser_state *p)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  invokable &#45;&#62; IDENTIFIER | PREG</pre>

<dt><a name="static_void_long_invocation(parser_state_*p)"
><b><code lang='und' xml:lang='und'>static void long_invocation(parser_state *p)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  long&#45;invocation &#45;&#62; &#39;.begin_call&#39; &#39;\n&#39;
                     { &#39;.arg&#39; expression arg_flags }
                     ( &#39;.call&#39;|&#39;.nci_call&#39;) invokable &#39;\n&#39;
                     | &#39;.invocant&#39; invokable &#39;\n&#39;
                       &#39;.meth_call&#39; method &#39;\n&#39;
                     )
                     { (local_declaration | &#39;.result&#39; target param_flags &#39;\n&#39;) }
                     &#39;.end_call&#39; &#39;\n&#39;</pre>

<dt><a name="static_void_long_return_statement(parser_state_*p)"
><b><code lang='und' xml:lang='und'>static void long_return_statement(parser_state *p)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  long_return_statement &#45;&#62; &#39;.begin_return&#39; &#39;\n&#39;
                           { &#39;.return&#39; expression arg_flags &#39;\n&#39; }
                           &#39;.end_return&#39; &#39;\n&#39;</pre>

<dt><a name="static_void_long_yield_statement(parser_state_*p)"
><b><code lang='und' xml:lang='und'>static void long_yield_statement(parser_state *p)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  long_yield_statement &#45;&#62; &#39;.begin_yield&#39; &#39;\n&#39;
                          { &#39;.return&#39; expression arg_flags &#39;\n&#39; }
                          &#39;.end_yield&#39; &#39;\n&#39;</pre>

<dt><a name="static_void_target_statement(parser_state_*p)"
><b><code lang='und' xml:lang='und'>static void target_statement(parser_state *p)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  target_statement &#45;&#62; target ( &#39;=&#39; assignment
                             | augmented_op expression
                             | keylist &#39;=&#39; expression
                             | arguments
                             )
                             &#39;\n&#39;

  augmented_op     &#45;&#62; &#39;+=&#39; | &#39;&#45;=&#39; | &#39;%=&#39; | &#39;/=&#39;  | &#39;//=&#39; | &#39;*=&#39;  | &#39;.=&#39;
                    | &#39;~=&#39; | &#39;&#38;=&#39; | &#39;|=&#39; | &#39;**=&#39; | &#39;&#60;&#60;=&#39; | &#39;&#62;&#62;=&#39; | &#39;&#62;&#62;&#62;=&#39;</pre>

<dt><a name="static_void_target_list(parser_state_*p)"
><b><code lang='und' xml:lang='und'>static void target_list(parser_state *p)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  target_list &#45;&#62; &#39;(&#39; target param_flags {&#39;,&#39; target param_flags } &#39;)&#39;</pre>

<dt><a name="static_void_multi_result_invocation(parser_state_*p)"
><b><code lang='und' xml:lang='und'>static void multi_result_invocation(parser_state *p)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  multi&#45;result&#45;invocation &#45;&#62; target_list &#39;=&#39; (invokable arguments | methodcall) &#39;\n&#39;

  invokable &#45;&#62; IDENTIFIER | PREG | STRINGC</pre>

<dt><a name="static_void_macro_expansion(parser_state_*p)"
><b><code lang='und' xml:lang='und'>static void macro_expansion(parser_state *p)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  macro_expansion &#45;&#62; MACRO_IDENT [ &#39;(&#39; [ expression { &#39;,&#39; expression } &#39;)&#39; ] &#39;\n&#39;</pre>

<dt><a name="static_void_get_results_instruction(parser_state_*p)"
><b><code lang='und' xml:lang='und'>static void get_results_instruction(parser_state *p)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  get_results_instr &#45;&#62; &#39;.get_results&#39; target_list &#39;\n&#39;</pre>

<dt><a name="static_void_global_assignment(parser_state_*p)"
><b><code lang='und' xml:lang='und'>static void global_assignment(parser_state *p)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  global_assignment &#45;&#62; &#39;global&#39; string_value &#39;=&#39; (IDENTIFIER|PREG) &#39;\n&#39;</pre>

<dt><a name="static_void_instructions(parser_state_*p)"
><b><code lang='und' xml:lang='und'>static void instructions(parser_state *p)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  instructions &#45;&#62; {instruction}

  instruction  &#45;&#62; {LABEL [&#39;\n&#39;]} instr

  instr &#45;&#62; if_statement
         | unless_statement
         | local_declaration
         | lex_declaration
         | &#39;.globalconst&#39; const_definition
         | &#39;.const&#39; const_definition
         | return_statement
         | yield_statement
         | macro_expansion
         | target_statement
         | STRINGC arguments
         | methodcall
         | long_invocation
         | long_return_statement
         | long_yield_statement
         | &#39;null&#39; var
         | get_results_instruction
         | global_assignment
         | &#39;\n&#39;</pre>
</dl>

<h3><a name="Compilation_Units"
>Compilation Units</a></h3>

<dl>
<dt><a name="static_void_multi_type_list(parser_state_*p)"
><b><code lang='und' xml:lang='und'>static void multi_type_list(parser_state *p)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  multi&#45;type&#45;list &#45;&#62; &#39;(&#39; [multi&#45;type {&#39;,&#39; multi&#45;type } ] &#39;)&#39;

  multi&#45;type &#45;&#62; IDENTIFIER | STRINGC | keylist | type</pre>

<dt><a name="static_void_sub_flags(parser_state_*p)"
><b><code lang='und' xml:lang='und'>static void sub_flags(parser_state *p)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  sub_flags &#45;&#62; [sub_flag { sub_flag } ]

  sub_flag  &#45;&#62; &#39;:anon&#39;
             | &#39;:init&#39;
             | &#39;:load&#39;
             | &#39;:main&#39;
             | &#39;:method&#39;
             | &#39;:lex&#39;
             | &#39;:outer&#39; &#39;(&#39; ( STRINGC | IDENTIFIER )  &#39;)&#39;
             | &#39;:vtable&#39; &#39;(&#39; STRINGC &#39;)&#39;
             | &#39;:multi&#39; multi&#45;type&#45;list
             | &#39;:postcomp&#39;
             | &#39;:immediate&#39;</pre>

<dt><a name="static_void_parameters(parser_state_*p)"
><b><code lang='und' xml:lang='und'>static void parameters(parser_state *p)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  parameters &#45;&#62; { &#39;.param&#39; parameter[param_flag] &#39;\n&#39; }

  parameter &#45;&#62; type [ STRING_CONSTANT &#39;=&#62;&#39; ] IDENTIFIER</pre>

<dt><a name="static_void_sub_definition(parser_state_*p)"
><b><code lang='und' xml:lang='und'>static void sub_definition(parser_state *p)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  sub_definition &#45;&#62; &#39;.sub&#39; (IDENTIFIER | STRINGC) subflags &#39;\n&#39; parameters instructions &#39;.end&#39;</pre>

<dt><a name="static_void_macro_parameters(parser_state_*p)"
><b><code lang='und' xml:lang='und'>static void macro_parameters(parser_state *p)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  macro_parameters &#45;&#62; [ &#39;(&#39; [ id {&#39;,&#39; id} ] &#39;)&#39; ]</pre>

<dt><a name="static_void_macro_definition(parser_state_*p)"
><b><code lang='und' xml:lang='und'>static void macro_definition(parser_state *p)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'> macro&#45;definition &#45;&#62; &#39;.macro&#39; IDENTIFIER macro_parameters &#39;\n&#39; macro_body &#39;.endm&#39;</pre>

<dt><a name="static_void_include(parser_state_*p)"
><b><code lang='und' xml:lang='und'>static void include(parser_state *p)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  include &#45;&#62; &#39;.include&#39; STRINGC</pre>

<dt><a name="static_void_pragma(parser_state_*p)"
><b><code lang='und' xml:lang='und'>static void pragma(parser_state *p)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  pragma &#45;&#62; &#39;.pragma&#39; &#39;n_operators&#39; INTC</pre>

<dt><a name="static_void_hll_specifier(parser_state_*p)"
><b><code lang='und' xml:lang='und'>static void hll_specifier(parser_state *p)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  hll_specifier &#45;&#62; &#39;.HLL&#39; STRINGC &#39;,&#39; STRINGC</pre>

<dt><a name="static_void_hll_mapping(parser_state_*p)"
><b><code lang='und' xml:lang='und'>static void hll_mapping(parser_state *p)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  hll_mapping &#45;&#62; &#39;.HLL_map&#39; STRINGC &#39;,&#39; STRINGC</pre>

<dt><a name="static_void_namespace_declaration(parser_state_*p)"
><b><code lang='und' xml:lang='und'>static void namespace_declaration(parser_state *p)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  namespace_declaration &#45;&#62; &#39;.namespace&#39; [ &#39;[&#39; STRINGC { (&#39;,&#39;|&#39;;&#39;) STRINGC &#39;]&#39; ]</pre>

<dt><a name="static_void_loadlib(parser_state_*p)"
><b><code lang='und' xml:lang='und'>static void loadlib(parser_state *p)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  loadlib &#45;&#62; &#39;.loadlib&#39; STRINGC</pre>

<dt><a name="static_void_compilation_unit(parser_state_*p)"
><b><code lang='und' xml:lang='und'>static void compilation_unit(parser_state *p)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  compilation_unit &#45;&#62; sub_definition
                    | &#39;.const&#39; const_definition
                    | include
                    | macro_definition
                    | pragma
                    | loadlib
                    | namespace_declaration
                    | hll_specifier
                    | hll_mapping</pre>

<dt><a name="static_void_program(parser_state_*p)"
><b><code lang='und' xml:lang='und'>static void program(parser_state *p)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  program &#45;&#62; {&#39;\n&#39;} compilation_unit { &#39;\n&#39; compilation_unit } EOF</pre>

<dt><a name="void_TOP(parser_state_*p)"
><b><code lang='und' xml:lang='und'>void TOP(parser_state *p)</b></code></a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>  TOP &#45;&#62; program</pre>
</dl>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../../resources/parrot_small.png"
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
