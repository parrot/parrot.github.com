<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
    <HEAD>
        <TITLE>Parsing Expression Grammar for Lua, version 0.8</TITLE>
        <LINK REL="stylesheet" TYPE="text/css"
            HREF="../../../../../resources/perl.css"
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY>
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Parsing Expression Grammar for Lua, version 0.8</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../../../html/index.html">Contents</a> | <a href="../../../../../html/languages.html">Language Implementations</a> | <a href="../../../../../html/lua.html">Lua</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../../../resources/up.gif'></a></a></h1>

<p>lib/lpeg.pir &#45; Parsing Expression Grammar for Lua,
version 0.8</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../../../resources/up.gif'></a></a></h1>

<p>See original on <a href='http://www.inf.puc&#45;rio.br/~roberto/lpeg.html'><a href="http://www.inf.puc&#45;rio.br/~roberto/lpeg.html">http://www.inf.puc&#45;rio.br/~roberto/lpeg.html</a></a></p>

<h2><a name="Introduction"
>Introduction <a href='#_top'><img alt='^' border=0 src='../../../../../resources/up.gif'></a></a></h2>

<p>See on <a href='http://www.inf.puc&#45;rio.br/~roberto/lpeg.html#intro'><a href="http://www.inf.puc&#45;rio.br/~roberto/lpeg.html#intro">http://www.inf.puc&#45;rio.br/~roberto/lpeg.html#intro</a></a></p>

<h2><a name="Functions"
>Functions <a href='#_top'><img alt='^' border=0 src='../../../../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="lpeg.match_(pattern,_subject_[,_init])"
><b><code lang='und' xml:lang='und'>lpeg.match (pattern, subject [, init])</b></code></a></dt><p class="pad"></p>

<dd>The matching function.
It attempts to match the given pattern against the subject string.
If the match succeeds,
returns the index in the subject of the first character after the match,
or the values of <a href='#Captures'>captured values</a> (if the pattern captured any value).</dd><p class="pad"></p>

<dd>An optional numeric argument <code lang='und' xml:lang='und'>init</code> makes the match starts at that position in the subject string.
As usual in Lua libraries,
a negative value counts from the end.</dd><p class="pad"></p>

<dd>Unlike typical pattern&#45;matching functions,
<code lang='und' xml:lang='und'>match</code> works only in <i>anchored</i> mode; that is,
it tries to match the pattern with a prefix of the given subject string (at position <code lang='und' xml:lang='und'>init</code>),
not with an arbitrary substring of the subject.
So,
if we want to find a pattern anywhere in a string,
we must either write a loop in Lua or write a pattern that matches anywhere.
This second approach is easy and quite efficient; see <a href='#Some_Examples'>examples</a>.</dd><p class="pad"></p>

<dd>NOT YET IMPLEMENTED.</dd><p class="pad"></p>

<dt><a name="lpeg.print_(pattern)"
><b><code lang='und' xml:lang='und'>lpeg.print (pattern)</b></code></a></dt><p class="pad"></p>

<dd>UNDOCUMENTED.</dd><p class="pad"></p>

<dt><a name="lpeg.span_(string)"
><b><code lang='und' xml:lang='und'>lpeg.span (string)</b></code></a></dt><p class="pad"></p>

<dd>NOT YET IMPLEMENTED.</dd><p class="pad"></p>

<dt><a name="lpeg.type_(value)"
><b><code lang='und' xml:lang='und'>lpeg.type (value)</b></code></a></dt><p class="pad"></p>

<dd>If the given value is a pattern,
returns the string <code lang='und' xml:lang='und'>&#34;pattern&#34;</code>.
Otherwise returns <b>nil</b>.</dd><p class="pad"></p>

<dt><a name="lpeg.version_()"
><b><code lang='und' xml:lang='und'>lpeg.version ()</b></code></a></dt><p class="pad"></p>

<dd>Returns a string with the running version of LPEG.</dd><p class="pad"></p>
</dl>

<h2><a name="Basic_Constructions"
>Basic Constructions <a href='#_top'><img alt='^' border=0 src='../../../../../resources/up.gif'></a></a></h2>

<p>The following operations build patterns.
All operations that expect a pattern as an argument may receive also strings,
tables,
numbers,
booleans,
or functions,
which are translated to patterns according to the rules of function <code lang='und' xml:lang='und'>lpeg.P</code>.</p>

<dl>
<dt><a name="lpeg.P_(value)"
><b><code lang='und' xml:lang='und'>lpeg.P (value)</b></code></a></dt><p class="pad"></p>

<dd>Converts the given value into a proper pattern,
according to the following rules:</dd><p class="pad"></p>

<dd>* If the argument is a pattern,
it is returned unmodified.</dd><p class="pad"></p>

<dd>* If the argument is a string,
it is translated to a pattern that matches literally the string.</dd><p class="pad"></p>

<dd>* If the argument is a number,
it is translated as follows.
A non&#45;negative number <i>n</i> gives a pattern that matches exactly <i>n</i> characters; a negative number <i>&#45;n</i> gives a pattern that succeeds only if the input string does not have <i>n</i> characters.
It is (as expected) equivalent to the unary minus operation (see below) applied over the absolute value of <i>n</i>.</dd><p class="pad"></p>

<dd>* If the argument is a boolean,
the result is a pattern that always succeeds or always fails (according to the boolean value),
without consuming any input.</dd><p class="pad"></p>

<dd>* If the argument is a table,
it is interpreted as a grammar (see <a href='#Grammars'>&#34;Grammars&#34;</a>).</dd><p class="pad"></p>

<dd>* If the argument is a function,
returns a pattern equivalent to a match&#45;time capture over the empty string.</dd><p class="pad"></p>

<dd>If the function is called with parameters <i>s</i> and <i>i</i>,
its result is valid if it is in the range <i>[i,
len(s) + 1]</i>.</dd><p class="pad"></p>

<dd>NOT YET IMPLEMENTED (see getpatt).</dd><p class="pad"></p>

<dt><a name="lpeg.R_({range})"
><b><code lang='und' xml:lang='und'>lpeg.R ({range})</b></code></a></dt><p class="pad"></p>

<dd>Returns a pattern that matches any single character belonging to one of the given <i>ranges</i>.
Each <code lang='und' xml:lang='und'>range</code> is a string <i>xy</i> of length 2,
representing all characters with code between the codes of <i>x</i> and <i>y</i> (both inclusive).</dd><p class="pad"></p>

<dd>As an example,
the pattern <code lang='und' xml:lang='und'>lpeg.R(&#34;09&#34;)</code> matches any digit,
and <code lang='und' xml:lang='und'>lpeg.R(&#34;az&#34;, &#34;AZ&#34;)</code> matches any ASCII letter.</dd><p class="pad"></p>

<dd>NOT YET IMPLEMENTED.</dd><p class="pad"></p>

<dt><a name="lpeg.S_(string)"
><b><code lang='und' xml:lang='und'>lpeg.S (string)</b></code></a></dt><p class="pad"></p>

<dd>Returns a pattern that matches any single character that appears in the given string.
(The <code lang='und' xml:lang='und'>S</code> stands for <i>Set</i>.)</dd><p class="pad"></p>

<dd>As an example,
the pattern <code lang='und' xml:lang='und'>lpeg.S(&#34;+&#45;*/&#34;)</code> matches any arithmetic operator.</dd><p class="pad"></p>

<dd>Note that,
if <i>s</i> is a character (that is,
a string of length 1),
then <code lang='und' xml:lang='und'>lpeg.P(s)</code> is equivalent to <code lang='und' xml:lang='und'>lpeg.S(s)</code> which is equivalent to <code lang='und' xml:lang='und'>lpeg.R(s..s)</code>.
Note also that both <code lang='und' xml:lang='und'>lpeg.S(&#34;&#34;)</code> and <code lang='und' xml:lang='und'>lpeg.R()</code> are patterns that always fail.</dd><p class="pad"></p>

<dd>NOT YET IMPLEMENTED.</dd><p class="pad"></p>

<dt><a name="lpeg.V_(v)"
><b><code lang='und' xml:lang='und'>lpeg.V (v)</b></code></a></dt><p class="pad"></p>

<dd>This operation creates a non&#45;terminal (a <i>variable</i>) for a grammar.
The created non&#45;terminal refers to the rule indexed by <code lang='und' xml:lang='und'>v</code> in the enclosing grammar.
(See <a href='#Grammars'>&#34;Grammars&#34;</a> for details.)</dd><p class="pad"></p>

<dd>NOT YET IMPLEMENTED.</dd><p class="pad"></p>

<dt><a name="#patt"
><b><code lang='und' xml:lang='und'>#patt</b></code></a></dt><p class="pad"></p>

<dd>Returns a pattern equivalent to <i>&#38;patt</i> in the original PEG notation.
This is a pattern that matches only if the input string does match <code lang='und' xml:lang='und'>patt</code>,
but without consuming any input,
independently of success or failure.</dd><p class="pad"></p>

<dd>When it succeeds,
<code lang='und' xml:lang='und'>#patt</code> produces all captures produced by <code lang='und' xml:lang='und'>patt</code>.</dd><p class="pad"></p>

<dd>NOT YET IMPLEMENTED.</dd><p class="pad"></p>

<dt><a name="&#45;patt"
><b><code lang='und' xml:lang='und'>&#45;patt</b></code></a></dt><p class="pad"></p>

<dd>Returns a pattern equivalent to <i>!patt</i> in the original PEG notation.
This pattern matches only if the input string does not match <code lang='und' xml:lang='und'>patt</code>.
It does not consume any input,
independently of success or failure.</dd><p class="pad"></p>

<dd>As an example,
the pattern <code lang='und' xml:lang='und'>&#45;1</code> matches only the end of string.</dd><p class="pad"></p>

<dd>This pattern never produces any captures,
because either <code lang='und' xml:lang='und'>patt</code> fails or <code lang='und' xml:lang='und'>&#45;patt</code> fails.
(A failing pattern produces no captures.)</dd><p class="pad"></p>

<dd>NOT YET IMPLEMENTED (see __sub).</dd><p class="pad"></p>

<dt><a name="patt1_+_patt2"
><b><code lang='und' xml:lang='und'>patt1 + patt2</b></code></a></dt><p class="pad"></p>

<dd>Returns a pattern equivalent to an <i>ordered choice</i> of <code lang='und' xml:lang='und'>patt1</code> and <code lang='und' xml:lang='und'>patt2</code>.
(This is denoted by <i>patt1 / patt2</i> in the original PEG notation,
not to be confused with the <code lang='und' xml:lang='und'>/</code> operation in LPeg.) It matches either <code lang='und' xml:lang='und'>patt1</code> or <code lang='und' xml:lang='und'>patt2</code> (with no backtracking once one of them succeeds).
The identity element for this operation is the pattern <code lang='und' xml:lang='und'>lpeg.P(false)</code>,
which always fails.</dd><p class="pad"></p>

<dd>If both <code lang='und' xml:lang='und'>patt1</code> and <code lang='und' xml:lang='und'>patt2</code> are character sets,
this operation is equivalent to set union:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'> lower = lpeg.R(&#34;az&#34;)
 upper = lpeg.R(&#34;AZ&#34;)
 letter = lower + upper</pre>

<dd>NOT YET IMPLEMENTED.</dd><p class="pad"></p>

<dt><a name="patt1_&#45;_patt2"
><b><code lang='und' xml:lang='und'>patt1 &#45; patt2</b></code></a></dt><p class="pad"></p>

<dd>Returns a pattern equivalent to <i>!patt2 patt1</i>. This pattern asserts that the input does not match <code lang='und' xml:lang='und'>patt2</code> and then matches <code lang='und' xml:lang='und'>patt1</code>.</dd><p class="pad"></p>

<dd>If both <code lang='und' xml:lang='und'>patt1</code> and <code lang='und' xml:lang='und'>patt2</code> are character sets, this operation is equivalent to set difference. Note that <code lang='und' xml:lang='und'>&#45;patt</code> is equivalent to <code lang='und' xml:lang='und'>&#34;&#34; &#45; patt</code> (or <code lang='und' xml:lang='und'>0 &#45; patt</code>). If <code lang='und' xml:lang='und'>patt</code> is a character set, <code lang='und' xml:lang='und'>1 &#45; patt</code> is its complement.</dd><p class="pad"></p>

<dd>NOT YET IMPLEMENTED.</dd><p class="pad"></p>

<dt><a name="patt1_*_patt2"
><b><code lang='und' xml:lang='und'>patt1 *patt2</b></code></a></dt><p class="pad"></p>

<dd>Returns a pattern that matches <code lang='und' xml:lang='und'>patt1</code> and then matches <code lang='und' xml:lang='und'>patt2</code>, starting where <code lang='und' xml:lang='und'>patt1</code> finished. The identity element for this operation is the pattern <code lang='und' xml:lang='und'>lpeg.P(true)</code>, which always succeeds.</dd><p class="pad"></p>

<dd>(LPeg uses the <code lang='und' xml:lang='und'>*</code> operator [instead of the more obvious <code lang='und' xml:lang='und'>..</code>] both because it has the right priority and because in formal languages it is common to use a dot for denoting concatenation.)</dd><p class="pad"></p>

<dd>NOT YET IMPLEMENTED.</dd><p class="pad"></p>

<dt><a name="patt^n"
><b><code lang='und' xml:lang='und'>patt^n</b></code></a></dt><p class="pad"></p>

<dd>If <code lang='und' xml:lang='und'>n</code> is nonnegative, this pattern is equivalent to <i>pattn patt*</i>. It matches at least <code lang='und' xml:lang='und'>n</code> occurrences of <code lang='und' xml:lang='und'>patt</code>.</dd><p class="pad"></p>

<dd>Otherwise, when <code lang='und' xml:lang='und'>n</code> is negative, this pattern is equivalent to <i>(patt?)&#45;n</i>. That is, it matches at most <code lang='und' xml:lang='und'>&#45;n</code> occurrences of <code lang='und' xml:lang='und'>patt</code>.</dd><p class="pad"></p>

<dd>In particular, <code lang='und' xml:lang='und'>patt^0</code> is equivalent to <i>patt*</i>, <code lang='und' xml:lang='und'>patt^1</code> is equivalent to <i>patt+</i>, and <code lang='und' xml:lang='und'>patt^&#45;1</code> is equivalent to <i>patt?</i> in the original PEG notation.</dd><p class="pad"></p>

<dd>In all cases, the resulting pattern is greedy with no backtracking. That is, it matches only the longest possible sequence of matches for <code lang='und' xml:lang='und'>patt</code>.</dd><p class="pad"></p>

<dd>NOT YET IMPLEMENTED.</dd><p class="pad"></p>
</dl>

<h2><a name="Grammars"
>Grammars <a href='#_top'><img alt='^' border=0 src='../../../../../resources/up.gif'></a></a></h2>

<p>With the use of Lua variables, it is possible to define patterns incrementally, with each new pattern using previously defined ones. However, this technique does not allow the definition of recursive patterns. For recursive patterns, we need real grammars.</p>

<p>LPeg represents grammars with tables, where each entry is a rule.</p>

<p>The call <code lang='und' xml:lang='und'>lpeg.V(v)</code> creates a pattern that represents the nonterminal (or <i>variable</i>) with index <code lang='und' xml:lang='und'>v</code> in a grammar. Because the grammar still does not exist when this function is evaluated, the result is an <i>open reference</i> to the respective rule.</p>

<p>A table is <i>fixed</i> when it is converted to a pattern (either by calling <code lang='und' xml:lang='und'>lpeg.P</code> or by using it wherein a pattern is expected). Then every open reference created by <code lang='und' xml:lang='und'>lpeg.V(v)</code> is corrected to refer to the rule indexed by <code lang='und' xml:lang='und'>v</code> in the table.</p>

<p>When a table is fixed, the result is a pattern that matches its <i>initial rule</i>. The entry with index 1 in the table defines its initial rule. If that entry is a string, it is assumed to be the name of the initial rule. Otherwise, LPeg assumes that the entry 1 itself is the initial rule.</p>

<p>As an example, the following grammar matches strings of a&#39;s and b&#39;s that have the same number of a&#39;s and b&#39;s:</p>

<pre lang='und' xml:lang='und'> equalcount = lpeg.P{
  &#34;S&#34;;   &#45;&#45; initial rule name
  S = &#34;a&#34; * lpeg.V&#34;B&#34; + &#34;b&#34; * lpeg.V&#34;A&#34; + &#34;&#34;,
  A = &#34;a&#34; * lpeg.V&#34;S&#34; + &#34;b&#34; * lpeg.V&#34;A&#34; * lpeg.V&#34;A&#34;,
  B = &#34;b&#34; * lpeg.V&#34;S&#34; + &#34;a&#34; * lpeg.V&#34;B&#34; * lpeg.V&#34;B&#34;,
 } * &#45;1</pre>

<h2><a name="Captures"
>Captures <a href='#_top'><img alt='^' border=0 src='../../../../../resources/up.gif'></a></a></h2>

<p>Captures specify what a match operation should return (the so called <i>semantic information</i>). LPeg offers several kinds of captures, which produces values based on matches and combine them to produce new values.</p>

<p>A capture pattern produces its values every time it succeeds. For instance, a capture inside a loop produces as many values as matched by the loop. A capture produces a value only when it succeeds. For instance, the pattern <code lang='und' xml:lang='und'>lpeg.C(lpeg.P&#34;a&#34;^&#45;1)</code> produces the empty string when there is no <code lang='und' xml:lang='und'>&#34;a&#34;</code> (because the pattern <code lang='und' xml:lang='und'>&#34;a&#34;?</code> succeeds), while the pattern <code lang='und' xml:lang='und'>lpeg.C(&#34;a&#34;)^&#45;1</code> does not produce any value when there is no <code lang='und' xml:lang='und'>&#34;a&#34;</code> (because the pattern <code lang='und' xml:lang='und'>&#34;a&#34;</code> fails).</p>

<p>Usually, LPEG evaluates all captures only after (and if) the entire match succeeds. At <i>match time</i> it only gathers enough information to produce the capture values later. As a particularly important consequence, most captures cannot affect the way a pattern matches a subject. The only exception to this rule is the so&#45;called <i>match&#45;time capture</i>. When a match&#45;time capture matches, it forces the immediate evaluation of all its nested captures and then calls its corresponding function, which tells whether the match succeeds and also what values are produced.</p>

<dl>
<dt><a name="lpeg.C_(patt)"
><b><code lang='und' xml:lang='und'>lpeg.C (patt)</b></code></a></dt><p class="pad"></p>

<dd>Creates a <i>simple capture</i>, which captures the substring of the subject that matches <code lang='und' xml:lang='und'>patt</code>. The captured value is a string. If <code lang='und' xml:lang='und'>patt</code> has other captures, their values are returned after this one.</dd><p class="pad"></p>

<dd>NOT YET IMPLEMENTED (see capture_aux).</dd><p class="pad"></p>

<dt><a name="lpeg.Ca_(patt)"
><b><code lang='und' xml:lang='und'>lpeg.Ca (patt)</b></code></a></dt><p class="pad"></p>

<dd>Creates an <i>accumulator capture</i>. This capture assumes that <code lang='und' xml:lang='und'>patt</code> should produce at least one captured value of any kind, which becomes the initial value of an <i>accumulator</i>. Pattern <code lang='und' xml:lang='und'>patt</code> then may produce zero or more <i>function captures</i>. Each of these functions in these captures is called having the accumulator as its first argument (followed by any other arguments provided by its own pattern), and the value returned by the function becomes the new value of the accumulator. The final value of this accumulator is the sole result of the whole capture.</dd><p class="pad"></p>

<dd>As an example, the following pattern matches a list of numbers separated by commas and returns their addition:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'> &#45;&#45; matches a numeral and captures its value
 local number = lpeg.R&#34;09&#34;^1 / tonumber
 &#45;&#45;
 &#45;&#45; auxiliary function to add two numbers
 local function add (acc, newvalue) return acc + newvalue end
 &#45;&#45;
 list = lpeg.Ca(number * (&#34;,&#34; * number / add)^0)
 &#45;&#45;
 &#45;&#45; example of use
 print(list:match(&#34;10,30,43&#34;))   &#45;&#45;&#62; 83</pre>

<dd>NOT YET IMPLEMENTED (see capture_aux).</dd><p class="pad"></p>

<dt><a name="lpeg.Carg_(n)"
><b><code lang='und' xml:lang='und'>lpeg.Carg (n)</b></code></a></dt><p class="pad"></p>

<dd>Creates an <i>argument capture</i>. This pattern matches the empty string and produces the value given as the nth extra argument given in the call to <code lang='und' xml:lang='und'>lpeg.match</code>.</dd><p class="pad"></p>

<dd>NOT YET IMPLEMENTED (see emptycap_aux).</dd><p class="pad"></p>

<dt><a name="lpeg.Cb_(n)"
><b><code lang='und' xml:lang='und'>lpeg.Cb (n)</b></code></a></dt><p class="pad"></p>

<dd>Creates a <i>back capture</i>. This pattern matches the empty string and produces the values produced by the nth previous capture.</dd><p class="pad"></p>

<dd>Captures are numbered dynamically. So, the first previous capture is the last capture to match before the current one. The numbering includes only complete captures; so, if the back capture is inside another capture, this enclosing capture is ignored (because it is not complete when the back capture is seen). Numbering does not count nested captures. Numbering counts captures, not the values produced by them; it does not matter whether a capture produces zero or many values, it counts as one.</dd><p class="pad"></p>

<dd><b>This is an experimental feature. It probably will be changed or even removed in future releases.</b></dd><p class="pad"></p>

<dd>NOT YET IMPLEMENTED (see emptycap_aux).</dd><p class="pad"></p>

<dt><a name="lpeg.Cc_({value})"
><b><code lang='und' xml:lang='und'>lpeg.Cc ({value})</b></code></a></dt><p class="pad"></p>

<dd>Creates a <i>constant capture</i>. This pattern matches the empty string and produces all given values as its captured values.</dd><p class="pad"></p>

<dd>NOT YET IMPLEMENTED.</dd><p class="pad"></p>

<dt><a name="lpeg.Cp_()"
><b><code lang='und' xml:lang='und'>lpeg.Cp ()</b></code></a></dt><p class="pad"></p>

<dd>Creates a <i>position capture</i>. It matches the empty string and captures the position in the subject where the match occurs. The captured value is a number.</dd><p class="pad"></p>

<dd>NOT YET IMPLEMENTED.</dd><p class="pad"></p>

<dt><a name="lpeg.Cs_(patt)"
><b><code lang='und' xml:lang='und'>lpeg.Cs (patt)</b></code></a></dt><p class="pad"></p>

<dd>Creates a <i>substitution capture</i>, which captures the substring of the subject that matches <code lang='und' xml:lang='und'>patt</code>, with <i>substitutions</i>. For any capture inside <code lang='und' xml:lang='und'>patt</code>, the substring that matched the capture is replaced by the capture value (which should be a string). The capture values from <code lang='und' xml:lang='und'>patt</code> are not returned independently (only as substrings in the resulting string).</dd><p class="pad"></p>

<dd>NOT YET IMPLEMENTED (see capture_aux).</dd><p class="pad"></p>

<dt><a name="lpeg.Ct_(patt)"
><b><code lang='und' xml:lang='und'>lpeg.Ct (patt)</b></code></a></dt><p class="pad"></p>

<dd>Creates a <i>table capture</i>. This capture creates a table and puts all captures made by <code lang='und' xml:lang='und'>patt</code> inside this table in successive integer keys, starting at 1.</dd><p class="pad"></p>

<dd>The captured value is only this table. The captures made by <code lang='und' xml:lang='und'>patt</code> are not returned independently (only as table elements).</dd><p class="pad"></p>

<dd>NOT YET IMPLEMENTED (see capture_aux).</dd><p class="pad"></p>

<dt><a name="patt_/_string"
><b><code lang='und' xml:lang='und'>patt / string</b></code></a></dt><p class="pad"></p>

<dd>Creates a <i>string capture</i>. It creates a capture string based on <code lang='und' xml:lang='und'>string</code>. The captured value is a copy of <code lang='und' xml:lang='und'>string</code>, except that the character <code lang='und' xml:lang='und'>%</code> works as an escape character: any sequence in <code lang='und' xml:lang='und'>string</code> of the form <i>%n</i>, with <i>n</i> between 1 and 9, stands for the match of the <i>n</i>&#45;th capture in <code lang='und' xml:lang='und'>patt</code>. (Currently these nested captures can be only simple captures.) The sequence <code lang='und' xml:lang='und'>%0</code> stands for the whole match. The sequence <code lang='und' xml:lang='und'>%%</code> stands for a single <code lang='und' xml:lang='und'>%</code>.</dd><p class="pad"></p>

<dt><a name="patt_/_table"
><b><code lang='und' xml:lang='und'>patt / table</b></code></a></dt><p class="pad"></p>

<dd>Creates a <i>query capture</i>. It indexes the given table using as key the value of the first capture of <code lang='und' xml:lang='und'>patt</code>, or the whole match if <code lang='und' xml:lang='und'>patt</code> made no capture. The value at that index is the final value of the capture. If the table does not have that key, there is no captured value. Everything works as if there was no capture.</dd><p class="pad"></p>

<dt><a name="patt_/_function"
><b><code lang='und' xml:lang='und'>patt / function</b></code></a></dt><p class="pad"></p>

<dd>Creates a <i>function capture</i>. It calls the given function passing all captures made by <code lang='und' xml:lang='und'>patt</code> as arguments, or the whole match if <code lang='und' xml:lang='und'>patt</code> made no capture. The values returned by the <code lang='und' xml:lang='und'>function</code> are the final values of the capture. (This capture may create multiple values.) In particular, if function returns no value, there is no captured value; everything works as if there was no capture.</dd><p class="pad"></p>

<dd>NOT YET IMPLEMENTED (see capture_aux).</dd><p class="pad"></p>

<dt><a name="lpeg.Cmt_(patt,_function)"
><b><code lang='und' xml:lang='und'>lpeg.Cmt (patt, function)</b></code></a></dt><p class="pad"></p>

<dd>Creates a <i>match&#45;time capture</i>. Unlike all other captures, this one is evaluated immediately when a match occurs. It forces the immediate evaluation of all its nested captures and then calls <code lang='und' xml:lang='und'>function</code>.</dd><p class="pad"></p>

<dd>The function gets as arguments the entire subject, the current position (after the match of <code lang='und' xml:lang='und'>patt</code>), plus any capture values produced by <code lang='und' xml:lang='und'>patt</code>.</dd><p class="pad"></p>

<dd>The first value returned by <code lang='und' xml:lang='und'>function</code> defines how the match happens. If the call returns a number, the match succeeds and the returned number becomes the new current position. (Assuming a subject <i>s</i> and current position <i>i</i>, the returned number must be in the range <i>[i, len(s) + 1]</i>.) If the call returns <b>false</b>, <b>nil</b>, or no value, the match fails.</dd><p class="pad"></p>

<dd>Any extra values returned by the function become the values produced by the capture.</dd><p class="pad"></p>

<dd>NOT YET IMPLEMENTED.</dd><p class="pad"></p>
</dl>

<h2><a name="Some_Examples"
>Some Examples <a href='#_top'><img alt='^' border=0 src='../../../../../resources/up.gif'></a></a></h2>

<p><a href='http://www.inf.puc&#45;rio.br/~roberto/lpeg.html#ex'><a href="http://www.inf.puc&#45;rio.br/~roberto/lpeg.html#ex">http://www.inf.puc&#45;rio.br/~roberto/lpeg.html#ex</a></a></p>

<h1><a name="LINKS"
>LINKS <a href='#_top'><img alt='^' border=0 src='../../../../../resources/up.gif'></a></a></h1>

<dl>
<dt><a name="Parsing_Expression_Grammars"
>Parsing Expression Grammars</a></dt><p class="pad"></p>

<dd><a href='http://pdos.csail.mit.edu/%7Ebaford/packrat/'><a href="http://pdos.csail.mit.edu/%7Ebaford/packrat/">http://pdos.csail.mit.edu/%7Ebaford/packrat/</a></a></dd><p class="pad"></p>

<dt><a name="Wikipedia_Entry_for_PEG"
>Wikipedia Entry for PEG</a></dt><p class="pad"></p>

<dd><a href='http://en.wikipedia.org/wiki/Parsing_expression_grammar'><a href="http://en.wikipedia.org/wiki/Parsing_expression_grammar">http://en.wikipedia.org/wiki/Parsing_expression_grammar</a></a></dd><p class="pad"></p>

<dt><a name="Parsing_Expression_Grammars:_A_Recognition&#45;Based_Syntactic_Foundation"
>Parsing Expression Grammars: A Recognition&#45;Based Syntactic Foundation</a></dt><p class="pad"></p>

<dd><a href='http://pdos.csail.mit.edu/%7Ebaford/packrat/popl04/peg&#45;popl04.pdf'><a href="http://pdos.csail.mit.edu/%7Ebaford/packrat/popl04/peg&#45;popl04.pdf">http://pdos.csail.mit.edu/%7Ebaford/packrat/popl04/peg&#45;popl04.pdf</a></a></dd><p class="pad"></p>
</dl>

<h1><a name="AUTHORS"
>AUTHORS <a href='#_top'><img alt='^' border=0 src='../../../../../resources/up.gif'></a></a></h1>

<p>Francois Perrad</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../../../resources/parrot_small.png"
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
