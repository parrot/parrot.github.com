<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
    <HEAD>
        <TITLE>Untitled</TITLE>
        <LINK REL="stylesheet" TYPE="text/css"
            HREF="../../../../../../../resources/perl.css"
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY>
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Untitled</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../../../../../html/index.html">Contents</a> | <a href="../../../../../../../html/languages.html">Language Implementations</a> | <a href="../../../../../../../html/c99.html">C99</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<p>grammar C99::CPP::Grammar is PCT::Grammar;</p>

<p>token ws { | \h* | &#60;multilinecomment&#62; }</p>

<p>token TOP { ^ &#60;pre_processing_file&#62; [ $ || &#60;.panic: Syntax error&#62; ] {*} }</p>

<p>## A.1.5 Constants ## token constant { | &#60;floating_constant&#62; {*} #= floating_constant | &#60;integer_constant&#62; {*} #= integer_constant | &#60;enumeration_constant&#62; {*} #= enumeration_constant | &#60;character_constant&#62; {*} #= character_constant }</p>

<p>token integer_constant { [ &#60;decimal_constant&#62; | &#60;octal_constant&#62; | &#60;hexadecimal_constant&#62; ] &#60;integer_suffix&#62;?
{*} }</p>

<p>token decimal_constant { &#60;[1..9]&#62; &#60;digit&#62;* }</p>

<p>token octal_constant { 0 &#60;[0..7]&#62;* }</p>

<p>token hexadecimal_constant { 0 &#60;[xX]&#62; &#60;xdigit&#62;+ }</p>

<p>token integer_suffix { | &#60;[uU]&#62; [ll?|LL?]?
| [ll?|LL?] &#60;[uU]&#62;?
}</p>

<p>token floating_constant { [ | &#60;decimal_floating_constant&#62; | &#60;hexadecimal_floating_constant&#62; ] {*} }</p>

<p>token decimal_floating_constant { [ | &#60;fractional_constant&#62; &#60;exponent_part&#62;?
| &#60;digit_sequence&#62; &#60;exponent_part&#62; ] &#60;floating_suffix&#62;?
}</p>

<p>token hexadecimal_prefix { 0 &#60;[xX]&#62; }</p>

<p>token hexadecimal_floating_constant { &#60;hexadecimal_prefix&#62; [ | &#60;hexadecimal_fractional_constant&#62; | &#60;hexadecimal_digit_constant&#62; ] &#60;binary_exponent_part&#62; &#60;floating_suffix&#62;?
}</p>

<p>token fractional_constant { | &#60;digit_sequence&#62;?
\.
&#60;digit_sequence&#62; | &#60;digit_sequence&#62; \.
}</p>

<p>token exponent_part { &#60;[eE]&#62; [&#39;+&#39;|&#39;&#45;&#39;]?
&#60;digit_sequence&#62; }</p>

<p>token digit_sequence { &#60;digit&#62;+ }</p>

<p>token hexadecimal_fractional_constant { | &#60;hexadecimal_digit_sequence&#62;?
\.
&#60;hexadecimal_digit_sequence&#62; | &#60;hexadecimal_digit_sequence&#62; \.
}</p>

<p>token binary_exponent_part { &#60;[pP]&#62; [&#39;+&#39;|&#39;&#45;&#39;]?
&#60;digit_sequence&#62; }</p>

<p>token hexadecimal_digit_sequence { &#60;xdigit&#62;+ }</p>

<p>token floating_suffix { &#60;[fFlL]&#62; }</p>

<p>token enumeration_constant { &#60;identifier&#62; }</p>

<p>token character_constant { [L]?
\&#39; &#60;c_char&#62;+ \&#39; }</p>

<p>token &#60;c_char&#62; { &#60;&#45;[&#39;\\\n]&#62; | &#60;escape_sequence&#62; }</p>

<p>token escape_sequence { \\ [ &#60;[&#39;&#34;?\\abfnrtv]&#62; | &#60;octal_digit&#62;**{1..3} | x &#60;xdigit&#62;+ | &#60;universal_character_name&#62; ] }</p>

<p>## A.1.6 String literals token c_string_literal { [L]?
&#60;string_literal: &#39;&#34;&#39;&#62; {*} }</p>

<p>##\&#34; &#60;s_char&#62;* \&#34;</p>

<p>token s_char { &#60;&#45;[&#34;\\\n]&#62; | &#60;escape_sequence&#62; }</p>

<p>## A.2 Phrase structure grammar ##</p>

<p>## A.2.1 Expressions ##</p>

<p>rule expression { &#60;constant_expression&#62; {*} }</p>

<p>rule constant_expression { &#60;conditional_expression&#62; {*} }</p>

<p>rule assign_op { &#39;=&#39;|&#39;*=&#39;|&#39;/=&#39;|&#39;%=&#39;|&#39;+=&#39;|&#39;&#45;=&#39;|&#39;&#60;&#60;=&#39;|&#39;&#62;&#62;=&#39;|&#39;&#38;=&#39;|&#39;^=&#39;|&#39;|=&#39; }</p>

<p>rule conditional_expression { &#60;logical_expression&#62; [&#39;?&#39; &#60;conditional_expression&#62; &#39;:&#39; &#60;conditional_expression&#62;]?
{*} }</p>

<p>rule logical_expression is optable { ...
}</p>

<p>proto &#39;infix:||&#39; is precedence(&#39;1&#39;) { ...
}</p>

<p>proto &#39;infix:&#38;&#38;&#39; is tighter(&#39;infix:||&#39;) { ...
}</p>

<p>proto &#39;infix:|&#39; is tighter(&#39;infix:&#38;&#38;&#39;) { ...
}</p>

<p>proto &#39;infix:^&#39; is tighter(&#39;infix:|&#39;) { ...
}</p>

<p>proto &#39;infix:&#38;&#39; is tighter(&#39;infix:^&#39;) { ...
}</p>

<p>proto &#39;infix:==&#39; is tighter(&#39;infix:&#38;&#39;) { ...
} proto &#39;infix:!=&#39; is equal(&#39;infix:==&#39;) { ...
}</p>

<p>proto &#39;infix:&#60;&#39; is tighter(&#39;infix:==&#39;) { ...
} proto &#39;infix:&#62;&#39; is equal(&#39;infix:&#60;&#39;) { ...
} proto &#39;infix:&#62;=&#39; is equal(&#39;infix:&#60;&#39;) { ...
} proto &#39;infix:&#60;=&#39; is equal(&#39;infix:&#60;&#39;) { ...
}</p>

<p>proto &#39;infix:&#60;&#60;&#39; is tighter(&#39;infix:==&#39;) { ...
} proto &#39;infix:&#62;&#62;&#39; is equal(&#39;infix:&#60;&#60;&#39;) { ...
}</p>

<p>proto &#39;infix:+&#39; is tighter(&#39;infix:&#60;&#60;&#39;) is pirop(&#39;n_add&#39;) { ...
} proto &#39;infix:&#45;&#39; is equal(&#39;infix:+&#39;) is pirop(&#39;n_sub&#39;) { ...
}</p>

<p>proto &#39;infix:*&#39; is tighter(&#39;infix:+&#39;) is pirop(&#39;n_mul&#39;) { ...
} proto &#39;infix:/&#39; is equal(&#39;infix:*&#39;) is pirop(&#39;n_div&#39;) { ...
} proto &#39;infix:%&#39; is equal(&#39;infix:*&#39;) is pirop(&#39;n_mod&#39;) { ...
}</p>

<p>proto &#39;term:&#39; is tighter(&#39;infix:*&#39;) is parsed(&#38;cast_expression) { ...
}</p>

<p>rule postfix_expression_prefix { | &#60;primary_expression&#62; {*} #= primary_expression | &#39;(&#39; &#60;type_name&#62; &#39;)&#39; &#39;{&#39; &#60;initializer_list&#62; [&#39;,&#39;]?
&#39;}&#39; {*} #= type_name }</p>

<p>rule postfix_expression { &#60;postfix_expression_prefix&#62; &#60;postfix_expression_suffix&#62;* {*} }</p>

<p>rule postfix_expression_suffix { | &#60;index&#62; {*} #= index | &#60;arguments&#62; {*} #= arguments | &#60;direct_field&#62; {*} #= direct_field | &#60;indirect_field&#62; {*} #= indirect_field | &#60;inc_or_dec&#62; {*} #= inc_or_dec }</p>

<p>rule inc_or_dec { $&#60;op&#62;=[&#39;++&#39;|&#39;&#45;&#45;&#39;] {*} }</p>

<p>rule index { &#39;[&#39; &#60;expression&#62; &#39;]&#39; {*} }</p>

<p>rule direct_field { &#39;.&#39; &#60;identifier&#62; {*} }</p>

<p>rule indirect_field { &#39;&#45;&#62;&#39; &#60;identifier&#62; {*} }</p>

<p>rule arguments { &#39;(&#39; &#60;argument_expression_list&#62;?
&#39;)&#39; {*} }</p>

<p>rule argument_expression_list { &#60;assignment_expression&#62; [&#39;,&#39; &#60;assignment_expression&#62;]* {*} }</p>

<p>rule unary_expression { | &#60;postfix_expression&#62; {*} #= postfix_expression | &#60;prefix_expression&#62; {*} #= prefix_expression | &#60;unary_operator&#62; &#60;cast_expression&#62; | &#39;sizeof&#39; &#60;unary_expression&#62; | &#39;sizeof&#39; &#39;(&#39; &#60;type_name&#62; &#39;)&#39; }</p>

<p>rule prefix_expression { $&#60;op&#62;=[&#39;++&#39;|&#39;&#45;&#45;&#39;] &#60;unary_expression&#62; {*} }</p>

<p>rule unary_operator { &#39;&#38;&#39; | &#39;*&#39; | &#39;+&#39; | &#39;&#45;&#39; | &#39;~&#39; | &#39;!&#39; }</p>

<p>rule cast_expression { [&#39;(&#39; &#60;type_name&#62; &#39;)&#39;]* &#60;unary_expression&#62; {*} }</p>

<p>rule primary_expression { | &#60;identifier&#62; {*} #= identifier | &#60;constant&#62; {*} #= constant | &#60;c_string_literal&#62; {*} #= c_string_literal | &#39;(&#39; &#60;expression&#62; &#39;)&#39; {*} #= expression }</p>

<p>token pound { &#39;#&#39; } token begincomment { &#39;/*&#39; }</p>

<p>token multilinecomment { &#39;/*&#39; .*?
&#39;*/&#39; }</p>

<p>regex preprocessing_token { # | &#60;multilinecomment&#62; | &#60;header_name&#62; | &#60;identifier&#62; | &#60;pp_number&#62; | &#60;character_constant&#62; | &#39;&#34;&#39; &#60;string_literal: &#39;&#34;&#39;&#62; &#39;&#34;&#39; | &#60;!pound&#62; &#60;!begincomment&#62; &#60;punctuator&#62; | &#60;universal_character_name&#62; | &#60;!begincomment&#62;&#60;&#45;[# \t\r\n]&#62;\S* ## &#60;&#45;[#]&#45;\S&#62;\S* ##non&#45;whitespace }</p>

<p>## A.1.2 Keywords ## token keyword { [ auto | enum | restrict | unsigned | break | extern | return | void | case | float | short | volatile | char | for | signed | while | const | goto | sizeof | _Bool | continue | if | static | _Complex | default | inline | struct | _Imaginary | do | int | switch | double | long | typedef | else | register | union ]&#62;&#62; }</p>

<p>token reserved_word { &#60;keyword&#62; }</p>

<p>token identifier { &#60;!reserved_word&#62; &#60;identifier_nondigit&#62; [ &#60;identifier_nondigit&#62; | &#60;digit&#62; ]* {*} }</p>

<p>token identifier_nondigit { &#60;alpha&#62; | &#60;[_]&#62; | &#60;universal_character_name&#62; }</p>

<p>token character_constant { [L]?
\&#39; &#60;c_char&#62;+ \&#39; }</p>

<p>token &#60;c_char&#62; { &#60;&#45;[&#39;\\\n]&#62; | &#60;escape_sequence&#62; }</p>

<p>## A.1.4 Universal character names ## token universal_character_name { | &#39;\u&#39; &#60;xdigit&#62;**{4} | &#39;\U&#39; &#60;xdigit&#62;**{8} }</p>

<p>## A.1.7 Punctuators ##</p>

<p>token punctuator { | \[ | \] | &#60;[(){}.]&#62; | &#39;&#45;&#62;&#39; | &#39;++&#39; | &#39;&#45;&#45;&#39; | &#60;[&#38;*+\&#45;~!/%]&#62; | &#39;&#60;&#60;&#39; | &#39;&#62;&#62;&#39; | &#39;&#60;&#39; | &#39;&#62;&#39; | &#39;&#60;=&#39; | &#39;&#62;=&#39; | &#39;==&#39; | &#39;!=&#39; | &#60;[^|]&#62; | &#39;&#38;&#38;&#39; | &#39;||&#39; | &#60;[?:;]&#62; | &#39;...&#39; | &#60;[*/%+\&#45;&#38;^|]&#62; | &#39;&#60;&#60;&#39; | &#39;&#62;&#62;&#39; | &#39;=&#39; | &#60;[,#]&#62; | &#39;##&#39; | &#39;&#60;:&#39; | &#39;:&#62;&#39; | &#39;&#60;%&#39; | &#39;%&#62;&#39; | &#39;%:&#39; | &#39;%:%:&#39; }</p>

<p>## A.3 Preprocessing directives ##</p>

<p>rule pre_processing_file { &#60;group&#62;?
}</p>

<p>rule group { &#60;group_part&#62;+ }</p>

<p>rule group_part { | &#60;pp_tokens&#62;?
&#60;newline&#62; | &#60;if_section&#62; | &#60;control_line&#62; }</p>

<p>rule if_section { &#60;if_group&#62; &#60;elif_group&#62;* &#60;else_group&#62;?
&#60;endif_line&#62; }</p>

<p>rule if_group { | &#39;#&#39; &#39;if&#39; &#60;constant_expression&#62; &#60;newline&#62; &#60;group&#62;?
| &#39;#&#39; &#39;ifdef&#39; &#60;identifier&#62; &#60;newline&#62; &#60;group&#62;?
| &#39;#&#39; &#39;ifndef&#39; &#60;identifier&#62; &#60;newline&#62; &#60;group&#62;?
}</p>

<p>rule elif_group { &#39;#&#39; &#39;elif&#39; &#60;constant_expression&#62; &#60;newline&#62; &#60;group&#62;?
}</p>

<p>rule else_group { &#39;#&#39; &#39;else&#39; &#60;newline&#62; &#60;group&#62;?
}</p>

<p>rule endif_line { &#39;#&#39; &#39;endif&#39; &#60;newline&#62; }</p>

<p>rule control_line { | &#39;#&#39; &#39;include&#39; &#60;pp_tokens&#62; &#60;newline&#62; | &#39;#&#39; &#39;define&#39; &#60;identifier&#62; &#60;replacement_list&#62; &#60;newline&#62; | &#39;#&#39; &#39;define&#39; &#60;identifier&#62; &#60;lparen&#62; &#60;identifier_list&#62;?
&#39;)&#39; &#60;replacement_list&#62; &#60;newline&#62; | &#39;#&#39; &#39;define&#39; &#60;identifier&#62; &#60;lparen&#62; &#39;...&#39; &#39;)&#39; &#60;replacement_list&#62; &#60;newline&#62; | &#39;#&#39; &#39;define&#39; &#60;identifier&#62; &#60;lparen&#62; &#60;identifier_list&#62; &#39;,&#39; &#39;...&#39; &#39;)&#39; &#60;replacement_list&#62; &#60;newline&#62; | &#39;#&#39; &#39;undef&#39; &#60;identifier&#62; &#60;newline&#62; | &#39;#&#39; &#39;line&#39; &#60;pp_tokens&#62; &#60;newline&#62; | &#39;#&#39; &#39;error&#39; &#60;pp_tokens&#62;?
&#60;newline&#62; | &#39;#&#39; &#39;pragma&#39; &#60;pp_tokens&#62;?
&#60;newline&#62; | &#39;#&#39; &#60;newline&#62; }</p>

<p>rule pp_tokens { [ &#60;preprocessing_token&#62; ]+ }</p>

<p>token pp_number { [&#39;.&#39;]?
&#60;digit&#62; &#60;pp_number_suffix&#62;* }</p>

<p>token pp_number_suffix { | &#39;.&#39; | &#60;identifier_nondigit&#62; | &#60;digit&#62; | &#60;[eEpP]&#62; [&#39;+&#39;|&#39;&#45;&#39;] }</p>

<p>rule replacement_list { &#60;pp_tokens&#62;?
}</p>

<p>token lparen { &#39;(&#39; }</p>

<p>token newline { \n }</p>

<p>## A.1.8 Header names token header_name { | \&#60; &#60;h_char&#62;+ \&#62; | \&#34; &#60;q_char&#62;+ \&#34; }</p>

<p>token h_char { &#60;&#45;[\n&#62;]&#62; } token q_char { &#60;&#45;[\n&#34;]&#62; }</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../../../../../resources/parrot_small.png"
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
