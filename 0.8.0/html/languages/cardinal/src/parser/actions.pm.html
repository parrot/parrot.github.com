<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
    <HEAD>
        <TITLE>Untitled</TITLE>
        <LINK REL="stylesheet" TYPE="text/css"
            HREF="../../../../../resources/perl.css"
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY>
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Untitled</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../../../html/index.html">Contents</a> | <a href="../../../../../html/languages.html">Language Implementations</a> | <a href="../../../../../html/cardinal.html">Cardinal</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<p>class cardinal::Grammar::Actions;</p>

<p>method TOP($/) { my $past := $( $&#60;comp_stmt&#62; ); $past.blocktype(&#39;declaration&#39;); $past.pirflags(&#39;:load&#39;);</p>

<pre lang='und' xml:lang='und'>    our $?INIT;
        if defined( $?INIT ) {
        $?INIT.unshift(
            PAST::Var.new(
                :name(&#39;$def&#39;),
                :scope(&#39;lexical&#39;),
                :isdecl(1)
            )
        );
        $?INIT.blocktype(&#39;declaration&#39;);
        $?INIT.pirflags(&#39;:init :load&#39;);
        $past.unshift( $?INIT );
        $?INIT := PAST::Block.new(); # For the next eval.
    }

    make $past;
}</pre>

<p>method comp_stmt($/,$key) { our $?BLOCK; our @?BLOCK; our $?BLOCK_SIGNATURED; if $key eq &#39;open&#39; { if $?BLOCK_SIGNATURED { $?BLOCK := $?BLOCK_SIGNATURED; $?BLOCK_SIGNATURED := 0; } else { $?BLOCK := PAST::Block.new( PAST::Stmts.new(), :node($/)); my $block := PAST::Var.new(:scope(&#39;parameter&#39;), :named(&#39;!BLOCK&#39;), :name(&#39;!BLOCK&#39;), :viviself(&#39;Undef&#39;)); $?BLOCK.symbol($block.name(), :scope(&#39;lexical&#39;)); $?BLOCK[0].push($block); } @?BLOCK.unshift($?BLOCK); } if $key eq &#39;close&#39; { my $past := @?BLOCK.shift(); $?BLOCK := @?BLOCK[0]; $past.push( $( $&#60;stmts&#62; ) ); make $past; } }</p>

<p>method stmts($/) { my $past := PAST::Stmts.new( :node($/) ); for $&#60;stmt&#62; { $past.push($($_)); } make $past; }</p>

<p>method basic_stmt($/, $key) { make $( $/{$key} ); }</p>

<p>method stmt($/) { my $past := $( $&#60;basic_stmt&#62; ); for $&#60;stmt_mod&#62; { my $modifier := $( $_ ); $modifier.push($past); $past := $modifier; } make $past; }</p>

<p>method stmt_mod($/) { my $op; if $&#60;sym&#62; eq &#39;until&#39; { ## there is no :pasttype(&#39;until&#39;); this is called repeat_until $op := &#39;repeat_until&#39;; } else { ## if, while and unless are valid :pasttypes. $op := ~$&#60;sym&#62;; } make PAST::Op.new( $( $&#60;expr&#62; ), :pasttype($op), :node($/) );</p>

<p>}</p>

<p>method expr($/) { my $past := $( $&#60;arg&#62; ); if +$&#60;not&#62; { $past := PAST::Op.new( $past, :pirop(&#39;not&#39;), :node($/) ); } if $&#60;expr&#62; { my $op; if ~$&#60;op&#62;[0] eq &#39;and&#39; { $op := &#39;if&#39;; } else { $op := &#39;unless&#39;; } $past := PAST::Op.new( $past, $( $&#60;expr&#62;[0] ), :pasttype($op), :node($/) ); } make $past; }</p>

<p>method return_stmt($/) { my $past := $($&#60;call_args&#62;); $past.pasttype(&#39;inline&#39;); $past.inline(&#39; .return(%0)&#39;); make $past; }</p>

<p>## not entirely sure what alias does, but this is a guess... method alias($/) { my $fname := $&#60;fname&#62;[0]; my $alias := $&#60;fname&#62;[1]; make PAST::Op.new( $alias, $fname, :pasttype(&#39;bind&#39;), :node($/) ); }</p>

<p>method begin($/) { my $past := $( $&#60;comp_stmt&#62; ); my $sub := PAST::Compiler.compile( $past ); $sub(); ## XXX what to do here? empty block? stolen from rakudo. make PAST::Block.new( :node($/) ); }</p>

<p>method end($/) { my $past := PAST::Block.new( $( $&#60;comp_stmt&#62; ), :node($/) ); $past.blocktype(&#39;declaration&#39;); my $sub := PAST::Compiler.compile( $past ); PIR q&#60; $P0 = get_hll_global [&#39;cardinal&#39;], &#39;@?END_BLOCKS&#39; &#62;; PIR q&#60; $P1 = find_lex &#39;$sub&#39; &#62;; PIR q&#60; push $P0, $P1 &#62;; make $past; }</p>

<p>method indexed_assignment($/) { my $key := $( $&#60;key&#62; ); my $rhs := $( $&#60;rhs&#62; ); my $primary := $( $&#60;basic_primary&#62; );</p>

<pre lang='und' xml:lang='und'>    my $past := PAST::Op.new( :name(&#39;[]=&#39;), :pasttype(&#39;callmethod&#39;), :node($/) );

    $past.push( $primary );
    $past.push( $key );
    $past.push( $rhs );

    make $past;
}
method member_assignment($/) {
    my $rhs := $( $&#60;rhs&#62; );
    my $primary := $( $&#60;basic_primary&#62; );

    my $past := PAST::Op.new( :name(~$&#60;key&#62;&#60;ident&#62; ~ &#39;=&#39;), :pasttype(&#39;callmethod&#39;), :node($/) );

    $past.push( $primary );
    $past.push( $rhs );

    make $past;
}
method assignment($/) {
    my $lhs := $( $&#60;mlhs&#62; );
    our $?BLOCK;
    my $name := $lhs.name();
    unless $?BLOCK.symbol(~$name) {
        our @?BLOCK;
        my $exists := 0;
        my $scope;
        for @?BLOCK {
            if $_ {
                my $sym_table := $_.symbol(~$name);
                if $sym_table {
                    $exists := 1;
                    $scope := &#39;&#39; ~ $sym_table&#60;scope&#62;;
                }
            }
        }
        our $?CLASS;
        if $exists == 0 &#38;&#38; defined($?CLASS) {
            my $block := $?CLASS[0];
            my $sym_table := $block.symbol(~$name);
            if $sym_table {
                $exists := 1;
                $scope := &#39;&#39; ~ $sym_table&#60;scope&#62;;
            }
        }
        if $exists == 0 {
            $lhs.isdecl(1);
            $scope := &#39;lexical&#39;;
        }
        $?BLOCK.symbol(~$name, :scope($scope));
        $lhs.scope($scope);
    }

    my $rhs := $( $&#60;mrhs&#62; );
    make PAST::Op.new( $lhs, $rhs, :pasttype(&#39;bind&#39;), :lvalue(1), :node($/) );
}</pre>

<p>method mlhs($/, $key) { make $( $/{$key} ); }</p>

<p>method lhs($/, $key) { make $( $/{$key} ); }</p>

<p>method member_variable($/) { make $( $&#60;primary&#62; ); # XXX fix field. }</p>

<p>method indexed($/) { my $args; if $&#60;args&#62; { $args := $( $&#60;args&#62;[0] ); }</p>

<pre lang='und' xml:lang='und'>    my $past := PAST::Op.new( :name(&#39;[]&#39;), :pasttype(&#39;callmethod&#39;), :node($/) );
    while $args[0] {
        $past.push( $args.shift() );
    }

    make $past;
}</pre>

<p>method variable($/, $key) { my $past; if $key eq &#39;varname&#39; { $past := $( $/&#60;varname&#62; ); } elsif $key eq &#39;self&#39; { $past := PAST::Op.new(:inline(&#39;%r = self&#39;)); } elsif $key eq &#39;nil&#39; { $past := PAST::Var.new(:scope(&#39;package&#39;), :name(&#39;nil&#39;)); } make $past; }</p>

<p>method varname($/, $key) { my $past := $( $/{$key} ); if is_a_sub(~$/) { # unary sub $past := PAST::Op.new( :pasttype(&#39;call&#39;), :node($/), $past ); } make $past; }</p>

<p>method global($/) { my @namespace; our @?BLOCK; my $toplevel := @?BLOCK[0]; $toplevel.symbol(~$/, :scope(&#39;package&#39;), :namespace(@namespace)); make PAST::Var.new( :name(~$/), :scope(&#39;package&#39;), :namespace(@namespace), :viviself(&#39;Undef&#39;), :node($/) ); }</p>

<p>method instance_variable($/) { our $?CLASS; our $?BLOCK; my $name := ~$/; my $past := PAST::Var.new( :name($name), :scope(&#39;attribute&#39;), :viviself(&#39;Undef&#39;), :node($/) ); my $block := $?CLASS[0]; unless $block.symbol(~$/) { $?CLASS.push( PAST::Op.new( :pasttype(&#39;call&#39;), :name(&#39;!keyword_has&#39;), PAST::Var.new( :name(&#39;$def&#39;), :scope(&#39;lexical&#39;) ), PAST::Val.new( :value($name) ) ) );</p>

<pre lang='und' xml:lang='und'>        $block.symbol(~$name, :scope(&#39;attribute&#39;));
        $?BLOCK.symbol(~$name, :scope(&#39;attribute&#39;));
    }
    make $past;
}</pre>

<p>method class_variable($/) { our $?CLASS; our $?BLOCK; my $name := ~$/; my $past := PAST::Var.new( :name($name), :scope(&#39;package&#39;), :viviself(&#39;Undef&#39;), :node($/) ); my $block := $?CLASS[0]; unless $block.symbol(~$/) { $block.symbol(~$name, :scope(&#39;package&#39;)); $?BLOCK.symbol(~$name, :scope(&#39;package&#39;)); } make $past; }</p>

<p>method local_variable($/) { our $?BLOCK; my $past := PAST::Var.new( :name(~$&#60;ident&#62;), :node($/), :viviself(&#39;Undef&#39;) ); if +$&#60;ns&#62; { $past.scope(&#39;package&#39;); $past.namespace(~$&#60;ns&#62;[0]); } elsif $?BLOCK.symbol($&#60;ident&#62;) { my $scope := &#39;&#39; ~ $?BLOCK.symbol($&#60;ident&#62;)&#60;scope&#62;; $past.scope(~$scope); } else { our @?BLOCK; my $exists := 0; my $scope; for @?BLOCK { if $_ { my $sym_table := $_.symbol(~$&#60;ident&#62;); if $sym_table { $exists := 1; $scope := &#39;&#39; ~ $sym_table&#60;scope&#62;; } } } if $exists == 0 { $past.scope(&#39;package&#39;); my @a; $past.namespace(@a); } else { $past.scope($scope); } } make $past; }</p>

<p>method funcall($/) { my $past := $( $&#60;local_variable&#62; ); make $past; }</p>

<p>method constant_variable($/) { my @a; my $name := ~$/; if $name eq &#39;Array&#39; { $name := &#34;CardinalArray&#34;; } elsif $name eq &#39;Hash&#39; { $name := &#34;CardinalHash&#34;; } elsif $name eq &#39;String&#39; { $name := &#34;CardinalString&#34;; } elsif $name eq &#39;Range&#39; { $name := &#34;CardinalRange&#34;; } elsif $name eq &#39;Integer&#39; { $name := &#34;CardinalInteger&#34;; } my $past := PAST::Var.new( :name($name), :scope(&#39;package&#39;), :node($/), :viviself(&#39;Undef&#39;), :namespace( @a ) ); make $past; }</p>

<p>method if_stmt($/) { my $cond := +$&#60;expr&#62; &#45; 1; my $comp := $( $&#60;comp_stmt&#62;[$cond] ); $comp.blocktype(&#39;immediate&#39;); my $past := PAST::Op.new( $( $&#60;expr&#62;[$cond] ), $comp, :pasttype(&#39;if&#39;), :node( $/ ) ); if ( $&#60;else&#62; ) { my $else := $( $&#60;else&#62;[0] ) ; $else.blocktype(&#39;immediate&#39;); $past.push( $else ); } while ($cond != 0) { $cond := $cond &#45; 1; $comp := $( $&#60;comp_stmt&#62;[$cond] ); $comp.blocktype(&#39;immediate&#39;); $past := PAST::Op.new( $( $&#60;expr&#62;[$cond] ), $comp, $past, :pasttype(&#39;if&#39;), :node( $/ ) ); } make $past; }</p>

<p>method unless_stmt($/) { my $cond := $( $&#60;expr&#62; ); my $body := $( $&#60;comp_stmt&#62; ); $body.blocktype(&#39;immediate&#39;); my $past := PAST::Op.new( $cond, $body, :pasttype(&#39;unless&#39;), :node($/) ); if $&#60;else&#62; { $past.push( $( $&#60;else&#62;[0] ) ); } make $past; }</p>

<p>method else($/) { make $( $&#60;comp_stmt&#62; ); }</p>

<p>method ensure($/) { make $( $&#60;comp_stmt&#62; ); }</p>

<p>method while_stmt($/) { my $cond := $( $&#60;expr&#62; ); my $body := $( $&#60;comp_stmt&#62; ); $body.blocktype(&#39;immediate&#39;); make PAST::Op.new( $cond, $body, :pasttype(~$&#60;sym&#62;), :node($/) ); }</p>

<p>method for_stmt($/) { my $list := $( $&#60;expr&#62; ); my $body := $( $&#60;comp_stmt&#62; ); my $var := $( $&#60;variable&#62; ); $body.blocktype(&#39;declaration&#39;); $var.scope(&#39;parameter&#39;); $var.isdecl(0); $body[0].push($var); make PAST::Op.new( $list, $body, :pasttype(&#39;for&#39;), :node($/) ); }</p>

<p>method control_command($/,$key) { make PAST::Op.new( :pasttype(&#39;call&#39;), :name(~$/), ); }</p>

<p>method yield($/) { our $?BLOCK; our @?BLOCK; my $blockname; if $?BLOCK.symbol(&#39;!BLOCK&#39;) { if defined($?BLOCK.symbol(&#39;!BLOCK&#39;)&#60;name&#62;) { $blockname := $?BLOCK.symbol(&#39;!BLOCK&#39;)&#60;name&#62;; } else { $blockname := &#39;!BLOCK&#39;; } } my $call := $( $&#60;call_args&#62; ); $call.unshift( PAST::Var.new(:scope(&#39;lexical&#39;), :name(~$blockname))); $call.node($/); make $call; }</p>

<p>method module($/) { my $past := $( $&#60;comp_stmt&#62; ); my $name := $( $&#60;module_identifier&#62; ); $past.namespace( $name.name() ); $past.blocktype(&#39;declaration&#39;); $past.pirflags(&#39;:load :init&#39;); make $past; }</p>

<p>method begin_end($/) { my $past := $( $&#60;comp_stmt&#62; ); # XXX handle resque and ensure clauses make $past; }</p>

<p>method classdef($/,$key) { our $?CLASS; our @?CLASS; our $?INIT;</p>

<pre lang='und' xml:lang='und'>    my $name := ~$&#60;module_identifier&#62;&#60;ident&#62;;
    if $key eq &#39;open&#39; {
        my $decl := PAST::Stmts.new();
        $decl.push(
            PAST::Op.new(
                :pasttype(&#39;bind&#39;),
                PAST::Var.new(
                    :name(&#39;$def&#39;),
                    :scope(&#39;lexical&#39;)
                ),
                PAST::Op.new(
                    :pasttype(&#39;call&#39;),
                    :name(&#39;!keyword_class&#39;),
                    PAST::Val.new( :value($name) )
                )
            )
        );
        @?CLASS.unshift( $?CLASS );
        $?CLASS := $decl;
        $?CLASS.unshift( PAST::Block.new() );
    }
    else {
        my $block := $( $&#60;comp_stmt&#62; );
        $block.namespace($name);
        $block.blocktype(&#39;declaration&#39;);
        $block.pirflags(&#39;:init :load&#39;);

        $?CLASS.push(
            PAST::Op.new(
                :pasttype(&#39;callmethod&#39;),
                :name(&#39;register&#39;),
                PAST::Var.new(
                    :scope(&#39;package&#39;),
                    :name(&#39;!CARDINALMETA&#39;),
                    :namespace(&#39;CardinalObject&#39;)
                ),
                PAST::Var.new(
                    :scope(&#39;lexical&#39;),
                    :name(&#39;$def&#39;)
                ),
                PAST::Val.new(
                    :value(&#39;CardinalObject&#39;),
                    :named( PAST::Val.new( :value(&#39;parent&#39;) ) )
                )
            )
        );

        unless defined( $?INIT ) {
            $?INIT := PAST::Block.new();
        }
        for @( $?CLASS ) {
            if $_.WHAT() eq &#39;Block&#39; {
                $block.push( $_ );
            }
            else {
                $?INIT.push( $_ );
            }
        }

        # Restore outer class.
        if +@?CLASS {
            $?CLASS := @?CLASS.shift();
        }
        else {
            $?CLASS := @?CLASS[0];
        }


        make $block;
    }
}</pre>

<p>method functiondef($/) { my $past := $( $&#60;comp_stmt&#62; ); my $name := $&#60;fname&#62;; my $arity := +$past[0]&#60;arity&#62;; #my $args := $( $&#60;argdecl&#62; ); #$past.push($args); $past.name(~$name); our $?BLOCK; our $?CLASS; $?BLOCK.symbol(~$name, :scope(&#39;package&#39;), :arity($arity)); if defined($?CLASS) { $past.pirflags(&#39;:method&#39;); } make $past; }</p>

<p>method sig_identifier($/) { my $past := $($&#60;identifier&#62;); if +$&#60;default&#62; == 1 { $past.viviself( $( $&#60;default&#62;[0] ) ); } make $past; }</p>

<p>method block_signature($/) { my $params := PAST::Stmts.new( :node($/) ); my $past := PAST::Block.new($params, :blocktype(&#39;declaration&#39;)); for $&#60;sig_identifier&#62; { my $parameter := $( $_ ); $past.symbol($parameter.name(), :scope(&#39;lexical&#39;)); $parameter.scope(&#39;parameter&#39;); $params.push($parameter); } if $&#60;slurpy_param&#62; { my $slurp := $( $&#60;slurpy_param&#62;[0] || $&#60;slurpy_param&#62; ); $past.symbol($slurp.name(), :scope(&#39;lexical&#39;)); $params.push( $slurp ); }</p>

<pre lang='und' xml:lang='und'>    if $&#60;block_param&#62; {
        my $block := $( $&#60;block_param&#62;[0] );
        $block.named(&#39;!BLOCK&#39;);
        $past.symbol($block.name(), :scope(&#39;lexical&#39;));
        $past.symbol(&#39;!BLOCK&#39;, :name(~$block.name()));
        $params.push($block);
    }
    else {
        my $block := PAST::Var.new(:scope(&#39;parameter&#39;), :named(&#39;!BLOCK&#39;), :name(&#39;!BLOCK&#39;), :viviself(&#39;Undef&#39;));
        $past.symbol($block.name(), :scope(&#39;lexical&#39;));
        $params.push($block);
    }
    $params.arity( +$&#60;sig_identifier&#62; + +$&#60;block_param&#62; );
    our $?BLOCK_SIGNATURED := $past;
    make $past;
}</pre>

<p>method slurpy_param($/) { my $past := $( $&#60;identifier&#62; ); $past.slurpy(1); $past.scope(&#39;parameter&#39;); make $past; }</p>

<p>method block_param($/) { my $past := $( $&#60;identifier&#62; ); $past.scope(&#39;parameter&#39;); make $past; }</p>

<p>method identifier($/) { make PAST::Var.new( :name(~$&#60;ident&#62;), :node($/) ); }</p>

<p>method module_identifier($/) { make PAST::Var.new( :name(~$/), :scope(&#39;package&#39;), :node($/) ); }</p>

<p>method mrhs($/) { make $( $&#60;args&#62; ); }</p>

<p>method methodcall($/) { my $op := $&#60;operation&#62;; my $past; if $&#60;call_args&#62; { $past := $( $&#60;call_args&#62;[0] ); } else { $past := PAST::Op.new(); }</p>

<pre lang='und' xml:lang='und'>    $past.pasttype(&#39;callmethod&#39;);

    if $&#60;do_block&#62; {
        $past.push( $( $&#60;do_block&#62;[0] ) );
    }

    $past.name(~$op);
    make $past;
}</pre>

<p>method do_block($/) { my $past := $( $&#60;comp_stmt&#62; ); make $past; }</p>

<p>method super_call($/) { my $past := $( $&#60;call_args&#62; ); ## how to invoke super.xxx ? make $past; }</p>

<p>method operation($/) { make $( $&#60;identifier&#62; ); }</p>

<p>method call_args($/) { my $past; if $&#60;args&#62; { $past := $( $&#60;args&#62; ); } else { $past := PAST::Op.new( :pasttype(&#39;call&#39;), :node($/) ); } if $&#60;do_block&#62; { my $do := $( $&#60;do_block&#62;[0] ); $do.named(PAST::Val.new(:value(&#39;!BLOCK&#39;))); $past.push($do); } make $past; }</p>

<p>method args($/) { my $past := PAST::Op.new( :pasttype(&#39;call&#39;), :node($/) ); for $&#60;arg&#62; { $past.push( $($_) ); } make $past; }</p>

<p>method basic_primary($/, $key) { make $( $/{$key} ); }</p>

<p>method primary($/) { my $past := $( $&#60;basic_primary&#62; );</p>

<pre lang='und' xml:lang='und'>    # XXX check this out:
    for $&#60;post_primary_expr&#62; {
        my $postexpr := $( $_ );
        $postexpr.unshift($past);
        $past := $postexpr;
    }
    make $past;
}</pre>

<p>method post_primary_expr($/, $key) { make $( $/{$key} ); }</p>

<p>method scope_identifier($/) { make $( $&#60;identifier&#62; ); # XXX handle :: operator. }</p>

<p>method literal($/, $key) { my $past := $( $/{$key} ); make $past; }</p>

<p>method pcomp_stmt($/) { make $( $&#60;comp_stmt&#62; ); }</p>

<p>method quote_string($/) { make $( $&#60;quote_expression&#62; ); }</p>

<p>method warray($/) { make $( $&#60;quote_expression&#62; ); }</p>

<p>method array($/) { my $list; if $&#60;args&#62; { $list := $( $&#60;args&#62;[0] ); $list.name(&#39;list&#39;); } else { $list := PAST::Op.new( :name(&#39;list&#39;), :node($/) ); }</p>

<pre lang='und' xml:lang='und'>    make $list;
}</pre>

<p>method ahash($/) { my $hash := PAST::Op.new( :name(&#39;hash&#39;), :node($/) ); if $&#60;assocs&#62; { my $items := $( $&#60;assocs&#62;[0] ); for @($items) { $hash.push( $_ ); } } make $hash; }</p>

<p>method assocs($/) { my $assoc := PAST::Stmts.new(:node($/)); for $&#60;assoc&#62; { my $item := $( $_ ); $assoc.push($item); } make $assoc; }</p>

<p>method assoc($/) { my $past := PAST::Op.new(:name(&#39;list&#39;), :node($/)); $past.push( $( $&#60;arg&#62;[0] ) ); $past.push( $( $&#60;arg&#62;[1] ) ); make $past; }</p>

<p>method float($/) { make PAST::Val.new( :value( ~$/ ), :returns(&#39;Float&#39;), :node($/) ); }</p>

<p>method integer($/) { make PAST::Val.new( :value( ~$/ ), :returns(&#39;CardinalInteger&#39;), :node($/) ); }</p>

<p>method string($/) { make PAST::Val.new( :value( ~$&#60;string_literal&#62; ), :returns(&#39;CardinalString&#39;), :node($/) ); }</p>

<p>method regex($/) { make $($&#60;quote_expression&#62;); }</p>

<p>method quote_expression($/, $key) { my $past; if $key eq &#39;quote_regex&#39; { our $?NS; $past := PAST::Block.new( $&#60;quote_regex&#62;, :compiler(&#39;PGE::Perl6Regex&#39;), :namespace($?NS), :blocktype(&#39;declaration&#39;), :node( $/ ) ); } elsif $key eq &#39;quote_concat&#39; { if +$&#60;quote_concat&#62; == 1 { $past := $( $&#60;quote_concat&#62;[0] ); } else { $past := PAST::Op.new( :name(&#39;list&#39;), :pasttype(&#39;call&#39;), :node( $/ ) ); for $&#60;quote_concat&#62; { $past.push( $($_) ); } } } make $past; }</p>

<p>method quote_concat($/) { my $terms := +$&#60;quote_term&#62;; my $count := 1; my $past := $( $&#60;quote_term&#62;[0] ); while ($count != $terms) { $past := PAST::Op.new( $past, $( $&#60;quote_term&#62;[$count] ), :pirop(&#39;concat&#39;), :pasttype(&#39;pirop&#39;) ); $count := $count + 1; } make $past; }</p>

<p>method quote_term($/, $key) { my $past; if ($key eq &#39;literal&#39;) { $past := PAST::Val.new( :value( ~$&#60;quote_literal&#62; ), :returns(&#39;CardinalString&#39;), :node($/) ); } elsif ($key eq &#39;variable&#39;) { $past := $( $&#60;variable&#62; ); } elsif ($key eq &#39;circumfix&#39;) { $past := $( $&#60;circumfix&#62; ); if $past.WHAT() eq &#39;Block&#39; { $past.blocktype(&#39;immediate&#39;); } } make $past; }</p>

<p>method arg($/, $key) { ## Handle the operator table ## if ($key eq &#39;end&#39;) { make $($&#60;expr&#62;); } else { my $past := PAST::Op.new( :name($&#60;type&#62;), :pasttype($&#60;top&#62;&#60;pasttype&#62;), :pirop($&#60;top&#62;&#60;pirop&#62;), :lvalue($&#60;top&#62;&#60;lvalue&#62;), :node($/) ); for @($/) { $past.push( $($_) ); } make $past; } }</p>

<p>sub is_a_sub($name) { our $?BLOCK; our @?BLOCK; if $?BLOCK.symbol(~$name) { if defined($?BLOCK.symbol(~$name)&#60;arity&#62;) { return(1); } else { return(0); } } for @?BLOCK { if $_ { my $sym_table := $_.symbol(~$name); if $sym_table { if defined($sym_table&#60;arity&#62;) { return(1); } else { return(0); } } } } my $lex := lex_lookup($name); if $lex &#38;&#38; ~lookup_class($lex) eq &#39;Sub&#39; { return(1); } return(0); }</p>

<p># Local Variables: # mode: cperl # cperl&#45;indent&#45;level: 4 # fill&#45;column: 100 # End: # vim: expandtab shiftwidth=4:</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../../../resources/parrot_small.png"
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
