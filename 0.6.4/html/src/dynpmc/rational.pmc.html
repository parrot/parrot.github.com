<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
    <HEAD>
        <TITLE>Rational numbers PMC</TITLE>
        <LINK REL="stylesheet" TYPE="text/css"
            HREF="../../../resources/perl.css"
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY>
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Rational numbers PMC</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../html/index.html">Contents</a> | <a href="../../../html/dynapmc.html">Dynamic PMCs</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>src/dynpmc/rational.pmc &#45; Rational numbers PMC</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Rational is currently going to get implemented.
It uses the GNU Multiple Precision (GMP) library,
like BigInt,
because implementation with integers would be too unstable and inaccurate.</p>

<p>&#39;LispRational&#39; will subclass this.</p>

<p>You may use Rational with any of parrot&#39;s basic data types as well as with String&#45;,
Integer&#45; and Float&#45;PMCs.</p>

<h1><a name="Functions"
>Functions <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Currently <code lang='und' xml:lang='und'>rational.pmc</code> only has some <code lang='und' xml:lang='und'>static</code> functions for code sharing.</p>

<ul>
<li>static STRING *rat_get_string_to_base(PARROT_INTERP,
PMC *self,
int base)</li><p class="pad"></p>

<p>Returns a string representation of a Rational&#45;PMC to a certain base.</p>

<li>static void rat_add_integer(PARROT_INTERP,
PMC *self,
int value,
PMC *dest)</li><p class="pad"></p>

<p>Adds an integer &#34;value&#34; to a Rational&#45;PMC and stores the result in (another) Rational&#45;PMC.</p>

<li>static void rat_add_float(PARROT_INTERP,
PMC *self,
double value,
PMC *dest)</li><p class="pad"></p>

<p>Adds a float &#34;value&#34; to a Rational&#45;PMC and stores the result in (another) Rational&#45;PMC.
&#34;value&#34; is first conveted to a rational using GMPs mpq_set_d&#45;function.
This is meant to be exact.</p>

<li>static void rat_multiply_integer(PARROT_INTERP,
PMC *self,
int value,
PMC *dest)</li><p class="pad"></p>

<p>Multiplys a Rational&#45;PMC with an integer &#34;value&#34; and stores the result in (another) Rational&#45;PMC.</p>

<li>static void rat_multiply_float(PARROT_INTERP,
PMC *self,
double value,
PMC *dest)</li><p class="pad"></p>

<p>Multiplies a Rational&#45;PMC with a float &#34;value&#34; and stores the result in (another) Rational&#45;PMC.</p>

<li>static void rat_divide_integer(PARROT_INTERP,
PMC *self,
int value,
PMC *dest)</li><p class="pad"></p>

<p>Divides a Rational&#45;PMC through an integer &#34;value&#34; and stores the result in (another) Rational&#45;PMC.</p>

<li>static void rat_divide_float(PARROT_INTERP,
PMC *self,
double value,
PMC *dest)</li><p class="pad"></p>

<p>Divides a Rational&#45;PMC through a float &#34;value&#34; and stores the result in (another) Rational&#45;PMC.</p>

<li>static void rat_power_int(PARROT_INTERP,
PMC *self,
int value,
PMC *dest)</li><p class="pad"></p>

<p>Calculates the power of a Rational&#45;PMC to an exponent value and stores the result in (another) Rational&#45;PMC.</p>
</ul>

<h2><a name="Methods"
>Methods <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>The DynPMC Rational has the following methods.
Note,
that all methods depend on GMP.
If GMP is not available,
an exception is thrown in almost all cases.
The only exception is the version&#45;method.</p>

<dl>
<dt><a name="METHOD_version()"
><b><code lang='und' xml:lang='und'>METHOD version()</b></code></a></dt><p class="pad"></p>

<dd>Returns the version of GNU Multiple Precision library.
Returns 0.0.0,
if GMP is not available.</dd><p class="pad"></p>

<dt><a name="void_init()"
><b><code lang='und' xml:lang='und'>void init()</b></code></a></dt><p class="pad"></p>

<dt><a name="void_clone()"
><b><code lang='und' xml:lang='und'>void clone()</b></code></a></dt><p class="pad"></p>

<dt><a name="void_destroy()"
><b><code lang='und' xml:lang='und'>void destroy()</b></code></a></dt><p class="pad"></p>

<dt><a name="void_set_integer_native(INTVAL)"
><b><code lang='und' xml:lang='und'>void set_integer_native(INTVAL)</b></code></a></dt><p class="pad"></p>

<dt><a name="void_set_number_native(FLOATVAL)"
><b><code lang='und' xml:lang='und'>void set_number_native(FLOATVAL)</b></code></a></dt><p class="pad"></p>

<dt><a name="void_set_string_native(STRING*)"
><b><code lang='und' xml:lang='und'>void set_string_native(STRING*)</b></code></a></dt><p class="pad"></p>

<dt><a name="void_set_string_keyed_int(INTVAL_base,_STRING_*value)"
><b><code lang='und' xml:lang='und'>void set_string_keyed_int(INTVAL base, STRING *value)</b></code></a></dt><p class="pad"></p>

<dt><a name="INTVAL_get_integer()"
><b><code lang='und' xml:lang='und'>INTVAL get_integer()</b></code></a></dt><p class="pad"></p>

<dt><a name="get_number()"
><b><code lang='und' xml:lang='und'>get_number()</b></code></a></dt><p class="pad"></p>

<dt><a name="get_bool()"
><b><code lang='und' xml:lang='und'>get_bool()</b></code></a></dt><p class="pad"></p>

<dt><a name="STRING_*get_string()"
><b><code lang='und' xml:lang='und'>STRING *get_string()</b></code></a></dt><p class="pad"></p>

<dt><a name="STRING_*get_string_keyed_int(INTVAL_base)"
><b><code lang='und' xml:lang='und'>STRING *get_string_keyed_int(INTVAL base)</b></code></a></dt><p class="pad"></p>

<dt><a name="void_increment()"
><b><code lang='und' xml:lang='und'>void increment()</b></code></a></dt><p class="pad"></p>

<dt><a name="void_decrement()"
><b><code lang='und' xml:lang='und'>void decrement()</b></code></a></dt><p class="pad"></p>

<dt><a name="PMC_*add(PMC*_value,_PMC*_dest)"
><b><code lang='und' xml:lang='und'>PMC *add(PMC *value, PMC *dest)</b></code></a></dt><p class="pad"></p>

<dd>Adds Integer&#45;,
Float&#45; or Rational&#45;PMCs to SELF and stores them in dest.</dd><p class="pad"></p>

<dt><a name="void_i_add(PMC_*value)"
><b><code lang='und' xml:lang='und'>void i_add(PMC *value)</b></code></a></dt><p class="pad"></p>

<dt><a name="PMC_*add_int(INTVAL_value,_PMC*_dest)"
><b><code lang='und' xml:lang='und'>PMC *add_int(INTVAL value, PMC *dest)</b></code></a></dt><p class="pad"></p>

<dt><a name="void_i_add_int(INTVAL_value)"
><b><code lang='und' xml:lang='und'>void i_add_int(INTVAL value)</b></code></a></dt><p class="pad"></p>

<dt><a name="PMC_*add_float(FLOATVAL_value,_PMC*_dest)"
><b><code lang='und' xml:lang='und'>PMC *add_float(FLOATVAL value, PMC *dest)</b></code></a></dt><p class="pad"></p>

<dt><a name="void_i_add_float(FLOATVAL_value)"
><b><code lang='und' xml:lang='und'>void i_add_float(FLOATVAL value)</b></code></a></dt><p class="pad"></p>

<dt><a name="PMC_*subtract(PMC*_value,_PMC*_dest)"
><b><code lang='und' xml:lang='und'>PMC *subtract(PMC *value, PMC *dest)</b></code></a></dt><p class="pad"></p>

<dt><a name="void_i_subtract(PMC_*value)"
><b><code lang='und' xml:lang='und'>void i_subtract(PMC *value)</b></code></a></dt><p class="pad"></p>

<dt><a name="PMC_*subtract_int(INTVAL_value,_PMC*_dest)"
><b><code lang='und' xml:lang='und'>PMC *subtract_int(INTVAL value, PMC *dest)</b></code></a></dt><p class="pad"></p>

<dt><a name="void_i_subtract_int(INTVAL_value)"
><b><code lang='und' xml:lang='und'>void i_subtract_int(INTVAL value)</b></code></a></dt><p class="pad"></p>

<dt><a name="PMC_*subtract_float(FLOATVAL_value,_PMC*_dest)"
><b><code lang='und' xml:lang='und'>PMC *subtract_float(FLOATVAL value, PMC *dest)</b></code></a></dt><p class="pad"></p>

<dt><a name="void_i_subtract_float(FLOATVAL_value)"
><b><code lang='und' xml:lang='und'>void i_subtract_float(FLOATVAL value)</b></code></a></dt><p class="pad"></p>

<dt><a name="PMC_*multiply(PMC*_value,_PMC*_dest)"
><b><code lang='und' xml:lang='und'>PMC *multiply(PMC *value, PMC *dest)</b></code></a></dt><p class="pad"></p>

<dt><a name="void_i_multiply(PMC_*value)"
><b><code lang='und' xml:lang='und'>void i_multiply(PMC *value)</b></code></a></dt><p class="pad"></p>

<dt><a name="PMC_*multiply_int(INTVAL_value,_PMC*_dest)"
><b><code lang='und' xml:lang='und'>PMC *multiply_int(INTVAL value, PMC *dest)</b></code></a></dt><p class="pad"></p>

<dt><a name="void_i_multiply_int(INTVAL_value)"
><b><code lang='und' xml:lang='und'>void i_multiply_int(INTVAL value)</b></code></a></dt><p class="pad"></p>

<dt><a name="PMC_*multiply_float(FLOATVAL_value,_PMC*_dest)"
><b><code lang='und' xml:lang='und'>PMC *multiply_float(FLOATVAL value, PMC *dest)</b></code></a></dt><p class="pad"></p>

<dt><a name="void_i_multiply_float(FLOATVAL_value)"
><b><code lang='und' xml:lang='und'>void i_multiply_float(FLOATVAL value)</b></code></a></dt><p class="pad"></p>

<dt><a name="PMC_*divide(PMC*_value,_PMC*_dest)"
><b><code lang='und' xml:lang='und'>PMC *divide(PMC *value, PMC *dest)</b></code></a></dt><p class="pad"></p>

<dt><a name="void_i_divide(PMC_*value)"
><b><code lang='und' xml:lang='und'>void i_divide(PMC *value)</b></code></a></dt><p class="pad"></p>

<dt><a name="PMC_*divide_int(INTVAL_value,_PMC*_dest)"
><b><code lang='und' xml:lang='und'>PMC *divide_int(INTVAL value, PMC *dest)</b></code></a></dt><p class="pad"></p>

<dt><a name="void_i_divide_int(INTVAL_value)"
><b><code lang='und' xml:lang='und'>void i_divide_int(INTVAL value)</b></code></a></dt><p class="pad"></p>

<dt><a name="PMC_*divide_float(FLOATVAL_value,_PMC*_dest)"
><b><code lang='und' xml:lang='und'>PMC *divide_float(FLOATVAL value, PMC *dest)</b></code></a></dt><p class="pad"></p>

<dt><a name="void_i_divide_float(FLOATVAL_value)"
><b><code lang='und' xml:lang='und'>void i_divide_float(FLOATVAL value)</b></code></a></dt><p class="pad"></p>

<dt><a name="PMC_*negate(PMC*_dest)"
><b><code lang='und' xml:lang='und'>PMC *negate(PMC *dest)</b></code></a></dt><p class="pad"></p>

<dt><a name="void_i_negate()"
><b><code lang='und' xml:lang='und'>void i_negate()</b></code></a></dt><p class="pad"></p>

<dt><a name="PMC_*absolute(PMC*_dest)"
><b><code lang='und' xml:lang='und'>PMC *absolute(PMC *dest)</b></code></a></dt><p class="pad"></p>

<dt><a name="void_i_absolute()"
><b><code lang='und' xml:lang='und'>void i_absolute()</b></code></a></dt><p class="pad"></p>

<dt><a name="INTVAL_cmp(PMC_*value)"
><b><code lang='und' xml:lang='und'>INTVAL cmp(PMC *value)</b></code></a></dt><p class="pad"></p>

<dt><a name="INTVAL_is_equal(PMC_*value)"
><b><code lang='und' xml:lang='und'>INTVAL is_equal(PMC *value)</b></code></a></dt><p class="pad"></p>
</dl>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../resources/parrot_small.png"
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
