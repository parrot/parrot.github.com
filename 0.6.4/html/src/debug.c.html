<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
    <HEAD>
        <TITLE>Parrot debugging</TITLE>
        <LINK REL="stylesheet" TYPE="text/css"
            HREF="../../resources/perl.css"
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY>
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Parrot debugging</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../html/index.html">Contents</a> | <a href="../../html/c.html">C</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>src/debug.c &#45; Parrot debugging</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>This file implements Parrot debugging and is used by <code lang='und' xml:lang='und'>pdb</code>,
the Parrot debugger,
and the <code lang='und' xml:lang='und'>debug</code> ops.</p>

<h2><a name="Functions"
>Functions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="static_const_char_*_nextarg"
><b><code lang='und' xml:lang='und'>static const char *nextarg</b></code></a></dt><p class="pad"></p>

<dd>Returns the position just past the current argument in the PASM instruction <code lang='und' xml:lang='und'>command</code>.
This is not the same as <code lang='und' xml:lang='und'>skip_command()</code>,
which is intended for debugger commands.
This function is used for <code lang='und' xml:lang='und'>eval</code>.</dd><p class="pad"></p>

<dt><a name="static_const_char_*_skip_command"
><b><code lang='und' xml:lang='und'>static const char *skip_command</b></code></a></dt><p class="pad"></p>

<dd>Returns the pointer past the current debugger command.
(This is an alternative to the <code lang='und' xml:lang='und'>skip_command()</code> macro above.)</dd><p class="pad"></p>

<dt><a name="static_const_char_*_parse_int"
><b><code lang='und' xml:lang='und'>static const char *parse_int</b></code></a></dt><p class="pad"></p>

<dd>Parse an <code lang='und' xml:lang='und'>int</code> out of a string and return a pointer to just after the <code lang='und' xml:lang='und'>int</code>.
The output parameter <code lang='und' xml:lang='und'>intP</code> contains the parsed value.</dd><p class="pad"></p>

<dt><a name="static_const_char_*_parse_string"
><b><code lang='und' xml:lang='und'>static const char *parse_string</b></code></a></dt><p class="pad"></p>

<dd>Parse a double&#45;quoted string out of a C string and return a pointer to just after the string.
The parsed string is converted to a Parrot <code lang='und' xml:lang='und'>STRING</code> and placed in the output parameter <code lang='und' xml:lang='und'>strP</code>.</dd><p class="pad"></p>

<dt><a name="static_const_char*_parse_key"
><b><code lang='und' xml:lang='und'>static const char *parse_key</b></code></a></dt><p class="pad"></p>

<dd>Parse an aggregate key out of a string and return a pointer to just after the key.
Currently only string and integer keys are allowed.</dd><p class="pad"></p>

<dt><a name="static_const_char_*_parse_command"
><b><code lang='und' xml:lang='und'>static const char *parse_command</b></code></a></dt><p class="pad"></p>

<dd>Convert the command at the beginning of a string into a numeric value that can be used as a switch key for fast lookup.</dd><p class="pad"></p>

<dt><a name="void_Parrot_debugger_init"
><b><code lang='und' xml:lang='und'>void Parrot_debugger_init</b></code></a></dt><p class="pad"></p>

<dd>Initializes the Parrot debugger,
if it&#39;s not already initialized.</dd><p class="pad"></p>

<dt><a name="void_Parrot_debugger_load"
><b><code lang='und' xml:lang='und'>void Parrot_debugger_load</b></code></a></dt><p class="pad"></p>

<dd>Loads a Parrot source file for the current program.</dd><p class="pad"></p>

<dt><a name="void_Parrot_debugger_break"
><b><code lang='und' xml:lang='und'>void Parrot_debugger_break</b></code></a></dt><p class="pad"></p>

<dd>Breaks execution and drops into the debugger.
If we are already into the debugger and it is the first call,
set a breakpoint.</dd><p class="pad"></p>

<dd>When you re run/continue the program being debugged it will pay no attention to the debug ops.</dd><p class="pad"></p>

<dd>RT #42377: clone the interpreter to allow people to play into the debugger and then continue the normal execution of the program.</dd><p class="pad"></p>

<dt><a name="void_PDB_get_command"
><b><code lang='und' xml:lang='und'>void PDB_get_command</b></code></a></dt><p class="pad"></p>

<dd>Get a command from the user input to execute.</dd><p class="pad"></p>

<dd>It saves the last command executed (in <code lang='und' xml:lang='und'>pdb&#45;&#62;last_command</code>),
so it first frees the old one and updates it with the current one.</dd><p class="pad"></p>

<dd>Also prints the next line to run if the program is still active.</dd><p class="pad"></p>

<dd>The user input can&#39;t be longer than DEBUG_CMD_BUFFER_LENGTH characters.</dd><p class="pad"></p>

<dd>The input is saved in <code lang='und' xml:lang='und'>pdb&#45;&#62;cur_command</code>.</dd><p class="pad"></p>

<dt><a name="void_PDB_script_file"
><b><code lang='und' xml:lang='und'>void PDB_script_file</b></code></a></dt><p class="pad"></p>

<dd>Interprets the contents of a file as user input commands</dd><p class="pad"></p>

<dt><a name="int_PDB_run_command"
><b><code lang='und' xml:lang='und'>int PDB_run_command</b></code></a></dt><p class="pad"></p>

<dd>Run a command.</dd><p class="pad"></p>

<dd>Hash the command to make a simple switch calling the correct handler.</dd><p class="pad"></p>

<dt><a name="void_PDB_next"
><b><code lang='und' xml:lang='und'>void PDB_next</b></code></a></dt><p class="pad"></p>

<dd>Execute the next N operation(s).</dd><p class="pad"></p>

<dd>Inits the program if needed,
runs the next N &#62;= 1 operations and stops.</dd><p class="pad"></p>

<dt><a name="void_PDB_trace"
><b><code lang='und' xml:lang='und'>void PDB_trace</b></code></a></dt><p class="pad"></p>

<dd>Execute the next N operations; if no number is specified,
it defaults to 1.</dd><p class="pad"></p>

<dt><a name="PDB_condition_t_*_PDB_cond"
><b><code lang='und' xml:lang='und'>PDB_condition_t *PDB_cond</b></code></a></dt><p class="pad"></p>

<dd>Analyzes a condition from the user input.</dd><p class="pad"></p>

<dt><a name="void_PDB_watchpoint"
><b><code lang='und' xml:lang='und'>void PDB_watchpoint</b></code></a></dt><p class="pad"></p>

<dd>Set a watchpoint.</dd><p class="pad"></p>

<dt><a name="void_PDB_set_break"
><b><code lang='und' xml:lang='und'>void PDB_set_break</b></code></a></dt><p class="pad"></p>

<dd>Set a break point,
the source code file must be loaded.</dd><p class="pad"></p>

<dt><a name="void_PDB_init"
><b><code lang='und' xml:lang='und'>void PDB_init</b></code></a></dt><p class="pad"></p>

<dd>Init the program.</dd><p class="pad"></p>

<dt><a name="void_PDB_continue"
><b><code lang='und' xml:lang='und'>void PDB_continue</b></code></a></dt><p class="pad"></p>

<dd>Continue running the program.
If a number is specified,
skip that many breakpoints.</dd><p class="pad"></p>

<dt><a name="PDB_breakpoint_t_*_PDB_find_breakpoint"
><b><code lang='und' xml:lang='und'>PDB_breakpoint_t *PDB_find_breakpoint</b></code></a></dt><p class="pad"></p>

<dd>Find breakpoint number N; returns <code lang='und' xml:lang='und'>NULL</code> if the breakpoint doesn&#39;t exist or if no breakpoint was specified.</dd><p class="pad"></p>

<dt><a name="void_PDB_disable_breakpoint"
><b><code lang='und' xml:lang='und'>void PDB_disable_breakpoint</b></code></a></dt><p class="pad"></p>

<dd>Disable a breakpoint; it can be reenabled with the enable command.</dd><p class="pad"></p>

<dt><a name="void_PDB_enable_breakpoint"
><b><code lang='und' xml:lang='und'>void PDB_enable_breakpoint</b></code></a></dt><p class="pad"></p>

<dd>Reenable a disabled breakpoint; if the breakpoint was not disabled,
has no effect.</dd><p class="pad"></p>

<dt><a name="void_PDB_delete_breakpoint"
><b><code lang='und' xml:lang='und'>void PDB_delete_breakpoint</b></code></a></dt><p class="pad"></p>

<dd>Delete a breakpoint.</dd><p class="pad"></p>

<dt><a name="void_PDB_delete_condition"
><b><code lang='und' xml:lang='und'>void PDB_delete_condition</b></code></a></dt><p class="pad"></p>

<dd>Delete a condition associated with a breakpoint.</dd><p class="pad"></p>

<dt><a name="void_PDB_skip_breakpoint"
><b><code lang='und' xml:lang='und'>void PDB_skip_breakpoint</b></code></a></dt><p class="pad"></p>

<dd>Skip <code lang='und' xml:lang='und'>i</code> times all breakpoints.</dd><p class="pad"></p>

<dt><a name="char_PDB_program_end"
><b><code lang='und' xml:lang='und'>char PDB_program_end</b></code></a></dt><p class="pad"></p>

<dd>End the program.</dd><p class="pad"></p>

<dt><a name="char_PDB_check_condition"
><b><code lang='und' xml:lang='und'>char PDB_check_condition</b></code></a></dt><p class="pad"></p>

<dd>Returns true if the condition was met.</dd><p class="pad"></p>

<dt><a name="char_PDB_break"
><b><code lang='und' xml:lang='und'>char PDB_break</b></code></a></dt><p class="pad"></p>

<dd>Returns true if we have to stop running.</dd><p class="pad"></p>

<dt><a name="char_*_PDB_escape"
><b><code lang='und' xml:lang='und'>char *PDB_escape</b></code></a></dt><p class="pad"></p>

<dd>Escapes <code lang='und' xml:lang='und'>&#34;</code>,
<code lang='und' xml:lang='und'>\r</code>,
<code lang='und' xml:lang='und'>\n</code>,
<code lang='und' xml:lang='und'>\t</code>,
<code lang='und' xml:lang='und'>\a</code> and <code lang='und' xml:lang='und'>\\</code>.</dd><p class="pad"></p>

<dd>The returned string must be freed.</dd><p class="pad"></p>

<dt><a name="int_PDB_unescape"
><b><code lang='und' xml:lang='und'>int PDB_unescape</b></code></a></dt><p class="pad"></p>

<dd>Do inplace unescape of <code lang='und' xml:lang='und'>\r</code>,
<code lang='und' xml:lang='und'>\n</code>,
<code lang='und' xml:lang='und'>\t</code>,
<code lang='und' xml:lang='und'>\a</code> and <code lang='und' xml:lang='und'>\\</code>.</dd><p class="pad"></p>

<dt><a name="size_t_PDB_disassemble_op"
><b><code lang='und' xml:lang='und'>size_t PDB_disassemble_op</b></code></a></dt><p class="pad"></p>

<dd>Disassembles <code lang='und' xml:lang='und'>op</code>.</dd><p class="pad"></p>

<dt><a name="void_PDB_disassemble"
><b><code lang='und' xml:lang='und'>void PDB_disassemble</b></code></a></dt><p class="pad"></p>

<dd>Disassemble the bytecode.</dd><p class="pad"></p>

<dt><a name="long_PDB_add_label"
><b><code lang='und' xml:lang='und'>long PDB_add_label</b></code></a></dt><p class="pad"></p>

<dd>Add a label to the label list.</dd><p class="pad"></p>

<dt><a name="void_PDB_free_file"
><b><code lang='und' xml:lang='und'>void PDB_free_file</b></code></a></dt><p class="pad"></p>

<dd>Frees any allocated source files.</dd><p class="pad"></p>

<dt><a name="void_PDB_load_source"
><b><code lang='und' xml:lang='und'>void PDB_load_source</b></code></a></dt><p class="pad"></p>

<dd>Load a source code file.</dd><p class="pad"></p>

<dt><a name="char_PDB_hasinstruction"
><b><code lang='und' xml:lang='und'>char PDB_hasinstruction</b></code></a></dt><p class="pad"></p>

<dd>Return true if the line has an instruction.</dd><p class="pad"></p>

<dd>RT #46129:</dd><p class="pad"></p>

<ul>
<li>This should take the line,
get an instruction,
get the opcode for that instruction and check that is the correct one.</li><p class="pad"></p>

<li>Decide what to do with macros if anything.</li><p class="pad"></p>
</ul>

<dt><a name="void_PDB_list"
><b><code lang='und' xml:lang='und'>void PDB_list</b></code></a></dt><p class="pad"></p>

<dd>Show lines from the source code file.</dd><p class="pad"></p>

<dt><a name="void_PDB_eval"
><b><code lang='und' xml:lang='und'>void PDB_eval</b></code></a></dt><p class="pad"></p>

<dd><code lang='und' xml:lang='und'>eval</code>s an instruction.</dd><p class="pad"></p>

<dt><a name="opcode_t_*_PDB_compile"
><b><code lang='und' xml:lang='und'>opcode_t *PDB_compile</b></code></a></dt><p class="pad"></p>

<dd>Compiles instructions with the PASM compiler.</dd><p class="pad"></p>

<dd>Appends an <code lang='und' xml:lang='und'>end</code> op.</dd><p class="pad"></p>

<dd>This may be called from <code lang='und' xml:lang='und'>PDB_eval</code> above or from the compile opcode which generates a malloced string.</dd><p class="pad"></p>

<dt><a name="static_void_dump_string"
><b><code lang='und' xml:lang='und'>static void dump_string</b></code></a></dt><p class="pad"></p>

<dd>Dumps the buflen,
flags,
bufused,
strlen,
and offset associated with a string and the string itself.</dd><p class="pad"></p>

<dt><a name="void_PDB_print"
><b><code lang='und' xml:lang='und'>void PDB_print</b></code></a></dt><p class="pad"></p>

<dd>Print interp registers.</dd><p class="pad"></p>

<dt><a name="void_PDB_info"
><b><code lang='und' xml:lang='und'>void PDB_info</b></code></a></dt><p class="pad"></p>

<dd>Print the interpreter info.</dd><p class="pad"></p>

<dt><a name="void_PDB_help"
><b><code lang='und' xml:lang='und'>void PDB_help</b></code></a></dt><p class="pad"></p>

<dd>Print the help text.
&#34;Help&#34; with no arguments prints a list of commands.
&#34;Help xxx&#34; prints information on command xxx.</dd><p class="pad"></p>

<dt><a name="void_PDB_backtrace"
><b><code lang='und' xml:lang='und'>void PDB_backtrace</b></code></a></dt><p class="pad"></p>

<dd>Prints a backtrace of the interp&#39;s call chain.</dd><p class="pad"></p>

<dt><a name="static_const_char*_GDB_print_reg"
><b><code lang='und' xml:lang='und'>static const char *GDB_print_reg</b></code></a></dt><p class="pad"></p>

<dd>Used by GDB_P to convert register values for display.
Takes register type and number as arguments.</dd><p class="pad"></p>

<dd>Returns a pointer to the start of the string,
(except for PMCs,
which print directly and return &#34;&#34;).</dd><p class="pad"></p>

<dt><a name="static_const_char*_GDB_P"
><b><code lang='und' xml:lang='und'>static const char *GDB_P</b></code></a></dt><p class="pad"></p>

<dd>Used by PDB_print to print register values.
Takes a pointer to the register name(s).</dd><p class="pad"></p>

<dd>Returns &#34;&#34; or error message.</dd><p class="pad"></p>

<dt><a name="static_int_GDB_B"
><b><code lang='und' xml:lang='und'>static int GDB_B</b></code></a></dt><p class="pad"></p>

<dd>Inserts a break&#45;point into a table (which it creates if necessary).
Takes an instruction counter (?).</dd><p class="pad"></p>

<dd>Currently unused.</dd><p class="pad"></p>

<dd>Returns break&#45;point count,
or &#45;1 if point is out of bounds.</dd><p class="pad"></p>
</dl>

<h1><a name="SEE_ALSO"
>SEE ALSO <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p><em lang='und' xml:lang='und'>include/parrot/debug.h</em>,
<em lang='und' xml:lang='und'><a href="pdb.c.html">src/pdb.c</a></em> and <em lang='und' xml:lang='und'>ops/debug.ops</em>.</p>

<h1><a name="HISTORY"
>HISTORY <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<dl>
<dt><a name="Initial_version_by_Daniel_Grunblatt_on_2002.5.19."
>Initial version by Daniel Grunblatt on 2002.5.19.</a></dt><p class="pad"></p>

<dt><a name="Start_of_rewrite_&#45;_leo_2005.02.16"
>Start of rewrite &#45; leo 2005.02.16</a></dt><p class="pad"></p>

<dd>The debugger now uses its own interpreter.
User code is run in Interp *debugee.
We have:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  debug_interp&#45;&#62;pdb&#45;&#62;debugee&#45;&#62;debugger
    ^                            |
    |                            v
    +&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; := &#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;+</pre>

<dd>Debug commands are mostly run inside the <code lang='und' xml:lang='und'>debugger</code>. User code runs of course in the <code lang='und' xml:lang='und'>debugee</code>.</dd><p class="pad"></p>
</dl>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../resources/parrot_small.png"
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
