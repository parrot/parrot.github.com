<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
    <HEAD>
        <TITLE>Parrot embedding system</TITLE>
        <LINK REL="stylesheet" TYPE="text/css"
            HREF="../../resources/perl.css"
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY>
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Parrot embedding system</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../html/index.html">Contents</a> | <a href="../../html/docs.html">Documentation</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>embed.pod &#45; Parrot embedding system</p>

<h1><a name="SYNOPSIS"
>SYNOPSIS <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<pre lang='und' xml:lang='und'>    #include &#60;parrot.h&#62;
    #include &#60;parrot/embed.h&#62;
    #include &#60;parrot/extend.h&#62;

    int main(int argc, char* argv[])
    {
        Parrot_Interp interp;
        Parrot_PackFile pf;

        interp = Parrot_new(NULL);
        if (!interp) {
            return 1;
        }

        pf = Parrot_readbc(interp, &#34;foo.pbc&#34;);
        Parrot_loadbc(interp, pf);
        Parrot_runcode(pf, argc, argv);

        Parrot_destroy(interp);

        return 0;
    }</pre>

<h1><a name="FILES"
>FILES <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<dl>
<dt><a name="include/parrot.h"
><em lang='und' xml:lang='und'>include/parrot.h</em></a></dt><p class="pad"></p>

<dt><a name="include/parrot/embed.h"
><em lang='und' xml:lang='und'>include/parrot/embed.h</em></a></dt><p class="pad"></p>

<dt><a name="include/parrot/extend.h"
><em lang='und' xml:lang='und'>include/parrot/extend.h</em></a></dt><p class="pad"></p>
</dl>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>This is the documentation for Parrot&#39;s embedding API.</p>

<h2><a name="Data_structures"
>Data structures <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="Parrot_Interp"
><b><code lang='und' xml:lang='und'>Parrot_Interp</b></code></a></dt><p class="pad"></p>

<dd>The topmost data structure in Parrot is <code lang='und' xml:lang='und'>Parrot_Interp</code>, which represents a Parrot interpreter. It is a required argument to almost every Parrot API function. The structure is opaque in an embedded environment, so you cannot directly access any of its members.</dd><p class="pad"></p>

<dt><a name="Parrot_PackFile"
><b><code lang='und' xml:lang='und'>Parrot_PackFile</b></code></a></dt><p class="pad"></p>

<dd>A Parrot packfile, the internal structure containing Parrot bytecode.</dd><p class="pad"></p>

<dt><a name="Parrot_String"
><b><code lang='und' xml:lang='und'>Parrot_String</b></code></a></dt><p class="pad"></p>

<dd>Parrot&#39;s internal string type, which contains character encoding information.</dd><p class="pad"></p>

<dt><a name="Parrot_PMC"
><b><code lang='und' xml:lang='und'>Parrot_PMC</b></code></a></dt><p class="pad"></p>

<dd>A Parrot Magic Cookie. This is the opaque external type for (PMC *). Note that this is a macro, so there can be only one <code lang='und' xml:lang='und'>Parrot_PMC</code> declaration per line.</dd><p class="pad"></p>

<dt><a name="Parrot_Int"
><b><code lang='und' xml:lang='und'>Parrot_Int</b></code></a></dt><p class="pad"></p>

<dt><a name="Parrot_Float"
><b><code lang='und' xml:lang='und'>Parrot_Float</b></code></a></dt><p class="pad"></p>

<dt><a name="Parrot_Int"
><b><code lang='und' xml:lang='und'>Parrot_Int</b></code></a></dt><p class="pad"></p>

<dt><a name="Parrot_UInt"
><b><code lang='und' xml:lang='und'>Parrot_UInt</b></code></a></dt><p class="pad"></p>

<dd>Parrot&#39;s numeric types.</dd><p class="pad"></p>
</dl>

<h2><a name="Constants"
>Constants <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Not documented yet.</p>

<h2><a name="Type_signatures"
>Type signatures <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>These are used with the Parrot_call_sub family of functions.</p>

<dl>
<dt><a name="v_&#45;_void_(return_only)"
>v &#45; void (return only)</a></dt><p class="pad"></p>

<dt><a name="I_&#45;_integer_(return_or_argument)"
>I &#45; integer (return or argument)</a></dt><p class="pad"></p>

<dt><a name="N_&#45;_float_(return_or_argument)"
>N &#45; float (return or argument)</a></dt><p class="pad"></p>

<dt><a name="S_&#45;_string_(return_or_argument)"
>S &#45; string (return or argument)</a></dt><p class="pad"></p>

<dt><a name="P_&#45;_PMC_(return_or_argument)"
>P &#45; PMC (return or argument)</a></dt><p class="pad"></p>
</dl>

<h2><a name="Interpreter_initialization_and_destruction"
>Interpreter initialization and destruction <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="Parrot_Interp_Parrot_new(Parrot_Interp_parent)"
><b><code lang='und' xml:lang='und'>Parrot_Interp Parrot_new(Parrot_Interp parent)</b></code></a></dt><p class="pad"></p>

<dd>Creates a new interpreter, inheriting some data structures from a parent interpreter, if supplied. The first interpreter in any process should be created with a NULL parent, and all subsequent interpreters in the same process should use the first interpreter as their parent. Failure to do so may result in unpredictable errors.</dd><p class="pad"></p>

<dt><a name="Parrot_set_flag(Parrot_Interp_interp,_Parrot_int_flags)"
><b><code lang='und' xml:lang='und'>Parrot_set_flag(Parrot_Interp interp, Parrot_int flags)</b></code></a></dt><p class="pad"></p>

<dd>Sets or unsets interpreter flags. Flags should be OR&#39;d together. Valid flags include:</dd><p class="pad"></p>

<dl>
<dt><a name="PARROT_NO_FLAGS"
>PARROT_NO_FLAGS</a></dt><p class="pad"></p>

<dt><a name="PARROT_BOUNDS_FLAG"
>PARROT_BOUNDS_FLAG</a></dt><p class="pad"></p>

<dt><a name="PARROT_GC_DEBUG_FLAG"
>PARROT_GC_DEBUG_FLAG</a></dt><p class="pad"></p>

<dt><a name="PARROT_EXTERN_CODE_FLAG"
>PARROT_EXTERN_CODE_FLAG</a></dt><p class="pad"></p>

<dt><a name="PARROT_DESTROY_FLAG"
>PARROT_DESTROY_FLAG</a></dt><p class="pad"></p>

<dt><a name="PARROT_IS_THREAD"
>PARROT_IS_THREAD</a></dt><p class="pad"></p>

<dt><a name="PARROT_THR_COPY_INTERP"
>PARROT_THR_COPY_INTERP</a></dt><p class="pad"></p>

<dt><a name="PARROT_THR_THREAD_POOL"
>PARROT_THR_THREAD_POOL</a></dt><p class="pad"></p>

<dt><a name="PARROT_THR_TYPE_1"
>PARROT_THR_TYPE_1</a></dt><p class="pad"></p>

<dt><a name="PARROT_THR_TYPE_2"
>PARROT_THR_TYPE_2</a></dt><p class="pad"></p>

<dt><a name="PARROT_THR_TYPE_3"
>PARROT_THR_TYPE_3</a></dt><p class="pad"></p>
</dl>

<dd>See <em lang='und' xml:lang='und'>interpreter.h</em> for the definition of these flags (TODO: document flag definitions here).</dd><p class="pad"></p>

<dt><a name="void_Parrot_set_run_core(Parrot_Interp_interp,_Parrot_Run_core_t_core)"
><b><code lang='und' xml:lang='und'>void Parrot_set_run_core(Parrot_Interp interp, Parrot_Run_core_t core)</b></code></a></dt><p class="pad"></p>

<dd>Sets the runcore for the interpreter. Must be called before executing any bytecode. Valid runcores include:</dd><p class="pad"></p>

<dl>
<dt><a name="PARROT_SLOW_CORE"
>PARROT_SLOW_CORE</a></dt><p class="pad"></p>

<dt><a name="PARROT_FUNCTION_CORE"
>PARROT_FUNCTION_CORE</a></dt><p class="pad"></p>

<dt><a name="PARROT_FAST_CORE"
>PARROT_FAST_CORE</a></dt><p class="pad"></p>

<dt><a name="PARROT_SWITCH_CORE"
>PARROT_SWITCH_CORE</a></dt><p class="pad"></p>

<dt><a name="PARROT_CGP_CORE"
>PARROT_CGP_CORE</a></dt><p class="pad"></p>

<dt><a name="PARROT_CGOTO_CORE"
>PARROT_CGOTO_CORE</a></dt><p class="pad"></p>

<dt><a name="PARROT_JIT_CORE"
>PARROT_JIT_CORE</a></dt><p class="pad"></p>

<dt><a name="PARROT_CGP_JIT_CORE"
>PARROT_CGP_JIT_CORE</a></dt><p class="pad"></p>

<dt><a name="PARROT_SWITCH_JIT_CORE"
>PARROT_SWITCH_JIT_CORE</a></dt><p class="pad"></p>

<dt><a name="PARROT_EXEC_CORE"
>PARROT_EXEC_CORE</a></dt><p class="pad"></p>

<dt><a name="PARROT_GC_DEBUG_CORE"
>PARROT_GC_DEBUG_CORE</a></dt><p class="pad"></p>
</dl>

<dd>See <em lang='und' xml:lang='und'>interpreter.h</em> for the definitive list. If you&#39;re not sure which runcore to use, don&#39;t call this function. The default will be fine for most cases. (TODO: document runcores here).</dd><p class="pad"></p>

<dt><a name="Parrot_set_trace(Parrot_Interp,_Parrot_UInt_flags)"
><b><code lang='und' xml:lang='und'>Parrot_set_trace(Parrot_Interp, Parrot_UInt flags)</b></code></a></dt><p class="pad"></p>

<dd>Sets the interpreter&#39;s trace flags. Flags should be OR&#39;d together. Valid flags are:</dd><p class="pad"></p>

<dl>
<dt><a name="PARROT_NO_TRACE"
>PARROT_NO_TRACE</a></dt><p class="pad"></p>

<dt><a name="PARROT_TRACE_OPS_FLAG"
>PARROT_TRACE_OPS_FLAG</a></dt><p class="pad"></p>

<dt><a name="PARROT_TRACE_FIND_METH_FLAG"
>PARROT_TRACE_FIND_METH_FLAG</a></dt><p class="pad"></p>

<dt><a name="PARROT_TRACE_SUB_CALL_FLAG"
>PARROT_TRACE_SUB_CALL_FLAG</a></dt><p class="pad"></p>

<dt><a name="PARROT_ALL_TRACE_FLAGS"
>PARROT_ALL_TRACE_FLAGS</a></dt><p class="pad"></p>

<dd></dd><p class="pad"></p>
</dl>

<dt><a name="void_Parrot_set_executable_name(Parrot_Interp_interp,_Parrot_string_name)"
><b><code lang='und' xml:lang='und'>void Parrot_set_executable_name(Parrot_Interp interp, Parrot_string name)</b></code></a></dt><p class="pad"></p>

<dd>Sets the executable name of the calling process. Note that the name is a Parrot string, not a C string.</dd><p class="pad"></p>

<dt><a name="void_Parrot_destroy(Parrot_Interp_interp)"
><b><code lang='und' xml:lang='und'>void Parrot_destroy(Parrot_Interp interp)</b></code></a></dt><p class="pad"></p>

<dd>Destroys an interpreter. At the time of this writing, this is a no&#45;op. See &#60;Parrot_really_destroy()&#62;.</dd><p class="pad"></p>

<dt><a name="void_Parrot_really_destroy(Parrot_Interp_interp,_int_exit_code)"
><b><code lang='und' xml:lang='und'>void Parrot_really_destroy(Parrot_Interp interp, int exit_code)</b></code></a></dt><p class="pad"></p>

<dd>Destroys an interpreter, regardless of the environment. The exit code is currently unused.</dd><p class="pad"></p>

<dt><a name="void_Parrot_exit(Parrot_Interp_interp,_int_status)"
><b><code lang='und' xml:lang='und'>void Parrot_exit(Parrot_Interp interp, int status)</b></code></a></dt><p class="pad"></p>

<dd>Destroys the interpreter and exits with an exit code of <code lang='und' xml:lang='und'>status</code>. Before exiting, the function calls all registered exit handlers in LIFO order. <code lang='und' xml:lang='und'>Parrot_really_destroy()</code> is usually called as the last exit handler.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>void Parrot_on_exit(Parrot_Interp interp, void (*handler)(Parrot_Interp, int, void *), void *arg)</b></code></a></dt><p class="pad"></p>

<dd>Registers an exit handler to be called from <code lang='und' xml:lang='und'>Parrot_exit()</code> in LIFO order. The handler function should accept as arguments an interpreter, an integer exit code, and an argument (which can be NULL).</dd><p class="pad"></p>

<dt><a name="void_imcc_init(Parrot_Interp_interp)"
><b><code lang='und' xml:lang='und'>void imcc_init(Parrot_Interp interp)</b></code></a></dt><p class="pad"></p>

<dd>Initializes the IMCC subsystem. Required for compiling PIR.</dd><p class="pad"></p>
</dl>

<h2><a name="Loading_and_running_bytecode"
>Loading and running bytecode <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="Parrot_PackFile_Parrot_readbc(Parrot_Interp_interp,_const_char_*path)"
><b><code lang='und' xml:lang='und'>Parrot_PackFile Parrot_readbc(Parrot_Interp interp, const char *path)</b></code></a></dt><p class="pad"></p>

<dd>Reads Parrot bytecode or PIR from the file referenced by <code lang='und' xml:lang='und'>path</code>. Returns a packfile structure for use by <code lang='und' xml:lang='und'>Parrot_loadbc()</code>.</dd><p class="pad"></p>

<dt><a name="void_Parrot_loadbc(Parrot_Interp_interp,_Parrot_PackFile_pf)"
><b><code lang='und' xml:lang='und'>void Parrot_loadbc(Parrot_Interp interp, Parrot_PackFile pf)</b></code></a></dt><p class="pad"></p>

<dd>Loads a packfile into the interpreter. After this operation the interpreter is ready to run the bytecode in the packfile.</dd><p class="pad"></p>

<dt><a name="void_Parrot_runcode(Parrot_Interp_interp,_int_argc,_char_*argv[])"
><b><code lang='und' xml:lang='und'>void Parrot_runcode(Parrot_Interp interp, int argc, char *argv[])</b></code></a></dt><p class="pad"></p>

<dd>Runs the bytecode associated with the interpreter. Use <code lang='und' xml:lang='und'>argc</code> and <code lang='und' xml:lang='und'>argv[]</code> to pass arguments to the bytecode.</dd><p class="pad"></p>

<dt><a name="Parrot_PackFile_PackFile_new_dummy(Parrot_Interp_interp,_char_*name)"
><b><code lang='und' xml:lang='und'>Parrot_PackFile PackFile_new_dummy(Parrot_Interp interp, char *name)</b></code></a></dt><p class="pad"></p>

<dd>Creates a &#34;dummy&#34; packfile in lieu of actually creating one from a bytecode file on disk.</dd><p class="pad"></p>

<dt><a name="void_Parrot_load_bytecode(Parrot_Interp_interp,_const_char_*path)"
><b><code lang='und' xml:lang='und'>void Parrot_load_bytecode(Parrot_Interp interp, const char *path)</b></code></a></dt><p class="pad"></p>

<dd>Reads and load Parrot bytecode or PIR from the file referenced by <code lang='und' xml:lang='und'>path</code>. You should create a dummy packfile beforehand; see <code lang='und' xml:lang='und'>PackFile_new_dummy</code> for details. Due to the void return type, the behavior of this function on error is unclear.</dd><p class="pad"></p>
</dl>

<h2><a name="Data_manipulation"
>Data manipulation <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<h3><a name="Native_types"
>Native types</a></h3>

<dl>
<dt><a name="int_Parrot_PMC_typenum(Parrot_Interp_interp,_const_char_*type)"
><b><code lang='und' xml:lang='und'>int Parrot_PMC_typenum(Parrot_Interp interp, const char *type)</b></code></a></dt><p class="pad"></p>

<dd>Returns the internal type number corresponding to <code lang='und' xml:lang='und'>type</code>. Useful for instantiating various Parrot data types.</dd><p class="pad"></p>

<dt><a name="char_*string_to_cstring(Parrot_Interp_interp)"
><b><code lang='und' xml:lang='und'>char *string_to_cstring(Parrot_Interp interp)</b></code></a></dt><p class="pad"></p>

<dd>XXX needs to be a formal Parrot_* API. Returns the C string representation of a Parrot string.</dd><p class="pad"></p>

<dt><a name="STRING_*string_from_cstring(Parrot_Interp_interp,_const_char_*string,_int_len)"
><b><code lang='und' xml:lang='und'>STRING *string_from_cstring(Parrot_Interp interp, const char *string, int len)</b></code></a></dt><p class="pad"></p>

<dd>XXX needs to be a formal Parrot_* API. Returns the Parrot string representation of a C string.</dd><p class="pad"></p>

<dt><a name="string_from_literal(Parrot_Interp_interp,_const_char_*string)"
><b><code lang='und' xml:lang='und'>string_from_literal(Parrot_Interp interp, const char *string)</b></code></a></dt><p class="pad"></p>

<dd>XXX needs to be a formal Parrot_* API. A macro for simplifying calls to <code lang='und' xml:lang='und'>string_from_cstring</code>.</dd><p class="pad"></p>
</dl>

<h3><a name="PMCs"
>PMCs</a></h3>

<dl>
<dt><a name="Parrot_PMC_Parrot_PMC_new(Parrot_Interp_interp,_int_typenum)"
><b><code lang='und' xml:lang='und'>Parrot_PMC Parrot_PMC_new(Parrot_Interp interp, int typenum)</b></code></a></dt><p class="pad"></p>

<dd>Creates a new PMC of the type identified by <code lang='und' xml:lang='und'>typenum</code>. Use <code lang='und' xml:lang='und'>Parrot_PMC_typenum</code> to obtain the correct type number.</dd><p class="pad"></p>

<dt><a name="void_Parrot_register_pmc(Parrot_PMC_pmc)"
><b><code lang='und' xml:lang='und'>void Parrot_register_pmc(Parrot_PMC pmc)</b></code></a></dt><p class="pad"></p>

<dd>Registers an externally created PMC with the garbage collector. You MUST call this for any PMCs you create outside of Parrot bytecode, otherwise your PMC may be garbage collected before you are finished using it.</dd><p class="pad"></p>

<dt><a name="void_Parrot_unregister_pmc(Parrot_PMC_pmc)"
><b><code lang='und' xml:lang='und'>void Parrot_unregister_pmc(Parrot_PMC pmc)</b></code></a></dt><p class="pad"></p>

<dd>Unegisters an externally created PMC from the garbage collector. You MUST call this after you are finished using PMCs you create outside of Parrot bytecode, or risk memory leaks.</dd><p class="pad"></p>
</dl>

<h3><a name="Globals"
>Globals</a></h3>

<dl>
<dt><a name="Parrot_PMC_Parrot_find_global_cur(Parrot_Interp_interp,_Parrot_String_name)"
><b><code lang='und' xml:lang='und'>Parrot_PMC Parrot_find_global_cur(Parrot_Interp interp, Parrot_String name)</b></code></a></dt><p class="pad"></p>

<dd>Find and return a global called <code lang='und' xml:lang='und'>name</code> in the current namespace. Returns <code lang='und' xml:lang='und'>PMCNULL</code> if not found.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>Parrot_PMC Parrot_find_global_n(Parrot_Interp interp, Parrot_String namespace, Parrot_String name)</b></code></a></dt><p class="pad"></p>

<dd>Not documented yet.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>Parrot_PMC Parrot_find_global_s(Parrot_Interp interp, Parrot_String namespace, Parrot_String name)</b></code></a></dt><p class="pad"></p>

<dd>Find and return a global called <code lang='und' xml:lang='und'>name</code> in the namespace <code lang='und' xml:lang='und'>namespace</code>. Returns <code lang='und' xml:lang='und'>PMCNULL</code> if not found.</dd><p class="pad"></p>

<dt><a name="void_Parrot_store_global_cur(Parrot_Interp_interp,_Parrot_String_name,_Parrot_PMC_val)"
><b><code lang='und' xml:lang='und'>void Parrot_store_global_cur(Parrot_Interp interp, Parrot_String name, Parrot_PMC val)</b></code></a></dt><p class="pad"></p>

<dd>Sets the value of a global called <code lang='und' xml:lang='und'>name</code> in the current namespace. Does nothing if the global is not found.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>void Parrot_store_global_n(Parrot_Interp interp, Parrot_String namespace, Parrot_String name, Parrot_PMC val)</b></code></a></dt><p class="pad"></p>

<dd>Not documented yet.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>void Parrot_store_global_s(Parrot_Interp interp, Parrot_String namespace, Parrot_String name, Parrot_PMC val)</b></code></a></dt><p class="pad"></p>

<dd>Sets the value of a global called <code lang='und' xml:lang='und'>name</code> in the namespace <code lang='und' xml:lang='und'>namespace</code>. Does nothing if the global is not found.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>Parrot_PMC Parrot_find_global_k(Parrot_Interp interp, Parrot_PMC namespace_key, Parrot_String name)</b></code></a></dt><p class="pad"></p>

<dd>Find and return a global called <code lang='und' xml:lang='und'>name</code> in the keyed namespace <code lang='und' xml:lang='und'>namespace</code>. Returns <code lang='und' xml:lang='und'>PMCNULL</code> if not found.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>void Parrot_store_global_k(Parrot_Interp interp, Parrot_PMC namespace_key, Parrot_String name, Parrot_PMC val)</b></code></a></dt><p class="pad"></p>

<dd>Sets the value of a global called <code lang='und' xml:lang='und'>name</code> in the keyed namespace <code lang='und' xml:lang='und'>namespace</code>. Does nothing if the global is not found.</dd><p class="pad"></p>
</dl>

<h3><a name="Lexicals"
>Lexicals</a></h3>

<p>Not documented yet.</p>

<h2><a name="Calling_subroutines"
>Calling subroutines <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="void_*Parrot_call_sub(Parrot_Interp_interp,_Parrot_PMC_sub,_const_char_*signature)"
><b><code lang='und' xml:lang='und'>void *Parrot_call_sub(Parrot_Interp interp, Parrot_PMC sub, const_char *signature)</b></code></a></dt><p class="pad"></p>

<dd>Call a Parrot subroutine that returns a pointer using the supplied signature.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>Parrot_Int Parrot_call_sub_ret_int(Parrot_Interp interp, Parrot_PMC sub, const_char *signature)</b></code></a></dt><p class="pad"></p>

<dd>Call a Parrot subroutine that returns an integer using the supplied signature.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>Parrot_Float Parrot_call_sub_ret_float(Parrot_Interp interp, Parrot_PMC sub, const_char *signature)</b></code></a></dt><p class="pad"></p>

<dd>Call a Parrot subroutine that returns an float using the supplied signature.</dd><p class="pad"></p>
</dl>

<h2><a name="Objects"
>Objects <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<h3><a name="Creating_and_destroying_objects"
>Creating and destroying objects</a></h3>

<dl>
<dt><a name="Parrot_PMC_Parrot_oo_get_class(Parrot_Interp_interp,_Parrot_PMC_namespace)"
><b><code lang='und' xml:lang='und'>Parrot_PMC Parrot_oo_get_class(Parrot_Interp interp, Parrot_PMC namespace)</b></code></a></dt><p class="pad"></p>

<dd>Returns the class corresponding to the supplied namespace.</dd><p class="pad"></p>

<dt><a
><b><code lang='und' xml:lang='und'>Parrot_PMC Parrot_Class_instantiate(Parrot_Interp interp, Parrot_PMC the_class Parrot_PMC arg)</b></code></a></dt><p class="pad"></p>

<dd>Instantiates a new object of class <code lang='und' xml:lang='und'>the_class</code>, which can be obtained from <code lang='und' xml:lang='und'>Parrot_oo_get_class()</code>. Passes an optional PMC argument <code lang='und' xml:lang='und'>arg</code> to the constructor (see init versus init_pmc). Use <code lang='und' xml:lang='und'>PMCNULL</code> if you are not supplying an argument.</dd><p class="pad"></p>
</dl>

<h3><a name="Calling_methods"
>Calling methods</a></h3>

<p>Not documented yet.</p>

<h1><a name="COMPILING"
>COMPILING <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>Note: This section is aimed at you if you are writing an application external to parrot which links against an installed parrot library.</p>

<h2><a name="Caveats"
>Caveats <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Several API functions are missing prototypes in Parrot&#39;s header files. This means you may receive type warnings during compilation even though the types of your arguments and return variables are correct. In this case it is safe to cast to the correct type; not doing so may cause undesired behavior.</p>

<h2><a name="Compiler_and_linker_flags"
>Compiler and linker flags <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>Your application will need to include the appropriate header files and link against parrot and its dependencies.</p>

<p>Because the location of these files can vary from platform to platform, and build to build, a general method is provided to find out the necessary flags to use.</p>

<p>pkg&#45;config is a helper tool, now common on many platforms, which many packages have adopted to provide the necessary compiler and linker flags required to build against a library. parrot will install a file called <em lang='und' xml:lang='und'>parrot.pc</em> which can be queried using pkg&#45;config.</p>

<p>To start with, find out what version of parrot is installed by running pkg&#45;config with the <code lang='und' xml:lang='und'>&#45;&#45;modversion</code> flag. If this command fails with an error, skip to the end of this section.</p>

<pre lang='und' xml:lang='und'>  pkg&#45;config &#45;&#45;modversion parrot</pre>

<p>To find out the necessary <code lang='und' xml:lang='und'>&#45;I</code> flags, use <code lang='und' xml:lang='und'>&#45;&#45;cflags</code>:</p>

<pre lang='und' xml:lang='und'>  pkg&#45;config &#45;&#45;cflags parrot</pre>

<p>... and to find the necessary <code lang='und' xml:lang='und'>&#45;L</code> and <code lang='und' xml:lang='und'>&#45;l</code> flags, use <code lang='und' xml:lang='und'>&#45;&#45;libs</code>:</p>

<pre lang='und' xml:lang='und'>  pkg&#45;config &#45;&#45;libs parrot</pre>

<p>Where both compiling and linking are performed in one step, query both sets of flags with:</p>

<pre lang='und' xml:lang='und'>  pkg&#45;config &#45;&#45;cflags &#45;&#45;libs parrot</pre>

<p>The pkg&#45;config command can be incorporated with a compile as shown here.</p>

<pre lang='und' xml:lang='und'>  cc src/disassemble.c `pkg&#45;config &#45;&#45;cflags &#45;&#45;libs parrot`</pre>

<p>Most applications will probably choose to run pkg&#45;config as part of a configure script, so if you are using autoconf you could use a test such as this.</p>

<pre lang='und' xml:lang='und'>  PARROT_REQUIRED_VERSION=0.4.1
  AC_SUBST(PARROT_REQUIRED_VERSION)
  PKG_CHECK_MODULES(PARROT, parrot &#62;= $PARROT_REQUIRED_VERSION,
                    [AC_DEFINE([HAVE_PARROT], 1, [define if have parrot])])
  AC_SUBST(PARROT_LIBS)
  AC_SUBST(PARROT_CFLAGS)</pre>

<p>If parrot has been installed system&#45;wide, then any of the previous lines should have returned the relevant flags. If it is not installed in one of the standard places that pkg&#45;config looks, then you will get an error message.</p>

<pre lang='und' xml:lang='und'>  pkg&#45;config &#45;&#45;libs parrot
  Package parrot was not found in the pkg&#45;config search path.
  Perhaps you should add the directory containing `parrot.pc&#39;
  to the PKG_CONFIG_PATH environment variable
  No package &#39;parrot&#39; found</pre>

<p>As stated in the error message, use an environment variable to make pkg&#45;config look in more locations.</p>

<pre lang='und' xml:lang='und'>  export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig</pre>

<p>The last part of the variable will almost certainly be <em lang='und' xml:lang='und'>.../lib/pkgconfig</em>. Set this variable in your login scripts if you need it to be available in future.</p>

<h1><a name="EXAMPLES"
>EXAMPLES <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<h2><a name="Load_bytecode_as_a_library_and_run_a_single_subroutine"
>Load bytecode as a library and run a single subroutine <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<pre lang='und' xml:lang='und'>    #include &#60;parrot/parrot.h&#62;
    #include &#60;parrot/embed.h&#62;
    #include &#60;parrot/extend.h&#62;

    int main(int argc, char *argv[])
    {
        Parrot_Interp interp;
        Parrot_PackFile pf;
        Parrot_PMC sub;
        Parrot_String pstr;

        interp = Parrot_new(NULL);
        imcc_init(interp);

        /* create a new packfile &#45;&#45; any name will do */
        pf = PackFile_new_dummy(interp, &#34;my&#45;parrot&#45;code&#34;);

        pstr = string_from_literal(interp, &#34;foo.pir&#34;);
        Parrot_load_bytecode(interp, pstr);

        /* find the subroutine named &#34;foo&#34; in the global namespace */
        pstr = string_from_literal(interp, &#34;foo&#34;);
        sub = Parrot_find_global_cur(interp, pstr);

        /* run foo(), which returns nothing */
        Parrot_call_sub(interp, sub, &#34;v&#34;);

        Parrot_destroy(interp);

        return(0);
    }</pre>

<h1><a name="SEE_ALSO"
>SEE ALSO <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p><em lang='und' xml:lang='und'><a href="../src/main.c.html">src/main.c</a></em> and <em lang='und' xml:lang='und'>t/src/*.t</em> for Parrot&#39;s use of the embedding system.</p>

<p><a href='http://pkgconfig.freedesktop.org/wiki/'><a href="http://pkgconfig.freedesktop.org/wiki/">http://pkgconfig.freedesktop.org/wiki/</a></a> A pkg&#45;config page</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../resources/parrot_small.png"
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
