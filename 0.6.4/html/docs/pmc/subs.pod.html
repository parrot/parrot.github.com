<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
    <HEAD>
        <TITLE>Parrot Subroutines</TITLE>
        <LINK REL="stylesheet" TYPE="text/css"
            HREF="../../../resources/perl.css"
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY>
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Parrot Subroutines</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../html/index.html">Contents</a> | <a href="../../../html/docs.html">Documentation</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Subs &#45; Parrot Subroutines</p>

<h1><a name="VERSION"
>VERSION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>$Revision$</p>

<h1><a name="ABSTRACT"
>ABSTRACT <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>This document describes how to define,
call,
and return from Parrot subroutine objects and other invokables.</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Parrot comes with different subroutine and related classes which implement CPS (Continuation Passing Style) and PCC (Parrot Calling Conventions) <em lang='und' xml:lang='und'><a href="../pdds/pdd03_calling_conventions.pod.html">docs/pdds/pdd03_calling_conventions.pod</a></em>.</p>

<h2><a name="Class_Tree"
>Class Tree <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>These are all of the built&#45;in classes that are directly callable,
or &#34;invokable&#34;:</p>

<pre lang='und' xml:lang='und'>  Sub
    Closure
    Coroutine
    Eval
  Continuation
    RetContinuation
    Exception_Handler</pre>

<p>By &#34;invokable&#34; we mean that they can be supplied as the first argument to the <code lang='und' xml:lang='und'>invoke</code>, <code lang='und' xml:lang='und'>invokecc</code>, or <code lang='und' xml:lang='und'>tailcall</code> instructions. Generally speaking, invokable objects are divided into two subtypes: <code lang='und' xml:lang='und'>Sub</code> and classes that are built on it create a new context when invoked, and <code lang='und' xml:lang='und'>Continuation</code> classes return control to an existing context that was captured when the <code lang='und' xml:lang='und'>Continuation</code> was created.</p>

<p>There are (of course) two classes that straddle this distinction:</p>

<ol>
<li>Invoking a <code lang='und' xml:lang='und'>Closure</code> object creates a new context for the sub it refers to directly, but it also captures an &#34;outer&#34; context that provides bindings for the immediately&#45;enclosing lexical scope (and, if that context is itself is for a <code lang='und' xml:lang='und'>Closure</code>, the subsequent scopes working outwards).</li><p class="pad"></p>

<p>[add a <code lang='und' xml:lang='und'>newclosure</code> example? &#45;&#45; rgr, 6&#45;Apr&#45;08.]</p>

<li>A <code lang='und' xml:lang='und'>Coroutine</code> acts like a normal sub when called initially, and can also return normally, but acts like a continuation when exited via the <code lang='und' xml:lang='und'>yield</code> instruction and re&#45;entered by re&#45;invoking.</li><p class="pad"></p>

<p>[need a reference to a <code lang='und' xml:lang='und'>coroutine</code> example. &#45;&#45; rgr, 6&#45;Apr&#45;08.]</p>
</ol>

<h1><a name="SYNOPSIS"
>SYNOPSIS <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<h2><a name="Creating_subs"
>Creating subs <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>Subs are created by IMCC (the PIR compiler) via the <b>.sub</b> directive. Unless the <code lang='und' xml:lang='und'>:anon</code> pragma is included, they are stored in the constant table associated with the bytecode and can be fetched with the <b>get_hll_global</b> and <b>get_root_global</b> opcodes. Within the PIR source, they can also be put in registers with a <code lang='und' xml:lang='und'>.const .Sub</code> declaration:</p>

<pre lang='und' xml:lang='und'>    .const .Sub rsub = &#39;random_sub&#39;</pre>

<p>This uses <code lang='und' xml:lang='und'>find_sub_not_null</code> under the hood to look up the sub named &#34;random_sub&#34;.</p>

<p>Here&#39;s an example of fetching a sub from another namespace:</p>

<pre lang='und' xml:lang='und'>    .sub main :main
        get_hll_global $P0, [&#39;Other&#39;; &#39;Namespace&#39;], &#34;the_sub&#34;
        $P0()
        print &#34;back\n&#34;
    .end

    .namespace [&#39;Other&#39;; &#39;Namespace&#39;]

    .sub the_sub
        print &#34;in sub\n&#34;
    .end</pre>

<p>Note that <code lang='und' xml:lang='und'>the_sub</code> could be defined in a different bytecode or PIR source file from <code lang='und' xml:lang='und'>main</code>.</p>

<h2><a name="Program_entry_point"
>Program entry point <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>One subroutine in the first executed source or bytecode file may be flagged as the &#34;main&#34; subroutine, where execution starts.</p>

<pre lang='und' xml:lang='und'>  .sub the_main_event :main</pre>

<p>In the absence of a <b>:main</b> entry Parrot starts execution at the first statement. Any <code lang='und' xml:lang='und'>:main</code> directives in a subsequent PIR or bytecode file that are loaded under program control are ignored.</p>

<p>Note that if the first executed source or bytecode file contains more than one sub flagged as <code lang='und' xml:lang='und'>:main</code>, Parrot currently picks the <i>last</i> such sub to start execution. This is arguably a bug, so users should not depend upon it.</p>

<h2><a name="Load&#45;time_initialization"
>Load&#45;time initialization <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>If a subroutine is marked as <b>:load</b> this subroutine is run, before the <b>load_bytecode</b> opcode returns.</p>

<p>e.g.</p>

<pre lang='und' xml:lang='und'>  .sub main :main
     print &#34;in main\n&#34;
     load_bytecode &#34;library_code.pir&#34;
     print &#34;back to main\n&#34;
  .end

  # library_code.pir

  .sub _my_lib_init :load
     print &#34;initializing library\n&#34;
  .end</pre>

<p>If a subroutine is marked as <b>:init</b> this subroutine is run before the <b>:main</b> or the first subroutine in the source file runs. Unlike <b>:main</b> subs, <b>:init</b> subs are also run when compiling from memory. <b>:load</b> subs are run only in any source or bytecode files loaded subsequently.</p>

<p>These markers are called &#34;pragmas&#34;, and are defined fully in <a href='TODO#pdds%2Fdraft%2Fpdd19_pir.pod'>&#34;pdds/draft/pdd19_pir.pod&#34; in docs</a>. The following table summarizes the behavior of the five pragmas that cause Parrot to run a sub implicitly:</p>

<pre lang='und' xml:lang='und'>                &#45;&#45;&#45;&#45;&#45;&#45; Executed when &#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;
                compiling to    &#45;&#45; loading &#45;&#45;
  Sub Pragma    disk  memory    first   after
  ==========    ====  ======    =====   =====
   :immediate   yes   yes       no      no        
   :postcomp    yes   no        no      no        
   :load        no    no        no      yes       
   :init        no    yes       yes     no        
   :main        no    no        yes     no        </pre>

<p>The same load&#45;time behavior applies regardless of whether the loaded file is PIR source or bytecode. Note that it is possible to mark a sub with both <b>:load</b> and <b>:init</b>.</p>

<h2><a name="Calling_the_sub"
>Calling the sub <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>PIR sub invocation syntax is similar to HLL syntax:</p>

<pre lang='und' xml:lang='und'>    $P0 = do_something($P1, $S3)</pre>

<p>This is syntactic sugar for the following four bytecode instructions:</p>

<pre lang='und' xml:lang='und'>    # Establish arguments.
    set_args &#39;(0,0)&#39;, $P1, $S3
    # Find the sub.
    $P8 = find_sub_not_null &#34;do_something&#34;
    # Establish return values.
    get_results &#39;(0)&#39;, $P0
    # Call the sub in $P8, implicitly creating a return continuation.
    invokecc $P8</pre>

<p>The sub name could be replaced with a PMC register, in which case the <code lang='und' xml:lang='und'>find_sub_not_null</code> instruction would not be needed. If the return values from the sub were ignored (by dropping the <code lang='und' xml:lang='und'>$P0 =</code> part), the <code lang='und' xml:lang='und'>get_results</code> instruction would be omitted. However, <code lang='und' xml:lang='und'>set_args</code> is emitted even in the case of a call without arguments.</p>

<p>The first operands to the <code lang='und' xml:lang='und'>set_args</code> and <code lang='und' xml:lang='und'>get_results</code> instructions are actually placeholders for an integer array that describes the register types. For example, the &#39;(0,0)&#39; for <code lang='und' xml:lang='und'>set_args</code> is replaced internally with <code lang='und' xml:lang='und'>[2, 1]</code>, which means &#34;two arguments, of type PMC and string&#34;. Note that return values get the same register type coercion as sub parameters. This is all described in much more detail in <a href='TODO#pdds%2Fpdd03_calling_conventions.pod'>&#34;pdds/pdd03_calling_conventions.pod&#34; in docs</a>.</p>

<p>To receive multiple values, put the register names in parentheses:</p>

<pre lang='und' xml:lang='und'>    ($P10, $P11) = do_something($P1, $S3)</pre>

<p>To test whether a value was returned, declare it <code lang='und' xml:lang='und'>:optional</code>, and follow it with an integer register declared <code lang='und' xml:lang='und'>:opt_val</code>:</p>

<pre lang='und' xml:lang='und'>    ($P10 :optional, $I10 :opt_val) = do_something($P1, $S3)</pre>

<p>Both of these affect only the signature provided via <code lang='und' xml:lang='und'>get_results</code>.</p>

<p>[should also describe :flat, :slurpy, :named, ..., or at least provide a reference. &#45;&#45; rgr, 25&#45;May&#45;08.]</p>

<pre lang='und' xml:lang='und'>    # Call the sub in $P8, with continuation (created earlier) in $P9.
    invoke $P8, $P9</pre>

<h2><a name="Returning_from_a_sub"
>Returning from a sub <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>PIR supports a convenient syntax for returning any number of values from a sub or closure:</p>

<pre lang='und' xml:lang='und'>    .return ($P0, $I1, $S3)</pre>

<p>Integer, float, and string constants are also accepted. This is translated to:</p>

<pre lang='und' xml:lang='und'>    get_results &#39;(0,0,0)&#39;, $P0, $I1, $S3
    returncc    # return by calling the current continuation</pre>

<p>As for <code lang='und' xml:lang='und'>set_args</code>, the &#39;(0,0,0)&#39; is actually a placeholder for an integer array that describes the register types; it is replaced internally with <code lang='und' xml:lang='und'>[2, 0, 1]</code>, which means &#34;three arguments, of type PMC, integer, and string&#34;.</p>

<p>Another way to return from a sub is to use tail&#45;calling, which calls a new sub with the current continuation, so that the new sub returns directly to the caller of the old sub (i.e. without first returning to the old sub). This passes the three values to <code lang='und' xml:lang='und'>another_sub</code> via tail&#45;calling:</p>

<pre lang='und' xml:lang='und'>    .return another_sub($P0, $I1, $S3)</pre>

<p>This is translated into a <code lang='und' xml:lang='und'>set_args</code> instruction for the call, but with <code lang='und' xml:lang='und'>tailcall</code> instead of <code lang='und' xml:lang='und'>invokecc</code>:</p>

<pre lang='und' xml:lang='und'>    set_args &#39;(0,0,0)&#39;, $P0, $I1, $S3
    $P8 = find_sub_not_null &#34;another_sub&#34;
    tailcall $P8</pre>

<p>As for calling, the sub name could be replaced with a PMC register, in which case the <code lang='und' xml:lang='und'>find_sub_not_null</code> instruction would not be needed.</p>

<p>If needed, the current continuation can be extracted and called explicitly as follows:</p>

<pre lang='und' xml:lang='und'>    ## This is what defines .INTERPINFO_CURRENT_CONT.
    .include &#39;interpinfo.pasm&#39;
    ## Store our return continuation as exit_cont.
    .local pmc exit_cont
    exit_cont = interpinfo .INTERPINFO_CURRENT_CONT
    ## Invoke it explicitly:
    invokecc exit_cont
    ## ... or equivalently:
    tailcall exit_cont</pre>

<p>To return values, use <code lang='und' xml:lang='und'>set_args</code> as before.</p>

<h2><a name="All_together_now"
>All together now <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h2>

<p>The following complete example illustrates the typical call/return pattern:</p>

<pre lang='und' xml:lang='und'>    .sub main :main
        print &#34;in main\n&#34;
        the_sub()
        print &#34;back to main\n&#34;
    .end

    .sub the_sub
        print &#34;in sub\n&#34;
    .end</pre>

<p>Notice that we are not passing or returning values here.</p>

<p>[example of passing values. this could get pretty elaborate; look for other examples first. &#45;&#45; rgr, 6&#45;Apr&#45;08.]</p>

<p>If a short subroutine is called several times, for instance inside a loop, the creation of the return continuation can be done outside the loop:</p>

<pre lang='und' xml:lang='und'>    .sub main :main
            ## Initialize the sub and the return cont.
            .local pmc cont
            cont = new &#39;Continuation&#39;
            set_addr cont, ret_label
            .const .Sub rsub = &#39;random_sub&#39;
            ## Loop initialization.
            .local int loop_max, i
            loop_max = 1000000
            i = 0

            ## Main loop.
    again:
            set_args &#39;(0)&#39;, i
            invoke rsub, cont
    ret_label:
            ## This is where &#34;cont&#34; returns.
            inc i
            if i &#60; loop_max goto again
    .end

    .sub random_sub
            .param int foo
            ## do_something
    .end</pre>

<p>If the sub returns values, the <code lang='und' xml:lang='und'>get_results</code> must be <b>after</b> <code lang='und' xml:lang='und'>ret_label</code> in order to receive them.</p>

<p>Since this is much more obscure than the PIR calling syntax, it should only be done if there is a measurable performance advantage. Even in this trivial example, calling &#34;rsub(i)&#34; is only about a third slower on x86.</p>

<h1><a name="FILES"
>FILES <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p><em lang='und' xml:lang='und'><a href="../../src/pmc/sub.pmc.html">src/pmc/sub.pmc</a></em>, <em lang='und' xml:lang='und'><a href="../../src/pmc/closure.pmc.html">src/pmc/closure.pmc</a></em>, <em lang='und' xml:lang='und'><a href="../../src/pmc/continuation.pmc.html">src/pmc/continuation.pmc</a></em>, <em lang='und' xml:lang='und'><a href="../../src/pmc/coroutine.pmc.html">src/pmc/coroutine.pmc</a></em>, <em lang='und' xml:lang='und'><a href="../../src/sub.c.html">src/sub.c</a></em>, <em lang='und' xml:lang='und'><a href="../../t/pmc/sub.t.html">t/pmc/sub.t</a></em></p>

<h1><a name="SEE_ALSO"
>SEE ALSO <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p><em lang='und' xml:lang='und'><a href="../pdds/pdd03_calling_conventions.pod.html">docs/pdds/pdd03_calling_conventions.pod</a></em> <em lang='und' xml:lang='und'><a href="../pdds/draft/pdd19_pir.pod.html">docs/pdds/draft/pdd19_pir.pod</a></em></p>

<h1><a name="AUTHOR"
>AUTHOR <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Leopold Toetsch &#60;lt@toetsch.at&#62;</p>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../resources/parrot_small.png"
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
